<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java虚拟机(JVM)面试题</title>
    <url>/myblog/interview/Java%E8%99%9A%E6%8B%9F%E6%9C%BA(JVM)%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h4 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h4><a id="more"></a>
<h5 id="说一下-JVM-的主要组成部分及其作用？"><a href="#说一下-JVM-的主要组成部分及其作用？" class="headerlink" title="说一下 JVM 的主要组成部分及其作用？"></a>说一下 JVM 的主要组成部分及其作用？</h5><p><img src="https://img-blog.csdnimg.cn/20200103213149526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<p>JVM包含两个子系统和两个组件，两个子系统为Class loader(类装载)、Execution engine(执行引擎)；两个组件为Runtime data area(运行时数据区)、Native Interface(本地接口)。</p>
<ul>
<li>Class loader(类装载)：根据给定的全限定名类名(如：java.lang.Object)来装载class文件到Runtime data area中的method area。</li>
<li>Execution engine（执行引擎）：执行classes中的指令。</li>
<li>Native Interface(本地接口)：与native libraries交互，是其它编程语言交互的接口。</li>
<li>Runtime data area(运行时数据区域)：这就是我们常说的JVM的内存。</li>
</ul>
<p><strong>作用</strong> ：首先通过编译器把 Java 代码转换成字节码，类加载器（ClassLoader）再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方法区内，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p>
<!--more-->

<p><strong>下面是Java程序运行机制详细说明</strong></p>
<p>Java程序运行机制步骤</p>
<ul>
<li>首先利用IDE集成开发工具编写Java源代码，源文件的后缀为.java；</li>
<li>再利用编译器(javac命令)将源代码编译成字节码文件，字节码文件的后缀名为.class；</li>
<li>运行字节码的工作是由解释器(java命令)来完成的。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2020031416414486.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt></p>
<p>从上图可以看，java文件通过编译器变成了.class文件，接下来类加载器又将这些.class文件加载到JVM中。<br>其实可以一句话来解释：类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class对象，用来封装类在方法区内的数据结构。</p>
<h5 id="说一下-JVM-运行时数据区"><a href="#说一下-JVM-运行时数据区" class="headerlink" title="说一下 JVM 运行时数据区"></a>说一下 JVM 运行时数据区</h5><p><strong>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存区域</strong>划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有些区域随着虚拟机进程的启动而存在，有些区域则是依赖线程的启动和结束而建立和销毁。Java 虚拟机所管理的内存被划分为如下几个区域：<br><img src="https://img-blog.csdnimg.cn/20200103213220764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<p>不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：</p>
<ul>
<li>程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；</li>
<li>Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；</li>
<li>本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；</li>
<li>Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；</li>
<li>方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</li>
</ul>
<h5 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h5><p>浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址，</p>
<p>深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存，</p>
<p>使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的错误。</p>
<p>浅复制：仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改变。</p>
<p>深复制：在计算机中开辟一块新的内存地址用于存放复制的对象。</p>
<h5 id="说一下堆栈的区别？"><a href="#说一下堆栈的区别？" class="headerlink" title="说一下堆栈的区别？"></a>说一下堆栈的区别？</h5><p>物理地址</p>
<p>堆的物理地址分配对对象是不连续的。因此性能慢些。在GC的时候也要考虑到不连续的分配，所以有各种算法。比如，标记-消除，复制，标记-压缩，分代（即新生代使用复制算法，老年代使用标记——压缩）</p>
<p>栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。</p>
<p>内存分别</p>
<p>堆因为是不连续的，所以分配的内存是在运行期确认的，因此大小不固定。一般堆大小远远大于栈。</p>
<p>栈是连续的，所以分配的内存大小要在编译期就确认，大小是固定的。</p>
<p>存放的内容</p>
<p>堆存放的是对象的实例和数组。因此该区更关注的是数据的存储</p>
<p>栈存放：局部变量，操作数栈，返回结果。该区更关注的是程序方法的执行。</p>
<p>PS：</p>
<ol>
<li>静态变量放在方法区</li>
<li>静态的对象还是放在堆。</li>
</ol>
<p>程序的可见度</p>
<p>堆对于整个应用程序都是共享、可见的。</p>
<p>栈只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同。</p>
<h5 id="队列和栈是什么？有什么区别？"><a href="#队列和栈是什么？有什么区别？" class="headerlink" title="队列和栈是什么？有什么区别？"></a>队列和栈是什么？有什么区别？</h5><p>队列和栈都是被用来预存储数据的。</p>
<ul>
<li>操作的名称不同。队列的插入称为入队，队列的删除称为出队。栈的插入称为进栈，栈的删除称为出栈。</li>
<li>可操作的方式不同。队列是在队尾入队，队头出队，即两边都可操作。而栈的进栈和出栈都是在栈顶进行的，无法对栈底直接进行操作。</li>
<li>操作的方法不同。队列是先进先出（FIFO），即队列的修改是依先进先出的原则进行的。新来的成员总是加入队尾（不能从中间插入），每次离开的成员总是队列头上（不允许中途离队）。而栈为后进先出（LIFO）,即每次删除（出栈）的总是当前栈中最新的元素，即最后插入（进栈）的元素，而最先插入的被放在栈的底部，要到最后才能删除。</li>
</ul>
<h4 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h4><h5 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h5><p>说到对象的创建，首先让我们看看 Java 中提供的几种对象创建方式：</p>
<table>
<thead>
<tr>
<th>Header</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>使用new关键字</td>
<td>调用了构造函数</td>
</tr>
<tr>
<td>使用Class的newInstance方法</td>
<td>调用了构造函数</td>
</tr>
<tr>
<td>使用Constructor类的newInstance方法</td>
<td>调用了构造函数</td>
</tr>
<tr>
<td>使用clone方法</td>
<td>没有调用构造函数</td>
</tr>
<tr>
<td>使用反序列化</td>
<td>没有调用构造函数</td>
</tr>
</tbody></table>
<p>下面是对象创建的主要流程:</p>
<p><img src="https://img-blog.csdnimg.cn/20200103213726902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<p>虚拟机遇到一条new指令时，先检查常量池是否已经加载相应的类，如果没有，必须先执行相应的类加载。类加载通过后，接下来分配内存。若Java堆中内存是绝对规整的，使用“指针碰撞“方式分配内存；如果不是规整的，就从空闲列表中分配，叫做”空闲列表“方式。划分内存时还需要考虑一个问题-并发，也有两种方式: CAS同步处理，或者本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)。然后内存空间初始化操作，接着是做一些必要的对象设置(元信息、哈希码…)，最后执行<init>方法。</init></p>
<h5 id="为对象分配内存"><a href="#为对象分配内存" class="headerlink" title="为对象分配内存"></a>为对象分配内存</h5><p>类加载完成后，接着会在Java堆中划分一块内存分配给对象。内存分配根据Java堆是否规整，有两种方式：</p>
<ul>
<li>指针碰撞：如果Java堆的内存是规整，即所有用过的内存放在一边，而空闲的的放在另一边。分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离，这样便完成分配内存工作。</li>
<li>空闲列表：如果Java堆的内存不是规整的，则需要由虚拟机维护一个列表来记录那些内存是可用的，这样在分配的时候可以从列表中查询到足够大的内存分配给对象，并在分配后更新列表记录。</li>
</ul>
<p>选择哪种分配方式是由 Java 堆是否规整来决定的，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<p><img src="https://img-blog.csdnimg.cn/20200103213812259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<h5 id="处理并发安全问题"><a href="#处理并发安全问题" class="headerlink" title="处理并发安全问题"></a>处理并发安全问题</h5><p>对象的创建在虚拟机中是一个非常频繁的行为，哪怕只是修改一个指针所指向的位置，在并发情况下也是不安全的，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案：</p>
<ul>
<li>对分配内存空间的动作进行同步处理（采用 CAS + 失败重试来保障更新操作的原子性）；\</li>
<li>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。哪个线程要分配内存，就在哪个线程的 TLAB 上分配。只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁。通过-XX:+/-UserTLAB参数来设定虚拟机是否使用TLAB。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200103213833317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<h5 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h5><p>Java程序需要通过 JVM 栈上的引用访问堆中的具体对象。对象的访问方式取决于 JVM 虚拟机的实现。目前主流的访问方式有 句柄 和 直接指针 两种方式。</p>
<pre><code>指针： 指向对象，代表一个对象在内存中的起始地址。
句柄： 可以理解为指向指针的指针，维护着对象的指针。句柄不直接指向对象，而是指向对象的指针（句柄不发生变化，指向固定内存地址），再由对象的指针指向对象的真实内存地址。</code></pre><h5 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h5><p>Java堆中划分出一块内存来作为句柄池，引用中存储对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息，具体构造如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20200103213926911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<p><strong>优势</strong>：引用中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而引用本身不需要修改。</p>
<h5 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h5><p>如果使用直接指针访问，引用 中存储的直接就是对象地址，那么Java堆对象内部的布局中就必须考虑如何放置访问类型数据的相关信息。</p>
<p><img src="https://img-blog.csdnimg.cn/20200103213948956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<p><strong>优势：</strong>速度更快，节省了<strong>一次指针定位</strong>的时间开销。由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。HotSpot 中采用的就是这种方式。</p>
<h4 id="内存溢出异常"><a href="#内存溢出异常" class="headerlink" title="内存溢出异常"></a>内存溢出异常</h4><h5 id="Java会存在内存泄漏吗？请简单描述"><a href="#Java会存在内存泄漏吗？请简单描述" class="headerlink" title="Java会存在内存泄漏吗？请简单描述"></a>Java会存在内存泄漏吗？请简单描述</h5><p>内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说，Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。</p>
<p>但是，即使这样，Java也还是存在着内存泄漏的情况，java导致内存泄露的原因很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。</p>
<h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><h5 id="简述Java垃圾回收机制"><a href="#简述Java垃圾回收机制" class="headerlink" title="简述Java垃圾回收机制"></a>简述Java垃圾回收机制</h5><p>在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</p>
<h5 id="GC是什么？为什么要GC"><a href="#GC是什么？为什么要GC" class="headerlink" title="GC是什么？为什么要GC"></a>GC是什么？为什么要GC</h5><p>GC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存</p>
<p>回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动</p>
<p>回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。</p>
<h5 id="垃圾回收的优点和原理。并考虑2种回收机制"><a href="#垃圾回收的优点和原理。并考虑2种回收机制" class="headerlink" title="垃圾回收的优点和原理。并考虑2种回收机制"></a>垃圾回收的优点和原理。并考虑2种回收机制</h5><p>java语言最显著的特点就是引入了垃圾回收机制，它使java程序员在编写程序时不再考虑内存管理的问题。</p>
<p>由于有这个垃圾回收机制，java中的对象不再有“作用域”的概念，只有引用的对象才有“作用域”。</p>
<p>垃圾回收机制有效的防止了内存泄露，可以有效的使用可使用的内存。</p>
<p>垃圾回收器通常作为一个单独的低级别的线程运行，在不可预知的情况下对内存堆中已经死亡的或很长时间没有用过的对象进行清除和回收。</p>
<p>程序员不能实时的对某个对象或所有对象调用垃圾回收器进行垃圾回收。</p>
<p>垃圾回收有分代复制垃圾回收、标记垃圾回收、增量垃圾回收。</p>
<h5 id="垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？"><a href="#垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？" class="headerlink" title="垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？"></a>垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？</h5><p>对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。</p>
<p>通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。</p>
<p>可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。</p>
<h5 id="Java-中都有哪些引用类型？"><a href="#Java-中都有哪些引用类型？" class="headerlink" title="Java 中都有哪些引用类型？"></a>Java 中都有哪些引用类型？</h5><ul>
<li>强引用：发生 gc 的时候不会被回收。</li>
<li>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。</li>
<li>弱引用：有用但不是必须的对象，在下一次GC时会被回收。</li>
<li>虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。</li>
</ul>
<h5 id="怎么判断对象是否可以被回收？"><a href="#怎么判断对象是否可以被回收？" class="headerlink" title="怎么判断对象是否可以被回收？"></a>怎么判断对象是否可以被回收？</h5><p>垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收的，哪些对象是「存活」的，是不可以被回收的；哪些对象已经「死掉」了，需要被回收。</p>
<p>一般有两种方法来判断：</p>
<ul>
<li>引用计数器法：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；</li>
<li>可达性分析算法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</li>
</ul>
<h5 id="在Java中，对象什么时候可以被垃圾回收"><a href="#在Java中，对象什么时候可以被垃圾回收" class="headerlink" title="在Java中，对象什么时候可以被垃圾回收"></a>在Java中，对象什么时候可以被垃圾回收</h5><p>当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。<br>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。</p>
<h5 id="JVM中的永久代中会发生垃圾回收吗"><a href="#JVM中的永久代中会发生垃圾回收吗" class="headerlink" title="JVM中的永久代中会发生垃圾回收吗"></a>JVM中的永久代中会发生垃圾回收吗</h5><p>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。请参考下Java8：从永久代到元数据区<br>(译者注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区)</p>
<h5 id="说一下-JVM-有哪些垃圾回收算法？"><a href="#说一下-JVM-有哪些垃圾回收算法？" class="headerlink" title="说一下 JVM 有哪些垃圾回收算法？"></a>说一下 JVM 有哪些垃圾回收算法？</h5><ul>
<li>标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。</li>
<li>复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。</li>
<li>标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</li>
<li>分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</li>
</ul>
<h5 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h5><p>标记无用对象，然后进行清除回收。</p>
<p>标记-清除算法（Mark-Sweep）是一种常见的基础垃圾收集算法，它将垃圾收集分为两个阶段：</p>
<ul>
<li>标记阶段：标记出可以回收的对象。</li>
<li>清除阶段：回收被标记的对象所占用的空间。</li>
</ul>
<p>标记-清除算法之所以是基础的，是因为后面讲到的垃圾收集算法都是在此算法的基础上进行改进的。</p>
<p><strong>优点：</strong>实现简单，不需要对象进行移动。</p>
<p><strong>缺点</strong>：标记、清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的频率。</p>
<p>标记-清除算法的执行的过程如下图所示</p>
<p><img src="https://img-blog.csdnimg.cn/20200104115917418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>为了解决标记-清除算法的效率不高的问题，产生了复制算法。它把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾收集时，遍历当前使用的区域，把存活对象复制到另外一个区域中，最后将当前使用的区域的可回收的对象进行回收。</p>
<p><strong>优点</strong>：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。</p>
<p><strong>缺点</strong>：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。</p>
<p>复制算法的执行过程如下图所示</p>
<p><img src="https://img-blog.csdnimg.cn/20200104115940771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<h5 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h5><p>在新生代中可以使用复制算法，但是在老年代就不能选择复制算法了，因为老年代的对象存活率会较高，这样会有较多的复制操作，导致效率变低。标记-清除算法可以应用在老年代中，但是它效率不高，在内存回收后容易产生大量内存碎片。因此就出现了一种标记-整理算法（Mark-Compact）算法，与标记-整理算法不同的是，在标记可回收的对象后将所有存活的对象压缩到内存的一端，使他们紧的排列在一起，然后对端边界以外的内存进行回收。回收后，已用和未用的内存都各自一边。</p>
<p><strong>优点</strong>：解决了标记-清理算法存在的内存碎片问题。</p>
<p><strong>缺点</strong>：仍需要进行局部对象移动，一定程度上降低了效率。</p>
<p>标记-整理算法的执行过程如下图所示</p>
<p><img src="https://img-blog.csdnimg.cn/20200104120006513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<p><strong>分代收集算法</strong></p>
<p>当前商业虚拟机都采用<strong>分代收集</strong>的垃圾收集算法。分代收集算法，顾名思义是根据对象的<strong>存活周期</strong>将内存划分为几块。一般包括年轻代、<strong>老年</strong>代 和 <strong>永久代</strong>，如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20200104120031885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<h5 id="说一下-JVM-有哪些垃圾回收器？"><a href="#说一下-JVM-有哪些垃圾回收器？" class="headerlink" title="说一下 JVM 有哪些垃圾回收器？"></a>说一下 JVM 有哪些垃圾回收器？</h5><p>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。下图展示了7种作用于不同分代的收集器，其中用于回收新生代的收集器包括Serial、PraNew、Parallel Scavenge，回收老年代的收集器包括Serial Old、Parallel Old、CMS，还有用于回收整个Java堆的G1收集器。不同收集器之间的连线表示它们可以搭配使用。</p>
<p><img src="https://img-blog.csdnimg.cn/20200104120144820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<ul>
<li>Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；</li>
<li>ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；</li>
<li>Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；</li>
<li>Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本；</li>
<li>Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；</li>
<li>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。</li>
<li>G1(Garbage First)收集器 (标记-整理算法)： Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。</li>
</ul>
<h5 id="详细介绍一下-CMS-垃圾回收器？"><a href="#详细介绍一下-CMS-垃圾回收器？" class="headerlink" title="详细介绍一下 CMS 垃圾回收器？"></a>详细介绍一下 CMS 垃圾回收器？</h5><p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。</p>
<p>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p>
<h5 id="新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？"><a href="#新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？" class="headerlink" title="新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？"></a>新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？</h5><ul>
<li>新生代回收器：Serial、ParNew、Parallel Scavenge</li>
<li>老年代回收器：Serial Old、Parallel Old、CMS</li>
<li>整堆回收器：G1</li>
</ul>
<p>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</p>
<h5 id="简述分代垃圾回收器是怎么工作的？"><a href="#简述分代垃圾回收器是怎么工作的？" class="headerlink" title="简述分代垃圾回收器是怎么工作的？"></a>简述分代垃圾回收器是怎么工作的？</h5><p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。</p>
<p>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p>
<ul>
<li>把 Eden + From Survivor 存活的对象放入 To Survivor 区；</li>
<li>清空 Eden 和 From Survivor 分区；</li>
<li>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。</li>
</ul>
<p>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</p>
<p>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p>
<h4 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h4><h5 id="简述java内存分配与回收策率以及Minor-GC和Major-GC"><a href="#简述java内存分配与回收策率以及Minor-GC和Major-GC" class="headerlink" title="简述java内存分配与回收策率以及Minor GC和Major GC"></a>简述java内存分配与回收策率以及Minor GC和Major GC</h5><p>所谓自动内存管理，最终要解决的也就是内存分配和内存回收两个问题。前面我们介绍了内存回收，这里我们再来聊聊内存分配。</p>
<p>对象的内存分配通常是在 Java 堆上分配（随着虚拟机优化技术的诞生，某些场景下也会在栈上分配，后面会详细介绍），对象主要分配在新生代的 Eden 区，如果启动了本地线程缓冲，将按照线程优先在 TLAB 上分配。少数情况下也会直接在老年代上分配。总的来说分配规则不是百分百固定的，其细节取决于哪一种垃圾收集器组合以及虚拟机相关参数有关，但是虚拟机对于内存的分配还是会遵循以下几种「普世」规则：</p>
<h5 id="对象优先在-Eden-区分配"><a href="#对象优先在-Eden-区分配" class="headerlink" title="对象优先在 Eden 区分配"></a>对象优先在 Eden 区分配</h5><p>多数情况，对象都在新生代 Eden 区分配。当 Eden 区分配没有足够的空间进行分配时，虚拟机将会发起一次 Minor GC。如果本次 GC 后还是没有足够的空间，则将启用分配担保机制在老年代中分配内存。</p>
<p>这里我们提到 Minor GC，如果你仔细观察过 GC 日常，通常我们还能从日志中发现 Major GC/Full GC。</p>
<ul>
<li>Minor GC 是指发生在新生代的 GC，因为 Java 对象大多都是朝生夕死，所有 Minor GC 非常频繁，一般回收速度也非常快；</li>
<li>Major GC/Full GC 是指发生在老年代的 GC，出现了 Major GC 通常会伴随至少一次 Minor GC。Major GC 的速度通常会比 Minor GC 慢 10 倍以上。</li>
</ul>
<h5 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h5><p>所谓大对象是指需要大量连续内存空间的对象，频繁出现大对象是致命的，会导致在内存还有不少空间的情况下提前触发 GC 以获取足够的连续空间来安置新对象。</p>
<p>前面我们介绍过新生代使用的是标记-清除算法来处理垃圾回收的，如果大对象直接在新生代分配就会导致 Eden 区和两个 Survivor 区之间发生大量的内存复制。因此对于大对象都会直接在老年代进行分配。</p>
<h5 id="长期存活对象将进入老年代"><a href="#长期存活对象将进入老年代" class="headerlink" title="长期存活对象将进入老年代"></a>长期存活对象将进入老年代</h5><p>虚拟机采用分代收集的思想来管理内存，那么内存回收时就必须判断哪些对象应该放在新生代，哪些对象应该放在老年代。因此虚拟机给每个对象定义了一个对象年龄的计数器，如果对象在 Eden 区出生，并且能够被 Survivor 容纳，将被移动到 Survivor 空间中，这时设置对象年龄为 1。对象在 Survivor 区中每「熬过」一次 Minor GC 年龄就加 1，当年龄达到一定程度（默认 15） 就会被晋升到老年代。</p>
<h4 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h4><h5 id="简述java类加载机制"><a href="#简述java类加载机制" class="headerlink" title="简述java类加载机制?"></a>简述java类加载机制?</h5><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的java类型。</p>
<h5 id="描述一下JVM加载Class文件的原理机制"><a href="#描述一下JVM加载Class文件的原理机制" class="headerlink" title="描述一下JVM加载Class文件的原理机制"></a>描述一下JVM加载Class文件的原理机制</h5><p>Java中的所有类，都需要由类加载器装载到JVM中才能运行。类加载器本身也是一个类，而它的工作就是把class文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。</p>
<p>类装载方式，有两种 ：</p>
<p>1.隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中，</p>
<p>2.显式装载， 通过class.forname()等方法，显式加载需要的类</p>
<p>Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到jvm中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。</p>
<h5 id="什么是类加载器，类加载器有哪些"><a href="#什么是类加载器，类加载器有哪些" class="headerlink" title="什么是类加载器，类加载器有哪些?"></a>什么是类加载器，类加载器有哪些?</h5><p>实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。</p>
<p>主要有一下四种类加载器:</p>
<ol>
<li>启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。</li>
<li>扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li>
<li>系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。</li>
<li>用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。</li>
</ol>
<h5 id="说一下类装载的执行过程？"><a href="#说一下类装载的执行过程？" class="headerlink" title="说一下类装载的执行过程？"></a>说一下类装载的执行过程？</h5><p>类装载分为以下 5 个步骤：</p>
<ul>
<li>加载：根据查找路径找到相应的 class 文件然后导入；</li>
<li>验证：检查加载的 class 文件的正确性；</li>
<li>准备：给类中的静态变量分配内存空间；</li>
<li>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</li>
<li>初始化：对静态变量和静态代码块执行初始化工作。</li>
</ul>
<h5 id="什么是双亲委派模型？"><a href="#什么是双亲委派模型？" class="headerlink" title="什么是双亲委派模型？"></a>什么是双亲委派模型？</h5><p>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</p>
<p><img src="https://img-blog.csdnimg.cn/20200104165551656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<p>类加载器分类：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；</li>
<li>其他类加载器：</li>
<li>扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；</li>
<li>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</li>
</ul>
<p>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</p>
<p>当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。</p>
<h4 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h4><h5 id="说一下-JVM-调优的工具？"><a href="#说一下-JVM-调优的工具？" class="headerlink" title="说一下 JVM 调优的工具？"></a>说一下 JVM 调优的工具？</h5><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p>
<ul>
<li>jconsole：用于对 JVM 中的内存、线程和类等进行监控；</li>
<li>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</li>
</ul>
<h5 id="常用的-JVM-调优的参数都有哪些？"><a href="#常用的-JVM-调优的参数都有哪些？" class="headerlink" title="常用的 JVM 调优的参数都有哪些？"></a>常用的 JVM 调优的参数都有哪些？</h5><ul>
<li>-Xms2g：初始化推大小为 2g；</li>
<li>-Xmx2g：堆最大内存为 2g；</li>
<li>-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；</li>
<li>-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；</li>
<li>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；</li>
<li>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；</li>
<li>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；</li>
<li>-XX:+PrintGC：开启打印 gc 信息；</li>
<li>-XX:+PrintGCDetails：打印 gc 详细信息。</li>
</ul>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>Java异常面试题</title>
    <url>/myblog/interview/Java%E5%BC%82%E5%B8%B8%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h4 id="Java异常架构与异常关键字"><a href="#Java异常架构与异常关键字" class="headerlink" title="Java异常架构与异常关键字"></a>Java异常架构与异常关键字</h4><a id="more"></a>
<h5 id="Java异常简介"><a href="#Java异常简介" class="headerlink" title="Java异常简介"></a>Java异常简介</h5><p>Java异常是Java提供的一种识别及响应错误的一致性机制。<br>Java异常机制可以使程序中异常处理代码和正常业务代码分离，保证程序代码更加优雅，并提高程序健壮性。在有效使用异常的情况下，异常能清晰的回答what, where, why这3个问题：异常类型回答了“什么”被抛出，异常堆栈跟踪回答了“在哪”抛出，异常信息回答了“为什么”会抛出。<br>Java异常架构</p>
<p><img src="https://img-blog.csdnimg.cn/20200314173417278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt></p>
<ol>
<li><h5 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h5></li>
</ol>
<p>Throwable 是 Java 语言中所有错误与异常的超类。</p>
<p>Throwable 包含两个子类：Error（错误）和 Exception（异常），它们通常用于指示发生了异常情况。</p>
<p>Throwable 包含了其线程创建时线程执行堆栈的快照，它提供了 printStackTrace() 等接口用于获取堆栈跟踪数据等信息。</p>
<!--more-->

<ol start="2">
<li><h5 id="Error（错误）"><a href="#Error（错误）" class="headerlink" title="Error（错误）"></a>Error（错误）</h5></li>
</ol>
<p>定义：Error 类及其子类。程序中无法处理的错误，表示运行应用程序中出现了严重的错误。</p>
<p>特点：此类错误一般表示代码运行时 JVM 出现问题。通常有 Virtual MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）等。比如 OutOfMemoryError：内存不足错误；StackOverflowError：栈溢出错误。此类错误发生时，JVM 将终止线程。</p>
<p>这些错误是不受检异常，非代码性错误。因此，当此类错误发生时，应用程序不应该去处理此类错误。按照Java惯例，我们是不应该实现任何新的Error子类的！<br>3. ##### Exception（异常）</p>
<p>程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。</p>
<p><strong>运行时异常</strong></p>
<p><strong>定义</strong>：RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。</p>
<p><strong>特点</strong>：Java 编译器不会检查它。也就是说，当程序中可能出现这类异常时，倘若既”没有通过throws声明抛出它”，也”没有用try-catch语句捕获它”，还是会编译通过。比如NullPointerException空指针异常、ArrayIndexOutBoundException数组下标越界异常、ClassCastException类型转换异常、ArithmeticExecption算术异常。此类异常属于不受检异常，一般是由程序逻辑错误引起的，在程序中可以选择捕获处理，也可以不处理。虽然 Java 编译器不会检查运行时异常，但是我们也可以通过 throws 进行声明抛出，也可以通过 try-catch 对它进行捕获处理。如果产生运行时异常，则需要通过修改代码来进行避免。例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！</p>
<p>RuntimeException 异常会由 Java 虚拟机自动抛出并自动捕获（<strong>就算我们没写异常捕获语句运行时也会抛出错误！！</strong>），此类异常的出现绝大数情况是代码本身有问题应该从逻辑上去解决并改进代码。</p>
<h6 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h6><p><strong>定义</strong>: Exception 中除 RuntimeException 及其子类之外的异常。</p>
<p><strong>特点</strong>: Java 编译器会检查它。如果程序中出现此类异常，比如 ClassNotFoundException（没有找到指定的类异常），IOException（IO流异常），要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。在程序中，通常不会自定义该类异常，而是直接使用系统提供的异常类。该异常我们必须手动在代码里添加捕获语句来处理该异常。</p>
<ol start="4">
<li><h5 id="受检异常与非受检异常"><a href="#受检异常与非受检异常" class="headerlink" title="受检异常与非受检异常"></a>受检异常与非受检异常</h5></li>
</ol>
<p>Java 的所有异常可以分为受检异常（checked exception）和非受检异常（unchecked exception）。</p>
<h6 id="受检异常"><a href="#受检异常" class="headerlink" title="受检异常"></a>受检异常</h6><p>编译器要求必须处理的异常。正确的程序在运行过程中，经常容易出现的、符合预期的异常情况。一旦发生此类异常，就必须采用某种方式进行处理。除 <strong>RuntimeException 及其子类外，其他的 Exception 异常都属于受检异常</strong>。编译器会检查此类异常，也就是说当编译器检查到应用中的某处可能会此类异常时，将会提示你处理本异常——要么使用try-catch捕获，要么使用方法签名中用 throws 关键字抛出，否则编译不通过。</p>
<h6 id="非受检异常"><a href="#非受检异常" class="headerlink" title="非受检异常"></a>非受检异常</h6><p>编译器不会进行检查并且不要求必须处理的异常，也就说当程序中出现此类异常时，即使我们没有try-catch捕获它，也没有使用throws抛出该异常，编译也会正常通过。<strong>该类异常包括运行时异常（RuntimeException极其子类）和错误（Error）。</strong></p>
<h5 id="Java异常关键字"><a href="#Java异常关键字" class="headerlink" title="Java异常关键字"></a>Java异常关键字</h5><p>• <strong>try</strong> – 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。<br>• <strong>catch</strong> – 用于捕获异常。catch用来捕获try语句块中发生的异常。<br>• <strong>finally</strong> – finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。<br>• <strong>throw</strong> – 用于抛出异常。<br>• <strong>throws</strong> – 用在方法签名中，用于声明该方法可能抛出的异常。</p>
<h5 id="Java异常处理"><a href="#Java异常处理" class="headerlink" title="Java异常处理"></a>Java异常处理</h5><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xMC8xNmU1NWYyYzMyMWQ5MDlk?x-oss-process=image/format,png" alt></p>
<p>Java 通过面向对象的方法进行异常处理，一旦方法抛出异常，系统自动根据该异常对象寻找合适异常处理器（Exception Handler）来处理该异常，把各种不同的异常进行分类，并提供了良好的接口。在 Java 中，每个异常都是一个对象，它是 Throwable 类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java 的异常处理是通过 5 个关键词来实现的：try、catch、throw、throws 和 finally。</p>
<p>在Java应用中，异常的处理机制分为声明异常，抛出异常和捕获异常。</p>
<h4 id="声明异常"><a href="#声明异常" class="headerlink" title="声明异常"></a>声明异常</h4><p>通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 throws 关键字声明可能会抛出的异常。</p>
<p>注意</p>
<ul>
<li>非检查异常（Error、RuntimeException 或它们的子类）不可使用 throws 关键字来声明要抛出的异常。</li>
<li>一个方法出现编译时异常，就需要 try-catch/ throws 处理，否则会导致编译错误。</li>
</ul>
<h4 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h4><p>如果你觉得解决不了某些异常问题，且不需要调用者处理，那么你可以抛出异常。</p>
<p>throw关键字作用是在方法内部抛出一个Throwable类型的异常。任何Java代码都可以通过throw语句抛出异常。</p>
<h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4><p>程序通常在运行之前不报错，但是运行后可能会出现某些未知的错误，但是还不想直接抛出到上一级，那么就需要通过try…catch…的形式进行异常捕获，之后根据不同的异常情况来进行相应的处理。</p>
<h4 id="如何选择异常类型"><a href="#如何选择异常类型" class="headerlink" title="如何选择异常类型"></a>如何选择异常类型</h4><p>可以根据下图来选择是捕获异常，声明异常还是抛出异常</p>
<p><img src="https://img-blog.csdnimg.cn/20200314173209267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt></p>
<h4 id="常见异常处理方式"><a href="#常见异常处理方式" class="headerlink" title="常见异常处理方式"></a>常见异常处理方式</h4><h5 id="直接抛出异常"><a href="#直接抛出异常" class="headerlink" title="直接抛出异常"></a>直接抛出异常</h5><p>通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 throws 关键字声明可能会抛出的异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">    String result;</span><br><span class="line">    BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(file));</span><br><span class="line">    <span class="keyword">while</span>((result = reader.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">    reader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="封装异常再抛出"><a href="#封装异常再抛出" class="headerlink" title="封装异常再抛出"></a>封装异常再抛出</h5><p>有时我们会从 catch 中抛出一个异常，目的是为了改变异常的类型。多用于在多系统集成时，当某个子系统故障，异常类型可能有多种，可以用统一的异常类型向外暴露，不需暴露太多内部异常细节。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> MyException </span>&#123;    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        MyException ex = <span class="keyword">new</span> MyException(<span class="string">"read file failed."</span>);</span><br><span class="line">        ex.initCause(e);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="捕获异常-1"><a href="#捕获异常-1" class="headerlink" title="捕获异常"></a>捕获异常</h5><p>在一个 try-catch 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// handle FileNotFoundException</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        <span class="comment">// handle IOException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同一个 catch 也可以捕获多种类型异常，用 | 隔开</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException | UnknownHostException e) &#123;</span><br><span class="line">        <span class="comment">// handle FileNotFoundException or UnknownHostException</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        <span class="comment">// handle IOException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h5><p>习惯上，定义一个异常类应包含两个构造函数，一个无参构造函数和一个带有详细描述信息的构造函数（Throwable 的 toString 方法会打印这些详细信息，调试时很有用）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h5><p>当方法中发生异常，异常处之后的代码不会再执行，如果之前获取了一些本地资源需要释放，则需要在方法正常结束时和 catch 语句中都调用释放本地资源的代码，显得代码比较繁琐，finally 语句可以解决这个问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> MyException </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">    String result;</span><br><span class="line">    BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(file));</span><br><span class="line">        <span class="keyword">while</span>((result = reader.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">"readFile method catch block."</span>);</span><br><span class="line">        MyException ex = <span class="keyword">new</span> MyException(<span class="string">"read file failed."</span>);</span><br><span class="line">        ex.initCause(e);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"readFile method finally block."</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != reader) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用该方法时，读取文件时若发生异常，代码会进入 catch 代码块，之后进入 finally 代码块；若读取文件时未发生异常，则会跳过 catch 代码块直接进入 finally 代码块。所以无论代码中是否发生异常，fianlly 中的代码都会执行。</p>
<p>若 catch 代码块中包含 return 语句，finally 中的代码还会执行吗？将以上代码中的 catch 子句修改如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">"readFile method catch block."</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 readFile 方法，观察当 catch 子句中调用 return 语句时，finally 子句是否执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">readFile method <span class="keyword">catch</span> block.</span><br><span class="line">readFile method <span class="keyword">finally</span> block.</span><br></pre></td></tr></table></figure>

<p>可见，即使 catch 中包含了 return 语句，finally 子句依然会执行。若 finally 中也包含 return 语句，finally 中的 return 会覆盖前面的 return.</p>
<h5 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a>try-with-resource</h5><p>上面例子中，finally 中的 close 方法也可能抛出 IOException, 从而覆盖了原始异常。JAVA 7 提供了更优雅的方式来实现资源的自动释放，自动释放的资源需要是实现了 AutoCloseable 接口的类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tryWithResourceTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (Scanner scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> FileInputStream(<span class="string">"c:/abc"</span>),<span class="string">"UTF-8"</span>))&#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        <span class="comment">// handle exception</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>try 代码块退出时，会自动调用 scanner.close 方法，和把 scanner.close 方法放在 finally 代码块中不同的是，若 scanner.close 抛出异常，则会被抑制，抛出的仍然为原始异常。被抑制的异常会由 addSusppressed 方法添加到原来的异常，如果想要获取被抑制的异常列表，可以调用 getSuppressed 方法来获取。</p>
<h4 id="Java异常常见面试题"><a href="#Java异常常见面试题" class="headerlink" title="Java异常常见面试题"></a>Java异常常见面试题</h4><ol>
<li><h5 id="Error-和-Exception-区别是什么？"><a href="#Error-和-Exception-区别是什么？" class="headerlink" title="Error 和 Exception 区别是什么？"></a>Error 和 Exception 区别是什么？</h5></li>
</ol>
<p>Error 类型的错误通常为虚拟机相关错误，如系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，JAVA 应用程序也不应对这类错误进行捕获，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复；</p>
<p>Exception 类的错误是可以在应用程序中进行捕获并处理的，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。<br>2. ##### 运行时异常和一般异常(受检异常)区别是什么？</p>
<p>运行时异常包括 RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。 Java 编译器不会检查运行时异常。</p>
<p>受检异常是Exception 中除 RuntimeException 及其子类之外的异常。 Java 编译器会检查受检异常。</p>
<p><strong>RuntimeException异常和受检异常之间的区别</strong>：是否强制要求调用者必须处理此异常，如果强制要求调用者必须进行处理，那么就使用受检异常，否则就选择非受检异常(RuntimeException)。一般来讲，如果没有特殊的要求，我们建议使用RuntimeException异常。</p>
<ol start="3">
<li><h5 id="JVM-是如何处理异常的？"><a href="#JVM-是如何处理异常的？" class="headerlink" title="JVM 是如何处理异常的？"></a>JVM 是如何处理异常的？</h5></li>
</ol>
<p>在一个方法中如果发生异常，这个方法会创建一个异常对象，并转交给 JVM，该异常对象包含异常名称，异常描述以及异常发生时应用程序的状态。创建异常对象并转交给 JVM 的过程称为抛出异常。可能有一系列的方法调用，最终才进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈。</p>
<p>JVM 会顺着调用栈去查找看是否有可以处理异常的代码，如果有，则调用异常处理代码。当 JVM 发现可以处理异常的代码时，会把发生的异常传递给它。如果 JVM 没有找到可以处理该异常的代码块，JVM 就会将该异常转交给默认的异常处理器（默认处理器为 JVM 的一部分），默认异常处理器打印出异常信息并终止应用程序。<br>4. ##### throw 和 throws 的区别是什么？</p>
<p>Java 中的异常处理除了包括捕获异常和处理异常之外，还包括声明异常和拋出异常，可以通过 throws 关键字在方法上声明该方法要拋出的异常，或者在方法内部通过 throw 拋出异常对象。</p>
<p><strong>throws 关键字和 throw 关键字在使用上的几点区别如下：</strong></p>
<ul>
<li>throw 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。</li>
<li>throws 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。</li>
</ul>
<ol start="5">
<li><h5 id="final、finally、finalize-有什么区别？"><a href="#final、finally、finalize-有什么区别？" class="headerlink" title="final、finally、finalize 有什么区别？"></a>final、finally、finalize 有什么区别？</h5><ul>
<li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。</li>
<li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li>
<li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，Java 中允许使用 finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。</li>
</ul>
</li>
<li><h5 id="NoClassDefFoundError-和-ClassNotFoundException-区别？"><a href="#NoClassDefFoundError-和-ClassNotFoundException-区别？" class="headerlink" title="NoClassDefFoundError 和 ClassNotFoundException 区别？"></a>NoClassDefFoundError 和 ClassNotFoundException 区别？</h5></li>
</ol>
<p>NoClassDefFoundError 是一个 Error 类型的异常，是由 JVM 引起的，不应该尝试捕获这个异常。</p>
<p>引起该异常的原因是 JVM 或 ClassLoader 尝试加载某类时在内存中找不到该类的定义，该动作发生在运行期间，即编译时该类存在，但是在运行时却找不到了，可能是变异后被删除了等原因导致；</p>
<p>ClassNotFoundException 是一个受查异常，需要显式地使用 try-catch 对其进行捕获和处理，或在方法签名中用 throws 关键字进行声明。当使用 Class.forName, ClassLoader.loadClass 或 ClassLoader.findSystemClass 动态加载类到内存的时候，通过传入的类路径参数没有找到该类，就会抛出该异常；另一种抛出该异常的可能原因是某个类已经由一个类加载器加载至内存中，另一个加载器又尝试去加载它。<br>7. ##### try-catch-finally 中哪个部分可以省略？</p>
<p>答：catch 可以省略</p>
<p><strong>原因</strong></p>
<p>更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以catch可以省略，你加上catch编译器也觉得无可厚非。</p>
<p>理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾处理，或者加上catch捕获以便进一步处理。</p>
<p>至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。<br>8. ##### try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</p>
<p>答：会执行，在 return 前执行。</p>
<p>注意：在 finally 中改变返回值的做法是不好的，因为如果存在 finally 代码块，try中的 return 语句不会立马返回调用者，而是记录下返回值待 finally 代码块执行完毕之后再向调用者返回其值，然后如果在 finally 中修改了返回值，就会返回修改后的值。显然，在 finally 中返回或者修改返回值会对程序造成很大的困扰，C#中直接用编译错误的方式来阻止程序员干这种龌龊的事情，Java 中也可以通过提升编译器的语法检查级别来产生警告或错误。</p>
<p>代码示例1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(a / <span class="number">0</span>);</span><br><span class="line">        a = <span class="number">20</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">        a = <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了</span></span><br><span class="line"><span class="comment">         * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40</span></span><br><span class="line"><span class="comment">         * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        a = <span class="number">40</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：30</p>
<p>代码示例2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(a / <span class="number">0</span>);</span><br><span class="line">        a = <span class="number">20</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">        a = <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        a = <span class="number">40</span>;</span><br><span class="line">        <span class="comment">//如果这样，就又重新形成了一条返回路径，由于只能通过1个return返回，所以这里直接返回40</span></span><br><span class="line">        <span class="keyword">return</span> a; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：40<br>9. 类 ExampleA 继承 Exception，类 ExampleB 继承ExampleA。</p>
<p>有如下代码片断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> ExampleB(<span class="string">"b"</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span>（ExampleA e）&#123;</span><br><span class="line">	System.out.println(<span class="string">"ExampleA"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>（Exception e）&#123;</span><br><span class="line">	System.out.println(<span class="string">"Exception"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问执行此段代码的输出是什么？</p>
<p>答：</p>
<p>输出：ExampleA。（根据里氏代换原则[能使用父类型的地方一定能使用子类型]，抓取 ExampleA 类型异常的 catch 块能够抓住 try 块中抛出的 ExampleB 类型的异常）</p>
<p>面试题 - 说出下面代码的运行结果。（此题的出处是《Java 编程思想》一书）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Annoyance</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sneeze</span> <span class="keyword">extends</span> <span class="title">Annoyance</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> Sneeze();</span><br><span class="line">			&#125; <span class="keyword">catch</span> ( Annoyance a ) &#123;</span><br><span class="line">				System.out.println(<span class="string">"Caught Annoyance"</span>);</span><br><span class="line">				<span class="keyword">throw</span> a;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> ( Sneeze s ) &#123;</span><br><span class="line">			System.out.println(<span class="string">"Caught Sneeze"</span>);</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Caught Annoyance</span><br><span class="line">Caught Sneeze</span><br><span class="line">Hello World!xxxxxxxxxx Caught AnnoyanceCaught SneezeHello World!<span class="number">123</span></span><br></pre></td></tr></table></figure>

<ol start="10">
<li><h5 id="常见的-RuntimeException-有哪些？"><a href="#常见的-RuntimeException-有哪些？" class="headerlink" title="常见的 RuntimeException 有哪些？"></a>常见的 RuntimeException 有哪些？</h5><ul>
<li><p>ClassCastException(类转换异常)</p>
</li>
<li><p>IndexOutOfBoundsException(数组越界)</p>
</li>
<li><p>NullPointerException(空指针)</p>
</li>
<li><p>ArrayStoreException(数据存储异常，操作数组时类型不一致)</p>
</li>
<li><p>还有IO操作的BufferOverflowException异常</p>
</li>
</ul>
</li>
</ol>
<ol start="11">
<li><h5 id="Java常见异常有哪些"><a href="#Java常见异常有哪些" class="headerlink" title="Java常见异常有哪些"></a>Java常见异常有哪些</h5></li>
</ol>
<p>java.lang.IllegalAccessError：违法访问错误。当一个应用试图访问、修改某个类的域（Field）或者调用其方法，但是又违反域或方法的可见性声明，则抛出该异常。</p>
<p>java.lang.InstantiationError：实例化错误。当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常.</p>
<p>java.lang.OutOfMemoryError：内存不足错误。当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。</p>
<p>java.lang.StackOverflowError：堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出或者陷入死循环时抛出该错误。</p>
<p>java.lang.ClassCastException：类造型异常。假设有类A和B（A不是B的父类或子类），O是A的实例，那么当强制将O构造为类B的实例时抛出该异常。该异常经常被称为强制类型转换异常。</p>
<p>java.lang.ClassNotFoundException：找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。</p>
<p>java.lang.ArithmeticException：算术条件异常。譬如：整数除零等。</p>
<p>java.lang.ArrayIndexOutOfBoundsException：数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</p>
<p>java.lang.IndexOutOfBoundsException：索引越界异常。当访问某个序列的索引值小于0或大于等于序列大小时，抛出该异常。</p>
<p>java.lang.InstantiationException：实例化异常。当试图通过newInstance()方法创建某个类的实例，而该类是一个抽象类或接口时，抛出该异常。</p>
<p>java.lang.NoSuchFieldException：属性不存在异常。当访问某个类的不存在的属性时抛出该异常。</p>
<p>java.lang.NoSuchMethodException：方法不存在异常。当访问某个类的不存在的方法时抛出该异常。</p>
<p>java.lang.NullPointerException：空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等。</p>
<p>java.lang.NumberFormatException：数字格式异常。当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。</p>
<p>java.lang.StringIndexOutOfBoundsException：字符串索引越界异常。当使用索引值访问某个字符串中的字符，而该索引值小于0或大于等于序列大小时，抛出该异常。</p>
<h5 id="Java异常处理最佳实践"><a href="#Java异常处理最佳实践" class="headerlink" title="Java异常处理最佳实践"></a>Java异常处理最佳实践</h5><p>在 Java 中处理异常并不是一个简单的事情。不仅仅初学者很难理解，即使一些有经验的开发者也需要花费很多时间来思考如何处理异常，包括需要处理哪些异常，怎样处理等等。这也是绝大多数开发团队都会制定一些规则来规范进行异常处理的原因。而团队之间的这些规范往往是截然不同的。</p>
<p>本文给出几个被很多团队使用的异常处理最佳实践。</p>
<ol>
<li><h5 id="在-finally-块中清理资源或者使用-try-with-resource-语句"><a href="#在-finally-块中清理资源或者使用-try-with-resource-语句" class="headerlink" title="在 finally 块中清理资源或者使用 try-with-resource 语句"></a>在 finally 块中清理资源或者使用 try-with-resource 语句</h5></li>
</ol>
<p>当使用类似InputStream这种需要使用后关闭的资源时，一个常见的错误就是在try块的最后关闭资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doNotCloseResourceInTry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FileInputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"./tmp.txt"</span>);</span><br><span class="line">        inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        <span class="comment">// use the inputStream to read a file</span></span><br><span class="line">        <span class="comment">// do NOT do this</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题就是，只有没有异常抛出的时候，这段代码才可以正常工作。try 代码块内代码会正常执行，并且资源可以正常关闭。但是，使用 try 代码块是有原因的，一般调用一个或多个可能抛出异常的方法，而且，你自己也可能会抛出一个异常，这意味着代码可能不会执行到 try 代码块的最后部分。结果就是，你并没有关闭资源。</p>
<p>所以，你应该把清理工作的代码放到 finally 里去，或者使用 try-with-resource 特性。</p>
<h5 id="1-1-使用-finally-代码块"><a href="#1-1-使用-finally-代码块" class="headerlink" title="1.1 使用 finally 代码块"></a>1.1 使用 finally 代码块</h5><p>与前面几行 try 代码块不同，finally 代码块总是会被执行。不管 try 代码块成功执行之后还是你在 catch 代码块中处理完异常后都会执行。因此，你可以确保你清理了所有打开的资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeResourceInFinally</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FileInputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"./tmp.txt"</span>);</span><br><span class="line">        inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        <span class="comment">// use the inputStream to read a file</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                log.error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-Java-7-的-try-with-resource-语法"><a href="#1-2-Java-7-的-try-with-resource-语法" class="headerlink" title="1.2 Java 7 的 try-with-resource 语法"></a>1.2 Java 7 的 try-with-resource 语法</h5><p>如果你的资源实现了 AutoCloseable 接口，你可以使用这个语法。大多数的 Java 标准资源都继承了这个接口。当你在 try 子句中打开资源，资源会在 try 代码块执行后或异常处理后自动关闭。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">automaticallyCloseResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"./tmp.txt"</span>);</span><br><span class="line">    <span class="keyword">try</span> (FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(file);) &#123;</span><br><span class="line">        <span class="comment">// use the inputStream to read a file</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><h5 id="优先明确的异常"><a href="#优先明确的异常" class="headerlink" title="优先明确的异常"></a>优先明确的异常</h5></li>
</ol>
<p>你抛出的异常越明确越好，永远记住，你的同事或者几个月之后的你，将会调用你的方法并且处理异常。</p>
<p>因此需要保证提供给他们尽可能多的信息。这样你的 API 更容易被理解。你的方法的调用者能够更好的处理异常并且避免额外的检查。</p>
<p>因此，总是尝试寻找最适合你的异常事件的类，例如，抛出一个 NumberFormatException 来替换一个 IllegalArgumentException 。避免抛出一个不明确的异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doNotDoThis</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doThis</span><span class="params">()</span> <span class="keyword">throws</span> NumberFormatException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><h5 id="对异常进行文档说明"><a href="#对异常进行文档说明" class="headerlink" title="对异常进行文档说明"></a>对异常进行文档说明</h5></li>
</ol>
<p>当在方法上声明抛出异常时，也需要进行文档说明。目的是为了给调用者提供尽可能多的信息，从而可以更好地避免或处理异常。<br>在 Javadoc 添加 @throws 声明，并且描述抛出异常的场景。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(String input)</span> <span class="keyword">throws</span> MyBusinessException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><h5 id="使用描述性消息抛出异常"><a href="#使用描述性消息抛出异常" class="headerlink" title="使用描述性消息抛出异常"></a>使用描述性消息抛出异常</h5></li>
</ol>
<p>在抛出异常时，需要尽可能精确地描述问题和相关信息，这样无论是打印到日志中还是在监控工具中，都能够更容易被人阅读，从而可以更好地定位具体错误信息、错误的严重程度等。</p>
<p>但这里并不是说要对错误信息长篇大论，因为本来 Exception 的类名就能够反映错误的原因，因此只需要用一到两句话描述即可。</p>
<p>如果抛出一个特定的异常，它的类名很可能已经描述了这种错误。所以，你不需要提供很多额外的信息。一个很好的例子是 NumberFormatException 。当你以错误的格式提供 String 时，它将被 java.lang.Long 类的构造函数抛出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> Long(<span class="string">"xyz"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><h5 id="优先捕获最具体的异常"><a href="#优先捕获最具体的异常" class="headerlink" title="优先捕获最具体的异常"></a>优先捕获最具体的异常</h5></li>
</ol>
<p>大多数 IDE 都可以帮助你实现这个最佳实践。当你尝试首先捕获较不具体的异常时，它们会报告无法访问的代码块。</p>
<p>但问题在于，只有匹配异常的第一个 catch 块会被执行。 因此，如果首先捕获 IllegalArgumentException ，则永远不会到达应该处理更具体的 NumberFormatException 的 catch 块，因为它是 IllegalArgumentException 的子类。</p>
<p>总是优先捕获最具体的异常类，并将不太具体的 catch 块添加到列表的末尾。</p>
<p>你可以在下面的代码片断中看到这样一个 try-catch 语句的例子。 第一个 catch 块处理所有 NumberFormatException 异常，第二个处理所有非 NumberFormatException 异常的IllegalArgumentException 异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">catchMostSpecificExceptionFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doSomething(<span class="string">"A message"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        log.error(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><h5 id="不要捕获-Throwable-类"><a href="#不要捕获-Throwable-类" class="headerlink" title="不要捕获 Throwable 类"></a>不要捕获 Throwable 类</h5></li>
</ol>
<p>Throwable 是所有异常和错误的超类。你可以在 catch 子句中使用它，但是你永远不应该这样做！</p>
<p>如果在 catch 子句中使用 Throwable ，它不仅会捕获所有异常，也将捕获所有的错误。JVM 抛出错误，指出不应该由应用程序处理的严重问题。 典型的例子是 OutOfMemoryError 或者 StackOverflowError 。两者都是由应用程序控制之外的情况引起的，无法处理。</p>
<p>所以，最好不要捕获 Throwable ，除非你确定自己处于一种特殊的情况下能够处理错误。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doNotCatchThrowable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// don't do this!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><h5 id="不要忽略异常"><a href="#不要忽略异常" class="headerlink" title="不要忽略异常"></a>不要忽略异常</h5></li>
</ol>
<p>很多时候，开发者很有自信不会抛出异常，因此写了一个catch块，但是没有做任何处理或者记录日志。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doNotIgnoreExceptions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        <span class="comment">// this will never happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但现实是经常会出现无法预料的异常，或者无法确定这里的代码未来是不是会改动(删除了阻止异常抛出的代码)，而此时由于异常被捕获，使得无法拿到足够的错误信息来定位问题。</p>
<p>合理的做法是至少要记录异常的信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logAnException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        log.error(<span class="string">"This should never happen: "</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li><h5 id="不要记录并抛出异常"><a href="#不要记录并抛出异常" class="headerlink" title="不要记录并抛出异常"></a>不要记录并抛出异常</h5></li>
</ol>
<p>这可能是本文中最常被忽略的最佳实践。可以发现很多代码甚至类库中都会有捕获异常、记录日志并再次抛出的逻辑。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> Long(<span class="string">"xyz"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个处理逻辑看着是合理的。但这经常会给同一个异常输出多条日志。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">17</span>:<span class="number">44</span>:<span class="number">28</span>,<span class="number">945</span> ERROR TestExceptionHandling:<span class="number">65</span> - java.lang.NumberFormatException: For input string: <span class="string">"xyz"</span></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.NumberFormatException: For input string: <span class="string">"xyz"</span></span><br><span class="line">at java.lang.NumberFormatException.forInputString(NumberFormatException.java:<span class="number">65</span>)</span><br><span class="line">at java.lang.Long.parseLong(Long.java:<span class="number">589</span>)</span><br><span class="line">at java.lang.Long.(Long.java:<span class="number">965</span>)</span><br><span class="line">at com.stackify.example.TestExceptionHandling.logAndThrowException(TestExceptionHandling.java:<span class="number">63</span>)</span><br><span class="line">at com.stackify.example.TestExceptionHandling.main(TestExceptionHandling.java:<span class="number">58</span>)</span><br></pre></td></tr></table></figure>

<p>如上所示，后面的日志也没有附加更有用的信息。如果想要提供更加有用的信息，那么可以将异常包装为自定义异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wrapException</span><span class="params">(String input)</span> <span class="keyword">throws</span> MyBusinessException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MyBusinessException(<span class="string">"A message that describes the error."</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，仅仅当想要处理异常时才去捕获，否则只需要在方法签名中声明让调用者去处理。<br>9. ##### 包装异常时不要抛弃原始的异常</p>
<p>捕获标准异常并包装为自定义异常是一个很常见的做法。这样可以添加更为具体的异常信息并能够做针对的异常处理。<br>在你这样做时，请确保将原始异常设置为原因（注：参考下方代码 NumberFormatException e 中的原始异常 e ）。Exception 类提供了特殊的构造函数方法，它接受一个 Throwable 作为参数。否则，你将会丢失堆栈跟踪和原始异常的消息，这将会使分析导致异常的异常事件变得困难。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wrapException</span><span class="params">(String input)</span> <span class="keyword">throws</span> MyBusinessException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MyBusinessException(<span class="string">"A message that describes the error."</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="10">
<li><h5 id="不要使用异常控制程序的流程"><a href="#不要使用异常控制程序的流程" class="headerlink" title="不要使用异常控制程序的流程"></a>不要使用异常控制程序的流程</h5></li>
</ol>
<p>不应该使用异常控制应用的执行流程，例如，本应该使用if语句进行条件判断的情况下，你却使用异常处理，这是非常不好的习惯，会严重影响应用的性能。<br>11. ##### 使用标准异常</p>
<p>如果使用内建的异常可以解决问题，就不要定义自己的异常。Java API 提供了上百种针对不同情况的异常类型，在开发中首先尽可能使用 Java API 提供的异常，如果标准的异常不能满足你的要求，这时候创建自己的定制异常。尽可能得使用标准异常有利于新加入的开发者看懂项目代码。<br>12. ##### 异常会影响性能</p>
<p>异常处理的性能成本非常高，每个 Java 程序员在开发时都应牢记这句话。创建一个异常非常慢，抛出一个异常又会消耗1~5ms，当一个异常在应用的多个层级之间传递时，会拖累整个应用的性能。</p>
<ul>
<li>仅在异常情况下使用异常；</li>
<li>在可恢复的异常情况下使用异常；</li>
</ul>
<p>尽管使用异常有利于 Java 开发，但是在应用中最好不要捕获太多的调用栈，因为在很多情况下都不需要打印调用栈就知道哪里出错了。因此，异常消息应该提供恰到好处的信息。<br>13. 总结</p>
<p>综上所述，当你抛出或捕获异常的时候，有很多不同的情况需要考虑，而且大部分事情都是为了改善代码的可读性或者 API 的可用性。</p>
<p>异常不仅仅是一个错误控制机制，也是一个通信媒介。因此，为了和同事更好的合作，一个团队必须要制定出一个最佳实践和规则，只有这样，团队成员才能理解这些通用概念，同时在工作中使用它。</p>
<h5 id="异常处理-阿里巴巴Java开发手册"><a href="#异常处理-阿里巴巴Java开发手册" class="headerlink" title="异常处理-阿里巴巴Java开发手册"></a>异常处理-阿里巴巴Java开发手册</h5><ol>
<li><p>【强制】Java 类库中定义的可以通过预检查方式规避的RuntimeException异常不应该通过catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException等等。 说明：无法通过预检查的异常除外，比如，在解析字符串形式的数字时，可能存在数字格式错误，不得不通过catch NumberFormatException来实现。 正例：if (obj != null) {…} 反例：try { obj.method(); } catch (NullPointerException e) {…}</p>
</li>
<li><p>【强制】异常不要用来做流程控制，条件控制。 说明：异常设计的初衷是解决程序运行中的各种意外情况，且异常的处理效率比条件判断方式要低很多。</p>
</li>
<li><p>【强制】catch时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的catch尽可能进行区分异常类型，再做对应的异常处理。 说明：对大段代码进行try-catch，使程序无法根据不同的异常做出正确的应激反应，也不利于定位问题，这是一种不负责任的表现。 正例：用户注册的场景中，如果用户输入非法字符，或用户名称已存在，或用户输入密码过于简单，在程序上作出分门别类的判断，并提示给用户。</p>
</li>
<li><p>【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。</p>
</li>
<li><p>【强制】有try块放到了事务代码中，catch异常后，如果需要回滚事务，一定要注意手动回滚事务。</p>
</li>
<li><p>【强制】finally块必须对资源对象、流对象进行关闭，有异常也要做try-catch。 说明：如果JDK7及以上，可以使用try-with-resources方式。</p>
</li>
<li><p>【强制】不要在finally块中使用return。 说明：try块中的return语句执行成功后，并不马上返回，而是继续执行finally块中的语句，如果此处存在return语句，则在此直接返回，无情丢弃掉try块中的返回点。 反例：</p>
<p> private int x = 0;<br> public int checkReturn() {</p>
<pre><code>try {
    // x等于1，此处不返回
    return ++x;
} finally {
    // 返回的结果是2
    return ++x;
}</code></pre><p> }</p>
</li>
<li><p>【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。 说明：如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况。</p>
</li>
<li><p>【强制】在调用RPC、二方包、或动态生成类的相关方法时，捕捉异常必须使用Throwable类来进行拦截。 说明：通过反射机制来调用方法，如果找不到方法，抛出NoSuchMethodException。什么情况会抛出NoSuchMethodError呢？二方包在类冲突时，仲裁机制可能导致引入非预期的版本使类的方法签名不匹配，或者在字节码修改框架（比如：ASM）动态创建或修改类时，修改了相应的方法签名。这些情况，即使代码编译期是正确的，但在代码运行期时，会抛出NoSuchMethodError。</p>
</li>
<li><p>【推荐】方法的返回值可以为null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回null值。 说明：本手册明确防止NPE是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回null的情况。</p>
</li>
<li><p>【推荐】防止NPE，是程序员的基本修养，注意NPE产生的场景： 1） 返回类型为基本数据类型，return包装数据类型的对象时，自动拆箱有可能产生NPE。 反例：public int f() { return Integer对象}， 如果为null，自动解箱抛NPE。 2） 数据库的查询结果可能为null。 3） 集合里的元素即使isNotEmpty，取出的数据元素也可能为null。 4） 远程调用返回对象时，一律要求进行空指针判断，防止NPE。 5） 对于Session中获取的数据，建议进行NPE检查，避免空指针。 6） 级联调用obj.getA().getB().getC()；一连串调用，易产生NPE。<br>正例：使用JDK8的Optional类来防止NPE问题。</p>
</li>
<li><p>【推荐】定义时区分unchecked / checked 异常，避免直接抛出new RuntimeException()，更不允许抛出Exception或者Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：DAOException / ServiceException等。</p>
</li>
<li><p>【参考】对于公司外的http/api开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间RPC调用优先考虑使用Result方式，封装isSuccess()方法、“错误码”、“错误简短信息”。 说明：关于RPC方法返回方式使用Result方式的理由： 1）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。 2）如果不加栈信息，只是new自定义异常，加入自己的理解的error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。</p>
</li>
<li><p>【参考】避免出现重复的代码（Don’t Repeat Yourself），即DRY原则。 说明：随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是组件化。 正例：一个类中有多个public方法，都需要进行数行相同的参数校验操作，这个时候请抽取：<br>private boolean checkParam(DTO dto) {…}</p>
</li>
</ol>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis面试题</title>
    <url>/myblog/interview/MyBatis%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h4 id="MyBatis简介"><a href="#MyBatis简介" class="headerlink" title="MyBatis简介"></a>MyBatis简介</h4><a id="more"></a>
<h5 id="MyBatis是什么？"><a href="#MyBatis是什么？" class="headerlink" title="MyBatis是什么？"></a>MyBatis是什么？</h5><p>MyBatis 是一款优秀的持久层框架，一个半 ORM（对象关系映射）框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p>
<h5 id="ORM是什么"><a href="#ORM是什么" class="headerlink" title="ORM是什么"></a>ORM是什么</h5><p>ORM（Object Relational Mapping），对象关系映射，是一种为了解决关系型数据库数据与简单Java对象（POJO）的映射关系的技术。简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系型数据库中。</p>
<h5 id="为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"><a href="#为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？" class="headerlink" title="为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"></a>为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</h5><p>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。</p>
<p>而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</p>
<!--more-->

<h5 id="传统JDBC开发存在的问题"><a href="#传统JDBC开发存在的问题" class="headerlink" title="传统JDBC开发存在的问题"></a>传统JDBC开发存在的问题</h5><ul>
<li>频繁创建数据库连接对象、释放，容易造成系统资源浪费，影响系统性能。可以使用连接池解决这个问题。但是使用jdbc需要自己实现连接池。</li>
<li>sql语句定义、参数设置、结果集处理存在硬编码。实际项目中sql语句变化的可能性较大，一旦发生变化，需要修改java代码，系统需要重新编译，重新发布。不好维护。</li>
<li>使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护。</li>
<li>结果集处理存在重复代码，处理麻烦。如果可以映射成Java对象会比较方便。</li>
</ul>
<h5 id="JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？"><a href="#JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？" class="headerlink" title="JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？"></a>JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？</h5><p>1、数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库连接池可解决此问题。</p>
<p>解决：在mybatis-config.xml中配置数据链接池，使用连接池管理数据库连接。</p>
<p>2、Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。</p>
<p>解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。</p>
<p>3、向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。</p>
<p>解决： Mybatis自动将java对象映射至sql语句。</p>
<p>4、对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。</p>
<p>解决：Mybatis自动将sql执行结果映射至java对象。</p>
<h5 id="Mybatis优缺点"><a href="#Mybatis优缺点" class="headerlink" title="Mybatis优缺点"></a>Mybatis优缺点</h5><p><strong>优点</strong></p>
<p>与传统的数据库访问技术相比，ORM有以下优点：</p>
<ul>
<li>基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用</li>
<li>与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接</li>
<li>很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）</li>
<li>提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护</li>
<li>能够与Spring很好的集成</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求</li>
<li>SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库</li>
</ul>
<h5 id="MyBatis框架适用场景"><a href="#MyBatis框架适用场景" class="headerlink" title="MyBatis框架适用场景"></a>MyBatis框架适用场景</h5><ul>
<li>MyBatis专注于SQL本身，是一个足够灵活的DAO层解决方案。</li>
<li>对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis将是不错的选择。</li>
</ul>
<h5 id="Hibernate-和-MyBatis-的区别"><a href="#Hibernate-和-MyBatis-的区别" class="headerlink" title="Hibernate 和 MyBatis 的区别"></a>Hibernate 和 MyBatis 的区别</h5><p><strong>相同点</strong></p>
<p>都是对jdbc的封装，都是持久层的框架，都用于dao层的开发。</p>
<p><strong>不同点</strong></p>
<p>映射关系</p>
<ul>
<li>MyBatis 是一个半自动映射的框架，配置Java对象与sql语句执行结果的对应关系，多表关联关系配置简单</li>
<li>Hibernate 是一个全表映射的框架，配置Java对象与数据库表的对应关系，多表关联关系配置复杂</li>
</ul>
<p>SQL优化和移植性</p>
<ul>
<li>Hibernate 对SQL语句封装，提供了日志、缓存、级联（级联比 MyBatis 强大）等特性，此外还提供 HQL（Hibernate Query Language）操作数据库，数据库无关性支持好，但会多消耗性能。如果项目需要支持多种数据库，代码开发量少，但SQL语句优化困难。</li>
<li>MyBatis 需要手动编写 SQL，支持动态 SQL、处理列表、动态生成表名、支持存储过程。开发工作量相对大些。直接使用SQL语句操作数据库，不支持数据库无关性，但sql语句优化容易。</li>
</ul>
<p>开发难易程度和学习成本</p>
<ul>
<li>Hibernate 是重量级框架，学习使用门槛高，适合于需求相对稳定，中小型的项目，比如：办公自动化系统</li>
<li>MyBatis 是轻量级框架，学习使用门槛低，适合于需求变化频繁，大型的项目，比如：互联网电子商务系统</li>
</ul>
<p><strong>总结</strong></p>
<p>MyBatis 是一个小巧、方便、高效、简单、直接、半自动化的持久层框架，</p>
<p>Hibernate 是一个强大、方便、高效、复杂、间接、全自动化的持久层框架。</p>
<h4 id="MyBatis的解析和运行原理"><a href="#MyBatis的解析和运行原理" class="headerlink" title="MyBatis的解析和运行原理"></a>MyBatis的解析和运行原理</h4><h5 id="MyBatis编程步骤是什么样的？"><a href="#MyBatis编程步骤是什么样的？" class="headerlink" title="MyBatis编程步骤是什么样的？"></a>MyBatis编程步骤是什么样的？</h5><p>1、 创建SqlSessionFactory</p>
<p>2、 通过SqlSessionFactory创建SqlSession</p>
<p>3、 通过sqlsession执行数据库操作</p>
<p>4、 调用session.commit()提交事务</p>
<p>5、 调用session.close()关闭会话</p>
<h5 id="请说说MyBatis的工作原理"><a href="#请说说MyBatis的工作原理" class="headerlink" title="请说说MyBatis的工作原理"></a>请说说MyBatis的工作原理</h5><p>在学习 MyBatis 程序之前，需要了解一下 MyBatis 工作原理，以便于理解程序。MyBatis 的工作原理如下图</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL015QmF0aXMlRTYlQTElODYlRTYlOUUlQjYlRTYlODAlQkIlRTclQkIlOTMvTXlCYXRpcyVFNSVCNyVBNSVFNCVCRCU5QyVFNSU4RSU5RiVFNyU5MCU4Ni5wbmc" alt></p>
<p>1）读取 MyBatis 配置文件：mybatis-config.xml 为 MyBatis 的全局配置文件，配置了 MyBatis 的运行环境等信息，例如数据库连接信息。</p>
<p>2）加载映射文件。映射文件即 SQL 映射文件，该文件中配置了操作数据库的 SQL 语句，需要在 MyBatis 配置文件 mybatis-config.xml 中加载。mybatis-config.xml 文件可以加载多个映射文件，每个文件对应数据库中的一张表。</p>
<p>3）构造会话工厂：通过 MyBatis 的环境等配置信息构建会话工厂 SqlSessionFactory。</p>
<p>4）创建会话对象：由会话工厂创建 SqlSession 对象，该对象中包含了执行 SQL 语句的所有方法。</p>
<p>5）Executor 执行器：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据 SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。</p>
<p>6）MappedStatement 对象：在 Executor 接口的执行方法中有一个 MappedStatement 类型的参数，该参数是对映射信息的封装，用于存储要映射的 SQL 语句的 id、参数等信息。</p>
<p>7）输入参数映射：输入参数类型可以是 Map、List 等集合类型，也可以是基本数据类型和 POJO 类型。输入参数映射过程类似于 JDBC 对 preparedStatement 对象设置参数的过程。</p>
<p>8）输出结果映射：输出结果类型可以是 Map、 List 等集合类型，也可以是基本数据类型和 POJO 类型。输出结果映射过程类似于 JDBC 对结果集的解析过程。</p>
<h5 id="MyBatis的功能架构是怎样的"><a href="#MyBatis的功能架构是怎样的" class="headerlink" title="MyBatis的功能架构是怎样的"></a>MyBatis的功能架构是怎样的</h5><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL015QmF0aXMlRTYlQTElODYlRTYlOUUlQjYlRTYlODAlQkIlRTclQkIlOTMvTXlCYXRpcyVFNSU4QSU5RiVFOCU4MyVCRCVFNiU5RSVCNiVFNiU5RSU4NC5wbmc" alt></p>
<p>我们把Mybatis的功能架构分为三层：</p>
<ul>
<li>API接口层：提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。</li>
<li>数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。</li>
<li>基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。</li>
</ul>
<h5 id="MyBatis的框架架构设计是怎么样的"><a href="#MyBatis的框架架构设计是怎么样的" class="headerlink" title="MyBatis的框架架构设计是怎么样的"></a>MyBatis的框架架构设计是怎么样的</h5><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL015QmF0aXMlRTYlQTElODYlRTYlOUUlQjYlRTYlODAlQkIlRTclQkIlOTMvTXlCYXRpcyVFNiVBMSU4NiVFNiU5RSVCNiVFNiU5RSVCNiVFNiU5RSU4NC5wbmc" alt></p>
<p>这张图从上往下看。MyBatis的初始化，会从mybatis-config.xml配置文件，解析构造成Configuration这个类，就是图中的红框。</p>
<p>(1)加载配置：配置来源于两个地方，一处是配置文件，一处是Java代码的注解，将SQL的配置信息加载成为一个个MappedStatement对象（包括了传入参数映射配置、执行的SQL语句、结果映射配置），存储在内存中。</p>
<p>(2)SQL解析：当API接口层接收到调用请求时，会接收到传入SQL的ID和传入对象（可以是Map、JavaBean或者基本数据类型），Mybatis会根据SQL的ID找到对应的MappedStatement，然后根据传入参数对象对MappedStatement进行解析，解析后可以得到最终要执行的SQL语句和参数。</p>
<p>(3)SQL执行：将最终得到的SQL和参数拿到数据库进行执行，得到操作数据库的结果。</p>
<p>(4)结果映射：将操作数据库的结果按照映射的配置进行转换，可以转换成HashMap、JavaBean或者基本数据类型，并将最终结果返回。</p>
<h5 id="为什么需要预编译"><a href="#为什么需要预编译" class="headerlink" title="为什么需要预编译"></a>为什么需要预编译</h5><ol>
<li>定义：<br>SQL 预编译指的是数据库驱动在发送 SQL 语句和参数给 DBMS 之前对 SQL 语句进行编译，这样 DBMS 执行 SQL 时，就不需要重新编译。</li>
<li>为什么需要预编译<br>JDBC 中使用对象 PreparedStatement 来抽象预编译语句，使用预编译。预编译阶段可以优化 SQL 的执行。预编译之后的 SQL 多数情况下可以直接执行，DBMS 不需要再次编译，越复杂的SQL，编译的复杂度将越大，预编译阶段可以合并多次操作为一个操作。同时预编译语句对象可以重复利用。把一个 SQL 预编译后产生的 PreparedStatement 对象缓存下来，下次对于同一个SQL，可以直接使用这个缓存的 PreparedState 对象。Mybatis默认情况下，将对所有的 SQL 进行预编译。</li>
</ol>
<h5 id="Mybatis都有哪些Executor执行器？它们之间的区别是什么？"><a href="#Mybatis都有哪些Executor执行器？它们之间的区别是什么？" class="headerlink" title="Mybatis都有哪些Executor执行器？它们之间的区别是什么？"></a>Mybatis都有哪些Executor执行器？它们之间的区别是什么？</h5><p>Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。</p>
<p><strong>SimpleExecutor</strong>：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</p>
<p><strong>ReuseExecutor</strong>：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用Statement对象。</p>
<p>BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</p>
<p>作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。</p>
<h5 id="Mybatis中如何指定使用哪一种Executor执行器？"><a href="#Mybatis中如何指定使用哪一种Executor执行器？" class="headerlink" title="Mybatis中如何指定使用哪一种Executor执行器？"></a>Mybatis中如何指定使用哪一种Executor执行器？</h5><p>在Mybatis配置文件中，在设置（settings）可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数，如SqlSession openSession(ExecutorType execType)。</p>
<p>配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。</p>
<h5 id="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"></a>Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</h5><p>Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。</p>
<p>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p>
<p>当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</p>
<h4 id="映射器"><a href="#映射器" class="headerlink" title="映射器"></a>映射器</h4><h5 id="和-的区别"><a href="#和-的区别" class="headerlink" title="#{}和${}的区别"></a>#{}和${}的区别</h5><ul>
<li>#{}是占位符，预编译处理；${}是拼接符，字符串替换，没有预编译处理。</li>
<li>Mybatis在处理#{}时，#{}传入参数是以字符串传入，会将SQL中的#{}替换为?号，调用PreparedStatement的set方法来赋值。</li>
<li>Mybatis在处理时，是原值传入，就是把{}替换成变量的值，相当于JDBC中的Statement编译</li>
<li>变量替换后，#{} 对应的变量自动加上单引号 ‘’；变量替换后，${} 对应的变量不会加上单引号 ‘’</li>
<li>#{} 可以有效的防止SQL注入，提高系统安全性；${} 不能防止SQL 注入</li>
<li>#{} 的变量替换是在DBMS 中；${} 的变量替换是在 DBMS 外</li>
</ul>
<h5 id="模糊查询like语句该怎么写"><a href="#模糊查询like语句该怎么写" class="headerlink" title="模糊查询like语句该怎么写"></a>模糊查询like语句该怎么写</h5><p>（1）’%${question}%’ 可能引起SQL注入，不推荐</p>
<p>（2）”%”#{question}”%” 注意：因为#{…}解析成sql语句时候，会在变量外侧自动加单引号’ ‘，所以这里 % 需要使用双引号” “，不能使用单引号 ’ ‘，不然会查不到任何结果。</p>
<p>（3）CONCAT(’%’,#{question},’%’) 使用CONCAT()函数，推荐</p>
<p>（4）使用bind标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"listUserLikeUsername"</span> <span class="attr">resultType</span>=<span class="string">"com.jourwon.pojo.User"</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">"pattern"</span> <span class="attr">value</span>=<span class="string">"'%' + username + '%'"</span> /&gt;</span></span><br><span class="line">　　select id,sex,age,username,password from person where username LIKE #&#123;pattern&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="在mapper中如何传递多个参数"><a href="#在mapper中如何传递多个参数" class="headerlink" title="在mapper中如何传递多个参数"></a>在mapper中如何传递多个参数</h5><p><strong>方法1：顺序传参法</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">public User selectUser(String name, int deptId);</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUser"</span> <span class="attr">resultMap</span>=<span class="string">"UserResultMap"</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line">    where user_name = #&#123;0&#125; and dept_id = #&#123;1&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>#{}里面的数字代表传入参数的顺序。</p>
<p>这种方法不建议使用，sql层表达不直观，且一旦顺序调整容易出错。</p>
<p><strong>方法2：@Param注解传参法</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">public User selectUser(@Param("userName") String name, int @Param("deptId") deptId);</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUser"</span> <span class="attr">resultMap</span>=<span class="string">"UserResultMap"</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line">    where user_name = #&#123;userName&#125; and dept_id = #&#123;deptId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>#{}里面的名称对应的是注解@Param括号里面修饰的名称。</p>
<p>这种方法在参数不多的情况还是比较直观的，推荐使用。</p>
<p><strong>方法3：Map传参法</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">public User selectUser(Map<span class="tag">&lt;<span class="name">String,</span> <span class="attr">Object</span>&gt;</span> params);</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUser"</span> <span class="attr">parameterType</span>=<span class="string">"java.util.Map"</span> <span class="attr">resultMap</span>=<span class="string">"UserResultMap"</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line">    where user_name = #&#123;userName&#125; and dept_id = #&#123;deptId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>#{}里面的名称对应的是Map里面的key名称。</p>
<p>这种方法适合传递多个参数，且参数易变能灵活传递的情况。</p>
<p><strong>方法4：Java Bean传参法</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">public User selectUser(User user);</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUser"</span> <span class="attr">parameterType</span>=<span class="string">"com.jourwon.pojo.User"</span> <span class="attr">resultMap</span>=<span class="string">"UserResultMap"</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line">    where user_name = #&#123;userName&#125; and dept_id = #&#123;deptId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>#{}里面的名称对应的是User类里面的成员属性。</p>
<p>这种方法直观，需要建一个实体类，扩展不容易，需要加属性，但代码可读性强，业务逻辑处理方便，推荐使用。</p>
<h4 id="Mybatis如何执行批量操作"><a href="#Mybatis如何执行批量操作" class="headerlink" title="Mybatis如何执行批量操作"></a>Mybatis如何执行批量操作</h4><h5 id="使用foreach标签"><a href="#使用foreach标签" class="headerlink" title="使用foreach标签"></a>使用foreach标签</h5><p>foreach的主要用在构建in条件中，它可以在SQL语句中进行迭代一个集合。foreach标签的属性主要有item，index，collection，open，separator，close。</p>
<ul>
<li>item　　表示集合中每一个元素进行迭代时的别名，随便起的变量名；</li>
<li>index　　指定一个名字，用于表示在迭代过程中，每次迭代到的位置，不常用；</li>
<li>open　　表示该语句以什么开始，常用“(”；</li>
<li>separator表示在每次进行迭代之间以什么符号作为分隔符，常用“,”；</li>
<li>close　　表示以什么结束，常用“)”。</li>
</ul>
<p>在使用foreach的时候最关键的也是最容易出错的就是collection属性，该属性是必须指定的，但是在不同情况下，该属性的值是不一样的，主要有一下3种情况：</p>
<ol>
<li>如果传入的是单参数且参数类型是一个List的时候，collection属性值为list</li>
<li>如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array</li>
<li>如果传入的参数是多个的时候，我们就需要把它们封装成一个Map了，当然单参数也可以封装成map，实际上如果你在传入参数的时候，在MyBatis里面也是会把它封装成一个Map的，<br>map的key就是参数名，所以这个时候collection属性值就是传入的List或array对象在自己封装的map里面的key</li>
</ol>
<p>具体用法如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 批量保存(foreach插入多条数据两种方法)</span></span><br><span class="line"><span class="comment">       int addEmpsBatch(@Param("emps") List&lt;Employee&gt; emps); --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- MySQL下批量保存，可以foreach遍历 mysql支持values(),(),()语法 --&gt;</span> //推荐使用</span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addEmpsBatch"</span>&gt;</span></span><br><span class="line">    INSERT INTO emp(ename,gender,email,did)</span><br><span class="line">    VALUES</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"emps"</span> <span class="attr">item</span>=<span class="string">"emp"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">        (#&#123;emp.eName&#125;,#&#123;emp.gender&#125;,#&#123;emp.email&#125;,#&#123;emp.dept.id&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这种方式需要数据库连接属性allowMutiQueries=true的支持</span></span><br><span class="line"><span class="comment"> 如jdbc.url=jdbc:mysql://localhost:3306/mybatis?allowMultiQueries=true --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addEmpsBatch"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"emps"</span> <span class="attr">item</span>=<span class="string">"emp"</span> <span class="attr">separator</span>=<span class="string">";"</span>&gt;</span>                                 </span><br><span class="line">        INSERT INTO emp(ename,gender,email,did)</span><br><span class="line">        VALUES(#&#123;emp.eName&#125;,#&#123;emp.gender&#125;,#&#123;emp.email&#125;,#&#123;emp.dept.id&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="使用ExecutorType-BATCH"><a href="#使用ExecutorType-BATCH" class="headerlink" title="使用ExecutorType.BATCH"></a>使用ExecutorType.BATCH</h5><p>Mybatis内置的ExecutorType有3种，默认为simple,该模式下它为每个语句的执行创建一个新的预处理语句，单条提交sql；而batch模式重复使用已经预处理的语句，并且批量执行所有更新语句，显然batch性能将更优； 但batch模式也有自己的问题，比如在Insert操作时，在事务没有提交之前，是没有办法获取到自增的id，这在某型情形下是不符合业务要求的</p>
<p>具体用法如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//批量保存方法测试</span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBatch</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();</span><br><span class="line">    <span class="comment">//可以执行批量操作的sqlSession</span></span><br><span class="line">    SqlSession openSession = sqlSessionFactory.openSession(ExecutorType.BATCH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//批量保存执行前时间</span></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        EmployeeMapper mapper = openSession.getMapper(EmployeeMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            mapper.addEmp(<span class="keyword">new</span> Employee(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>), <span class="string">"b"</span>, <span class="string">"1"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        openSession.commit();</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//批量保存执行后的时间</span></span><br><span class="line">        System.out.println(<span class="string">"执行时长"</span> + (end - start));</span><br><span class="line">        <span class="comment">//批量 预编译sql一次==》设置参数==》10000次==》执行1次   677</span></span><br><span class="line">        <span class="comment">//非批量  （预编译=设置参数=执行 ）==》10000次   1121</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        openSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mapper和mapper.xml如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmployeeMapper</span> </span>&#123;   </span><br><span class="line">    <span class="comment">//批量保存员工</span></span><br><span class="line">    <span class="function">Long <span class="title">addEmp</span><span class="params">(Employee employee)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;mapper namespace=<span class="string">"com.jourwon.mapper.EmployeeMapper"</span></span><br><span class="line">     &lt;!--批量保存员工 --&gt;</span><br><span class="line">    &lt;insert id=<span class="string">"addEmp"</span>&gt;</span><br><span class="line">        <span class="function">insert into <span class="title">employee</span><span class="params">(lastName,email,gender)</span></span></span><br><span class="line"><span class="function">        <span class="title">values</span><span class="params">(#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;)</span></span></span><br><span class="line"><span class="function">    &lt;/insert&gt;</span></span><br><span class="line"><span class="function">&lt;/mapper&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="如何获取生成的主键"><a href="#如何获取生成的主键" class="headerlink" title="如何获取生成的主键"></a>如何获取生成的主键</h5><p><strong>对于支持主键自增的数据库（MySQL）</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertUser"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"userId"</span> &gt;</span></span><br><span class="line">    insert into user( </span><br><span class="line">    user_name, user_password, create_time) </span><br><span class="line">    values(#&#123;userName&#125;, #&#123;userPassword&#125; , #&#123;createTime, jdbcType= TIMESTAMP&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>parameterType 可以不写，Mybatis可以推断出传入的数据类型。如果想要访问主键，那么应当parameterType 应当是java实体或者Map。这样数据在插入之后 可以通过ava实体或者Map 来获取主键值。通过 getUserId获取主键</p>
<h5 id="不支持主键自增的数据库（Oracle）"><a href="#不支持主键自增的数据库（Oracle）" class="headerlink" title="不支持主键自增的数据库（Oracle）"></a>不支持主键自增的数据库（Oracle）</h5><p>对于像Oracle这样的数据，没有提供主键自增的功能，而是使用序列的方式获取自增主键。<br>可以使用＜selectKey＞标签来获取主键的值，这种方式不仅适用于不提供主键自增功能的数据库，也适用于提供主键自增功能的数据库<br>＜selectKey＞一般的用法</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyColumn</span>=<span class="string">"id"</span> <span class="attr">resultType</span>=<span class="string">"long"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> <span class="attr">order</span>=<span class="string">"BEFORE"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>属性     描述<br>keyProperty     selectKey 语句结果应该被设置的目标属性。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。<br>keyColumn     匹配属性的返回结果集中的列名称。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。<br>resultType     结果的类型，MyBatis 通常可以推算出来。MyBatis 允许任何简单类型用作主键的类型，包括字符串。如果希望作用于多个生成的列，则可以使用一个包含期望属性的 Object 或一个 Map。<br>order     值可为BEFORE 或 AFTER。如果是 BEFORE，那么它会先执行selectKey设置 keyProperty 然后执行插入语句。如果为AFTER则相反。<br>statementType     使用何种语句类型，默认PREPARED。 有STATEMENT，PREPARED 和 CALLABLE 语句的映射类型。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>keyProperty</td>
<td>selectKey 语句结果应该被设置的目标属性。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</td>
</tr>
<tr>
<td>keyColumn</td>
<td>匹配属性的返回结果集中的列名称。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</td>
</tr>
<tr>
<td>resultType</td>
<td>结果的类型，MyBatis 通常可以推算出来。MyBatis 允许任何简单类型用作主键的类型，包括字符串。如果希望作用于多个生成的列，则可以使用一个包含期望属性的 Object 或一个 Map。</td>
</tr>
<tr>
<td>order</td>
<td>值可为BEFORE 或 AFTER。如果是 BEFORE，那么它会先执行selectKey设置 keyProperty 然后执行插入语句。如果为AFTER则相反。</td>
</tr>
<tr>
<td>statementType</td>
<td>使用何种语句类型，默认PREPARED。 有STATEMENT，PREPARED 和 CALLABLE 语句的映射类型。</td>
</tr>
</tbody></table>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertUser"</span> &gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyColumn</span>=<span class="string">"id"</span> <span class="attr">resultType</span>=<span class="string">"long"</span> <span class="attr">keyProperty</span>=<span class="string">"userId"</span> <span class="attr">order</span>=<span class="string">"BEFORE"</span>&gt;</span></span><br><span class="line">		SELECT USER_ID.nextval as id from dual </span><br><span class="line">	<span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span> </span><br><span class="line">	insert into user( </span><br><span class="line">	user_id,user_name, user_password, create_time) </span><br><span class="line">	values(#&#123;userId&#125;,#&#123;userName&#125;, #&#123;userPassword&#125; , #&#123;createTime, jdbcType= TIMESTAMP&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此时会将Oracle生成的主键值赋予userId变量。这个userId 就是USER对象的属性，这样就可以将生成的主键值返回了。如果仅仅是在insert语句中使用但是不返回，此时keyProperty=“任意自定义变量名”，resultType 可以不写。<br>Oracle 数据库中的值要设置为 BEFORE ，这是因为 Oracle中需要先从序列获取值，然后将值作为主键插入到数据库中。</p>
<p><strong>扩展</strong><br>如果Mysql 使用selectKey的方式获取主键，需要注意下面两点：</p>
<p>order ： AFTER<br>获取递增主键值 ：SELECT LAST_INSERT_ID()<br>当实体类中的属性名和表中的字段名不一样 ，怎么办</p>
<p>第1种： 通过在查询的SQL语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getOrder"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"com.jourwon.pojo.Order"</span>&gt;</span></span><br><span class="line">       select order_id id, order_no orderno ,order_price price form orders where order_id=#&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第2种： 通过<resultMap>来映射字段名和实体类属性名的一一对应的关系。</resultMap></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getOrder"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultMap</span>=<span class="string">"orderResultMap"</span>&gt;</span></span><br><span class="line">	select * from orders where order_id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.jourwon.pojo.Order"</span> <span class="attr">id</span>=<span class="string">"orderResultMap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">!–用id属性来映射主键字段–</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"order_id"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">!–用result属性来映射非主键字段，property为实体类属性名，column为数据库表中的属性–</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span> =<span class="string">"orderno"</span> <span class="attr">column</span> =<span class="string">"order_no"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"price"</span> <span class="attr">column</span>=<span class="string">"order_price"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">reslutMap</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h5 id="Mapper-编写有哪几种方式？"><a href="#Mapper-编写有哪几种方式？" class="headerlink" title="Mapper 编写有哪几种方式？"></a>Mapper 编写有哪几种方式？</h5><p>第一种：接口实现类继承 SqlSessionDaoSupport：使用此种方法需要编写mapper 接口，mapper 接口实现类、mapper.xml 文件。</p>
<p>（1）在 sqlMapConfig.xml 中配置 mapper.xml 的位置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"mapper.xml 文件的地址"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"mapper.xml 文件的地址"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）定义 mapper 接口</p>
<p>（3）实现类集成 SqlSessionDaoSupport</p>
<p>mapper 方法中可以 this.getSqlSession()进行数据增删改查。</p>
<p>（4）spring 配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">" "</span> <span class="attr">class</span>=<span class="string">"mapper 接口的实现"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactory"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第二种：使用 org.mybatis.spring.mapper.MapperFactoryBean：</p>
<p>（1）在 sqlMapConfig.xml 中配置 mapper.xml 的位置，如果 mapper.xml 和mappre 接口的名称相同且在同一个目录，这里可以不用配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"mapper.xml 文件的地址"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"mapper.xml 文件的地址"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）定义 mapper 接口：</p>
<p>（3）mapper.xml 中的 namespace 为 mapper 接口的地址</p>
<p>（4）mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致</p>
<p>（5）Spring 中定义</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperInterface"</span> <span class="attr">value</span>=<span class="string">"mapper 接口地址"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第三种：使用 mapper 扫描器：</p>
<p>（1）mapper.xml 文件编写：</p>
<p>mapper.xml 中的 namespace 为 mapper 接口的地址；</p>
<p>mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致；</p>
<p>如果将 mapper.xml 和 mapper 接口的名称保持一致则不用在 sqlMapConfig.xml中进行配置。</p>
<p>（2）定义 mapper 接口：</p>
<p>注意 mapper.xml 的文件名和 mapper 的接口名称保持一致，且放在同一个目录</p>
<p>（3）配置 mapper 扫描器：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"mapper 接口包地址</span></span></span><br><span class="line"><span class="tag"><span class="string">    "</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactoryBeanName"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">value</span>=<span class="string">"sqlSessionFactory"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（4）使用扫描器后从 spring 容器中获取 mapper 的实现对象。</p>
<h5 id="什么是MyBatis的接口绑定？有哪些实现方式？"><a href="#什么是MyBatis的接口绑定？有哪些实现方式？" class="headerlink" title="什么是MyBatis的接口绑定？有哪些实现方式？"></a>什么是MyBatis的接口绑定？有哪些实现方式？</h5><p>接口绑定，就是在MyBatis中任意定义接口，然后把接口里面的方法和SQL语句绑定，我们直接调用接口方法就可以，这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置。</p>
<p>接口绑定有两种实现方式</p>
<p>通过注解绑定，就是在接口的方法上面加上 @Select、@Update等注解，里面包含Sql语句来绑定；</p>
<p>通过xml里面写SQL来绑定， 在这种情况下，要指定xml映射文件里面的namespace必须为接口的全路径名。当Sql语句比较简单时候，用注解绑定， 当SQL语句比较复杂时候，用xml绑定，一般用xml绑定的比较多。</p>
<h5 id="使用MyBatis的mapper接口调用时有哪些要求？"><a href="#使用MyBatis的mapper接口调用时有哪些要求？" class="headerlink" title="使用MyBatis的mapper接口调用时有哪些要求？"></a>使用MyBatis的mapper接口调用时有哪些要求？</h5><p>1、Mapper接口方法名和mapper.xml中定义的每个sql的id相同。</p>
<p>2、Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同。</p>
<p>3、Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同。</p>
<p>4、Mapper.xml文件中的namespace即是mapper接口的类路径。</p>
<h5 id="最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗"><a href="#最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗" class="headerlink" title="最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗"></a>最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗</h5><p>Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。在Mybatis中，每一个<select>、<insert>、<update>、<delete>标签，都会被解析为一个MappedStatement对象。</delete></update></insert></select></p>
<p>Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</p>
<p>Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</p>
<h5 id="Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"><a href="#Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？" class="headerlink" title="Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"></a>Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</h5><p>不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。</p>
<p>原因就是namespace+id是作为Map&lt;String, MappedStatement&gt;的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。</p>
<h4 id="简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"><a href="#简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？" class="headerlink" title="简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"></a>简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？</h4><p>答：Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，<parameterMap>标签会被解析为ParameterMap对象，其每个子元素会被解析为ParameterMapping对象。<resultMap>标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个<select>、<insert>、<update>、<delete>标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。</delete></update></insert></select></resultMap></parameterMap></p>
<h5 id="Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h5><p>第一种是使用<resultMap>标签，逐一定义列名和对象属性名之间的映射关系。</resultMap></p>
<p>第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。</p>
<p>有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>
<h5 id="Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？"><a href="#Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？" class="headerlink" title="Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？"></a>Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？</h5><p>还有很多其他的标签，<resultMap>、<parameterMap>、<sql>、<include>、<selectKey>，加上动态sql的9个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，其中<sql>为sql片段标签，通过<include>标签引入sql片段，<selectKey>为不支持自增的主键生成策略标签。</selectKey></include></sql></selectKey></include></sql></parameterMap></resultMap></p>
<h5 id="Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？"><a href="#Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？" class="headerlink" title="Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？"></a>Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？</h5><p>虽然Mybatis解析Xml映射文件是按照顺序解析的，但是，被引用的B标签依然可以定义在任何地方，Mybatis都可以正确识别。</p>
<p>原理是，Mybatis解析A标签，发现A标签引用了B标签，但是B标签尚未解析到，尚不存在，此时，Mybatis会将A标签标记为未解析状态，然后继续解析余下的标签，包含B标签，待所有标签解析完毕，Mybatis会重新解析那些被标记为未解析的标签，此时再解析A标签时，B标签已经存在，A标签也就可以正常解析完成了。</p>
<h4 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h4><h5 id="MyBatis实现一对一，一对多有几种方式，怎么操作的？"><a href="#MyBatis实现一对一，一对多有几种方式，怎么操作的？" class="headerlink" title="MyBatis实现一对一，一对多有几种方式，怎么操作的？"></a>MyBatis实现一对一，一对多有几种方式，怎么操作的？</h5><p>有联合查询和嵌套查询。联合查询是几个表联合查询，只查询一次，通过在resultMap里面的association，collection节点配置一对一，一对多的类就可以完成</p>
<p>嵌套查询是先查一个表，根据这个表里面的结果的外键id，去再另外一个表里面查询数据，也是通过配置association，collection，但另外一个表的查询通过select节点配置。</p>
<h5 id="Mybatis是否可以映射Enum枚举类？"><a href="#Mybatis是否可以映射Enum枚举类？" class="headerlink" title="Mybatis是否可以映射Enum枚举类？"></a>Mybatis是否可以映射Enum枚举类？</h5><p>Mybatis可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列上。映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和getResult()接口方法。</p>
<p>TypeHandler有两个作用，一是完成从javaType至jdbcType的转换，二是完成jdbcType至javaType的转换，体现为setParameter()和getResult()两个方法，分别代表设置sql问号占位符参数和获取列查询结果。</p>
<h4 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h4><h5 id="Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？"><a href="#Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？" class="headerlink" title="Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？"></a>Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？</h5><p>Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能，Mybatis提供了9种动态sql标签trim|where|set|foreach|if|choose|when|otherwise|bind。</p>
<p>其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。</p>
<h4 id="插件模块"><a href="#插件模块" class="headerlink" title="插件模块"></a>插件模块</h4><h5 id="Mybatis是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis是如何进行分页的？分页插件的原理是什么？"></a>Mybatis是如何进行分页的？分页插件的原理是什么？</h5><p>Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p>
<p>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p>
<p>举例：select * from student，拦截sql后重写为：select t.* from (select * from student) t limit 0, 10</p>
<h5 id="简述Mybatis的插件运行原理，以及如何编写一个插件。"><a href="#简述Mybatis的插件运行原理，以及如何编写一个插件。" class="headerlink" title="简述Mybatis的插件运行原理，以及如何编写一个插件。"></a>简述Mybatis的插件运行原理，以及如何编写一个插件。</h5><p>Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</p>
<p>实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><h5 id="Mybatis的一级、二级缓存"><a href="#Mybatis的一级、二级缓存" class="headerlink" title="Mybatis的一级、二级缓存"></a>Mybatis的一级、二级缓存</h5><p>1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。</p>
<p>2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<cache> ；</cache></p>
<p>3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis面试题</title>
    <url>/myblog/interview/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><a id="more"></a>
<h5 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h5><p>Redis(Remote Dictionary Server) 是一个使用 C 语言编写的，开源的（BSD许可）高性能非关系型（NoSQL）的键值对数据库。</p>
<p>Redis 可以存储键和五种不同类型的值之间的映射。键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。</p>
<p>与传统数据库不同的是 Redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。另外，Redis 也经常用来做分布式锁。除此之外，Redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。</p>
<h5 id="Redis有哪些优缺点"><a href="#Redis有哪些优缺点" class="headerlink" title="Redis有哪些优缺点"></a>Redis有哪些优缺点</h5><p>优点</p>
<ul>
<li><p>读写性能优异， Redis能读的速度是110000次/s，写的速度是81000次/s。</p>
</li>
<li><p>支持数据持久化，支持AOF和RDB两种持久化方式。</p>
</li>
<li><p>支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。</p>
</li>
<li><p>数据结构丰富，除了支持string类型的value外还支持hash、set、zset、list等数据结构。</p>
</li>
<li><p>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。</p>
<!--more-->

</li>
</ul>
<p>缺点</p>
<ul>
<li>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</li>
<li>Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。</li>
<li>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。</li>
<li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</li>
</ul>
<h5 id="为什么要用-Redis-为什么要用缓存"><a href="#为什么要用-Redis-为什么要用缓存" class="headerlink" title="为什么要用 Redis /为什么要用缓存"></a>为什么要用 Redis /为什么要用缓存</h5><p>主要从“高性能”和“高并发”这两点来看待这个问题。</p>
<p><strong>高性能：</strong></p>
<p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDUzNDg2OS02N2YxOGVmY2FmZTQ2NjlhLmpwZw?x-oss-process=image/format,png" alt></p>
<p><strong>高并发：</strong></p>
<p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDUzNDg2OS0wOWIxZDI3OWEwNWVmNWJjLmpwZw?x-oss-process=image/format,png" alt></p>
<h5 id="为什么要用-Redis-而不用-map-guava-做缓存"><a href="#为什么要用-Redis-而不用-map-guava-做缓存" class="headerlink" title="为什么要用 Redis 而不用 map/guava 做缓存?"></a>为什么要用 Redis 而不用 map/guava 做缓存?</h5><p>缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。</p>
<p>使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。</p>
<h5 id="Redis为什么这么快"><a href="#Redis为什么这么快" class="headerlink" title="Redis为什么这么快"></a>Redis为什么这么快</h5><p>1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)；</p>
<p>2、数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；</p>
<p>3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p>
<p>4、使用多路 I/O 复用模型，非阻塞 IO；</p>
<p>5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；<br>数据类型</p>
<h5 id="Redis有哪些数据类型"><a href="#Redis有哪些数据类型" class="headerlink" title="Redis有哪些数据类型"></a>Redis有哪些数据类型</h5><p>Redis主要有5种数据类型，包括String，List，Set，Zset，Hash，满足大部分的使用要求4</p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">可以存储的值</th>
<th align="center">操作</th>
<th align="center">应用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">STRING</td>
<td align="center">字符串、整数或者浮点数</td>
<td align="center">对整个字符串或者字符串的其中一部分执行操作 对整数和浮点数执行自增或者自减操作</td>
<td align="center">做简单的键值对缓存</td>
</tr>
<tr>
<td align="center">LIST</td>
<td align="center">列表</td>
<td align="center">从两端压入或者弹出元素 对单个或者多个元素进行修剪， 只保留一个范围内的元素</td>
<td align="center">存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的数据</td>
</tr>
<tr>
<td align="center">SET</td>
<td align="center">无序集合</td>
<td align="center">添加、获取、移除单个元素 检查一个元素是否存在于集合中  计算交集、并集、差集 从集合里面随机获取元素</td>
<td align="center">交集、并集、差集的操作，比如交集，可以把两个人的粉丝列表整一个交集</td>
</tr>
<tr>
<td align="center">HASH</td>
<td align="center">包含键值对的无序散列表</td>
<td align="center">添加、获取、移除单个键值对 获取所有键值对  检查某个键是否存在</td>
<td align="center">结构化的数据，比如一个对象</td>
</tr>
<tr>
<td align="center">ZSET</td>
<td align="center">有序集合</td>
<td align="center">添加、获取、删除元素 根据分值范围或者成员来获取元素  计算一个键的排名</td>
<td align="center">去重但可以排序，如获取排名前几名的用户</td>
</tr>
</tbody></table>
<h5 id="Redis的应用场景"><a href="#Redis的应用场景" class="headerlink" title="Redis的应用场景"></a>Redis的应用场景</h5><p><strong>总结一</strong></p>
<p>计数器</p>
<p>可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</p>
<p>缓存</p>
<p>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</p>
<p>会话缓存</p>
<p>可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</p>
<p>全页缓存（FPC）</p>
<p>除基本的会话token之外，Redis还提供很简便的FPC平台。以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</p>
<p>查找表</p>
<p>例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。</p>
<p>消息队列(发布/订阅功能)</p>
<p>List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。</p>
<p>分布式锁实现</p>
<p>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</p>
<p>其它</p>
<p>Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet 可以实现有序性操作，从而实现排行榜等功能。</p>
<p><strong>总结二</strong></p>
<p>Redis相比其他缓存，有一个非常大的优势，就是支持多种数据类型。</p>
<p>数据类型说明string字符串，最简单的k-v存储hashhash格式，value为field和value，适合ID-Detail这样的场景。list简单的list，顺序列表，支持首位或者末尾插入数据set无序list，查找速度快，适合交集、并集、差集处理sorted set有序的set</p>
<p>其实，通过上面的数据类型的特性，基本就能想到合适的应用场景了。</p>
<p>string——适合最简单的k-v存储，类似于memcached的存储结构，短信验证码，配置信息等，就用这种类型来存储。</p>
<p>hash——一般key为ID或者唯一标示，value对应的就是详情了。如商品详情，个人信息详情，新闻详情等。</p>
<p>list——因为list是有序的，比较适合存储一些有序且数据相对固定的数据。如省市区表、字典表等。因为list是有序的，适合根据写入的时间来排序，如：最新的***，消息队列等。</p>
<p>set——可以简单的理解为ID-List的模式，如微博中一个人有哪些好友，set最牛的地方在于，可以对两个set提供交集、并集、差集操作。例如：查找两个人共同的好友等。</p>
<p>Sorted Set——是set的增强版本，增加了一个score参数，自动会根据score的值进行排序。比较适合类似于top 10等不根据插入的时间来排序的数据。</p>
<p>如上所述，虽然Redis不像关系数据库那么复杂的数据结构，但是，也能适合很多场景，比一般的缓存数据结构要多。了解每种数据结构适合的业务场景，不仅有利于提升开发效率，也能有效利用Redis的性能。</p>
<h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><h5 id="什么是Redis持久化？"><a href="#什么是Redis持久化？" class="headerlink" title="什么是Redis持久化？"></a>什么是Redis持久化？</h5><p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。</p>
<h5 id="Redis-的持久化机制是什么？各自的优缺点？"><a href="#Redis-的持久化机制是什么？各自的优缺点？" class="headerlink" title="Redis 的持久化机制是什么？各自的优缺点？"></a>Redis 的持久化机制是什么？各自的优缺点？</h5><p>Redis 提供两种持久化机制 RDB（默认） 和 AOF 机制:</p>
<p>RDB：是Redis DataBase缩写快照</p>
<p>RDB是Redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MDU1NjY2LWMwNzAyMjIzMTUxODUyMjkucG5n?x-oss-process=image/format,png" alt></p>
<p>优点：</p>
<ul>
<li>1、只有一个文件 dump.rdb，方便持久化。</li>
<li>2、容灾性好，一个文件可以保存到安全的磁盘。</li>
<li>3、性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能</li>
<li>4.相对于数据集大时，比 AOF 的启动效率更高。</li>
</ul>
<p>缺点：</p>
<ul>
<li>1、数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)</li>
<li>2、AOF（Append-only file)持久化方式： 是指所有的命令行记录以 redis 命令请 求协议的格式完全持久化存储)保存为 aof 文件。</li>
</ul>
<p>AOF：持久化</p>
<p>AOF持久化(即Append Only File持久化)，则是将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。</p>
<p>当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MDU1NjY2LWUxN2NlNTY0NGZjN2FjZjMucG5n?x-oss-process=image/format,png" alt></p>
<p>优点：</p>
<ul>
<li>1、数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。</li>
<li>2、通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</li>
<li>3、AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)</li>
</ul>
<p>缺点：</p>
<ul>
<li>1、AOF 文件比 RDB 文件大，且恢复速度慢。</li>
<li>2、数据集大的时候，比 rdb 启动效率低。</li>
</ul>
<p>优缺点是什么？</p>
<ul>
<li>AOF文件比RDB更新频率高，优先使用AOF还原数据。</li>
<li>AOF比RDB更安全也更大</li>
<li>RDB性能比AOF好</li>
<li>如果两个都配了优先加载AOF</li>
</ul>
<p>如何选择合适的持久化方式</p>
<ul>
<li>一般来说， 如果想达到足以媲美PostgreSQL的数据安全性，你应该同时使用两种持久化功能。在这种情况下，当 Redis 重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</li>
<li>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用RDB持久化。</li>
<li>有很多用户都只使用AOF持久化，但并不推荐这种方式，因为定时生成RDB快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快，除此之外，使用RDB还可以避免AOF程序的bug。</li>
<li>如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。</li>
</ul>
<h5 id="Redis持久化数据和缓存怎么做扩容？"><a href="#Redis持久化数据和缓存怎么做扩容？" class="headerlink" title="Redis持久化数据和缓存怎么做扩容？"></a>Redis持久化数据和缓存怎么做扩容？</h5><ul>
<li>如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。</li>
<li>如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。</li>
</ul>
<h4 id="过期键的删除策略"><a href="#过期键的删除策略" class="headerlink" title="过期键的删除策略"></a>过期键的删除策略</h4><h5 id="Redis的过期键的删除策略"><a href="#Redis的过期键的删除策略" class="headerlink" title="Redis的过期键的删除策略"></a>Redis的过期键的删除策略</h5><p>我们都知道，Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。</p>
<p>过期策略通常有以下三种：</p>
<ul>
<li>定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</li>
<li>惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</li>
<li>定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。<br>(expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)</li>
</ul>
<p>Redis中同时使用了惰性过期和定期过期两种过期策略。</p>
<h5 id="Redis-key的过期时间和永久有效分别怎么设置？"><a href="#Redis-key的过期时间和永久有效分别怎么设置？" class="headerlink" title="Redis key的过期时间和永久有效分别怎么设置？"></a>Redis key的过期时间和永久有效分别怎么设置？</h5><p>EXPIRE和PERSIST命令。</p>
<h5 id="我们知道通过expire来设置key-的过期时间，那么对过期的数据怎么处理呢"><a href="#我们知道通过expire来设置key-的过期时间，那么对过期的数据怎么处理呢" class="headerlink" title="我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢?"></a>我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢?</h5><p>除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p>
<ol>
<li>定时去清理过期的缓存；</li>
<li>当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</li>
</ol>
<p>两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</p>
<h4 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a>内存相关</h4><h5 id="MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"><a href="#MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据" class="headerlink" title="MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"></a>MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据</h5><p>redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</p>
<h5 id="Redis的内存淘汰策略有哪些"><a href="#Redis的内存淘汰策略有哪些" class="headerlink" title="Redis的内存淘汰策略有哪些"></a>Redis的内存淘汰策略有哪些</h5><p>Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。</p>
<p><strong>全局的键空间选择性移除</strong></p>
<ul>
<li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。</li>
<li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（这个是最常用的）</li>
<li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。</li>
</ul>
<p><strong>设置过期时间的键空间选择性移除</strong></p>
<ul>
<li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。</li>
<li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。</li>
<li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。</li>
</ul>
<p>总结</p>
<p>Redis的内存淘汰策略的选取并不会影响过期的key的处理。内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；过期策略用于处理过期的缓存数据。</p>
<h5 id="Redis主要消耗什么物理资源？"><a href="#Redis主要消耗什么物理资源？" class="headerlink" title="Redis主要消耗什么物理资源？"></a>Redis主要消耗什么物理资源？</h5><p>内存。</p>
<h5 id="Redis的内存用完了会发生什么？"><a href="#Redis的内存用完了会发生什么？" class="headerlink" title="Redis的内存用完了会发生什么？"></a>Redis的内存用完了会发生什么？</h5><p>如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以配置内存淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。</p>
<h5 id="Redis如何做内存优化？"><a href="#Redis如何做内存优化？" class="headerlink" title="Redis如何做内存优化？"></a>Redis如何做内存优化？</h5><p>可以好好利用Hash,list,sorted set,set等集合类型数据，因为通常情况下很多小的Key-Value可以用更紧凑的方式存放到一起。尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key，而是应该把这个用户的所有信息存储到一张散列表里面</p>
<h4 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h4><h5 id="Redis线程模型"><a href="#Redis线程模型" class="headerlink" title="Redis线程模型"></a>Redis线程模型</h5><p>Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器（file event handler）。它的组成结构为4部分：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。</p>
<ul>
<li>文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li>
<li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li>
</ul>
<p>虽然文件事件处理器以单线程方式运行， 但通过使用 I/O 多路复用程序来监听多个套接字， 文件事件处理器既实现了高性能的网络通信模型， 又可以很好地与 redis 服务器中其他同样以单线程方式运行的模块进行对接， 这保持了 Redis 内部单线程设计的简单性。</p>
<p>参考：<a href="https://www.cnblogs.com/barrywxx/p/8570821.html" target="_blank" rel="noopener">https://www.cnblogs.com/barrywxx/p/8570821.html</a></p>
<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><h5 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h5><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。<br>Redis事务的概念</p>
<p>Redis 事务的本质是通过MULTI、EXEC、WATCH等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p>
<p>总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p>
<h5 id="Redis事务的三个阶段"><a href="#Redis事务的三个阶段" class="headerlink" title="Redis事务的三个阶段"></a>Redis事务的三个阶段</h5><ol>
<li>事务开始 MULTI</li>
<li>命令入队</li>
<li>事务执行 EXEC</li>
</ol>
<p>事务执行过程中，如果服务端收到有EXEC、DISCARD、WATCH、MULTI之外的请求，将会把请求放入队列中排队</p>
<h5 id="Redis事务相关命令"><a href="#Redis事务相关命令" class="headerlink" title="Redis事务相关命令"></a>Redis事务相关命令</h5><p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的</p>
<p>Redis会将一个事务中的所有命令序列化，然后按顺序执行。</p>
<ol>
<li>redis 不支持回滚，“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。</li>
<li>如果在一个事务中的命令出现错误，那么所有的命令都不会执行；</li>
<li>如果在一个事务中出现运行错误，那么正确的命令会被执行。</li>
</ol>
<ul>
<li>WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。</li>
<li>MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。</li>
<li>EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。</li>
<li>通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。</li>
<li>UNWATCH命令可以取消watch对所有key的监控。</li>
</ul>
<h4 id="事务管理（ACID）概述"><a href="#事务管理（ACID）概述" class="headerlink" title="事务管理（ACID）概述"></a>事务管理（ACID）概述</h4><p>原子性（Atomicity）<br>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</p>
<p>一致性（Consistency）<br>事务前后数据的完整性必须保持一致。</p>
<p>隔离性（Isolation）<br>多个事务并发执行时，一个事务的执行不应影响其他事务的执行</p>
<p>持久性（Durability）<br>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响</p>
<p><strong>Redis的事务总是具有ACID中的一致性和隔离性</strong>，其他特性是不支持的。当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，事务也具有耐久性。</p>
<h5 id="Redis事务支持隔离性吗"><a href="#Redis事务支持隔离性吗" class="headerlink" title="Redis事务支持隔离性吗"></a>Redis事务支持隔离性吗</h5><p>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，<strong>Redis 的事务是总是带有隔离性的。</strong></p>
<h5 id="Redis事务保证原子性吗，支持回滚吗"><a href="#Redis事务保证原子性吗，支持回滚吗" class="headerlink" title="Redis事务保证原子性吗，支持回滚吗"></a>Redis事务保证原子性吗，支持回滚吗</h5><p>Redis中，单条命令是原子性执行的，但<strong>事务不保证原子性，且没有回滚</strong>。事务中任意命令执行失败，其余的命令仍会被执行。</p>
<h5 id="Redis事务其他实现"><a href="#Redis事务其他实现" class="headerlink" title="Redis事务其他实现"></a>Redis事务其他实现</h5><ul>
<li>基于Lua脚本，Redis可以保证脚本内的命令一次性、按顺序地执行，<br>其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完<br>、</li>
<li>基于中间标记变量，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐</li>
</ul>
<h4 id="集群方案"><a href="#集群方案" class="headerlink" title="集群方案"></a>集群方案</h4><h5 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h5><p><img src="https://img-blog.csdnimg.cn/20200115174006561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<h5 id="哨兵的介绍"><a href="#哨兵的介绍" class="headerlink" title="哨兵的介绍"></a>哨兵的介绍</h5><p>sentinel，中文名是哨兵。哨兵是 redis 集群机构中非常重要的一个组件，主要有以下功能：</p>
<ul>
<li>集群监控：负责监控 redis master 和 slave 进程是否正常工作。</li>
<li>消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</li>
<li>故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。</li>
<li>配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。</li>
</ul>
<p><strong>哨兵用于实现 redis 集群的高可用</strong>，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。</p>
<ul>
<li>故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题。</li>
<li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身是单点的，那就很坑爹了。</li>
</ul>
<p><strong>哨兵的核心知识</strong></p>
<ul>
<li>哨兵至少需要 3 个实例，来保证自己的健壮性。</li>
<li>哨兵 + redis 主从的部署架构，是不保证数据零丢失的，只能保证 redis 集群的高可用性。</li>
<li>对于哨兵 + redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。</li>
</ul>
<h5 id="官方Redis-Cluster-方案-服务端路由查询"><a href="#官方Redis-Cluster-方案-服务端路由查询" class="headerlink" title="官方Redis Cluster 方案(服务端路由查询)"></a>官方Redis Cluster 方案(服务端路由查询)</h5><p><img src="https://img-blog.csdnimg.cn/20200115173621637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<p>redis 集群模式的工作原理能说一下么？在集群模式下，redis 的 key 是如何寻址的？分布式寻址都有哪些算法？了解一致性 hash 算法吗？</p>
<p><strong>简介</strong></p>
<p>Redis Cluster是一种服务端Sharding技术，3.0版本开始正式提供。Redis Cluster并没有使用一致性hash，而是采用slot(槽)的概念，一共分成16384个槽。将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行</p>
<p><strong>方案说明</strong></p>
<ol>
<li>通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽(哈希值)区间的数据，默认分配了16384 个槽位</li>
<li>每份数据分片会存储在多个互为主从的多节点上</li>
<li>数据写入先写主节点，再同步到从节点(支持配置为阻塞同步)</li>
<li>同一分片多个节点间的数据不保持一致性</li>
<li>读取数据时，当客户端操作的key没有分配在该节点上时，redis会返回转向指令，指向正确的节点</li>
<li>扩容时时需要需要把旧节点的数据迁移一部分到新节点</li>
</ol>
<p>在 redis cluster 架构下，每个 redis 要放开两个端口号，比如一个是 6379，另外一个就是 加1w 的端口号，比如 16379。</p>
<p>16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议，gossip 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。</p>
<p><strong>节点间的内部通信机制</strong></p>
<p>基本通信原理</p>
<p>集群元数据的维护有两种方式：集中式、Gossip 协议。redis cluster 节点间采用 gossip 协议进行通信。</p>
<p><strong>分布式寻址算法</strong></p>
<ul>
<li>hash 算法（大量缓存重建）</li>
<li>一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）</li>
<li>redis cluster 的 hash slot 算法</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>无中心架构，支持动态扩容，对业务透明</li>
<li>具备Sentinel的监控和自动Failover(故障转移)能力</li>
<li>客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可</li>
<li>高性能，客户端直连redis服务，免去了proxy代理的损耗</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>运维也很复杂，数据迁移需要人工干预</li>
<li>只能使用0号数据库</li>
<li>不支持批量操作(pipeline管道操作)</li>
<li>分布式逻辑和存储模块耦合等</li>
</ul>
<p>基于客户端分配</p>
<p><img src="https://img-blog.csdnimg.cn/20200115173640248.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<p><strong>简介</strong></p>
<p>Redis Sharding是Redis Cluster出来之前，业界普遍使用的多Redis实例集群方法。其主要思想是采用哈希算法将Redis数据的key进行散列，通过hash函数，特定的key会映射到特定的Redis节点上。Java redis客户端驱动jedis，支持Redis Sharding功能，即ShardedJedis以及结合缓存池的ShardedJedisPool</p>
<p><strong>优点</strong></p>
<p>优势在于非常简单，服务端的Redis实例彼此独立，相互无关联，每个Redis实例像单服务器一样运行，非常容易线性扩展，系统的灵活性很强</p>
<p><strong>缺点</strong></p>
<ul>
<li>由于sharding处理放到客户端，规模进一步扩大时给运维带来挑战。</li>
<li>客户端sharding不支持动态增删节点。服务端Redis实例群拓扑结构有变化时，每个客户端都需要更新调整。连接不能共享，当应用规模增大时，资源浪费制约优化</li>
</ul>
<h5 id="基于代理服务器分片"><a href="#基于代理服务器分片" class="headerlink" title="基于代理服务器分片"></a>基于代理服务器分片</h5><p><img src="https://img-blog.csdnimg.cn/20200115173630730.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<p><strong>简介</strong></p>
<p>客户端发送请求到一个代理组件，代理解析客户端的数据，并将请求转发至正确的节点，最后将结果回复给客户端</p>
<p><strong>特征</strong></p>
<ul>
<li>透明接入，业务程序不用关心后端Redis实例，切换成本低</li>
<li>Proxy 的逻辑和存储的逻辑是隔离的</li>
<li>代理层多了一次转发，性能有所损耗</li>
</ul>
<p><strong>业界开源方案</strong></p>
<ul>
<li>Twtter开源的Twemproxy</li>
<li>豌豆荚开源的Codis</li>
</ul>
<h5 id="Redis-主从架构"><a href="#Redis-主从架构" class="headerlink" title="Redis 主从架构"></a>Redis 主从架构</h5><p>单机的 redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑读<strong>高并发</strong>的。因此架构做成主从(master-slave)架构，一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。所有的<strong>读请求全部走从节点</strong>。这样也可以很轻松实现水平扩容，<strong>支撑读高并发。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200115180329317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<p>redis replication -&gt; 主从架构 -&gt; 读写分离 -&gt; 水平扩容支撑读高并发</p>
<h5 id="redis-replication-的核心机制"><a href="#redis-replication-的核心机制" class="headerlink" title="redis replication 的核心机制"></a>redis replication 的核心机制</h5><ul>
<li>redis 采用异步方式复制数据到 slave 节点，不过 redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量；</li>
<li>一个 master node 是可以配置多个 slave node 的；</li>
<li>slave node 也可以连接其他的 slave node；</li>
<li>slave node 做复制的时候，不会 block master node 的正常工作；</li>
<li>slave node 在做复制的时候，也不会 block 对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了；</li>
<li>slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量。</li>
</ul>
<p>注意，如果采用了主从架构，那么建议必须<strong>开启</strong> master node 的持久化，不建议用 slave node 作为 master node 的数据热备，因为那样的话，如果你关掉 master 的持久化，可能在 master 宕机重启的时候数据是空的，然后可能一经过复制， slave node 的数据也丢了。</p>
<p>另外，master 的各种备份方案，也需要做。万一本地的所有文件丢失了，从备份中挑选一份 rdb 去恢复 master，这样才能<strong>确保启动的时候，是有数据的</strong>，即使采用了后续讲解的高可用机制，slave node 可以自动接管 master node，但也可能 sentinel 还没检测到 master failure，master node 就自动重启了，还是可能导致上面所有的 slave node 数据被清空。</p>
<p><strong>redis 主从复制的核心原理</strong></p>
<p>当启动一个 slave node 的时候，它会发送一个 PSYNC 命令给 master node。</p>
<p>如果这是 slave node 初次连接到 master node，那么会触发一次 full resynchronization 全量复制。此时 master 会启动一个后台线程，开始生成一份 RDB 快照文件，</p>
<p>同时还会将从客户端 client 新收到的所有写命令缓存在内存中。RDB 文件生成完毕后， master 会将这个 RDB 发送给 slave，slave 会<strong>先写入本地磁盘，然后再从本地磁盘加载到内存</strong>中，</p>
<p>接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。</p>
<p>slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。</p>
<p><img src="https://img-blog.csdnimg.cn/20200115180337645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<p><strong>过程原理</strong></p>
<ol>
<li>当从库和主库建立MS关系后，会向主数据库发送SYNC命令</li>
<li>主库接收到SYNC命令后会开始在后台保存快照(RDB持久化过程)，并将期间接收到的写命令缓存起来</li>
<li>当快照完成后，主Redis会将快照文件和所有缓存的写命令发送给从Redis</li>
<li>从Redis接收到后，会载入快照文件并且执行收到的缓存的命令</li>
<li>之后，主Redis每当接收到写命令时就会将命令发送从Redis，从而保证数据的一致</li>
</ol>
<p><strong>缺点</strong></p>
<p>所有的slave节点数据的复制和同步都由master节点来处理，会照成master节点压力太大，使用主从从结构来解决</p>
<h5 id="Redis集群的主从复制模型是怎样的？"><a href="#Redis集群的主从复制模型是怎样的？" class="headerlink" title="Redis集群的主从复制模型是怎样的？"></a>Redis集群的主从复制模型是怎样的？</h5><p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型，每个节点都会有N-1个复制品</p>
<h5 id="生产环境中的-redis-是怎么部署的？"><a href="#生产环境中的-redis-是怎么部署的？" class="headerlink" title="生产环境中的 redis 是怎么部署的？"></a>生产环境中的 redis 是怎么部署的？</h5><p>redis cluster，10 台机器，5 台机器部署了 redis 主实例，另外 5 台机器部署了 redis 的从实例，每个主实例挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰qps可能可以达到每秒 5 万，5 台机器最多是 25 万读写请求/s。</p>
<p>机器是什么配置？32G 内存+ 8 核 CPU + 1T 磁盘，但是分配给 redis 进程的是10g内存，一般线上生产环境，redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。</p>
<p>5 台机器对外提供读写，一共有 50g 内存。</p>
<p>因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，redis 从实例会自动变成主实例继续提供读写服务。</p>
<p>你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是 10kb。100 条数据是 1mb，10 万条数据是 1g。常驻内存的是 200 万条商品数据，占用内存是 20g，仅仅不到总内存的 50%。目前高峰期每秒就是 3500 左右的请求量。</p>
<p>其实大型的公司，会有基础架构的 team 负责缓存集群的运维。</p>
<h5 id="说说Redis哈希槽的概念？"><a href="#说说Redis哈希槽的概念？" class="headerlink" title="说说Redis哈希槽的概念？"></a>说说Redis哈希槽的概念？</h5><p>Redis集群没有使用一致性hash,而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。</p>
<h5 id="Redis集群会有写操作丢失吗？为什么？"><a href="#Redis集群会有写操作丢失吗？为什么？" class="headerlink" title="Redis集群会有写操作丢失吗？为什么？"></a>Redis集群会有写操作丢失吗？为什么？</h5><p>Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。</p>
<h5 id="Redis集群之间是如何复制的？"><a href="#Redis集群之间是如何复制的？" class="headerlink" title="Redis集群之间是如何复制的？"></a>Redis集群之间是如何复制的？</h5><p>异步复制</p>
<h5 id="Redis集群最大节点个数是多少？"><a href="#Redis集群最大节点个数是多少？" class="headerlink" title="Redis集群最大节点个数是多少？"></a>Redis集群最大节点个数是多少？</h5><p>16384个</p>
<h5 id="Redis集群如何选择数据库？"><a href="#Redis集群如何选择数据库？" class="headerlink" title="Redis集群如何选择数据库？"></a>Redis集群如何选择数据库？</h5><p>Redis集群目前无法做数据库选择，默认在0数据库。<br>分区</p>
<h5 id="Redis是单线程的，如何提高多核CPU的利用率？"><a href="#Redis是单线程的，如何提高多核CPU的利用率？" class="headerlink" title="Redis是单线程的，如何提高多核CPU的利用率？"></a>Redis是单线程的，如何提高多核CPU的利用率？</h5><p>可以在同一个服务器部署多个Redis的实例，并把他们当作不同的服务器来使用，在某些时候，无论如何一个服务器是不够的， 所以，如果你想使用多个CPU，你可以考虑一下分片（shard）。</p>
<h5 id="为什么要做Redis分区？"><a href="#为什么要做Redis分区？" class="headerlink" title="为什么要做Redis分区？"></a>为什么要做Redis分区？</h5><p>分区可以让Redis管理更大的内存，Redis将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。分区使Redis的计算能力通过简单地增加计算机得到成倍提升，Redis的网络带宽也会随着计算机和网卡的增加而成倍增长。</p>
<h5 id="你知道有哪些Redis分区实现方案？"><a href="#你知道有哪些Redis分区实现方案？" class="headerlink" title="你知道有哪些Redis分区实现方案？"></a>你知道有哪些Redis分区实现方案？</h5><ul>
<li>客户端分区就是在客户端就已经决定数据会被存储到哪个redis节点或者从哪个redis节点读取。大多数客户端已经实现了客户端分区。</li>
<li>代理分区 意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些Redis实例，然后根据Redis的响应结果返回给客户端。redis和memcached的一种代理实现就是Twemproxy</li>
<li>查询路由(Query routing) 的意思是客户端随机地请求任意一个redis实例，然后由Redis将请求转发给正确的Redis节点。Redis Cluster实现了一种混合形式的查询路由，但并不是直接将请求从一个redis节点转发到另一个redis节点，而是在客户端的帮助下直接redirected到正确的redis节点。</li>
</ul>
<h5 id="Redis分区有什么缺点？"><a href="#Redis分区有什么缺点？" class="headerlink" title="Redis分区有什么缺点？"></a>Redis分区有什么缺点？</h5><ul>
<li>涉及多个key的操作通常不会被支持。例如你不能对两个集合求交集，因为他们可能被存储到不同的Redis实例（实际上这种情况也有办法，但是不能直接使用交集指令）。</li>
<li>同时操作多个key,则不能使用Redis事务.</li>
<li>分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集（The partitioning granularity is the key, so it is not possible to shard a dataset with a single huge key like a very big sorted set）</li>
<li>当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的Redis实例和主机同时收集RDB / AOF文件。</li>
<li>分区时动态扩容或缩容可能非常复杂。Redis集群在运行时增加或者删除Redis节点，能做到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这种特性。然而，有一种预分片的技术也可以较好的解决这个问题。</li>
</ul>
<h4 id="分布式问题"><a href="#分布式问题" class="headerlink" title="分布式问题"></a>分布式问题</h4><h5 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h5><p>Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用SETNX命令实现分布式锁。</p>
<p>当且仅当 key 不存在，将 key 的值设为 value。 若给定的 key 已经存在，则 SETNX 不做任何动作</p>
<p>SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p>
<p>返回值：设置成功，返回 1 。设置失败，返回 0 。</p>
<p><img src="https://img-blog.csdnimg.cn/20191213103148681.png" alt></p>
<p>使用SETNX完成同步锁的流程及事项如下：</p>
<p>使用SETNX命令获取锁，若返回0（key已存在，锁已存在）则获取失败，反之获取成功</p>
<p>为了防止获取锁后程序出现异常，导致其他线程/进程调用SETNX命令总是返回0而进入死锁状态，需要为该key设置一个“合理”的过期时间</p>
<p>释放锁，使用DEL命令将锁数据删除</p>
<h5 id="如何解决-Redis-的并发竞争-Key-问题"><a href="#如何解决-Redis-的并发竞争-Key-问题" class="headerlink" title="如何解决 Redis 的并发竞争 Key 问题"></a>如何解决 Redis 的并发竞争 Key 问题</h5><p>所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！</p>
<p>推荐一种方案：分布式锁（zookeeper 和 redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）</p>
<p>基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</p>
<p>在实践中，当然是从以可靠性为主。所以首推Zookeeper。</p>
<p>参考：<a href="https://www.jianshu.com/p/8bddd381de06" target="_blank" rel="noopener">https://www.jianshu.com/p/8bddd381de06</a></p>
<h5 id="分布式Redis是前期做还是后期规模上来了再做好？为什么？"><a href="#分布式Redis是前期做还是后期规模上来了再做好？为什么？" class="headerlink" title="分布式Redis是前期做还是后期规模上来了再做好？为什么？"></a>分布式Redis是前期做还是后期规模上来了再做好？为什么？</h5><p>既然Redis是如此的轻量（单实例只使用1M内存），为防止以后的扩容，最好的办法就是一开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让Redis以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。</p>
<p>一开始就多设置几个Redis实例，例如32或者64个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看做这点牺牲是值得的。</p>
<p>这样的话，当你的数据不断增长，需要更多的Redis服务器时，你需要做的就是仅仅将Redis实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了另一台服务器，你需要将你一半的Redis实例从第一台机器迁移到第二台机器。</p>
<h5 id="什么是-RedLock"><a href="#什么是-RedLock" class="headerlink" title="什么是 RedLock"></a>什么是 RedLock</h5><p>Redis 官方站提出了一种权威的基于 Redis 实现分布式锁的方式名叫 Redlock，此种方式比原先的单节点的方法更安全。它可以保证以下特性：</p>
<ol>
<li>安全特性：互斥访问，即永远只有一个 client 能拿到锁</li>
<li>避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源的 client crash 了或者出现了网络分区</li>
<li>容错性：只要大部分 Redis 节点存活就可以正常提供服务</li>
</ol>
<h4 id="缓存异常"><a href="#缓存异常" class="headerlink" title="缓存异常"></a>缓存异常</h4><h5 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h5><p><strong>缓存雪崩</strong>是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p>解决方案</p>
<ol>
<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li>
<li>一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。</li>
<li>给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。</li>
</ol>
<h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p><strong>缓存穿透</strong>是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p><strong>解决方案</strong></p>
<ol>
<li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；</li>
<li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</li>
<li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力</li>
</ol>
<p><strong>附加</strong></p>
<p>对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。<br>Bitmap： 典型的就是哈希表<br>缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了。</p>
<p>布隆过滤器（推荐）</p>
<p>就是引入了k(k&gt;1)k(k&gt;1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。<br>它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。<br>Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。<br>Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是Bloom-Filter的基本思想。<br>Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。</p>
<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p><strong>缓存击穿</strong>是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p>
<p><strong>解决方案</strong></p>
<ol>
<li>设置热点数据永远不过期。</li>
<li>加互斥锁，互斥锁</li>
</ol>
<h4 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h4><p><strong>缓存预热</strong>就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p>
<p>解决方案</p>
<ol>
<li>直接写个缓存刷新页面，上线时手工操作一下；</li>
<li>数据量不大，可以在项目启动的时候自动进行加载；</li>
<li>定时刷新缓存；</li>
</ol>
<h4 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h4><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p>
<p><strong>缓存降级</strong>的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p>
<p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p>
<ol>
<li>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li>
<li>警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</li>
<li>错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</li>
<li>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</li>
</ol>
<p>服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。</p>
<h4 id="热点数据和冷数据"><a href="#热点数据和冷数据" class="headerlink" title="热点数据和冷数据"></a>热点数据和冷数据</h4><p>热点数据，缓存才有价值</p>
<p>对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存</p>
<p>对于热点数据，比如我们的某IM产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。</p>
<p>数据更新前至少读取两次，缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。</p>
<p>那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到Redis缓存，减少数据库压力。</p>
<h4 id="缓存热点key"><a href="#缓存热点key" class="headerlink" title="缓存热点key"></a>缓存热点key</h4><p>缓存中的一个Key(比如一个促销商品)，在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p>
<p><strong>解决方案</strong></p>
<p>对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询</p>
<h4 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h4><h5 id="Redis支持的Java客户端都有哪些？官方推荐用哪个？"><a href="#Redis支持的Java客户端都有哪些？官方推荐用哪个？" class="headerlink" title="Redis支持的Java客户端都有哪些？官方推荐用哪个？"></a>Redis支持的Java客户端都有哪些？官方推荐用哪个？</h5><p>Redisson、Jedis、lettuce等等，官方推荐使用Redisson。</p>
<h5 id="Redis和Redisson有什么关系？"><a href="#Redis和Redisson有什么关系？" class="headerlink" title="Redis和Redisson有什么关系？"></a>Redis和Redisson有什么关系？</h5><p>Redisson是一个高级的分布式协调Redis客服端，能帮助用户在分布式环境中轻松实现一些Java的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。</p>
<h5 id="Jedis与Redisson对比有什么优缺点？"><a href="#Jedis与Redisson对比有什么优缺点？" class="headerlink" title="Jedis与Redisson对比有什么优缺点？"></a>Jedis与Redisson对比有什么优缺点？</h5><p>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
<h4 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h4><h5 id="Redis与Memcached的区别"><a href="#Redis与Memcached的区别" class="headerlink" title="Redis与Memcached的区别"></a>Redis与Memcached的区别</h5><p>两者都是非关系型内存键值数据库，现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！Redis 与 Memcached 主要有以下不同：</p>
<table>
<thead>
<tr>
<th align="center">对比参数</th>
<th align="center">Redis</th>
<th align="center">Memcached</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类型</td>
<td align="center">1. 支持内存 2. 非关系型数据库</td>
<td align="center">1. 支持内存 2. 键值对形式 3. 缓存形式</td>
</tr>
<tr>
<td align="center"><strong>数据存储类型</strong></td>
<td align="center">1. String 2. List 3. Set 4. Hash 5. Sort Set 【俗称ZSet】</td>
<td align="center">1. 文本型 2. 二进制类型</td>
</tr>
<tr>
<td align="center">查询【操作】类型</td>
<td align="center">1. 批量操作 2. 事务支持 3. 每个类型不同的CRUD</td>
<td align="center">1.常用的CRUD 2. 少量的其他命令</td>
</tr>
<tr>
<td align="center">附加功能</td>
<td align="center">1. 发布/订阅模式 2. 主从分区 3. 序列化支持 4. 脚本支持【Lua脚本】</td>
<td align="center">1. 多线程服务支持</td>
</tr>
<tr>
<td align="center"><strong>网络IO模型</strong></td>
<td align="center">1. 单线程的多路 IO 复用模型</td>
<td align="center">1. 多线程，非阻塞IO模式</td>
</tr>
<tr>
<td align="center">事件库</td>
<td align="center">自封转简易事件库AeEvent</td>
<td align="center">贵族血统的LibEvent事件库</td>
</tr>
<tr>
<td align="center"><strong>持久化支持</strong></td>
<td align="center">1. RDB 2. AOF</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center"><strong>集群模式</strong></td>
<td align="center">原生支持 cluster 模式，可以实现主从复制，读写分离</td>
<td align="center">没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据</td>
</tr>
<tr>
<td align="center">内存管理机制</td>
<td align="center">在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘</td>
<td align="center">Memcached 的数据则会一直在内存中，Memcached  将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储  100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</td>
</tr>
<tr>
<td align="center"><strong>适用场景</strong></td>
<td align="center">复杂数据结构，有持久化，高可用需求，value存储内容较大</td>
<td align="center">纯key-value，数据量非常大，并发量非常大的业务</td>
</tr>
</tbody></table>
<p>(1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</p>
<p>(2) redis的速度比memcached快很多</p>
<p>(3) redis可以持久化其数据</p>
<h5 id="如何保证缓存与数据库双写时的数据一致性？"><a href="#如何保证缓存与数据库双写时的数据一致性？" class="headerlink" title="如何保证缓存与数据库双写时的数据一致性？"></a>如何保证缓存与数据库双写时的数据一致性？</h5><p>你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？</p>
<p>一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况</p>
<p>串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p>
<p>还有一种方式就是可能会暂时产生不一致的情况，但是发生的几率特别小，就是<strong>先更新数据库，然后再删除缓存。</strong></p>
<table>
<thead>
<tr>
<th>问题场景</th>
<th>描述</th>
<th>解决</th>
</tr>
</thead>
<tbody><tr>
<td>先写缓存，再写数据库，缓存写成功，数据库写失败</td>
<td>缓存写成功，但写数据库失败或者响应延迟，则下次读取（并发读）缓存时，就出现脏读</td>
<td>这个写缓存的方式，本身就是错误的，需要改为先写数据库，把旧缓存置为失效；读取数据的时候，如果缓存不存在，则读取数据库再写缓存</td>
</tr>
<tr>
<td>先写数据库，再写缓存，数据库写成功，缓存写失败</td>
<td>写数据库成功，但写缓存失败，则下次读取（并发读）缓存时，则读不到数据</td>
<td>缓存使用时，假如读缓存失败，先读数据库，再回写缓存的方式实现</td>
</tr>
<tr>
<td>需要缓存异步刷新</td>
<td>指数据库操作和写缓存不在一个操作步骤中，比如在分布式场景下，无法做到同时写缓存或需要异步刷新（补救措施）时候</td>
<td>确定哪些数据适合此类场景，根据经验值确定合理的数据不一致时间，用户数据刷新的时间间隔</td>
</tr>
</tbody></table>
<h5 id="Redis常见性能问题和解决方案？"><a href="#Redis常见性能问题和解决方案？" class="headerlink" title="Redis常见性能问题和解决方案？"></a>Redis常见性能问题和解决方案？</h5><ol>
<li>Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化。</li>
<li>如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。</li>
<li>为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内。</li>
<li>尽量避免在压力较大的主库上增加从库</li>
<li>Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。</li>
<li>为了Master的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master&lt;–Slave1&lt;–Slave2&lt;–Slave3…，这样的结构也方便解决单点故障问题，实现Slave对Master的替换，也即，如果Master挂了，可以立马启用Slave1做Master，其他不变。</li>
</ol>
<h5 id="Redis官方为什么不提供Windows版本？"><a href="#Redis官方为什么不提供Windows版本？" class="headerlink" title="Redis官方为什么不提供Windows版本？"></a>Redis官方为什么不提供Windows版本？</h5><p>因为目前Linux版本已经相当稳定，而且用户量很大，无需开发windows版本，反而会带来兼容性等问题。</p>
<h5 id="一个字符串类型的值能存储最大容量是多少？"><a href="#一个字符串类型的值能存储最大容量是多少？" class="headerlink" title="一个字符串类型的值能存储最大容量是多少？"></a>一个字符串类型的值能存储最大容量是多少？</h5><p>512M</p>
<h5 id="Redis如何做大量数据插入？"><a href="#Redis如何做大量数据插入？" class="headerlink" title="Redis如何做大量数据插入？"></a>Redis如何做大量数据插入？</h5><p>Redis2.6开始redis-cli支持一种新的被称之为pipe mode的新模式用于执行大量数据插入工作。</p>
<h5 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h5><p>使用keys指令可以扫出指定模式的key列表。<br>对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？<br>这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p>
<h5 id="使用Redis做过异步队列吗，是如何实现的"><a href="#使用Redis做过异步队列吗，是如何实现的" class="headerlink" title="使用Redis做过异步队列吗，是如何实现的"></a>使用Redis做过异步队列吗，是如何实现的</h5><p>使用list类型保存数据信息，rpush生产消息，lpop消费消息，当lpop没有消息时，可以sleep一段时间，然后再检查有没有信息，如果不想sleep的话，可以使用blpop, 在没有信息的时候，会一直阻塞，直到信息的到来。redis可以通过pub/sub主题订阅模式实现一个生产者，多个消费者，当然也存在一定的缺点，当消费者下线时，生产的消息会丢失。</p>
<h5 id="Redis如何实现延时队列"><a href="#Redis如何实现延时队列" class="headerlink" title="Redis如何实现延时队列"></a>Redis如何实现延时队列</h5><p>使用sortedset，使用时间戳做score, 消息内容作为key,调用zadd来生产消息，消费者使用zrangbyscore获取n秒之前的数据做轮询处理。<br>Redis回收进程如何工作的？</p>
<ol>
<li>一个客户端运行了新的命令，添加了新的数据。</li>
<li>Redis检查内存使用情况，如果大于maxmemory的限制， 则根据设定好的策略进行回收。</li>
<li>一个新的命令被执行，等等。</li>
<li>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。</li>
</ol>
<p>如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。</p>
<h5 id="Redis回收使用的是什么算法？"><a href="#Redis回收使用的是什么算法？" class="headerlink" title="Redis回收使用的是什么算法？"></a>Redis回收使用的是什么算法？</h5><p>LRU算法</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot面试题</title>
    <url>/myblog/interview/Spring%20Boot%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><a id="more"></a>
<h5 id="什么是-Spring-Boot？"><a href="#什么是-Spring-Boot？" class="headerlink" title="什么是 Spring Boot？"></a>什么是 Spring Boot？</h5><p>Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。</p>
<h5 id="Spring-Boot-有哪些优点？"><a href="#Spring-Boot-有哪些优点？" class="headerlink" title="Spring Boot 有哪些优点？"></a>Spring Boot 有哪些优点？</h5><p>Spring Boot 主要有如下优点：</p>
<ol>
<li>容易上手，提升开发效率，为 Spring 开发提供一个更快、更广泛的入门体验。</li>
<li>开箱即用，远离繁琐的配置。</li>
<li>提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等。</li>
<li>没有代码生成，也不需要XML配置。</li>
<li>避免大量的 Maven 导入和各种版本冲突。</li>
</ol>
<h5 id="Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？"><a href="#Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？" class="headerlink" title="Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？"></a>Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</h5><p>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：</p>
<p>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</p>
<p>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。</p>
<p>@ComponentScan：Spring组件扫描。</p>
<!--more-->

<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><h5 id="什么是-JavaConfig？"><a href="#什么是-JavaConfig？" class="headerlink" title="什么是 JavaConfig？"></a>什么是 JavaConfig？</h5><p>Spring JavaConfig 是 Spring 社区的产品，它提供了配置 Spring IoC 容器的纯Java 方法。因此它有助于避免使用 XML 配置。使用 JavaConfig 的优点在于：</p>
<p>（1）面向对象的配置。由于配置被定义为 JavaConfig 中的类，因此用户可以充分利用 Java 中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean 方法等。</p>
<p>（2）减少或消除 XML 配置。基于依赖注入原则的外化配置的好处已被证明。但是，许多开发人员不希望在 XML 和 Java 之间来回切换。JavaConfig 为开发人员提供了一种纯 Java 方法来配置与 XML 配置概念相似的 Spring 容器。从技术角度来讲，只使用 JavaConfig 配置类来配置容器是可行的，但实际上很多人认为将JavaConfig 与 XML 混合匹配是理想的。</p>
<p>（3）类型安全和重构友好。JavaConfig 提供了一种类型安全的方法来配置 Spring容器。由于 Java 5.0 对泛型的支持，现在可以按类型而不是按名称检索 bean，不需要任何强制转换或基于字符串的查找。</p>
<h5 id="Spring-Boot-自动配置原理是什么？"><a href="#Spring-Boot-自动配置原理是什么？" class="headerlink" title="Spring Boot 自动配置原理是什么？"></a>Spring Boot 自动配置原理是什么？</h5><p>注解 @EnableAutoConfiguration, @Configuration, @ConditionalOnClass 就是自动配置的核心，</p>
<p>@EnableAutoConfiguration 给容器导入META-INF/spring.factories 里定义的自动配置类。</p>
<p>筛选有效的自动配置类。</p>
<p>每一个自动配置类结合对应的 xxxProperties.java 读取配置文件进行自动配置功能</p>
<h5 id="你如何理解-Spring-Boot-配置加载顺序？"><a href="#你如何理解-Spring-Boot-配置加载顺序？" class="headerlink" title="你如何理解 Spring Boot 配置加载顺序？"></a>你如何理解 Spring Boot 配置加载顺序？</h5><p>在 Spring Boot 里面，可以使用以下几种方式来加载配置。</p>
<p>1）properties文件；</p>
<p>2）YAML文件；</p>
<p>3）系统环境变量；</p>
<p>4）命令行参数；</p>
<p>等等……</p>
<h5 id="什么是-YAML？"><a href="#什么是-YAML？" class="headerlink" title="什么是 YAML？"></a>什么是 YAML？</h5><p>YAML 是一种人类可读的数据序列化语言。它通常用于配置文件。与属性文件相比，如果我们想要在配置文件中添加复杂的属性，YAML 文件就更加结构化，而且更少混淆。可以看出 YAML 具有分层配置数据。</p>
<h5 id="YAML-配置的优势在哪里"><a href="#YAML-配置的优势在哪里" class="headerlink" title="YAML 配置的优势在哪里 ?"></a>YAML 配置的优势在哪里 ?</h5><p>YAML 现在可以算是非常流行的一种配置文件格式了，无论是前端还是后端，都可以见到 YAML 配置。那么 YAML 配置和传统的 properties 配置相比到底有哪些优势呢？</p>
<ol>
<li>配置有序，在一些特殊的场景下，配置有序很关键</li>
<li>支持数组，数组中的元素可以是基本数据类型也可以是对象</li>
<li>简洁</li>
</ol>
<p>相比 properties 配置文件，YAML 还有一个缺点，就是不支持 @PropertySource 注解导入自定义的 YAML 配置。</p>
<h5 id="Spring-Boot-是否可以使用-XML-配置"><a href="#Spring-Boot-是否可以使用-XML-配置" class="headerlink" title="Spring Boot 是否可以使用 XML 配置 ?"></a>Spring Boot 是否可以使用 XML 配置 ?</h5><p>Spring Boot 推荐使用 Java 配置而非 XML 配置，但是 Spring Boot 中也可以使用 XML 配置，通过 @ImportResource 注解可以引入一个 XML 配置。</p>
<h5 id="spring-boot-核心配置文件是什么？bootstrap-properties-和-application-properties-有何区别"><a href="#spring-boot-核心配置文件是什么？bootstrap-properties-和-application-properties-有何区别" class="headerlink" title="spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?"></a>spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?</h5><p>单纯做 Spring Boot 开发，可能不太容易遇到 bootstrap.properties 配置文件，但是在结合 Spring Cloud 时，这个配置就会经常遇到了，特别是在需要加载一些远程配置文件的时侯。</p>
<p>spring boot 核心的两个配置文件：</p>
<ul>
<li>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效。一般来说我们在 Spring Cloud Config 或者 Nacos 中会用到它。且 boostrap 里面的属性不能被覆盖；</li>
<li>application (. yml 或者 . properties)： 由ApplicatonContext 加载，用于 spring boot 项目的自动化配置。</li>
</ul>
<h5 id="什么是-Spring-Profiles？"><a href="#什么是-Spring-Profiles？" class="headerlink" title="什么是 Spring Profiles？"></a>什么是 Spring Profiles？</h5><p>Spring Profiles 允许用户根据配置文件（dev，test，prod 等）来注册 bean。因此，当应用程序在开发中运行时，只有某些 bean 可以加载，而在 PRODUCTION中，某些其他 bean 可以加载。假设我们的要求是 Swagger 文档仅适用于 QA 环境，并且禁用所有其他文档。这可以使用配置文件来完成。Spring Boot 使得使用配置文件非常简单。</p>
<h5 id="如何在自定义端口上运行-Spring-Boot-应用程序？"><a href="#如何在自定义端口上运行-Spring-Boot-应用程序？" class="headerlink" title="如何在自定义端口上运行 Spring Boot 应用程序？"></a>如何在自定义端口上运行 Spring Boot 应用程序？</h5><p>为了在自定义端口上运行 Spring Boot 应用程序，您可以在application.properties 中指定端口。server.port = 8090</p>
<h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><h5 id="如何实现-Spring-Boot-应用程序的安全性？"><a href="#如何实现-Spring-Boot-应用程序的安全性？" class="headerlink" title="如何实现 Spring Boot 应用程序的安全性？"></a>如何实现 Spring Boot 应用程序的安全性？</h5><p>为了实现 Spring Boot 的安全性，我们使用 spring-boot-starter-security 依赖项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩展WebSecurityConfigurerAdapter 并覆盖其方法。</p>
<h5 id="比较一下-Spring-Security-和-Shiro-各自的优缺点"><a href="#比较一下-Spring-Security-和-Shiro-各自的优缺点" class="headerlink" title="比较一下 Spring Security 和 Shiro 各自的优缺点 ?"></a>比较一下 Spring Security 和 Shiro 各自的优缺点 ?</h5><p>由于 Spring Boot 官方提供了大量的非常方便的开箱即用的 Starter ，包括 Spring Security 的 Starter ，使得在 Spring Boot 中使用 Spring Security 变得更加容易，甚至只需要添加一个依赖就可以保护所有的接口，所以，如果是 Spring Boot 项目，一般选择 Spring Security 。当然这只是一个建议的组合，单纯从技术上来说，无论怎么组合，都是没有问题的。Shiro 和 Spring Security 相比，主要有如下一些特点：</p>
<ol>
<li>Spring Security 是一个重量级的安全管理框架；Shiro 则是一个轻量级的安全管理框架</li>
<li>Spring Security 概念复杂，配置繁琐；Shiro 概念简单、配置简单</li>
<li>Spring Security 功能强大；Shiro 功能简单</li>
</ol>
<h5 id="Spring-Boot-中如何解决跨域问题"><a href="#Spring-Boot-中如何解决跨域问题" class="headerlink" title="Spring Boot 中如何解决跨域问题 ?"></a>Spring Boot 中如何解决跨域问题 ?</h5><p>跨域可以在前端通过 JSONP 来解决，但是 JSONP 只可以发送 GET 请求，无法发送其他类型的请求，在 RESTful 风格的应用中，就显得非常鸡肋，因此我们推荐在后端通过 （CORS，Cross-origin resource sharing） 来解决跨域问题。这种解决方案并非 Spring Boot 特有的，在传统的 SSM 框架中，就可以通过 CORS 来解决跨域问题，只不过之前我们是在 XML 文件中配置 CORS ，现在可以通过实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">"/**"</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">"*"</span>)</span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>)</span><br><span class="line">                .allowedMethods(<span class="string">"GET"</span>, <span class="string">"POST"</span>, <span class="string">"PUT"</span>, <span class="string">"DELETE"</span>, <span class="string">"OPTIONS"</span>)</span><br><span class="line">                .maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>项目中前后端分离部署，所以需要解决跨域的问题。<br>我们使用cookie存放用户登录的信息，在spring拦截器进行权限控制，当权限不符合时，直接返回给用户固定的json结果。<br>当用户登录以后，正常使用；当用户退出登录状态时或者token过期时，由于拦截器和跨域的顺序有问题，出现了跨域的现象。<br>我们知道一个http请求，先走filter，到达servlet后才进行拦截器的处理，如果我们把cors放在filter里，就可以优先于权限拦截器执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CorsConfiguration corsConfiguration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        corsConfiguration.addAllowedOrigin(<span class="string">"*"</span>);</span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="string">"*"</span>);</span><br><span class="line">        corsConfiguration.addAllowedMethod(<span class="string">"*"</span>);</span><br><span class="line">        corsConfiguration.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">        UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        urlBasedCorsConfigurationSource.registerCorsConfiguration(<span class="string">"/**"</span>, corsConfiguration);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(urlBasedCorsConfigurationSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="什么是-CSRF-攻击？"><a href="#什么是-CSRF-攻击？" class="headerlink" title="什么是 CSRF 攻击？"></a>什么是 CSRF 攻击？</h5><p>CSRF 代表跨站请求伪造。这是一种攻击，迫使最终用户在当前通过身份验证的Web 应用程序上执行不需要的操作。CSRF 攻击专门针对状态改变请求，而不是数据窃取，因为攻击者无法查看对伪造请求的响应。</p>
<h4 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h4><h5 id="Spring-Boot-中的监视器是什么？"><a href="#Spring-Boot-中的监视器是什么？" class="headerlink" title="Spring Boot 中的监视器是什么？"></a>Spring Boot 中的监视器是什么？</h5><p>Spring boot actuator 是 spring 启动框架中的重要功能之一。Spring boot 监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为 HTTP URL 访问的REST 端点来检查状态。</p>
<h5 id="如何在-Spring-Boot-中禁用-Actuator-端点安全性？"><a href="#如何在-Spring-Boot-中禁用-Actuator-端点安全性？" class="headerlink" title="如何在 Spring Boot 中禁用 Actuator 端点安全性？"></a>如何在 Spring Boot 中禁用 Actuator 端点安全性？</h5><p>默认情况下，所有敏感的 HTTP 端点都是安全的，只有具有 ACTUATOR 角色的用户才能访问它们。安全性是使用标准的 HttpServletRequest.isUserInRole 方法实施的。 我们可以使用来禁用安全性。只有在执行机构端点在防火墙后访问时，才建议禁用安全性。</p>
<h5 id="我们如何监视所有-Spring-Boot-微服务？"><a href="#我们如何监视所有-Spring-Boot-微服务？" class="headerlink" title="我们如何监视所有 Spring Boot 微服务？"></a>我们如何监视所有 Spring Boot 微服务？</h5><p>Spring Boot 提供监视器端点以监控各个微服务的度量。这些端点对于获取有关应用程序的信息（如它们是否已启动）以及它们的组件（如数据库等）是否正常运行很有帮助。但是，使用监视器的一个主要缺点或困难是，我们必须单独打开应用程序的知识点以了解其状态或健康状况。想象一下涉及 50 个应用程序的微服务，管理员将不得不击中所有 50 个应用程序的执行终端。为了帮助我们处理这种情况，我们将使用位于的开源项目。 它建立在 Spring Boot Actuator 之上，它提供了一个 Web UI，使我们能够可视化多个应用程序的度量。</p>
<h4 id="整合第三方项目"><a href="#整合第三方项目" class="headerlink" title="整合第三方项目"></a>整合第三方项目</h4><h5 id="什么是-WebSockets？"><a href="#什么是-WebSockets？" class="headerlink" title="什么是 WebSockets？"></a>什么是 WebSockets？</h5><p>WebSocket 是一种计算机通信协议，通过单个 TCP 连接提供全双工通信信道。</p>
<p>1、WebSocket 是双向的 -使用 WebSocket 客户端或服务器可以发起消息发送。</p>
<p>2、WebSocket 是全双工的 -客户端和服务器通信是相互独立的。</p>
<p>3、单个 TCP 连接 -初始连接使用 HTTP，然后将此连接升级到基于套接字的连接。然后这个单一连接用于所有未来的通信</p>
<p>4、Light -与 http 相比，WebSocket 消息数据交换要轻得多。</p>
<h5 id="什么是-Spring-Data"><a href="#什么是-Spring-Data" class="headerlink" title="什么是 Spring Data ?"></a>什么是 Spring Data ?</h5><p>Spring Data 是 Spring 的一个子项目。用于简化数据库访问，支持NoSQL 和 关系数据存储。其主要目标是使数据库的访问变得方便快捷。Spring Data 具有如下特点：</p>
<p>SpringData 项目支持 NoSQL 存储：</p>
<ol>
<li>MongoDB （文档数据库）</li>
<li>Neo4j（图形数据库）</li>
<li>Redis（键/值存储）</li>
<li>Hbase（列族数据库）</li>
</ol>
<p>SpringData 项目所支持的关系数据存储技术：</p>
<ol>
<li>JDBC</li>
<li>JPA</li>
</ol>
<p>Spring Data Jpa 致力于减少数据访问层 (DAO) 的开发量. 开发者唯一要做的，就是声明持久层的接口，其他都交给 Spring Data JPA 来帮你完成！Spring Data JPA 通过规范方法的名字，根据符合规范的名字来确定方法需要实现什么样的逻辑。</p>
<h5 id="什么是-Spring-Batch？"><a href="#什么是-Spring-Batch？" class="headerlink" title="什么是 Spring Batch？"></a>什么是 Spring Batch？</h5><p>Spring Boot Batch 提供可重用的函数，这些函数在处理大量记录时非常重要，包括日志/跟踪，事务管理，作业处理统计信息，作业重新启动，跳过和资源管理。它还提供了更先进的技术服务和功能，通过优化和分区技术，可以实现极高批量和高性能批处理作业。简单以及复杂的大批量批处理作业可以高度可扩展的方式利用框架处理重要大量的信息。</p>
<h5 id="什么是-FreeMarker-模板？"><a href="#什么是-FreeMarker-模板？" class="headerlink" title="什么是 FreeMarker 模板？"></a>什么是 FreeMarker 模板？</h5><p>FreeMarker 是一个基于 Java 的模板引擎，最初专注于使用 MVC 软件架构进行动态网页生成。使用 Freemarker 的主要优点是表示层和业务层的完全分离。程序员可以处理应用程序代码，而设计人员可以处理 html 页面设计。最后使用freemarker 可以将这些结合起来，给出最终的输出页面。</p>
<h5 id="如何集成-Spring-Boot-和-ActiveMQ？"><a href="#如何集成-Spring-Boot-和-ActiveMQ？" class="headerlink" title="如何集成 Spring Boot 和 ActiveMQ？"></a>如何集成 Spring Boot 和 ActiveMQ？</h5><p>对于集成 Spring Boot 和 ActiveMQ，我们使用依赖关系。 它只需要很少的配置，并且不需要样板代码。</p>
<h5 id="什么是-Apache-Kafka？"><a href="#什么是-Apache-Kafka？" class="headerlink" title="什么是 Apache Kafka？"></a>什么是 Apache Kafka？</h5><p>Apache Kafka 是一个分布式发布 - 订阅消息系统。它是一个可扩展的，容错的发布 - 订阅消息系统，它使我们能够构建分布式应用程序。这是一个 Apache 顶级项目。Kafka 适合离线和在线消息消费。</p>
<h5 id="什么是-Swagger？你用-Spring-Boot-实现了它吗？"><a href="#什么是-Swagger？你用-Spring-Boot-实现了它吗？" class="headerlink" title="什么是 Swagger？你用 Spring Boot 实现了它吗？"></a>什么是 Swagger？你用 Spring Boot 实现了它吗？</h5><p>Swagger 广泛用于可视化 API，使用 Swagger UI 为前端开发人员提供在线沙箱。Swagger 是用于生成 RESTful Web 服务的可视化表示的工具，规范和完整框架实现。它使文档能够以与服务器相同的速度更新。当通过 Swagger 正确定义时，消费者可以使用最少量的实现逻辑来理解远程服务并与其进行交互。因此，Swagger消除了调用服务时的猜测。</p>
<h5 id="前后端分离，如何维护接口文档"><a href="#前后端分离，如何维护接口文档" class="headerlink" title="前后端分离，如何维护接口文档 ?"></a>前后端分离，如何维护接口文档 ?</h5><p>前后端分离开发日益流行，大部分情况下，我们都是通过 Spring Boot 做前后端分离开发，前后端分离一定会有接口文档，不然会前后端会深深陷入到扯皮中。一个比较笨的方法就是使用 word 或者 md 来维护接口文档，但是效率太低，接口一变，所有人手上的文档都得变。在 Spring Boot 中，这个问题常见的解决方案是 Swagger ，使用 Swagger 我们可以快速生成一个接口文档网站，接口一旦发生变化，文档就会自动更新，所有开发工程师访问这一个在线网站就可以获取到最新的接口文档，非常方便。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h5 id="如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？Spring-Boot项目如何热部署？"><a href="#如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？Spring-Boot项目如何热部署？" class="headerlink" title="如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？"></a>如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？</h5><p>这可以使用 DEV 工具来实现。通过这种依赖关系，您可以节省任何更改，嵌入式tomcat 将重新启动。Spring Boot 有一个开发工具（DevTools）模块，它有助于提高开发人员的生产力。Java 开发人员面临的一个主要挑战是将文件更改自动部署到服务器并自动重启服务器。开发人员可以重新加载 Spring Boot 上的更改，而无需重新启动服务器。这将消除每次手动部署更改的需要。Spring Boot 在发布它的第一个版本时没有这个功能。这是开发人员最需要的功能。DevTools 模块完全满足开发人员的需求。该模块将在生产环境中被禁用。它还提供 H2 数据库控制台以更好地测试应用程序。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="您使用了哪些-starter-maven-依赖项？"><a href="#您使用了哪些-starter-maven-依赖项？" class="headerlink" title="您使用了哪些 starter maven 依赖项？"></a>您使用了哪些 starter maven 依赖项？</h5><p>使用了下面的一些依赖项</p>
<p>spring-boot-starter-activemq</p>
<p>spring-boot-starter-security</p>
<p>这有助于增加更少的依赖关系，并减少版本的冲突。</p>
<h5 id="Spring-Boot-中的-starter-到底是什么"><a href="#Spring-Boot-中的-starter-到底是什么" class="headerlink" title="Spring Boot 中的 starter 到底是什么 ?"></a>Spring Boot 中的 starter 到底是什么 ?</h5><p>首先，这个 Starter 并非什么新的技术点，基本上还是基于 Spring 已有功能来实现的。首先它提供了一个自动化配置类，一般命名为 XXXAutoConfiguration ，在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 Spring 中原本就有的），然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置，然后通过类型安全的属性注入将这些配置属性注入进来，新注入的属性会代替掉默认属性。正因为如此，很多第三方框架，我们只需要引入依赖就可以直接使用了。当然，开发者也可以自定义 Starter</p>
<h5 id="spring-boot-starter-parent-有什么用"><a href="#spring-boot-starter-parent-有什么用" class="headerlink" title="spring-boot-starter-parent 有什么用 ?"></a>spring-boot-starter-parent 有什么用 ?</h5><p>我们都知道，新创建一个 Spring Boot 项目，默认都是有 parent 的，这个 parent 就是 spring-boot-starter-parent ，spring-boot-starter-parent 主要有如下作用：</p>
<ol>
<li>定义了 Java 编译版本为 1.8 。</li>
<li>使用 UTF-8 格式编码。</li>
<li>继承自 spring-boot-dependencies，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。</li>
<li>执行打包操作的配置。</li>
<li>自动化的资源过滤。</li>
<li>自动化的插件配置。</li>
<li>针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配置文件，例如 application-dev.properties 和 application-dev.yml。</li>
</ol>
<h5 id="Spring-Boot-打成的-jar-和普通的-jar-有什么区别"><a href="#Spring-Boot-打成的-jar-和普通的-jar-有什么区别" class="headerlink" title="Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?"></a>Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?</h5><p>Spring Boot 项目最终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 java -jar xxx.jar 命令来运行，这种 jar 不可以作为普通的 jar 被其他项目依赖，即使依赖了也无法使用其中的类。</p>
<p>Spring Boot 的 jar 无法被其他项目依赖，主要还是他和普通 jar 的结构不同。普通的 jar 包，解压后直接就是包名，包里就是我们的代码，而 Spring Boot 打包成的可执行 jar 解压后，在 \BOOT-INF\classes 目录下才是我们的代码，因此无法被直接引用。如果非要引用，可以在 pom.xml 文件中增加配置，将 Spring Boot 项目打包成两个 jar ，一个可执行，一个可引用。</p>
<h5 id="运行-Spring-Boot-有哪几种方式？"><a href="#运行-Spring-Boot-有哪几种方式？" class="headerlink" title="运行 Spring Boot 有哪几种方式？"></a>运行 Spring Boot 有哪几种方式？</h5><p>1）打包用命令或者放到容器中运行</p>
<p>2）用 Maven/ Gradle 插件运行</p>
<p>3）直接执行 main 方法运行</p>
<h5 id="Spring-Boot-需要独立的容器运行吗？"><a href="#Spring-Boot-需要独立的容器运行吗？" class="headerlink" title="Spring Boot 需要独立的容器运行吗？"></a>Spring Boot 需要独立的容器运行吗？</h5><p>可以不需要，内置了 Tomcat/ Jetty 等容器。</p>
<h5 id="开启-Spring-Boot-特性有哪几种方式？"><a href="#开启-Spring-Boot-特性有哪几种方式？" class="headerlink" title="开启 Spring Boot 特性有哪几种方式？"></a>开启 Spring Boot 特性有哪几种方式？</h5><p>1）继承spring-boot-starter-parent项目</p>
<p>2）导入spring-boot-dependencies项目依赖</p>
<h5 id="如何使用-Spring-Boot-实现异常处理？"><a href="#如何使用-Spring-Boot-实现异常处理？" class="headerlink" title="如何使用 Spring Boot 实现异常处理？"></a>如何使用 Spring Boot 实现异常处理？</h5><p>Spring 提供了一种使用 ControllerAdvice 处理异常的非常有用的方法。 我们通过实现一个 ControlerAdvice 类，来处理控制器类抛出的所有异常。</p>
<h5 id="如何使用-Spring-Boot-实现分页和排序？"><a href="#如何使用-Spring-Boot-实现分页和排序？" class="headerlink" title="如何使用 Spring Boot 实现分页和排序？"></a>如何使用 Spring Boot 实现分页和排序？</h5><p>使用 Spring Boot 实现分页非常简单。使用 Spring Data-JPA 可以实现将可分页的传递给存储库方法。</p>
<h5 id="微服务中如何实现-session-共享"><a href="#微服务中如何实现-session-共享" class="headerlink" title="微服务中如何实现 session 共享 ?"></a>微服务中如何实现 session 共享 ?</h5><p>在微服务中，一个完整的项目被拆分成多个不相同的独立的服务，各个服务独立部署在不同的服务器上，各自的 session 被从物理空间上隔离开了，但是经常，我们需要在不同微服务之间共享 session ，常见的方案就是 Spring Session + Redis 来实现 session 共享。将所有微服务的 session 统一保存在 Redis 上，当各个微服务对 session 有相关的读写操作时，都去操作 Redis 上的 session 。这样就实现了 session 共享，Spring Session 基于 Spring 中的代理过滤器实现，使得 session 的同步操作对开发人员而言是透明的，非常简便。</p>
<h5 id="Spring-Boot-中如何实现定时任务"><a href="#Spring-Boot-中如何实现定时任务" class="headerlink" title="Spring Boot 中如何实现定时任务 ?"></a>Spring Boot 中如何实现定时任务 ?</h5><p>定时任务也是一个常见的需求，Spring Boot 中对于定时任务的支持主要还是来自 Spring 框架。</p>
<p>在 Spring Boot 中使用定时任务主要有两种不同的方式，一个就是使用 Spring 中的 @Scheduled 注解，另一个则是使用第三方框架 Quartz。</p>
<p>使用 Spring 中的 @Scheduled 的方式主要通过 @Scheduled 注解来实现。</p>
<p>使用 Quartz ，则按照 Quartz 的方式，定义 Job 和 Trigger 即可。</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud面试题</title>
    <url>/myblog/interview/Spring%20Cloud%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h4 id="为什么需要学习Spring-Cloud"><a href="#为什么需要学习Spring-Cloud" class="headerlink" title="为什么需要学习Spring Cloud"></a>为什么需要学习Spring Cloud</h4><a id="more"></a>
<p>不论是商业应用还是用户应用，在业务初期都很简单，我们通常会把它实现为单体结构的应用。但是，随着业务逐渐发展，产品思想会变得越来越复杂，单体结构的应用也会越来越复杂。这就会给应用带来如下的几个问题：</p>
<ul>
<li>代码结构混乱：业务复杂，导致代码量很大，管理会越来越困难。同时，这也会给业务的快速迭代带来巨大挑战；</li>
<li>开发效率变低：开发人员同时开发一套代码，很难避免代码冲突。开发过程会伴随着不断解决冲突的过程，这会严重的影响开发效率；</li>
<li>排查解决问题成本高：线上业务发现 bug，修复 bug 的过程可能很简单。但是，由于只有一套代码，需要重新编译、打包、上线，成本很高。</li>
</ul>
<p>由于单体结构的应用随着系统复杂度的增高，会暴露出各种各样的问题。近些年来，微服务架构逐渐取代了单体架构，且这种趋势将会越来越流行。Spring Cloud是目前最常用的微服务开发框架，已经在企业级开发中大量的应用。</p>
<h5 id="什么是Spring-Cloud"><a href="#什么是Spring-Cloud" class="headerlink" title="什么是Spring Cloud"></a>什么是Spring Cloud</h5><p>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p>
<!--more-->

<h4 id="设计目标与优缺点"><a href="#设计目标与优缺点" class="headerlink" title="设计目标与优缺点"></a>设计目标与优缺点</h4><h5 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h5><p>协调各个微服务，简化分布式系统开发。</p>
<h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p>微服务的框架那么多比如：dubbo、Kubernetes，为什么就要使用Spring Cloud的呢？</p>
<p>优点：</p>
<ul>
<li>产出于Spring大家族，Spring在企业级开发框架中无人能敌，来头很大，可以保证后续的更新、完善</li>
<li>组件丰富，功能齐全。Spring Cloud 为微服务架构提供了非常完整的支持。例如、配置管理、服务发现、断路器、微服务网关等；</li>
<li>Spring Cloud 社区活跃度很高，教程很丰富，遇到问题很容易找到解决方案</li>
<li>服务拆分粒度更细，耦合度比较低，有利于资源重复利用，有利于提高开发效率</li>
<li>可以更精准的制定优化服务方案，提高系统的可维护性</li>
<li>减轻团队的成本，可以并行开发，不用关注其他人怎么开发，先关注自己的开发</li>
<li>微服务可以是跨平台的，可以用任何一种语言开发</li>
<li>适于互联网时代，产品迭代周期更短</li>
</ul>
<p>缺点：</p>
<ul>
<li>微服务过多，治理成本高，不利于维护系统</li>
<li>分布式系统开发的成本高（容错，分布式事务等）对团队挑战大</li>
</ul>
<p>总的来说优点大过于缺点，目前看来Spring Cloud是一套非常完善的分布式框架，目前很多企业开始用微服务、Spring Cloud的优势是显而易见的。因此对于想研究微服务架构的同学来说，学习Spring Cloud是一个不错的选择。</p>
<h5 id="Spring-Cloud发展前景"><a href="#Spring-Cloud发展前景" class="headerlink" title="Spring Cloud发展前景"></a>Spring Cloud发展前景</h5><p>Spring Cloud对于中小型互联网公司来说是一种福音，因为这类公司往往没有实力或者没有足够的资金投入去开发自己的分布式系统基础设施，使用Spring Cloud一站式解决方案能在从容应对业务发展的同时大大减少开发成本。同时，随着近几年微服务架构和Docker容器概念的火爆，也会让Spring Cloud在未来越来越“云”化的软件开发风格中立有一席之地，尤其是在五花八门的分布式解决方案中提供了标准化的、全站式的技术方案，意义可能会堪比当年Servlet规范的诞生，有效推进服务端软件系统技术水平的进步。</p>
<h4 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h4><p><img src="https://img-blog.csdnimg.cn/20191226143921760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<h5 id="主要项目"><a href="#主要项目" class="headerlink" title="主要项目"></a>主要项目</h5><p>Spring Cloud的子项目，大致可分成两类，一类是对现有成熟框架”Spring Boot化”的封装和抽象，也是数量最多的项目；第二类是开发了一部分分布式系统的基础设施的实现，如Spring Cloud Stream扮演的就是kafka, ActiveMQ这样的角色。</p>
<h5 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h5><p>集中配置管理工具，分布式系统中统一的外部配置管理，默认使用Git来存储配置，可以支持客户端配置的刷新及加密、解密操作。</p>
<h5 id="Spring-Cloud-Netflix"><a href="#Spring-Cloud-Netflix" class="headerlink" title="Spring Cloud Netflix"></a>Spring Cloud Netflix</h5><p>Netflix OSS 开源组件集成，包括Eureka、Hystrix、Ribbon、Feign、Zuul等核心组件。</p>
<ul>
<li>Eureka：服务治理组件，包括服务端的注册中心和客户端的服务发现机制；</li>
<li>Ribbon：负载均衡的服务调用组件，具有多种负载均衡调用策略；</li>
<li>Hystrix：服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；</li>
<li>Feign：基于Ribbon和Hystrix的声明式服务调用组件；</li>
<li>Zuul：API网关组件，对请求提供路由及过滤功能。</li>
</ul>
<h5 id="Spring-Cloud-Bus"><a href="#Spring-Cloud-Bus" class="headerlink" title="Spring Cloud Bus"></a>Spring Cloud Bus</h5><p>用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置。</p>
<h5 id="Spring-Cloud-Consul"><a href="#Spring-Cloud-Consul" class="headerlink" title="Spring Cloud Consul"></a>Spring Cloud Consul</h5><p>基于Hashicorp Consul的服务治理组件。</p>
<h5 id="Spring-Cloud-Security"><a href="#Spring-Cloud-Security" class="headerlink" title="Spring Cloud Security"></a>Spring Cloud Security</h5><p>安全工具包，对Zuul代理中的负载均衡OAuth2客户端及登录认证进行支持。</p>
<h5 id="Spring-Cloud-Sleuth"><a href="#Spring-Cloud-Sleuth" class="headerlink" title="Spring Cloud Sleuth"></a>Spring Cloud Sleuth</h5><p>Spring Cloud应用程序的分布式请求链路跟踪，支持使用Zipkin、HTrace和基于日志（例如ELK）的跟踪。</p>
<h5 id="Spring-Cloud-Stream"><a href="#Spring-Cloud-Stream" class="headerlink" title="Spring Cloud Stream"></a>Spring Cloud Stream</h5><p>轻量级事件驱动微服务框架，可以使用简单的声明式模型来发送及接收消息，主要实现为Apache Kafka及RabbitMQ。</p>
<h5 id="Spring-Cloud-Task"><a href="#Spring-Cloud-Task" class="headerlink" title="Spring Cloud Task"></a>Spring Cloud Task</h5><p>用于快速构建短暂、有限数据处理任务的微服务框架，用于向应用中添加功能性和非功能性的特性。</p>
<h5 id="Spring-Cloud-Zookeeper"><a href="#Spring-Cloud-Zookeeper" class="headerlink" title="Spring Cloud Zookeeper"></a>Spring Cloud Zookeeper</h5><p>基于Apache Zookeeper的服务治理组件。</p>
<h5 id="Spring-Cloud-Gateway"><a href="#Spring-Cloud-Gateway" class="headerlink" title="Spring Cloud Gateway"></a>Spring Cloud Gateway</h5><p>API网关组件，对请求提供路由及过滤功能。</p>
<h5 id="Spring-Cloud-OpenFeign"><a href="#Spring-Cloud-OpenFeign" class="headerlink" title="Spring Cloud OpenFeign"></a>Spring Cloud OpenFeign</h5><p>基于Ribbon和Hystrix的声明式服务调用组件，可以动态创建基于Spring MVC注解的接口实现用于服务调用，在Spring Cloud 2.0中已经取代Feign成为了一等公民。</p>
<h5 id="Spring-Cloud的版本关系"><a href="#Spring-Cloud的版本关系" class="headerlink" title="Spring Cloud的版本关系"></a>Spring Cloud的版本关系</h5><p>Spring Cloud是一个由许多子项目组成的综合项目，各子项目有不同的发布节奏。 为了管理Spring Cloud与各子项目的版本依赖关系，发布了一个清单，其中包括了某个Spring Cloud版本对应的子项目版本。 为了避免Spring Cloud版本号与子项目版本号混淆，Spring Cloud版本采用了名称而非版本号的命名，这些版本的名字采用了伦敦地铁站的名字，根据字母表的顺序来对应版本时间顺序，例如Angel是第一个版本，Brixton是第二个版本。 当Spring Cloud的发布内容积累到临界点或者一个重大BUG被解决后，会发布一个”service releases”版本，简称SRX版本，比如Greenwich.SR2就是Spring Cloud发布的Greenwich版本的第2个SRX版本。目前Spring Cloud的最新版本是Hoxton。</p>
<h5 id="Spring-Cloud和SpringBoot版本对应关系"><a href="#Spring-Cloud和SpringBoot版本对应关系" class="headerlink" title="Spring Cloud和SpringBoot版本对应关系"></a>Spring Cloud和SpringBoot版本对应关系</h5><table>
<thead>
<tr>
<th align="center">Spring Cloud Version</th>
<th align="center">SpringBoot Version</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Hoxton</td>
<td align="center">2.2.x</td>
</tr>
<tr>
<td align="center">Greenwich</td>
<td align="center">2.1.x</td>
</tr>
<tr>
<td align="center">Finchley</td>
<td align="center">2.0.x</td>
</tr>
<tr>
<td align="center">Edgware</td>
<td align="center">1.5.x</td>
</tr>
<tr>
<td align="center">Dalston</td>
<td align="center">1.5.x</td>
</tr>
</tbody></table>
<h5 id="Spring-Cloud和各子项目版本对应关系"><a href="#Spring-Cloud和各子项目版本对应关系" class="headerlink" title="Spring Cloud和各子项目版本对应关系"></a>Spring Cloud和各子项目版本对应关系</h5><table>
<thead>
<tr>
<th align="center">Component</th>
<th align="center">Edgware.SR6</th>
<th align="center">Greenwich.SR2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">spring-cloud-bus</td>
<td align="center">1.3.4.RELEASE</td>
<td align="center">2.1.2.RELEASE</td>
</tr>
<tr>
<td align="center">spring-cloud-commons</td>
<td align="center">1.3.6.RELEASE</td>
<td align="center">2.1.2.RELEASE</td>
</tr>
<tr>
<td align="center">spring-cloud-config</td>
<td align="center">1.4.7.RELEASE</td>
<td align="center">2.1.3.RELEASE</td>
</tr>
<tr>
<td align="center">spring-cloud-netflix</td>
<td align="center">1.4.7.RELEASE</td>
<td align="center">2.1.2.RELEASE</td>
</tr>
<tr>
<td align="center">spring-cloud-security</td>
<td align="center">1.2.4.RELEASE</td>
<td align="center">2.1.3.RELEASE</td>
</tr>
<tr>
<td align="center">spring-cloud-consul</td>
<td align="center">1.3.6.RELEASE</td>
<td align="center">2.1.2.RELEASE</td>
</tr>
<tr>
<td align="center">spring-cloud-sleuth</td>
<td align="center">1.3.6.RELEASE</td>
<td align="center">2.1.1.RELEASE</td>
</tr>
<tr>
<td align="center">spring-cloud-stream</td>
<td align="center">Ditmars.SR5</td>
<td align="center">Fishtown.SR3</td>
</tr>
<tr>
<td align="center">spring-cloud-zookeeper</td>
<td align="center">1.2.3.RELEASE</td>
<td align="center">2.1.2.RELEASE</td>
</tr>
<tr>
<td align="center">spring-boot</td>
<td align="center">1.5.21.RELEASE</td>
<td align="center">2.1.5.RELEASE</td>
</tr>
<tr>
<td align="center">spring-cloud-task</td>
<td align="center">1.2.4.RELEASE</td>
<td align="center">2.1.2.RELEASE</td>
</tr>
<tr>
<td align="center">spring-cloud-gateway</td>
<td align="center">1.0.3.RELEASE</td>
<td align="center">2.1.2.RELEASE</td>
</tr>
<tr>
<td align="center">spring-cloud-openfeign</td>
<td align="center">暂无</td>
<td align="center">2.1.2.RELEASE</td>
</tr>
</tbody></table>
<p><strong>注意：Hoxton版本是基于SpringBoot 2.2.x版本构建的，不适用于1.5.x版本。随着2019年8月SpringBoot 1.5.x版本停止维护，Edgware版本也将停止维护</strong>。</p>
<h5 id="SpringBoot和SpringCloud的区别？"><a href="#SpringBoot和SpringCloud的区别？" class="headerlink" title="SpringBoot和SpringCloud的区别？"></a>SpringBoot和SpringCloud的区别？</h5><p>SpringBoot专注于快速方便的开发单个个体微服务。</p>
<p>SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，</p>
<p>为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务</p>
<p>SpringBoot可以离开SpringCloud独立使用开发项目， 但是SpringCloud离不开SpringBoot ，属于依赖的关系</p>
<p>SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。</p>
<h5 id="使用-Spring-Boot-开发分布式微服务时，我们面临以下问题"><a href="#使用-Spring-Boot-开发分布式微服务时，我们面临以下问题" class="headerlink" title="使用 Spring Boot 开发分布式微服务时，我们面临以下问题"></a>使用 Spring Boot 开发分布式微服务时，我们面临以下问题</h5><p>（1）与分布式系统相关的复杂性-这种开销包括网络问题，延迟开销，带宽问题，安全问题。</p>
<p>（2）服务发现-服务发现工具管理群集中的流程和服务如何查找和互相交谈。它涉及一个服务目录，在该目录中注册服务，然后能够查找并连接到该目录中的服务。</p>
<p>（3）冗余-分布式系统中的冗余问题。</p>
<p>（4）负载平衡 –负载平衡改善跨多个计算资源的工作负荷，诸如计算机，计算机集群，网络链路，中央处理单元，或磁盘驱动器的分布。</p>
<p>（5）性能-问题 由于各种运营开销导致的性能问题。</p>
<p>（6）部署复杂性-Devops 技能的要求。</p>
<h5 id="服务注册和发现是什么意思？Spring-Cloud-如何实现？"><a href="#服务注册和发现是什么意思？Spring-Cloud-如何实现？" class="headerlink" title="服务注册和发现是什么意思？Spring Cloud 如何实现？"></a>服务注册和发现是什么意思？Spring Cloud 如何实现？</h5><p>当我们开始一个项目时，我们通常在属性文件中进行所有的配置。随着越来越多的服务开发和部署，添加和修改这些属性变得更加复杂。有些服务可能会下降，而某些位置可能会发生变化。手动更改属性可能会产生问题。 Eureka 服务注册和发现可以在这种情况下提供帮助。由于所有服务都在 Eureka 服务器上注册并通过调用 Eureka 服务器完成查找，因此无需处理服务地点的任何更改和处理。</p>
<h5 id="Spring-Cloud-和dubbo区别"><a href="#Spring-Cloud-和dubbo区别" class="headerlink" title="Spring Cloud 和dubbo区别?"></a>Spring Cloud 和dubbo区别?</h5><p>（1）服务调用方式 dubbo是RPC springcloud Rest Api</p>
<p>（2）注册中心,dubbo 是zookeeper springcloud是eureka，也可以是zookeeper</p>
<p>（3）服务网关,dubbo本身没有实现，只能通过其他第三方技术整合，springcloud有Zuul路由网关，作为路由服务器，进行消费者的请求分发,springcloud支持断路器，与git完美集成配置文件支持版本控制，事物总线实现配置文件的更新与服务自动装配等等一系列的微服务架构要素。</p>
<h5 id="负载平衡的意义什么？"><a href="#负载平衡的意义什么？" class="headerlink" title="负载平衡的意义什么？"></a>负载平衡的意义什么？</h5><p>在计算中，负载平衡可以改善跨计算机，计算机集群，网络链接，中央处理单元或磁盘驱动器等多种计算资源的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间并避免任何单一资源的过载。使用多个组件进行负载平衡而不是单个组件可能会通过冗余来提高可靠性和可用性。负载平衡通常涉及专用软件或硬件，例如多层交换机或域名系统服务器进程。</p>
<h5 id="什么是-Hystrix？它如何实现容错？"><a href="#什么是-Hystrix？它如何实现容错？" class="headerlink" title="什么是 Hystrix？它如何实现容错？"></a>什么是 Hystrix？它如何实现容错？</h5><p>Hystrix 是一个延迟和容错库，旨在隔离远程系统，服务和第三方库的访问点，当出现故障是不可避免的故障时，停止级联故障并在复杂的分布式系统中实现弹性。</p>
<p>通常对于使用微服务架构开发的系统，涉及到许多微服务。这些微服务彼此协作。</p>
<p>思考以下微服务</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8zMC8xNmY1NWZiZmQzZTNmZDI4?x-oss-process=image/format,png" alt></p>
<p>假设如果上图中的微服务 9 失败了，那么使用传统方法我们将传播一个异常。但这仍然会导致整个系统崩溃。</p>
<p>随着微服务数量的增加，这个问题变得更加复杂。微服务的数量可以高达 1000.这是 hystrix 出现的地方 我们将使用 Hystrix 在这种情况下的 Fallback 方法功能。我们有两个服务 employee-consumer 使用由 employee-consumer 公开的服务。</p>
<p>简化图如下所示</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8zMC8xNmY1NWZiZmNlNjcxYjgz?x-oss-process=image/format,png" alt></p>
<p>现在假设由于某种原因，employee-producer 公开的服务会抛出异常。我们在这种情况下使用 Hystrix 定义了一个回退方法。这种后备方法应该具有与公开服务相同的返回类型。如果暴露服务中出现异常，则回退方法将返回一些值。</p>
<h5 id="什么是-Hystrix-断路器？我们需要它吗？"><a href="#什么是-Hystrix-断路器？我们需要它吗？" class="headerlink" title="什么是 Hystrix 断路器？我们需要它吗？"></a>什么是 Hystrix 断路器？我们需要它吗？</h5><p>由于某些原因，employee-consumer 公开服务会引发异常。在这种情况下使用Hystrix 我们定义了一个回退方法。如果在公开服务中发生异常，则回退方法返回一些默认值。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8zMC8xNmY1NWZiZmNlZWZhOTJh?x-oss-process=image/format,png" alt></p>
<p>如果 firstPage method() 中的异常继续发生，则 Hystrix 电路将中断，并且员工使用者将一起跳过 firtsPage 方法，并直接调用回退方法。 断路器的目的是给第一页方法或第一页方法可能调用的其他方法留出时间，并导致异常恢复。可能发生的情况是，在负载较小的情况下，导致异常的问题有更好的恢复机会 。</p>
<p><img src="http://zhao.zcycomputer.cn/16f55fbfd4e33ae7.webp" alt></p>
<h5 id="什么是-Netflix-Feign？它的优点是什么？"><a href="#什么是-Netflix-Feign？它的优点是什么？" class="headerlink" title="什么是 Netflix Feign？它的优点是什么？"></a>什么是 Netflix Feign？它的优点是什么？</h5><p>Feign 是受到 Retrofit，JAXRS-2.0 和 WebSocket 启发的 java 客户端联编程序。</p>
<p>Feign 的第一个目标是将约束分母的复杂性统一到 http apis，而不考虑其稳定性。</p>
<p>在 employee-consumer 的例子中，我们使用了 employee-producer 使用 REST模板公开的 REST 服务。</p>
<p>但是我们必须编写大量代码才能执行以下步骤</p>
<p>（1）使用功能区进行负载平衡。</p>
<p>（2）获取服务实例，然后获取基本 URL。</p>
<p>（3）利用 REST 模板来使用服务。 前面的代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerControllerClient</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> LoadBalancerClient loadBalancer;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getEmployee</span><span class="params">()</span> <span class="keyword">throws</span> RestClientException, IOException </span>&#123;</span><br><span class="line">	ServiceInstance serviceInstance=loadBalancer.choose(<span class="string">"employee-producer"</span>);</span><br><span class="line">	System.out.println(serviceInstance.getUri());</span><br><span class="line">	String baseUrl=serviceInstance.getUri().toString();</span><br><span class="line">	baseUrl=baseUrl+<span class="string">"/employee"</span>;</span><br><span class="line">	RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">	ResponseEntity&lt;String&gt; response=<span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		response=restTemplate.exchange(baseUrl,</span><br><span class="line">					HttpMethod.GET, getHeaders(),String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Exception ex)</span><br><span class="line">		&#123;</span><br><span class="line">		System.out.println(ex);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(response.getBody());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前的代码，有像 NullPointer 这样的例外的机会，并不是最优的。我们将看到如何使用 Netflix Feign 使呼叫变得更加轻松和清洁。如果 Netflix Ribbon 依赖关系也在类路径中，那么 Feign 默认也会负责负载平衡。</p>
<h5 id="什么是-Spring-Cloud-Bus？我们需要它吗？"><a href="#什么是-Spring-Cloud-Bus？我们需要它吗？" class="headerlink" title="什么是 Spring Cloud Bus？我们需要它吗？"></a>什么是 Spring Cloud Bus？我们需要它吗？</h5><p>考虑以下情况：我们有多个应用程序使用 Spring Cloud Config 读取属性，而Spring Cloud Config 从 GIT 读取这些属性。</p>
<p>下面的例子中多个员工生产者模块从 Employee Config Module 获取 Eureka 注册的财产。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8zMC8xNmY1NWZiZmQ3NzQ0YzQ3?x-oss-process=image/format,png" alt></p>
<p>如果假设 GIT 中的 Eureka 注册属性更改为指向另一台 Eureka 服务器，会发生什么情况。在这种情况下，我们将不得不重新启动服务以获取更新的属性。</p>
<p>还有另一种使用执行器端点/刷新的方式。但是我们将不得不为每个模块单独调用这个 url。例如，如果 Employee Producer1 部署在端口 8080 上，则调用 http：// localhost：8080 / refresh。同样对于 Employee Producer2 http：//localhost：8081 / refresh 等等。这又很麻烦。这就是 Spring Cloud Bus 发挥作用的地方。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8zMC8xNmY1NWZiZmY0OTgxYWU5?x-oss-process=image/format,png" alt></p>
<p>Spring Cloud Bus 提供了跨多个实例刷新配置的功能。因此，在上面的示例中，如果我们刷新 Employee Producer1，则会自动刷新所有其他必需的模块。如果我们有多个微服务启动并运行，这特别有用。这是通过将所有微服务连接到单个消息代理来实现的。无论何时刷新实例，此事件都会订阅到侦听此代理的所有微服务，并且它们也会刷新。可以通过使用端点/总线/刷新来实现对任何单个实例的刷新。</p>
<h5 id="Spring-Cloud断路器的作用"><a href="#Spring-Cloud断路器的作用" class="headerlink" title="Spring Cloud断路器的作用"></a>Spring Cloud断路器的作用</h5><p>当一个服务调用另一个服务由于网络原因或自身原因出现问题，调用者就会等待被调用者的响应 当更多的服务请求到这些资源导致更多的请求等待，发生连锁效应（雪崩效应）</p>
<p>断路器有完全打开状态:一段时间内 达到一定的次数无法调用 并且多次监测没有恢复的迹象 断路器完全打开 那么下次请求就不会请求到该服务</p>
<p>半开:短时间内 有恢复迹象 断路器会将部分请求发给该服务，正常调用时 断路器关闭</p>
<p>关闭：当服务一直处于正常状态 能正常调用</p>
<h5 id="什么是Spring-Cloud-Config"><a href="#什么是Spring-Cloud-Config" class="headerlink" title="什么是Spring Cloud Config?"></a>什么是Spring Cloud Config?</h5><p>在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是config server，二是config client。</p>
<p>使用：</p>
<p>（1）添加pom依赖</p>
<p>（2）配置文件添加相关配置</p>
<p>（3）启动类添加注解@EnableConfigServer</p>
<h5 id="什么是Spring-Cloud-Gateway"><a href="#什么是Spring-Cloud-Gateway" class="headerlink" title="什么是Spring Cloud Gateway?"></a>什么是Spring Cloud Gateway?</h5><p>Spring Cloud Gateway是Spring Cloud官方推出的第二代网关框架，取代Zuul网关。网关作为流量的，在微服务系统中有着非常作用，网关常见的功能有路由转发、权限校验、限流控制等作用。</p>
<p>使用了一个RouteLocatorBuilder的bean去创建路由，除了创建路由RouteLocatorBuilder可以让你添加各种predicates和filters，predicates断言的意思，顾名思义就是根据具体的请求的规则，由具体的route去处理，filters是各种过滤器，用来对请求做各种判断和修改。</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring MVC面试</title>
    <url>/myblog/interview/Spring%20MVC%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><a id="more"></a>
<h5 id="什么是Spring-MVC？简单介绍下你对Spring-MVC的理解？"><a href="#什么是Spring-MVC？简单介绍下你对Spring-MVC的理解？" class="headerlink" title="什么是Spring MVC？简单介绍下你对Spring MVC的理解？"></a>什么是Spring MVC？简单介绍下你对Spring MVC的理解？</h5><p>Spring MVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把模型-视图-控制器分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。</p>
<h5 id="Spring-MVC的优点"><a href="#Spring-MVC的优点" class="headerlink" title="Spring MVC的优点"></a>Spring MVC的优点</h5><p>（1）可以支持各种视图技术,而不仅仅局限于JSP；</p>
<p>（2）与Spring框架集成（如IoC容器、AOP等）；</p>
<p>（3）清晰的角色分配：前端控制器(dispatcherServlet) , 请求到处理器映射（handlerMapping), 处理器适配器（HandlerAdapter), 视图解析器（ViewResolver）。</p>
<p>（4） 支持各种请求资源的映射策略。</p>
<!--more-->

<h4 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h4><h5 id="Spring-MVC的主要组件？"><a href="#Spring-MVC的主要组件？" class="headerlink" title="Spring MVC的主要组件？"></a>Spring MVC的主要组件？</h5><p>（1）前端控制器 DispatcherServlet（不需要程序员开发）</p>
<p>作用：接收请求、响应结果，相当于转发器，有了DispatcherServlet 就减少了其它组件之间的耦合度。</p>
<p>（2）处理器映射器HandlerMapping（不需要程序员开发）</p>
<p>作用：根据请求的URL来查找Handler</p>
<p>（3）处理器适配器HandlerAdapter</p>
<p>注意：在编写Handler的时候要按照HandlerAdapter要求的规则去编写，这样适配器HandlerAdapter才可以正确的去执行Handler。</p>
<p>（4）处理器Handler（需要程序员开发）</p>
<p>（5）视图解析器 ViewResolver（不需要程序员开发）</p>
<p>作用：进行视图的解析，根据视图逻辑名解析成真正的视图（view）</p>
<p>（6）视图View（需要程序员开发jsp）</p>
<p>View是一个接口， 它的实现类支持不同的视图类型（jsp，freemarker，pdf等等）</p>
<h5 id="什么是DispatcherServlet"><a href="#什么是DispatcherServlet" class="headerlink" title="什么是DispatcherServlet"></a>什么是DispatcherServlet</h5><p>Spring的MVC框架是围绕DispatcherServlet来设计的，它用来处理所有的HTTP请求和响应。</p>
<h5 id="什么是Spring-MVC框架的控制器？"><a href="#什么是Spring-MVC框架的控制器？" class="headerlink" title="什么是Spring MVC框架的控制器？"></a>什么是Spring MVC框架的控制器？</h5><p>控制器提供一个访问应用程序的行为，此行为通常通过服务接口实现。控制器解析用户输入并将其转换为一个由视图呈现给用户的模型。Spring用一个非常抽象的方式实现了一个控制层，允许用户创建多种用途的控制器。<br>Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？</p>
<p>答：是单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的,解决方案是在控制器里面不能写字段。</p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><h5 id="请描述Spring-MVC的工作流程？描述一下-DispatcherServlet-的工作流程？"><a href="#请描述Spring-MVC的工作流程？描述一下-DispatcherServlet-的工作流程？" class="headerlink" title="请描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？"></a>请描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？</h5><p>（1）用户发送请求至前端控制器DispatcherServlet；<br>（2） DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handle；<br>（3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet；<br>（4）DispatcherServlet 调用 HandlerAdapter处理器适配器；<br>（5）HandlerAdapter 经过适配调用 具体处理器(Handler，也叫后端控制器)；<br>（6）Handler执行完成返回ModelAndView；<br>（7）HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet；<br>（8）DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析；<br>（9）ViewResolver解析后返回具体View；<br>（10）DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）<br>（11）DispatcherServlet响应用户。</p>
<p><img src="https://img-blog.csdnimg.cn/20200208211439106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt></p>
<h4 id="MVC框架"><a href="#MVC框架" class="headerlink" title="MVC框架"></a>MVC框架</h4><h5 id="MVC是什么？MVC设计模式的好处有哪些"><a href="#MVC是什么？MVC设计模式的好处有哪些" class="headerlink" title="MVC是什么？MVC设计模式的好处有哪些"></a>MVC是什么？MVC设计模式的好处有哪些</h5><p>mvc是一种设计模式（设计模式就是日常开发中编写代码的一种好的方法和经验的总结）。模型（model）-视图（view）-控制器（controller），三层架构的设计模式。用于实现前端页面的展现与后端业务数据处理的分离。</p>
<p>mvc设计模式的好处</p>
<p>1.分层设计，实现了业务系统各个组件之间的解耦，有利于业务系统的可扩展性，可维护性。</p>
<p>2.有利于系统的并行开发，提升开发效率。</p>
<h4 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h4><h5 id="注解原理是什么"><a href="#注解原理是什么" class="headerlink" title="注解原理是什么"></a>注解原理是什么</h5><p>注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。</p>
<h5 id="Spring-MVC常用的注解有哪些？"><a href="#Spring-MVC常用的注解有哪些？" class="headerlink" title="Spring MVC常用的注解有哪些？"></a>Spring MVC常用的注解有哪些？</h5><p>@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。</p>
<p>@RequestBody：注解实现接收http请求的json数据，将json转换为java对象。</p>
<p>@ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。</p>
<h5 id="SpingMvc中的控制器的注解一般用哪个-有没有别的注解可以替代？"><a href="#SpingMvc中的控制器的注解一般用哪个-有没有别的注解可以替代？" class="headerlink" title="SpingMvc中的控制器的注解一般用哪个,有没有别的注解可以替代？"></a>SpingMvc中的控制器的注解一般用哪个,有没有别的注解可以替代？</h5><p>答：一般用@Controller注解,也可以使用@RestController,@RestController注解相当于@ResponseBody ＋ @Controller,表示是表现层,除此之外，一般不用别的注解代替。</p>
<h5 id="Controller注解的作用"><a href="#Controller注解的作用" class="headerlink" title="@Controller注解的作用"></a>@Controller注解的作用</h5><p>在Spring MVC 中，控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。在Spring MVC 中提供了一个非常简便的定义Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用@Controller 标记一个类是Controller ，然后使用@RequestMapping 和@RequestParam 等一些注解用以定义URL 请求和Controller 方法之间的映射，这样的Controller 就能被外界访问到。此外Controller 不会直接依赖于HttpServletRequest 和HttpServletResponse 等HttpServlet 对象，它们可以通过Controller 的方法参数灵活的获取到。</p>
<p>@Controller 用于标记在一个类上，使用它标记的类就是一个Spring MVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping 注解。@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。单单使用@Controller 标记在一个类上还不能真正意义上的说它就是Spring MVC 的一个控制器类，因为这个时候Spring 还不认识它。那么要如何做Spring 才能认识它呢？这个时候就需要我们把这个控制器类交给Spring 来管理。有两种方式：</p>
<ul>
<li>在Spring MVC 的配置文件中定义MyController 的bean 对象。</li>
<li>在Spring MVC 的配置文件中告诉Spring 该到哪里去找标记为@Controller 的Controller 控制器。</li>
</ul>
<h5 id="RequestMapping注解的作用"><a href="#RequestMapping注解的作用" class="headerlink" title="@RequestMapping注解的作用"></a>@RequestMapping注解的作用</h5><p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p>
<p>RequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。</p>
<p><strong>value， method</strong></p>
<p>value： 指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；</p>
<p>method： 指定请求的method类型， GET、POST、PUT、DELETE等；</p>
<p><strong>consumes，produces</strong></p>
<p>consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;</p>
<p>produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；</p>
<p><strong>params，headers</strong></p>
<p>params： 指定request中必须包含某些参数值是，才让该方法处理。</p>
<p>headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。</p>
<h5 id="ResponseBody注解的作用"><a href="#ResponseBody注解的作用" class="headerlink" title="@ResponseBody注解的作用"></a>@ResponseBody注解的作用</h5><p>作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。</p>
<p>使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；</p>
<h5 id="PathVariable和-RequestParam的区别"><a href="#PathVariable和-RequestParam的区别" class="headerlink" title="@PathVariable和@RequestParam的区别"></a>@PathVariable和@RequestParam的区别</h5><p>请求路径上有个id的变量值，可以通过@PathVariable来获取 @RequestMapping(value = “/page/{id}”, method = RequestMethod.GET)</p>
<p>@RequestParam用来获得静态的URL请求入参 spring注解时action里用到。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h5 id="Spring-MVC与Struts2区别"><a href="#Spring-MVC与Struts2区别" class="headerlink" title="Spring MVC与Struts2区别"></a>Spring MVC与Struts2区别</h5><p>相同点</p>
<p>都是基于mvc的表现层框架，都用于web项目的开发。</p>
<p>不同点</p>
<p>1.前端控制器不一样。Spring MVC的前端控制器是servlet：DispatcherServlet。struts2的前端控制器是filter：StrutsPreparedAndExcutorFilter。</p>
<p>2.请求参数的接收方式不一样。Spring MVC是使用方法的形参接收请求的参数，基于方法的开发，线程安全，可以设计为单例或者多例的开发，推荐使用单例模式的开发（执行效率更高），默认就是单例开发模式。struts2是通过类的成员变量接收请求的参数，是基于类的开发，线程不安全，只能设计为多例的开发。</p>
<p>3.Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，Spring MVC通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl。</p>
<p>4.与spring整合不一样。Spring MVC是spring框架的一部分，不需要整合。在企业项目中，Spring MVC使用更多一些。</p>
<h5 id="Spring-MVC怎么样设定重定向和转发的？"><a href="#Spring-MVC怎么样设定重定向和转发的？" class="headerlink" title="Spring MVC怎么样设定重定向和转发的？"></a>Spring MVC怎么样设定重定向和转发的？</h5><p>（1）转发：在返回值前面加”forward:”，譬如”forward:user.do?name=method4”</p>
<p>（2）重定向：在返回值前面加”redirect:”，譬如”redirect:<a href="http://www.baidu.com&quot;" target="_blank" rel="noopener">http://www.baidu.com&quot;</a></p>
<h5 id="Spring-MVC怎么和AJAX相互调用的？"><a href="#Spring-MVC怎么和AJAX相互调用的？" class="headerlink" title="Spring MVC怎么和AJAX相互调用的？"></a>Spring MVC怎么和AJAX相互调用的？</h5><p>通过Jackson框架就可以把Java里面的对象直接转化成Js可以识别的Json对象。具体步骤如下 ：</p>
<p>（1）加入Jackson.jar</p>
<p>（2）在配置文件中配置json的映射</p>
<p>（3）在接受Ajax方法里面可以直接返回Object,List等,但方法前面要加上@ResponseBody注解。</p>
<h5 id="如何解决POST请求中文乱码问题，GET的又如何处理呢？"><a href="#如何解决POST请求中文乱码问题，GET的又如何处理呢？" class="headerlink" title="如何解决POST请求中文乱码问题，GET的又如何处理呢？"></a>如何解决POST请求中文乱码问题，GET的又如何处理呢？</h5><p>（1）解决post请求乱码问题：</p>
<p>在web.xml中配置一个CharacterEncodingFilter过滤器，设置成utf-8；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）get请求中文参数出现乱码解决方法有两个：</p>
<p>①修改tomcat配置文件添加编码与工程编码一致，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ConnectorURIEncoding="utf-8"</span> <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>②另外一种方法对参数进行重新编码：</p>
<p>String userName = new String(request.getParamter(“userName”).getBytes(“ISO8859-1”),“utf-8”)</p>
<p>ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码。</p>
<h5 id="Spring-MVC的异常处理？"><a href="#Spring-MVC的异常处理？" class="headerlink" title="Spring MVC的异常处理？"></a>Spring MVC的异常处理？</h5><p>答：可以将异常抛给Spring框架，由Spring框架来处理；我们只需要配置简单的异常处理器，在异常处理器中添视图页面即可。</p>
<h5 id="如果在拦截请求中，我想拦截get方式提交的方法-怎么配置"><a href="#如果在拦截请求中，我想拦截get方式提交的方法-怎么配置" class="headerlink" title="如果在拦截请求中，我想拦截get方式提交的方法,怎么配置"></a>如果在拦截请求中，我想拦截get方式提交的方法,怎么配置</h5><p>答：可以在@RequestMapping注解里面加上method=RequestMethod.GET。</p>
<h5 id="怎样在方法里面得到Request-或者Session？"><a href="#怎样在方法里面得到Request-或者Session？" class="headerlink" title="怎样在方法里面得到Request,或者Session？"></a>怎样在方法里面得到Request,或者Session？</h5><p>答：直接在方法的形参中声明request,Spring MVC就自动把request对象传入。</p>
<h5 id="如果想在拦截的方法里面得到从前台传入的参数-怎么得到？"><a href="#如果想在拦截的方法里面得到从前台传入的参数-怎么得到？" class="headerlink" title="如果想在拦截的方法里面得到从前台传入的参数,怎么得到？"></a>如果想在拦截的方法里面得到从前台传入的参数,怎么得到？</h5><p>答：直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样。</p>
<h5 id="如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？"><a href="#如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？" class="headerlink" title="如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？"></a>如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？</h5><p>答：直接在方法中声明这个对象,Spring MVC就自动会把属性赋值到这个对象里面。</p>
<h5 id="Spring-MVC中函数的返回值是什么？"><a href="#Spring-MVC中函数的返回值是什么？" class="headerlink" title="Spring MVC中函数的返回值是什么？"></a>Spring MVC中函数的返回值是什么？</h5><p>答：返回值可以有很多类型,有String, ModelAndView。ModelAndView类把视图和数据都合并的一起的，但一般用String比较好。</p>
<h5 id="Spring-MVC用什么对象从后台向前台传递数据的？"><a href="#Spring-MVC用什么对象从后台向前台传递数据的？" class="headerlink" title="Spring MVC用什么对象从后台向前台传递数据的？"></a>Spring MVC用什么对象从后台向前台传递数据的？</h5><p>答：通过ModelMap对象,可以在这个对象里面调用put方法,把对象加到里面,前台就可以通过el表达式拿到。</p>
<h5 id="怎么样把ModelMap里面的数据放入Session里面？"><a href="#怎么样把ModelMap里面的数据放入Session里面？" class="headerlink" title="怎么样把ModelMap里面的数据放入Session里面？"></a>怎么样把ModelMap里面的数据放入Session里面？</h5><p>答：可以在类上面加上@SessionAttributes注解,里面包含的字符串就是要放入session里面的key。</p>
<h5 id="Spring-MVC里面拦截器是怎么写的"><a href="#Spring-MVC里面拦截器是怎么写的" class="headerlink" title="Spring MVC里面拦截器是怎么写的"></a>Spring MVC里面拦截器是怎么写的</h5><p>有两种写法,一种是实现HandlerInterceptor接口，另外一种是继承适配器类，接着在接口方法当中，实现处理逻辑；然后在Spring MVC的配置文件中配置拦截器即可：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置Spring MVC的拦截器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置一个拦截器的Bean就可以了 默认是对所有请求都拦截 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myInterceptor"</span> <span class="attr">class</span>=<span class="string">"com.zwp.action.MyHandlerInterceptor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 只针对部分请求拦截 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/modelMap.do"</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.zwp.action.MyHandlerInterceptorAdapter"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="介绍一下-WebApplicationContext"><a href="#介绍一下-WebApplicationContext" class="headerlink" title="介绍一下 WebApplicationContext"></a>介绍一下 WebApplicationContext</h5><p>WebApplicationContext 继承了ApplicationContext 并增加了一些WEB应用必备的特有功能，它不同于一般的ApplicationContext ，因为它能处理主题，并找到被关联的servlet。</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 中 Redis的使用 及Spring Session共享实现</title>
    <url>/myblog/spring-boot/Spring-Boot-%E4%B8%AD-Redis%E7%9A%84%E4%BD%BF%E7%94%A8-%E5%8F%8ASpring-Session%E5%85%B1%E4%BA%AB%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="一、关于Redis"><a href="#一、关于Redis" class="headerlink" title="一、关于Redis"></a>一、关于Redis</h2> <a id="more"></a>                                     
<p><img src="https://img-blog.csdnimg.cn/20181119212947332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyODk0ODk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>最近阅读了《Redis开发与运维》，非常不错。这里对书中的知识整理一下，方便自己回顾Redis的整个体系，来对相关知识点查漏补缺。</strong></p>
<p><strong>按照五点把书中的内容进行一下整理：</strong></p>
<p>1、为什么要选择Redis：介绍Redis的使用场景与使用Redis的原因；</p>
<p>2、Redis常用命令总结：包括时间复杂度总结与具体数据类型在Redis内部使用的数据结构；</p>
<p>3、Redis的高级功能：包括持久化、复制、哨兵、集群介绍；</p>
<p>4、理解Redis：理解内存、阻塞，这部分是非常重要的，前面介绍的都可以成为术，这里应该属于道的部分；</p>
<p>5、开发技巧：主要是一些开发实战的总结，包括缓存设计与常见坑点。</p>
<p>先来开启第一部分的内容，对Redis来一次重新打量。</p>
<p><strong>Redis不是万金油</strong></p>
<p>在面试的时候，常被问比较下Redis与Memcache的优缺点，个人觉得这二者并不适合一起比较，一个是非关系型数据库不仅可以做缓存还能干其他事情，一个是仅用做缓存。常常让我们对这二者进行比较，主要也是由于Redis最广泛的应用场景就是Cache，那么Redis到底能干什么？又不能干什么呢？</p>
<p><img src="https://img-blog.csdnimg.cn/20181119213020882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyODk0ODk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

<h2 id="Redis都可以干什么事儿"><a href="#Redis都可以干什么事儿" class="headerlink" title="Redis都可以干什么事儿"></a>Redis都可以干什么事儿</h2><p>缓存，毫无疑问这是Redis当今最为人熟知的使用场景，再提升服务器性能方面非常有效。</p>
<p><strong>1.排行榜</strong>，如果使用传统的关系型数据库来做，非常麻烦，而利用Redis的SortSet数据结构能够非常方便搞定；</p>
<p><strong>2.计算器/限速器</strong>，利用Redis中原子性的自增操作，我们可以统计类似用户点赞数、用户访问数等，这类操作如果用MySQL，频繁的读写会带来相当大的压力；限速器比较典型的使用场景是限制某个用户访问某个API的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力；</p>
<p><strong>3.好友关系</strong>，利用集合的一些命令，比如求交集、并集、差集等，可以方便搞定一些共同好友、共同爱好之类的功能；</p>
<p><strong>4.简单消息队列</strong>，除了Redis自身的发布/订阅模式，我们也可以利用List来实现一个队列机制，比如到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的DB压力，完全可以用List来完成异步解耦；</p>
<p><strong>5.Session共享</strong>，以PHP为例，默认Session是保存在服务器的文件中，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登陆；采用Redis保存Session后，无论用户落在那台机器上都能够获取到对应的Session信息。</p>
<h2><a name="t1"></a><a name="t1"></a><a id="Redis_41"></a>Redis不能干什么事儿</h2>
<p>Redis感觉能干的事情特别多，但它不是万能的，合适的地方用它事半功倍，如果滥用可能导致系统的不稳定、成本增高等问题。</p>
<p>1.比如，用Redis去保存用户的基本信息，虽然它能够支持持久化，但是它的持久化方案并不能保证数据绝对的落地，并且还可能带来Redis性能下降，因为持久化太过频繁会增大Redis服务的压力。</p>
<p>2.简单总结就是数据量太大、数据访问频率非常低的业务都不适合使用Redis，数据太大会增加成本，访问频率太低，保存在内存中纯属浪费资源。</p>
<h2><a name="t2"></a><a name="t2"></a><a id="_51"></a>选择总需要找个理由</h2>
<p>上面说了Redis的一些使用场景，那么这些场景的解决方案也有很多其它选择，比如缓存可以用Memcache，Session共享还能用MySql来实现，消息队列可以用RabbitMQ，我们为什么一定要用Redis呢？</p>
<p>速度快，完全基于内存，使用C语言实现，网络层使用epoll解决高并发问题，单线程模型避免了不必要的上下文切换及竞争条件；</p>
<p><strong>注意：单线程仅仅是说在网络请求这一模块上用一个请求处理客户端的请求，像持久化它就会重开一个线程/进程去进行处理。</strong></p>
<p>丰富的数据类型，Redis有8种数据类型，当然常用的主要是 String、Hash、List、Set、 SortSet 这5种类型，他们都是基于键值的方式组织数据。每一种数据类型提供了非常丰富的操作命令，可以满足绝大部分需求，如果有特殊需求还能自己通过 lua 脚本自己创建新的命令（具备原子性）；</p>
<p><img src="https://img-blog.csdnimg.cn/20181119213123717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyODk0ODk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>除了提供的丰富的数据类型，Redis还提供了像慢查询分析、性能测试、Pipeline、事务、Lua自定义命令、Bitmaps、HyperLogLog、发布/订阅、Geo等个性化功能。</p>
<p>Redis的代码开源在GitHub，代码非常简单优雅，任何人都能够吃透它的源码；它的编译安装也是非常的简单，没有任何的系统依赖；有非常活跃的社区，各种客户端的语言支持也是非常完善。另外它还支持事务（没用过）、持久化、主从复制让高可用、分布式成为可能。</p>
<p><img src="https://img-blog.csdnimg.cn/20181119213141787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyODk0ODk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>做为一个开发者，对于我们使用的东西不能让它成为一个黑盒子，我们应该深入进去，对它更了解、更熟悉，今天简单说了下Redis的使用场景，以及为什么选择了Redis而不是其他。</p>

<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <!-- flowchart 箭头图标 勿删 -->
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"/>
                    </svg>
                                            <div id="article_content" class="article_content clearfix csdn-tracking-statistics">



<h2 id="二、为什么选择Redis"><a href="#二、为什么选择Redis" class="headerlink" title="二、为什么选择Redis"></a>二、为什么选择Redis</h2><h2 id="首先，要知道缓存技术，这里主要说一下这两个的（memcached，Redis）区别。"><a href="#首先，要知道缓存技术，这里主要说一下这两个的（memcached，Redis）区别。" class="headerlink" title="首先，要知道缓存技术，这里主要说一下这两个的（memcached，Redis）区别。"></a><p>首先，要知道缓存技术，这里主要说一下这两个的（memcached，Redis）区别。</p></h2></div></div><p>缓存：</p>
<p>&nbsp; &nbsp; &nbsp;1）定义</p>
<p><u>缓存就是在内存中存储的数据备份，当数据没有发生本质变化的时候，我们避免数据的查询操作直接连接数据库，而是去&nbsp; &nbsp; 内容中读取数据，这样就大大降低了数据库的读写次数，而且从内存中读数据的速度要比从数据库查询要快很多。</u></p>
<p>&nbsp; &nbsp; 2）缓存的形式</p>
<p>页面缓存（smarty静态化技术）：页面缓存经常用在CMS（content manage system）内存管理系统里面。</p>
<p>数据缓存：经常会用在页面的具体数据里面。</p>
<blockquote>
<p>1，memcached</p>
</blockquote>
<ul><li>
    <p>协议简单、基于libevent的事件处理、内置内存存储方式、memcached不互相通信的分布式。 各个memcached不会互相通信以共享信息，分布策略由客户端实现。不会对数据进行持久化，重启memcached、重启操作系统会导致全部数据消失。</p>
    </li>
    <li>
    <p>Memcached常见的应用场景是存储一些读取频繁但更新较少的数据，如静态网页、系统配置及规则数据、活跃用户的基本数据和个性化定制数据、准实时统计信息等。</p>
    </li>
</ul><blockquote>
<p>2，Redis</p>
</blockquote>
<ul><li>
    <p>Redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string、list、set、zset(有序集合)和hash。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序和算法。</p>
    </li>
    <li>
    <p>与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件（RDB和AOF两种方式），并且在此基础上实现了master-slave(主从)同步，机器重启后能通过持久化数据自动重建内存，使用Redis作为Cache时机器宕机后热点数据不会丢失。</p>
    </li>
    <li>
    <p>Redis丰富的数据结构也使其拥有更加丰富的应用场景。Redis的命令都是原子性的，可以简单地利用INCR和DECR实现计数功能。使用list可以实现获取最近N个数的操作。sort set支持对数据排序，可以应用在排行榜中。set集合可以应用到数据排重。Redis还支持过期时间设置，可以应用到需要设定精确过期时间的应用。只要可以使用Redis支持的数据结构表示的场景，就可以使用Redis进行存储。</p>
    </li>
    <li>
    <p>Redis基于乐观锁</p>
    </li>
</ul><p>为什么选择Redis？</p>
<blockquote>
<p>&nbsp; &nbsp; 1）Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。<br>
&nbsp; &nbsp; 2）Redis支持master-slave(主-从)模式应用<br>
&nbsp; &nbsp; 3）Redis支持数据持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。<br>
&nbsp; &nbsp; 4）Redis单个value的最大限制是1GB，memcached只能保存1MB的数据。</p>
</blockquote><p>主要是从两个角度去考虑:<strong>性能</strong>和<strong>并发</strong>。当然，redis还具备可以做分布式锁等其他功能，但是如果只是为了分布式锁这些其他功能，完全还有其他中间件(如zookpeer等)代替，并不是非要使用redis。因此，这个问题主要从性能和并发两个角度去答。</p>

<p><strong>一、Redis简介</strong></p>
<blockquote>
<p>REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p>
</blockquote>
<p><strong>二、支持的数据类型</strong></p>
<blockquote>
<p>Redis是Remote Dictionary Server(远程数据服务)的缩写，由意大利人antirez(Salvatore Sanfilippo)开发的一款内存高速缓存数据库，该软件使用C语言编写，它的数据模型为key-value。它支持丰富的数据结构(类型)，比如string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型，类似于<a href="http://lib.csdn.net/base/17" rel="nofollow" target="_blank">Java</a>中的map）。</p>
</blockquote>
<p>&nbsp;</p>
<p><strong>（一）性能</strong><br>
如下图所示，我们在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够<strong>迅速响应</strong>。<br><img alt class="has" src="https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk56fVjL0HJXvibicrE4666HwC9ibHNxGcIict6GSmQbA8Rn3RNvHsRkIgW8D97zhnfzNEiamA5C607FnWjg/640?wx_fmt=png"><br><strong>题外话：</strong>忽然想聊一下这个<strong>迅速响应</strong>的标准。其实根据交互效果的不同，这个响应时间没有固定标准。不过曾经有人这么告诉我:"在理想状态下，我们的页面跳转需要在<strong>瞬间</strong>解决，对于页内操作则需要在<strong>刹那</strong>间解决。另外，超过<strong>一弹指</strong>的耗时操作要有进度提示，并且可以随时中止或取消，这样才能给用户最好的体验。"</p>
<p><br>
那么<strong>瞬间、刹那、一弹指</strong>具体是多少时间呢？</p>
<p><br>
根据《摩诃僧祗律》记载</p>
<p>一刹那者为一念，二十念为一瞬，二十瞬为一弹指，二十弹指为一罗预，二十罗预为一须臾，一日一夜有三十须臾。<br>
&nbsp;</p>
<p>那么，经过周密的计算，一<strong>瞬间</strong>为0.36 秒,一<strong>刹那</strong>有 0.018 秒.一<strong>弹指</strong>长达 7.2 秒。</p>
<p><br><strong>（二）并发</strong></p>
<p><br>
如下图所示，在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问数据库。<br><img alt class="has" src="https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk56fVjL0HJXvibicrE4666HwC95NCicgQR2aYVARNYzjB1ZlgrL1HIxyicrlnBibQXFB537v6APjAKCoSfA/640?wx_fmt=png"></p>
<h3><a name="t0"></a><a name="t0"></a>&nbsp;</h3>
<p>2、使用redis有什么缺点</p>
<p><strong>&nbsp;</strong></p>
<p><strong>分析</strong>:大家用redis这么久，这个问题是必须要了解的，基本上使用redis都会碰到一些问题，常见的也就几个。</p>
<p><br><strong>回答</strong>:主要是四个问题<br>
(一)缓存和数据库双写一致性问题<br>
(二)缓存雪崩问题<br>
(三)缓存击穿问题<br>
(四)缓存的并发竞争问题<br>
这四个问题，我个人是觉得在项目中，比较常遇见的，具体解决方案，后文给出。</p>
<p>&nbsp;</p>
<h3><a name="t1"></a><a name="t1"></a>&nbsp;</h3>
<p>3、单线程的redis为什么这么快</p>
<p><strong>&nbsp;</strong></p>
<p><strong>分析</strong>:这个问题其实是对redis内部机制的一个考察。其实根据博主的面试经验，很多人其实都不知道redis是单线程工作模型。所以，这个问题还是应该要复习一下的。</p>
<p><br><strong>回答</strong>:主要是以下三点<br>
(一)纯内存操作<br>
(二)单线程操作，避免了频繁的上下文切换<br>
(三)采用了非阻塞<strong>I/O多路复用机制</strong></p>
<p><strong>&nbsp;</strong></p>
<p><strong>题外话：</strong>我们现在要仔细的说一说I/O多路复用机制，因为这个说法实在是太通俗了，通俗到一般人都不懂是什么意思。博主打一个比方：小曲在S城开了一家快递店，负责同城快送服务。小曲因为资金限制，雇佣了<strong>一批</strong>快递员，然后小曲发现资金不够了，只够买<strong>一辆</strong>车送快递。</p>
<p><br><strong>经营方式一</strong><br>
客户每送来一份快递，小曲就让一个快递员盯着，然后快递员开车去送快递。慢慢的小曲就发现了这种经营方式存在下述问题</p>
<ul><li>
    <p>几十个快递员基本上时间都花在了抢车上了，大部分快递员都处在闲置状态，谁抢到了车，谁就能去送快递</p>
    </li>
    <li>
    <p>随着快递的增多，快递员也越来越多，小曲发现快递店里越来越挤，没办法雇佣新的快递员了</p>
    </li>
    <li>
    <p>快递员之间的协调很花时间</p>
    </li>
</ul><p>综合上述缺点，小曲痛定思痛，提出了下面的经营方式</p>
<p><br><strong>经营方式二</strong><br>
小曲只雇佣一个快递员。然后呢，客户送来的快递，小曲按<strong>送达地点</strong>标注好，然后<strong>依次</strong>放在一个地方。最后，那个快递员<strong>依次</strong>的去取快递，一次拿一个，然后开着车去送快递，送好了就回来拿下一个快递。</p>
<p>&nbsp;</p>
<p><strong>对比</strong><br>
上述两种经营方式对比，是不是明显觉得第二种，效率更高，更好呢。在上述比喻中:</p>
<ul><li>
    <p>每个快递员----------&gt;每个线程</p>
    </li>
    <li>
    <p>每个快递------------&gt;每个socket(I/O流)</p>
    </li>
    <li>
    <p>快递的送达地点------&gt;socket的不同状态</p>
    </li>
    <li>
    <p>客户送快递请求------&gt;来自客户端的请求</p>
    </li>
    <li>
    <p>小曲的经营方式------&gt;服务端运行的代码</p>
    </li>
    <li>
    <p>一辆车---------------&gt;CPU的核数</p>
    </li>
</ul><p>&nbsp;</p>
<p>于是我们有如下结论<br>
1、经营方式一就是传统的并发模型，每个I/O流(快递)都有一个新的线程(快递员)管理。<br>
2、经营方式二就是I/O多路复用。只有单个线程(一个快递员)，通过跟踪每个I/O流的状态(每个快递的送达地点)，来管理多个I/O流。</p>
<p>下面类比到真实的redis线程模型，如图所示<br><img alt class="has" src="https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk56fVjL0HJXvibicrE4666HwC93yQahTTjSKTSVBicx4XcyOpD9l00KSyXeDjltA4gmnVpeTYGPuM3e5Q/640?wx_fmt=png"><br>
参照上图，简单来说，就是。我们的redis-client在操作的时候，会产生具有不同事件类型的socket。在服务端，有一段I/0多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。</p>
<p><br>
需要说明的是，这个I/O多路复用机制，redis还提供了select、epoll、evport、kqueue等多路复用函数库，大家可以自行去了解。</p>
<p>&nbsp;</p>
<h3><a name="t2"></a><a name="t2"></a>&nbsp;</h3>
<p>4、redis的数据类型，以及每种数据类型的使用场景</p>
<p><strong>&nbsp;</strong></p>
<p><strong>分析</strong>：是不是觉得这个问题很基础，其实我也这么觉得。然而根据面试经验发现，至少百分八十的人答不上这个问题。建议，在项目中用到后，再类比记忆，体会更深，不要硬记。基本上，一个合格的程序员，五种类型都会用到。</p>
<p><br><strong>回答</strong>：一共五种</p>
<p><br>
(一)String<br>
这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。一般做<strong>一些复杂的计数功能的缓存。</strong></p>
<p><br>
(二)hash<br>
这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做<strong>单点登录</strong>的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。</p>
<p><br>
(三)list<br>
使用List的数据结构，可以<strong>做简单的消息队列的功能</strong>。另外还有一个就是，可以利用lrange命令，<strong>做基于redis的分页功能</strong>，性能极佳，用户体验好。</p>
<p><br>
(四)set<br>
因为set堆放的是一堆不重复值的集合。所以可以做<strong>全局去重的功能</strong>。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。</p>
<p><br>
另外，就是利用交集、并集、差集等操作，可以<strong>计算共同喜好，全部的喜好，自己独有的喜好等功能</strong>。</p>
<p><br>
(五)sorted set<br>
sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做<strong>排行榜应用，取TOP N操作</strong>。sorted set可以用来做<strong>延时任务</strong>。最后一个应用就是可以做<strong>范围查找</strong>。</p>
<p>&nbsp;</p>
<p>5、redis的过期策略以及内存淘汰机制</p>
<p><strong>&nbsp;</strong></p>
<p><strong>分析</strong>:这个问题其实相当重要，到底redis有没用到家，这个问题就可以看出来。比如你redis只能存5G数据，可是你写了10G，那会删5G的数据。怎么删的，这个问题思考过么？还有，你的数据已经设置了过期时间，但是时间到了，内存占用率还是比较高，有思考过原因么?<br>
&nbsp;</p>
<p><strong>回答</strong>:<br>
redis采用的是定期删除+惰性删除策略。</p>
<p><br><strong>为什么不用定时删除策略?</strong><br>
定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.</p>
<p><br><strong>定期删除+惰性删除是如何工作的呢?</strong><br>
定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。</p>
<p><br>
于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。</p>
<p><br><strong>采用定期删除+惰性删除就没其他问题了么?</strong><br>
不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用<strong>内存淘汰机制</strong>。</p>
<p><br>
在redis.conf中有一行配置</p>
<p># maxmemory-policy volatile-lru<br>
&nbsp;</p>
<p>该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己)<br>
1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。<strong>应该没人用吧。</strong><br>
2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。<strong>推荐使用，目前项目在用这种。</strong><br>
3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。<strong>应该也没人用吧，你不删最少使用Key,去随机删。</strong><br>
4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。<strong>这种情况一般是把redis既当缓存，又做持久化存储的时候才用。不推荐</strong><br>
5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。<strong>依然不推荐</strong><br>
6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。<strong>不推荐</strong><br>
ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。</p>
<p>&nbsp;</p>
<h3><a name="t3"></a><a name="t3"></a>&nbsp;</h3>
<p>6、redis和数据库双写一致性问题</p>
<h3><a name="t4"></a><a name="t4"></a>&nbsp;</h3>
<p><strong>分析</strong>:一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。答这个问题，先明白一个前提。就是<strong>如果对数据有强一致性要求，不能放缓存。</strong>我们所做的一切，只能保证最终一致性。另外，我们所做的方案其实从根本上来说，只能说<strong>降低不一致发生的概率</strong>，无法完全避免。因此，有强一致性要求的数据，不能放缓存。</p>
<p><br><strong>回答</strong>:首先，采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。</p>
<p>&nbsp;</p>
<h3><a name="t5"></a><a name="t5"></a>&nbsp;</h3>
<p>7、如何应对缓存穿透和缓存雪崩问题</p>
<h3><a name="t6"></a><a name="t6"></a>&nbsp;</h3>
<p><strong>分析</strong>:这两个问题，说句实在话，一般中小型传统软件企业，很难碰到这个问题。如果有大并发的项目，流量有几百万左右。这两个问题一定要深刻考虑。</p>
<p><br><strong>回答</strong>:如下所示</p>
<p><br><strong>缓存穿透</strong>，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。</p>
<p><br><strong>解决方案</strong>:<br>
(一)利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试<br>
(二)采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做<strong>缓存预热</strong>(项目启动前，先加载缓存)操作。<br>
(三)提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。</p>
<p><br><strong>缓存雪崩</strong>，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。</p>
<p><br><strong>解决方案</strong>:<br>
(一)给缓存的失效时间，加上一个随机值，避免集体失效。<br>
(二)使用互斥锁，但是该方案吞吐量明显下降了。<br>
(三)双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。自己做缓存预热操作。然后细分以下几个小点</p>
<ul><li>
    <p>I 从缓存A读数据库，有则直接返回</p>
    </li>
    <li>
    <p>II A没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程。</p>
    </li>
    <li>
    <p>III 更新线程同时更新缓存A和缓存B。</p>
    </li>
</ul><p>&nbsp;</p>
<h3><a name="t7"></a><a name="t7"></a>&nbsp;</h3>
<p>8、如何解决redis的并发竞争key问题</p>
<h3><a name="t8"></a><a name="t8"></a>&nbsp;</h3>
<p><strong>分析</strong>:这个问题大致就是，同时有多个子系统去set一个key。这个时候要注意什么呢？大家思考过么。需要说明一下，博主提前百度了一下，发现答案基本都是推荐用redis事务机制。博主<strong>不推荐使用redis的事务机制。</strong>因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上。因此，<strong>redis的事务机制，十分鸡肋。</strong></p>
<p><br><strong>回答:</strong>如下所示<br>
(1)如果对这个key操作，<strong>不要求顺序</strong><br>
这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。<br>
(2)如果对这个key操作，<strong>要求顺序</strong><br>
假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC.<br>
期望按照key1的value值按照 valueA--&gt;valueB--&gt;valueC的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。假设时间戳如下</p>
<p>系统A key 1 {valueA &nbsp;3:00}<br>
系统B key 1 {valueB &nbsp;3:05}<br>
系统C key 1 {valueC &nbsp;3:10}</p>
<p>那么，假设这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。</p>
<p>其他方法，比如利用队列，将set方法变成串行访问也可以。总之，灵活变通。</p>
<p>&nbsp;</p>
<p>9 总结</p>
<p>本文对redis的常见问题做了一个总结。大部分是博主自己在工作中遇到，以及以前面试别人的时候，爱问的一些问题。另外，<strong>不推荐大家临时抱佛脚</strong>，真正碰到一些有经验的工程师，其实几下就能把你问懵。最后，希望大家有所收获吧。</p>



<h2 id="Redis的一些优点。"><a href="#Redis的一些优点。" class="headerlink" title="Redis的一些优点。"></a>Redis的一些优点。</h2><blockquote>
<p>异常快 - Redis非常快，每秒可执行大约110000次的设置(SET)操作，每秒大约可执行81000次的读取/获取(GET)操作。<br>支持丰富的数据类型 -<br>Redis支持开发人员常用的大多数数据类型，例如列表，集合，排序集和散列等等。这使得Redis很容易被用来解决各种问题，因为我们知道哪些问题可以更好使用地哪些数据类型来处理解决。<br>操作具有原子性 - 所有Redis操作都是原子操作，这确保如果两个客户端并发访问，Redis服务器能接收更新的值。 多实用工具 -<br>Redis是一个多实用工具，可用于多种用例，如：缓存，消息队列(Redis本地支持发布/订阅)，应用程序中的任何短期数据，例如，web应用程序中的会话，网页命中计数等。</p>
</blockquote>
<h2 id="三、-spring-boot-集成Redis"><a href="#三、-spring-boot-集成Redis" class="headerlink" title="三、 spring boot 集成Redis"></a>三、 spring boot 集成Redis</h2><p>1、添加依赖</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">  &lt;<span class="selector-tag">dependency</span>&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;<span class="selector-tag">dependency</span>&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;<span class="selector-tag">dependency</span>&gt;</span><br><span class="line">	&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;2.1.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;<span class="selector-tag">dependency</span>&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-cloud-context&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;2.1.2.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;<span class="selector-tag">dependency</span>&gt;</span><br><span class="line">  &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.5.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!<span class="selector-tag">--</span> <span class="selector-tag">Spring</span> <span class="selector-tag">Boot</span> 2<span class="selector-class">.0</span>中<span class="selector-tag">spring-boot-starter-data-redis</span>默认使用<span class="selector-tag">Lettuce</span>方式替代了<span class="selector-tag">Jedis</span>。使用<span class="selector-tag">Jedis</span>的话先排除掉<span class="selector-tag">Lettuce</span>的依赖，然后手动引入<span class="selector-tag">Jedis</span>的依赖。 <span class="selector-tag">--</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">dependency</span>&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">     &lt;<span class="selector-tag">exclusions</span>&gt;</span><br><span class="line">         &lt;<span class="selector-tag">exclusion</span>&gt;</span><br><span class="line">             &lt;groupId&gt;io.lettuce&lt;/groupId&gt;</span><br><span class="line">             &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;</span><br><span class="line">         &lt;/exclusion&gt;</span><br><span class="line">     &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;<span class="selector-tag">dependency</span>&gt;</span><br><span class="line">     &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;<span class="selector-tag">dependency</span>&gt;</span><br><span class="line">	&lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">	&lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>2、配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring.redis.host=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">#Redis服务器连接端口</span><br><span class="line">spring.redis.port=<span class="number">6379</span></span><br><span class="line">#Redis服务器连接密码（默认为空）</span><br><span class="line">spring.redis.password=</span><br><span class="line">#连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">spring.redis.pool.max-active=<span class="number">8</span></span><br><span class="line">#连接池最大阻塞等待时间（使用负值表示没有限制）</span><br><span class="line">spring.redis.pool.max-wait=-<span class="number">1</span></span><br><span class="line">#连接池中的最大空闲连接</span><br><span class="line">spring.redis.pool.max-idle=<span class="number">8</span></span><br><span class="line">#连接池中的最小空闲连接</span><br><span class="line">spring.redis.pool.min-idle=<span class="number">0</span></span><br><span class="line">#连接超时时间（毫秒）</span><br><span class="line">spring.redis.timeout=<span class="number">30000</span></span><br></pre></td></tr></table></figure>
<p>3、配置类RedisConfig</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.CacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CachingConfigurerSupport;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.EnableCaching;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.interceptor.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.context.config.annotation.RefreshScope;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.jedis.JedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor; </span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> <span class="keyword">extends</span> <span class="title">CachingConfigurerSupport</span></span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.redis.host&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.redis.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.redis.timeout&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> timeout;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.redis.password&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.redis.pool.max-active&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxActive;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.redis.pool.max-wait&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxWait;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.redis.pool.max-idle&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxIdle;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.redis.pool.min-idle&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minIdle;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RefreshScope</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KeyGenerator <span class="title">wiselyKeyGenerator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KeyGenerator() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">generate</span><span class="params">(Object target, Method method, Object... params)</span> </span>&#123;</span><br><span class="line">                StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                sb.append(target.getClass().getName());</span><br><span class="line">                sb.append(method.getName());</span><br><span class="line">                <span class="keyword">for</span> (Object obj : params) &#123;</span><br><span class="line">                    sb.append(obj.toString());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sb.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RefreshScope</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JedisConnectionFactory <span class="title">redisConnectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JedisConnectionFactory factory = <span class="keyword">new</span> JedisConnectionFactory();</span><br><span class="line">        factory.setHostName(host);</span><br><span class="line">        factory.setPort(port);</span><br><span class="line">        factory.setTimeout(timeout); <span class="comment">//设置连接超时时间</span></span><br><span class="line">        factory.setPassword(password);</span><br><span class="line">        factory.getPoolConfig().setMaxIdle(maxIdle);</span><br><span class="line">        factory.getPoolConfig().setMinIdle(minIdle);</span><br><span class="line">        factory.getPoolConfig().setMaxTotal(maxActive);</span><br><span class="line">        factory.getPoolConfig().setMaxWaitMillis(maxWait);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RefreshScope</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">		RedisCacheManager cacheManager = RedisCacheManager.create(connectionFactory);</span><br><span class="line">		<span class="comment">// Number of seconds before expiration. Defaults to unlimited (0)</span></span><br><span class="line">		<span class="comment">// cacheManager.setDefaultExpiration(10); // 设置key-value超时时间</span></span><br><span class="line">		<span class="keyword">return</span> cacheManager;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RefreshScope</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, String&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate(factory);</span><br><span class="line">        setSerializer(template); <span class="comment">//设置序列化工具，这样ReportBean不需要实现Serializable接口</span></span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RefreshScope</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setSerializer</span><span class="params">(StringRedisTemplate template)</span> </span>&#123;</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、RedisUtils类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.HashOperations;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.ListOperations;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.SetOperations;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.ValueOperations;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.ZSetOperations;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisUtils</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写入缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(<span class="keyword">final</span> String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ValueOperations&lt;Serializable, Object&gt; operations = redisTemplate.opsForValue();</span><br><span class="line">            operations.set(key, value);</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写入缓存设置时效时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(<span class="keyword">final</span> String key, Object value, Long expireTime ,TimeUnit timeUnit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ValueOperations&lt;Serializable, Object&gt; operations = redisTemplate.opsForValue();</span><br><span class="line">            operations.set(key, value);</span><br><span class="line">            redisTemplate.expire(key, expireTime, timeUnit);</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量删除对应的value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keys</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">final</span> String... keys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            remove(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量删除key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pattern</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removePattern</span><span class="params">(<span class="keyword">final</span> String pattern)</span> </span>&#123;</span><br><span class="line">        Set&lt;Serializable&gt; keys = redisTemplate.keys(pattern);</span><br><span class="line">        <span class="keyword">if</span> (keys.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            redisTemplate.delete(keys);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除对应的value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (exists(key)) &#123;</span><br><span class="line">            redisTemplate.delete(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断缓存中是否有对应的value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.hasKey(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        ValueOperations&lt;Serializable, Object&gt; operations = redisTemplate.opsForValue();</span><br><span class="line">        result = operations.get(key);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈希 添加</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hashKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hmSet</span><span class="params">(String key, Object hashKey, Object value)</span></span>&#123;</span><br><span class="line">        HashOperations&lt;String, Object, Object&gt; hash = redisTemplate.opsForHash();</span><br><span class="line">        hash.put(key,hashKey,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈希获取数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hashKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">hmGet</span><span class="params">(String key, Object hashKey)</span></span>&#123;</span><br><span class="line">        HashOperations&lt;String, Object, Object&gt;  hash = redisTemplate.opsForHash();</span><br><span class="line">        <span class="keyword">return</span> hash.get(key,hashKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 列表添加</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lPush</span><span class="params">(String k,Object v)</span></span>&#123;</span><br><span class="line">        ListOperations&lt;String, Object&gt; list = redisTemplate.opsForList();</span><br><span class="line">        list.rightPush(k,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 列表获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> l</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> l1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">lRange</span><span class="params">(String k, <span class="keyword">long</span> l, <span class="keyword">long</span> l1)</span></span>&#123;</span><br><span class="line">        ListOperations&lt;String, Object&gt; list = redisTemplate.opsForList();</span><br><span class="line">        <span class="keyword">return</span> list.range(k,l,l1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 集合添加</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String key,Object value)</span></span>&#123;</span><br><span class="line">        SetOperations&lt;String, Object&gt; set = redisTemplate.opsForSet();</span><br><span class="line">        set.add(key,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 集合获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">setMembers</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        SetOperations&lt;String, Object&gt; set = redisTemplate.opsForSet();</span><br><span class="line">        <span class="keyword">return</span> set.members(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有序集合添加</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> scoure</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zAdd</span><span class="params">(String key,Object value,<span class="keyword">double</span> scoure)</span></span>&#123;</span><br><span class="line">        ZSetOperations&lt;String, Object&gt; zset = redisTemplate.opsForZSet();</span><br><span class="line">        zset.add(key,value,scoure);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有序集合获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> scoure</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> scoure1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">rangeByScore</span><span class="params">(String key,<span class="keyword">double</span> scoure,<span class="keyword">double</span> scoure1)</span></span>&#123;</span><br><span class="line">        ZSetOperations&lt;String, Object&gt; zset = redisTemplate.opsForZSet();</span><br><span class="line">        <span class="keyword">return</span> zset.rangeByScore(key, scoure, scoure1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>5、测试，编写controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> com.chenqi.springboot.redis.RedisUtils;</span><br><span class="line"><span class="keyword">import</span> com.chenqi.springboot.service.TestService;</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"></span><br><span class="line">......    </span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> RedisUtils redisUtils;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping</span>(value = <span class="string">"/hello/&#123;deptNo&#125;"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">hello</span><span class="params">(@PathVariable(value = <span class="string">"deptNo"</span>)</span> String deptNo) </span>&#123;</span><br><span class="line">		<span class="comment">// 查询缓存中是否存在</span></span><br><span class="line">		<span class="keyword">boolean</span> hasKey = redisUtils.exists(deptNo);</span><br><span class="line">		Dept dept = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (hasKey) &#123;</span><br><span class="line">			<span class="comment">// 获取缓存</span></span><br><span class="line">			Object object = redisUtils.get(deptNo);</span><br><span class="line">			log.info(<span class="string">"从缓存获取的数据"</span> + object);</span><br><span class="line">			dept = (Dept) object;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 从数据库中获取信息</span></span><br><span class="line">			log.info(<span class="string">"从数据库中获取数据"</span>);</span><br><span class="line">			dept = deptService.getDeptInfo(Integer.valueOf(deptNo));</span><br><span class="line">			<span class="comment">// 数据插入缓存（set中的参数含义：key值，user对象，缓存存在时间10（long类型），时间单位）</span></span><br><span class="line">			redisUtils.set(deptNo, dept, <span class="number">10L</span>, TimeUnit.MINUTES);</span><br><span class="line">			log.info(<span class="string">"数据插入缓存"</span> + dept);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dept;</span><br><span class="line">	&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
 <p>6、启动项目，第一次访问：<a href="http://localhost:8002/hello/111" target="_blank" rel="nofollow noopener">http://localhost:8002/hello/111</a><br>
<img src="https://img-blog.csdnimg.cn/20190801200449949.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDYyMzczNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
<img src="https://img-blog.csdnimg.cn/20190801200458311.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDYyMzczNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
通过控制台输出，我们可以看到是从数据库中获取的数据，并且存入了redis缓存中。</p>                    
<p>7、我们再次刷新浏览器<br>
<img src="https://img-blog.csdnimg.cn/20190801200519680.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDYyMzczNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
可以看到，第二次是从缓存中读取的，我们试试不断刷新浏览器<br>
<img src="https://img-blog.csdnimg.cn/20190801200535433.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDYyMzczNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
可以看到，之后都是从缓存中获取的。</p>

<p>8、测试Redis<br>    测试输入命令：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">redis-cli</span><span class="selector-class">.exe</span> <span class="selector-tag">-h</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span> <span class="selector-tag">-p</span> 6379 </span><br><span class="line"><span class="selector-tag">set</span> <span class="selector-tag">userinfo</span> <span class="selector-tag">zjl</span></span><br><span class="line"><span class="selector-tag">get</span> <span class="selector-tag">userinfo</span></span><br></pre></td></tr></table></figure>
<p>9、使用RedisDesktopManager可视化工具进行查看<br><img src="https://img-blog.csdnimg.cn/20200415232823550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200415232855966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="四、SpringBoot-使用-Redis-实现-Session-共享"><a href="#四、SpringBoot-使用-Redis-实现-Session-共享" class="headerlink" title="四、SpringBoot 使用 Redis 实现 Session 共享"></a>四、SpringBoot 使用 Redis 实现 Session 共享</h2><p><strong>1、 什么是 Session</strong></p>
<blockquote>
<p>由于 HTTP 协议是无状态的协议，因而服务端需要记录用户的状态时，就需要用某种机制来识具体的用户。Session<br>是另一种记录客户状态的机制，不同的是 Cookie 保存在客户端浏览器中，而 Session<br>保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是<br>Session。客户端浏览器再次访问时只需要从该 Session 中查找该客户的状态就可以了。</p>
</blockquote>
<p><strong>2、 为什么需要同步session ？</strong></p>
<blockquote>
<p>当用户量比较大时候一个tomcat可能无法处理更多的请求，超过单个tomcat的承受能力，可能会出现用户等待，严重的导致tomcat宕机。<br><img src="https://img-blog.csdnimg.cn/2020041523514483.png#pic_center" alt="在这里插入图片描述">    </p>
<p>这时候我们后端可能会采用多个tomcat去处理请求，分派请求，不同请求让多个tomcat分担处理。</p>
<p> 登录的时候可能采用的是tomca1，下单的时候可能采用的是tomcat2 等等等。</p>
<p>若没有session共享同步，可能在tomcat1登录了，下一次请求被分派到tomcat2上，这时候用户就需要重新登录。</p>
<p>在实际工作中我们建议使用外部的缓存设备来共享 Session，避免单个节点挂掉而影响服务，使用外部缓存 Session 后，我们的<br>    共享数据都会放到外部缓存容器中，服务本身就会变成无状态的服务，可以随意的根据流量的大小增加或者减少负载的设备。</p>
</blockquote>
<p><strong>目前主流的分布式 Session 管理有两种方案</strong>。</p>
<p><strong>1 Session 复制</strong></p>
<p>部分 Web 服务器能够支持 Session 复制功能，如 Tomcat。用户可以通过修改 Web 服务器的配置文件，让 Web 服务器进行 Session 复制，保持每一个服务器节点的 Session 数据都能达到一致。</p>
<p>这种方案的实现依赖于 Web 服务器，需要 Web 服务器有 Session 复制功能。当 Web 应用中 Session 数量较多的时候，每个服务器节点都需要有一部分内存用来存放 Session，将会占用大量内存资源。同时大量的 Session 对象通过网络传输进行复制，不但占用了网络资源，还会因为复制同步出现延迟，导致程序运行错误。</p>
<p>在微服务架构中，往往需要 N 个服务端来共同支持服务，不建议采用这种方案。</p>
<p><strong>2 Session 集中存储</strong></p>
<p>在单独的服务器或服务器集群上使用缓存技术，如 Redis 存储 Session 数据，集中管理所有的 Session，所有的 Web 服务器都从这个存储介质中存取对应的 Session，实现 Session 共享。将 Session 信息从应用中剥离出来后，其实就达到了服务的无状态化，这样就方便在业务极速发展时水平扩充。</p>
<p>Spring Session<br>Spring Session 提供了一套创建和管理 Servlet HttpSession 的方案。Spring Session 提供了集群 Session（Clustered Sessions）功能，默认采用外置的 Redis 来存储 Session 数据，以此来解决 Session 共享的问题。</p>
<p>Spring Session 为企业级 Java 应用的 Session 管理带来了革新，使得以下的功能更加容易实现：</p>
<blockquote>
<p>API 和用于管理用户会话的实现； HttpSession，允许以应用程序容器（即 Tomcat）中性的方式替换<br>              HttpSession；    将 Session 所保存的状态卸载到特定的外部 Session 存储中，如 Redis 或<br>              Apache Geode    中，它们能够以独立于应用服务器的方式提供高质量的集群； 支持每个浏览器上使用多个<br>              Session，从而能够很容易地构建更加丰富的终端用户体验； 控制 Session ID<br>              如何在客户端和服务器之间进行交换，这样的话就能很容易地编写 Restful API，因为它可以从 HTTP 头信息中获取<br>              Session ID，而不必再依赖于 cookie； 当用户使用 WebSocket 发送请求的时候，能够保持<br>              HttpSession 处于活跃状态。  需要说明的很重要的一点就是，Spring Session 的核心项目并不依赖于<br>              Spring 框架，因此，我们甚至能够将其应用于不使用  Spring 框架的项目中。</p>
</blockquote>
<p>3、spring boot中如何使用<br>首先新建一个springboot项目<br>1）、pom文件中除了引人redis外还需引入</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">dependency</span>&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>2）、配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server.port=<span class="number">8080</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Redis 配置</span><br><span class="line"># Redis 数据库索引（默认为0）</span><br><span class="line">spring.redis.database=<span class="number">0</span></span><br><span class="line"># Redis 服务器地址</span><br><span class="line">spring.redis.host=localhost</span><br><span class="line"># Redis 服务器连接端口</span><br><span class="line">spring.redis.port=<span class="number">6379</span>  </span><br><span class="line"># Redis 服务器连接密码（默认为空）</span><br><span class="line">spring.redis.password=</span><br><span class="line"># 连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">spring.redis.lettuce.pool.max-active=<span class="number">8</span></span><br><span class="line">spring.redis.lettuce.pool.max-wait=-<span class="number">1</span></span><br><span class="line">spring.redis.lettuce.shutdown-timeout=<span class="number">100</span></span><br><span class="line">spring.redis.lettuce.pool.max-idle=<span class="number">8</span></span><br><span class="line">spring.redis.lettuce.pool.min-idle=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>3）、新建一个初始化类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * maxInactiveIntervalInSeconds: 设置 Session 失效时间</span></span><br><span class="line"><span class="comment"> * 使用 Redis Session 之后，原 Spring Boot 中的 server.session.timeout 属性不再生效。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableRedisHttpSession</span>(maxInactiveIntervalInSeconds = <span class="number">86400</span>*<span class="number">30</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4）、一个控制层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/setSession"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">setSession</span> <span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">       Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       request.getSession().setAttribute(<span class="string">"message"</span>, request.getRequestURL());</span><br><span class="line">       map.put(<span class="string">"request Url"</span>, request.getRequestURL());</span><br><span class="line">       <span class="keyword">return</span> map;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping</span>(value = <span class="string">"/getSession"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getSession</span> <span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">       Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       map.put(<span class="string">"sessionId"</span>, request.getSession().getId());</span><br><span class="line">       map.put(<span class="string">"message"</span>, request.getSession().getAttribute(<span class="string">"message"</span>));</span><br><span class="line">       <span class="keyword">return</span> map;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping</span>(value = <span class="string">"/login"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">login</span> <span class="params">(HttpServletRequest request,String userName,String password)</span></span>&#123;</span><br><span class="line">       String msg=<span class="string">"logon failure!"</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (userName!=<span class="keyword">null</span> &amp;&amp; <span class="string">"admin"</span>.equals(userName) &amp;&amp; <span class="string">"123"</span>.equals(password))&#123;</span><br><span class="line">           request.getSession().setAttribute(<span class="string">"user"</span>,userName);</span><br><span class="line">           msg=<span class="string">"login successful!"</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> msg;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>5）、同上再创建一个项目，该端口为8282</p>
<p>6）、分别启动并测试<br>   在端口是8282 的项目中登录<br>    <img src="https://img-blog.csdnimg.cn/20200416000520408.png#pic_center" alt="在这里插入图片描述"> 然后在端口是8282 和 8080的项目中获取session<br>    <img src="https://img-blog.csdnimg.cn/20200416000611251.png#pic_center" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200416000622929.png#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>两个服务中session id 是一致的，说明我们的session管理成功。</p>
<p>使用Spring Session 可以将session单独的从每个服务总抽离出来，存储到redis中进行集中管理。<br>相对于每个服务复制session的方式可谓简便至极，也不需要在每个Tomcat中修改配置文件，添加jar包等操作。</p>
</blockquote>
<p>有问题：316572403</p>
<p>原文出处1：<a href="http://mp.toutiao.com/preview_article/?pgc_id=6625563203793322503" target="_blank" rel="nofollow noopener">http://mp.toutiao.com/preview_article/?pgc_id=6625563203793322503</a></p>
<p>原文出处2：<a href="http://mp.toutiao.com/preview_article/?pgc_id=6625563203793322503" target="_blank" rel="nofollow noopener">https://blog.csdn.net/qq_43001609/article/details/82928798</a></p>
<p>原文出处3：<a href="http://mp.toutiao.com/preview_article/?pgc_id=6625563203793322503" target="_blank" rel="nofollow noopener">https://blog.csdn.net/weixin_40623736/article/details/98097708</a></p>   
<p>原文出处4：<a href="http://mp.toutiao.com/preview_article/?pgc_id=6625563203793322503" target="_blank" rel="nofollow noopener">https://segmentfault.com/a/1190000019625173</a></p>]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud 你需要知道的</title>
    <url>/myblog/spring-cloud/Spring-Cloud%EF%BC%8801%EF%BC%89%E4%B9%8B%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84/</url>
    <content><![CDATA[<h2 id="Spring-Cloud是什么"><a href="#Spring-Cloud是什么" class="headerlink" title="Spring Cloud是什么"></a>Spring Cloud是什么</h2><p>Spring Cloud 是一系列框架的有序集合。它利用 Spring Boot 的开发便利性，巧妙地简化了分布式系统基础设施的开发，如服务注册、服务发现、配置中心、消息总线、负载均衡、断路器、数据监控等，这些都可以用 Spring Boot 的开发风格做到一键启动和部署。</p>
<a id="more"></a>
<p>通俗地讲，Spring Cloud 就是用于构建微服务开发和治理的框架集合（并不是具体的一个框架），主要贡献来自 Netflix OSS。</p>
<p>Spring Cloud 模块的相关也就是需要掌握的介绍如下：</p>
<pre><code>Eureka：服务注册中心，用于服务管理。
Ribbon：基于客户端的负载均衡组件。
Hystrix：容错框架，能够防止服务的雪崩效应。
Feign：Web 服务客户端，能够简化 HTTP 接口的调用。
Zuul：API 网关，提供路由转发、请求过滤等功能。
Config：分布式配置管理。
Sleuth：服务跟踪。
Stream：构建消息驱动的微服务应用程序的框架。
Bus：消息代理的集群消息总线。</code></pre><p>除了上述模块，还有 Cli、Task、Gateway等等。在此只介绍一些常用的模块。</p>
<p>Spring Cloud 是一个非常好的框架集合，它包含的功能模块非常多，不可能一一讲解到，凡是在课程中出现的模块都是真实开发中用得到的，一句话我们先学常用的，其它技术点用到时再学习。</p>
<h2 id="Spring-Cloud-版本介绍"><a href="#Spring-Cloud-版本介绍" class="headerlink" title="Spring Cloud 版本介绍"></a>Spring Cloud 版本介绍</h2><p>相信大家跟我一样，在第一次访问 <a href="https://projects.spring.io/spring-cloud/#learn" target="_blank" rel="noopener">Spring Cloud 官网</a><br>时一定会有一个疑惑那就是版本也太多了撒，到底哪个是稳定版本？哪个才是自己需要的版本？这些都不是大问题。</p>
<p>访问官网 <a href="https://projects.spring.io/spring-cloud/#learn" target="_blank" rel="noopener">https://projects.spring.io/spring-cloud/#learn</a><br> 可以看到网页右侧的版本列表，如图 1 所示。<br> <img src="https://img-blog.csdnimg.cn/20200428212432294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">从图 1 中可以看到 Spring Cloud 不是像别的项目那样，版本号采用 1.1、1.2、1.3 这种的格式。因为 Spring Cloud 是一个拥有诸多子项目的大型综合项目，可以说是对微服务架构解决方案的综合套件组件，其中包含的各个子项目都独立进行着内容的迭代与更新，各自维护着自己的发布版本号。</p>
<p>Spring Cloud是一个由许多子项目组成的综合项目，各子项目有不同的发布节奏。 为了管理Spring Cloud与各子项目的版本依赖关系，发布了一个清单，其中包括了某个Spring Cloud版本对应的子项目版本。 为了避免Spring Cloud版本号与子项目版本号混淆，Spring Cloud版本采用了名称而非版本号的命名，这些版本的名字采用了伦敦地铁站的名字，根据字母表的顺序来对应版本时间顺序，例如Angel是第一个版本，Brixton是第二个版本。 当Spring Cloud的发布内容积累到临界点或者一个重大BUG被解决后，会发布一个”service releases”版本，简称SRX版本，比如Greenwich.SR2就是Spring Cloud发布的Greenwich版本的第2个SRX版本。目前Spring Cloud的最新版本是Hoxton。</p>
<p>至于怎么选择适合自己的版本，大家可以在接触的时候直接选最新的稳定版本。新版本中的 Bug 肯定要少，并且更稳定。</p>
<p>本课程的案例都是基于 Hoxton  进行讲解的。不同的版本有不同的功能，对应的每个子模块的版本也不一样，那么如何知道每个大版本下面具体的子模块是什么版本呢？</p>
<p>答案就在官网的首页上面，在页面的最下方有一个表格（见表 1 ），通过这个表格我们可以清楚地知道 Hoxton 对应的 Spring Boot 版本是 2.2.X，Spring-Cloud-Bus 是 2.2.1。<br><img src="https://img-blog.csdnimg.cn/2020042821335543.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>PS：Hoxton版本是基于SpringBoot 2.2.x版本构建的，不适用于1.5.x版本。随着2019年8月SpringBoot 1.5.x版本停止维护，Edgware版本也将停止维护。</p>
<h2 id="Spring-Cloud和Dubbo的区别及各自的优缺点"><a href="#Spring-Cloud和Dubbo的区别及各自的优缺点" class="headerlink" title="Spring Cloud和Dubbo的区别及各自的优缺点"></a>Spring Cloud和Dubbo的区别及各自的优缺点</h2><p>我们先从 Nginx 说起，了解为什么需要微服务。最初的服务化解决方案是给相同服务提供一个统一的域名，然后服务调用者向这个域发送 HTTP 请求，由 Nginx 负责请求的分发和跳转。</p>
<p>这种架构存在很多问题：Nginx 作为中间层，在配置文件中耦合了服务调用的逻辑，这削弱了微服务的完整性，也使得 Nginx 在一定程度上变成了一个重量级的 ESB。图 1 标识出了 Nginx 的转发信息流走向。<br>Nginx转发的信息流<br>图 1  Nginx 转发的信息流<br><img src="https://img-blog.csdnimg.cn/20200428214507329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>服务的信息分散在各个系统，无法统一管理和维护。每一次的服务调用都是一次尝试，服务消费方并不知道有哪些实例在给他们提供服务。这带来了一些问题：</p>
<pre><code>无法直观地看到服务提供方和服务消费方当前的运行状况与通信频率；
消费方的失败重发、负载均衡等都没有统一策略，这加大了开发每个服务的难度，不利于快速演化。</code></pre><p>为了解决上面的问题，我们需要一个现成的中心组件对服务进行整合，将每个服务的信息汇总，包括服务的组件名称、地址、数量等。</p>
<p>服务的调用方在请求某项服务时首先通过中心组件获取提供服务的实例信息（IP、端口等），再通过默认或自定义的策略选择该服务的某一提供方直接进行访问，所以考虑引入 Dubbo。</p>
<p>Dubbo 是阿里开源的一个 SOA 服务治理解决方案，文档丰富，在国内的使用度非常高。图 2 为 Dubbo 的基本架构图，使用 Dubbo 构建的微服务已经可以较好地解决上面提到的问题。<br>Dubbo的基本架构图<br>图 2  Dubbo 的基本架构图</p>
<p>从图 2 中，可以看出以下几点：<br><img src="https://img-blog.csdnimg.cn/20200428214550507.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<pre><code>调用中间层变成了可选组件，消费方可以直接访问服务提供方；
服务信息被集中到 Registry 中，形成了服务治理的中心组件；
通过 Monitor 监控系统，可以直观地展示服务调用的统计信息；
服务消费者可以进行负载均衡、服务降级的选择。</code></pre><p>但是对于微服务架构而言，Dubbo 并不是十全十美的，也有一些缺陷，比如：</p>
<pre><code>Registry 严重依赖第三方组件（ZooKeeper 或者 Redis），当这些组件出现问题时，服务调用很快就会中断。
Dubbo 只支持 RPC 调用。这使得服务提供方与调用方在代码上产生了强依赖，服务提供方需要不断将包含公共代码的 Jar 包打包出来供消费方使用。一旦打包出现问题，就会导致服务调用出错。</code></pre><p>个人认为，Dubbo 和 Spring Cloud 并不是完全的竞争关系，两者所解决的问题域并不一样。</p>
<p>Dubbo 的定位始终是一款 RPC 框架，而 Spring Cloud 的目标是微服务架构下的一站式解决方案。如果非要比较的话，Dubbo 可以类比到 Netflix OSS 技术栈，而 Spring Cloud 集成了 Netflix OSS 作为分布式服务治理解决方案，但除此之外 Spring Cloud 还提供了配置、消息、安全、调用链跟踪等分布式问题解决方案。</p>
<p>当前由于 RPC 协议、注册中心元数据不匹配等问题，在面临微服务基础框架选型时 Dubbo 与 Spring Cloud 只能二选一，这也是大家总是拿 Dubbo 和 Spring Cloud 做对比的原因之一。</p>
<p>Dubbo 已经适配到 Spring Cloud 生态，比如作为 Spring Cloud 的二进制通信方案来发挥 Dubbo 的性能优势，Dubbo 通过模块化以及对 HTTP 的支持适配到 Spring Cloud。</p>
<h2 id="Spring-Cloud-好在哪里"><a href="#Spring-Cloud-好在哪里" class="headerlink" title="Spring Cloud 好在哪里"></a>Spring Cloud 好在哪里</h2><p>作为新一代的服务框架，Spring Cloud 提出的口号是开发“面向云的应用程序”，它为微服务架构提供了更加全面的技术支持。结合我们一开始提到的微服务的诉求，参见表 1，把Spring Cloud 与 Dubbo 进行一番对比。</p>
<p>表 1 Spring Cloud与Dubbo功能对比 功能名称<br><img src="https://img-blog.csdnimg.cn/20200428214951436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Spring Cloud 抛弃了 Dubbo 的 RPC 通信，采用的是基于 HTTP 的 REST 方式。严格来说，这两种方式各有优劣。虽然从一定程度上来说，后者牺牲了服务调用的性能，但也避免了上面提到的原生 RPC 带来的问题。而且 REST 相比 RPC 更为灵活，服务提供方和调用方，不存在代码级别的强依赖，这在强调快速演化的微服务环境下显得更加合适。</p>
<p>很明显，Spring Cloud 的功能比 Dubbo 更加强大，涵盖面更广，而且作为 Spring 的拳头项目，它也能够与 Spring Framework、Spring Boot、Spring Data、Spring Batch 等其他 Spring 项目完美融合，这些对于微服务而言是至关重要的。</p>
<p>前面提到，微服务背后一个重要的理念就是持续集成、快速交付，而在服务内部使用一个统一的技术框架，显然比将分散的技术组合到一起更有效率。</p>
<p>更重要的是，相比于 Dubbo，它是一个正在持续维护的、社区更加火热的开源项目，这就可以保证使用它构建的系统持续地得到开源力量的支持。</p>
<p>下面列举 Spring Cloud 的几个优势。</p>
<pre><code>Spring Cloud 来源于 Spring，质量、稳定性、持续性都可以得到保证。
Spirng Cloud 天然支持 Spring Boot，更加便于业务落地。
Spring Cloud 发展得非常快，从开始接触时的相关组件版本为 1.x，到现在将要发布 2.x 系列。
Spring Cloud 是 Java 领域最适合做微服务的框架。</code></pre><p>相比于其他框架，Spring Cloud 对微服务周边环境的支持力度最大。对于中小企业来讲，使用门槛较低。</p>
<p>缺点：</p>
<pre><code>微服务过多，治理成本高，不利于维护系统
分布式系统开发的成本高（容错，分布式事务等）对团队挑战大</code></pre><p>总的来说优点大过于缺点，目前看来Spring Cloud是一套非常完善的分布式框架，目前很多企业开始用微服务、Spring Cloud的优势是显而易见的。因此对于想研究微服务架构的同学来说，学习Spring Cloud是一个不错的选择。</p>
<h2 id="Spring-Cloud发展前景"><a href="#Spring-Cloud发展前景" class="headerlink" title="Spring Cloud发展前景"></a>Spring Cloud发展前景</h2><p>Spring Cloud对于中小型互联网公司来说是一种福音，因为这类公司往往没有实力或者没有足够的资金投入去开发自己的分布式系统基础设施，使用Spring Cloud一站式解决方案能在从容应对业务发展的同时大大减少开发成本。同时，随着近几年微服务架构和Docker容器概念的火爆，也会让Spring Cloud在未来越来越“云”化的软件开发风格中立有一席之地，尤其是在五花八门的分布式解决方案中提供了标准化的、全站式的技术方案，意义可能会堪比当年Servlet规范的诞生，有效推进服务端软件系统技术水平的进步。<br><img src="https://img-blog.csdnimg.cn/20200428220218252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="主要项目"><a href="#主要项目" class="headerlink" title="主要项目"></a>主要项目</h2><p>Spring Cloud的子项目，大致可分成两类，一类是对现有成熟框架”Spring Boot化”的封装和抽象，也是数量最多的项目；第二类是开发了一部分分布式系统的基础设施的实现，如Spring Cloud Stream扮演的就是kafka, ActiveMQ这样的角色。<br>Spring Cloud Config</p>
<p>集中配置管理工具，分布式系统中统一的外部配置管理，默认使用Git来存储配置，可以支持客户端配置的刷新及加密、解密操作。<br>Spring Cloud Netflix</p>
<p>Netflix OSS 开源组件集成，包括Eureka、Hystrix、Ribbon、Feign、Zuul等核心组件。</p>
<pre><code>Eureka：服务治理组件，包括服务端的注册中心和客户端的服务发现机制；
Ribbon：负载均衡的服务调用组件，具有多种负载均衡调用策略；
Hystrix：服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；
Feign：基于Ribbon和Hystrix的声明式服务调用组件；
Zuul：API网关组件，对请求提供路由及过滤功能。</code></pre><p>Spring Cloud Bus</p>
<p>用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置。<br>Spring Cloud Consul</p>
<p>基于Hashicorp Consul的服务治理组件。<br>Spring Cloud Security</p>
<p>安全工具包，对Zuul代理中的负载均衡OAuth2客户端及登录认证进行支持。<br>Spring Cloud Sleuth</p>
<p>Spring Cloud应用程序的分布式请求链路跟踪，支持使用Zipkin、HTrace和基于日志（例如ELK）的跟踪。<br>Spring Cloud Stream</p>
<p>轻量级事件驱动微服务框架，可以使用简单的声明式模型来发送及接收消息，主要实现为Apache Kafka及RabbitMQ。<br>Spring Cloud Task</p>
<p>用于快速构建短暂、有限数据处理任务的微服务框架，用于向应用中添加功能性和非功能性的特性。<br>Spring Cloud Zookeeper</p>
<p>基于Apache Zookeeper的服务治理组件。<br>Spring Cloud Gateway</p>
<p>API网关组件，对请求提供路由及过滤功能。<br>Spring Cloud OpenFeign</p>
<p>基于Ribbon和Hystrix的声明式服务调用组件，可以动态创建基于Spring MVC注解的接口实现用于服务调用，在Spring Cloud 2.0中已经取代Feign成为了一等公民。</p>
<h2 id="和Spring-Boot的关系"><a href="#和Spring-Boot的关系" class="headerlink" title="和Spring Boot的关系"></a>和Spring Boot的关系</h2><ol>
<li><p>Spring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发单个微服务，Spring<br>Cloud是一个基于Spring Boot实现的云应用开发工具。Spring -&gt; Spring Boot &gt; Spring Cloud<br>这样的关系。</p>
</li>
<li><p>Spring Boot可以离开Spring Cloud独立使用开发项目，但是Spring Cloud离不开Spring<br>Boot，属于依赖的关系</p>
</li>
<li><p>Spring Boot专注于快速、方便集成的单个个体微服务，Spring Cloud是关注全局的服务治理框架</p>
</li>
<li><p>Spring Boot使用了默认大于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置，Spring<br>Cloud很大的一部分是基于Spring Boot来实现，可以不基于Spring Boot吗？不可以</p>
</li>
</ol>
<p>总之：Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud之Eureka服务注册与发现</title>
    <url>/myblog/spring-cloud/Spring-Cloud%EF%BC%8802%EF%BC%89%E4%B9%8BEureka%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="Eureka简介"><a href="#Eureka简介" class="headerlink" title="Eureka简介"></a>Eureka简介</h2><p>在微服务架构中往往会有一个注册中心，每个微服务都会向注册中心去注册自己的地址及端口信息，注册中心维护着服务名称与服务实例的对应关系。每个微服务都会定时从注册中心获取服务列表，同时汇报自己的运行情况，这样当有的服务需要调用其他服务时，就可以从自己获取到的服务列表中获取实例地址进行调用，Eureka实现了这套服务注册与发现机制。</p>
<a id="more"></a>
<p>下面将展示基于eclipse使用STS搭建Eureka服务的正确手法<br>(别问我什么是STS，我只会给你个眼神自己体会……)</p>
<h2 id="一、搭建Eureka注册中心"><a href="#一、搭建Eureka注册中心" class="headerlink" title="一、搭建Eureka注册中心"></a>一、搭建Eureka注册中心</h2><p><img src="https://img-blog.csdnimg.cn/2020042823074869.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200428231056675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>项目结构：<br><img src="https://img-blog.csdnimg.cn/20200428231838752.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">pom文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">	xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">	&lt;parent&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">		&lt;version&gt;2.2.6.RELEASE&lt;/version&gt;</span><br><span class="line">		&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">	&lt;/parent&gt;</span><br><span class="line">	&lt;groupId&gt;cn.chfsun&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;eureka-server&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">	&lt;name&gt;eureka-server&lt;/name&gt;</span><br><span class="line">	&lt;description&gt;eureka-server&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">	&lt;properties&gt;</span><br><span class="line">		&lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">		&lt;spring-cloud.version&gt;Hoxton.SR3&lt;/spring-cloud.version&gt;</span><br><span class="line">	&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">			&lt;scope&gt;<span class="built_in">test</span>&lt;/scope&gt;</span><br><span class="line">			&lt;exclusions&gt;</span><br><span class="line">				&lt;exclusion&gt;</span><br><span class="line">					&lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;</span><br><span class="line">					&lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;</span><br><span class="line">				&lt;/exclusion&gt;</span><br><span class="line">			&lt;/exclusions&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">	&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencyManagement&gt;</span><br><span class="line">		&lt;dependencies&gt;</span><br><span class="line">			&lt;dependency&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">				&lt;version&gt;<span class="variable">$&#123;spring-cloud.version&#125;</span>&lt;/version&gt;</span><br><span class="line">				&lt;<span class="built_in">type</span>&gt;pom&lt;/<span class="built_in">type</span>&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">			&lt;/dependency&gt;</span><br><span class="line">		&lt;/dependencies&gt;</span><br><span class="line">	&lt;/dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">	&lt;build&gt;</span><br><span class="line">		&lt;plugins&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">			&lt;/plugin&gt;</span><br><span class="line">		&lt;/plugins&gt;</span><br><span class="line">	&lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>

<p>配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8001<span class="comment"># 你的端口</span></span><br><span class="line"> </span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost <span class="comment"># 你的地址</span></span><br><span class="line">  client:</span><br><span class="line">    registerWithEureka: <span class="literal">false</span> <span class="comment"># 表示是否注册自身到eureka服务器，因为当前这个应用就是eureka服务器，没必要注册自身，所以这里是false</span></span><br><span class="line">    fetchRegistry: <span class="literal">false</span> <span class="comment"># fetchRegistry表示是否从eureka服务器获取注册信息</span></span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http://<span class="variable">$&#123;eureka.instance.hostname&#125;</span>:<span class="variable">$&#123;server.port&#125;</span>/eureka/</span><br><span class="line">      <span class="comment"># defaultZone就比较重要了，是设置eureka服务器所在的地址，查询服务和注册服务都需要依赖这个地址</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chfsun;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span> <span class="comment">// 该注解表明开启应用为eureka服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(EurekaServerApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接右键选择Spring Boot App，启动服务，浏览器中输入<a href="http://localhost:8000/" target="_blank" rel="noopener">http://localhost:8000/</a><br> 访问后，页面如下：<br><img src="https://img-blog.csdnimg.cn/20200428232713755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br></p>
<h2 id="二、搭建Eureka客户端"><a href="#二、搭建Eureka客户端" class="headerlink" title="二、搭建Eureka客户端"></a>二、搭建Eureka客户端</h2><p><img src="https://img-blog.csdnimg.cn/20200428233130562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>next后：<br><img src="https://img-blog.csdnimg.cn/20200428233452597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>项目结构：<br><img src="https://img-blog.csdnimg.cn/20200428233635209.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>pom文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">	xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">	&lt;parent&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">		&lt;version&gt;2.2.6.RELEASE&lt;/version&gt;</span><br><span class="line">		&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">	&lt;/parent&gt;</span><br><span class="line">	&lt;groupId&gt;cn.chfsun&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;eureka-client-springboot&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">	&lt;name&gt;eureka-client-springboot&lt;/name&gt;</span><br><span class="line">	&lt;description&gt;eureka-client&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">	&lt;properties&gt;</span><br><span class="line">		&lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">		&lt;spring-cloud.version&gt;Hoxton.SR3&lt;/spring-cloud.version&gt;</span><br><span class="line">	&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">			&lt;scope&gt;<span class="built_in">test</span>&lt;/scope&gt;</span><br><span class="line">			&lt;exclusions&gt;</span><br><span class="line">				&lt;exclusion&gt;</span><br><span class="line">					&lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;</span><br><span class="line">					&lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;</span><br><span class="line">				&lt;/exclusion&gt;</span><br><span class="line">			&lt;/exclusions&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">	&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencyManagement&gt;</span><br><span class="line">		&lt;dependencies&gt;</span><br><span class="line">			&lt;dependency&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">				&lt;version&gt;<span class="variable">$&#123;spring-cloud.version&#125;</span>&lt;/version&gt;</span><br><span class="line">				&lt;<span class="built_in">type</span>&gt;pom&lt;/<span class="built_in">type</span>&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">			&lt;/dependency&gt;</span><br><span class="line">		&lt;/dependencies&gt;</span><br><span class="line">	&lt;/dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">	&lt;build&gt;</span><br><span class="line">		&lt;plugins&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">			&lt;/plugin&gt;</span><br><span class="line">		&lt;/plugins&gt;</span><br><span class="line">	&lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>

<p>配置文件application.yml：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8101  <span class="comment"># 你的端口</span></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http://localhost:8000/eureka/  <span class="comment"># 服务中心地址</span></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: springboot <span class="comment"># 客户端的名字</span></span><br></pre></td></tr></table></figure>
<p>EurekaClientSpringbootApplication中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chfsun;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span> <span class="comment">// 开启客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaClientSpringbootApplication</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(EurekaClientSpringbootApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切换回之前的浏览器eureka服务中心，可发现：<br><img src="https://img-blog.csdnimg.cn/20200428234049690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><br></p>
<h2 id="三、-搭建Eureka注册中心集群"><a href="#三、-搭建Eureka注册中心集群" class="headerlink" title="三、 搭建Eureka注册中心集群"></a>三、 搭建Eureka注册中心集群</h2><p>搭建两个注册中心</p>
<blockquote>
<p>别问我为啥，我只会这样说：<br>由于所有服务都会注册到注册中心去，服务之间的调用都是通过从注册中心获取的服务列表来调用，注册中心一旦宕机，所有服务调用都会出现问题。所以我们需要多个注册中心组成集群来提供服务，下面将搭建一个双节点的注册中心集群。</p>
</blockquote>
<p>1、给eureka-sever添加配置文件application-replica1.yml配置第一个注册中心</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定运行端口</span></span><br><span class="line">server:</span><br><span class="line">  port: 8002</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定服务名称</span></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: eureka-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定主机地址</span></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: replica1</span><br><span class="line">  client:</span><br><span class="line">    fetch-registry: <span class="literal">true</span></span><br><span class="line">    register-with-eureka: <span class="literal">true</span></span><br><span class="line">    service-url:</span><br><span class="line">      <span class="comment"># 注册到另一个Eureka注册中心</span></span><br><span class="line">      defaultZone: http://replica2:8003/eureka/</span><br></pre></td></tr></table></figure>


<p>2、给eureka-sever添加配置文件application-replica2.yml配置第二个注册中心</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定运行端口</span></span><br><span class="line">server:</span><br><span class="line">  port: 8003</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定服务名称</span></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: eureka-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定主机地址</span></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: replica2</span><br><span class="line">  client:</span><br><span class="line">    fetch-registry: <span class="literal">true</span></span><br><span class="line">    register-with-eureka: <span class="literal">true</span></span><br><span class="line">    service-url:</span><br><span class="line">      <span class="comment"># 注册到另一个Eureka注册中心</span></span><br><span class="line">      defaultZone: http://replica1:8002/eureka/</span><br></pre></td></tr></table></figure>

<p>这里我们通过两个注册中心互相注册，搭建了注册中心的双节点集群，由于defaultZone使用了域名，所以还需在本机的hosts文件中配置一下。</p>
<p><em>PS:建议先备份一个hosts文件，万一你改错了，影响到了系统的其它文件呢，然后就会……你懂的…..</em> </p>
<p>修改本地host文件，用管理员权限进入C:\Windows\System32\drivers\etc，添加如下配置，然后保存</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1 replica1</span><br><span class="line">127.0.0.1 replica2</span><br></pre></td></tr></table></figure>
<p>然后运行Eureka注册中心集群：<br>3、添加两个配置，分别以application-replica1.yml和application-replica2.yml来启动eureka-server<br><img src="https://img-blog.csdnimg.cn/20200429003437193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>下一步，项目单击右键Run As–》最后一项 Run Configurations<br><img src="https://img-blog.csdnimg.cn/20200429003730609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>同样方式来个第二个，换下指定配置文件即可，这里不再啰嗦。</p>
<p>启动两个eureka-server，访问其中一个注册中心<a href="http://replica1:8002/发现另一个已经成为其备份：" target="_blank" rel="noopener">http://replica1:8002/发现另一个已经成为其备份：</a><br><img src="https://img-blog.csdnimg.cn/20200429004023492.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>修改Eureka-client，在eureka-client-springboot的配置文件中添加一个application-replica.yml，让其同时注册到两个注册中心。，让其连接到集群：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定运行端口</span></span><br><span class="line">server:</span><br><span class="line">  port: 8102</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定服务名称</span></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: eureka-client</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    <span class="comment"># 注册到Eureka的注册中心</span></span><br><span class="line">    register-with-eureka: <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 获取注册实例列表</span></span><br><span class="line">    fetch-registry: <span class="literal">true</span></span><br><span class="line">    service-url:</span><br><span class="line">      <span class="comment"># 同时注册到两个注册中心</span></span><br><span class="line">      defaultZone: http://replica1:8002/eureka/,http://replica2:8003/eureka/</span><br></pre></td></tr></table></figure>
<p>以该配置文件启动后访问任意一个注册中心节点都可以看到eureka-client-springboot：<br><img src="https://img-blog.csdnimg.cn/20200429095320105.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="四、为Eureka注册中心添加安全访问认证"><a href="#四、为Eureka注册中心添加安全访问认证" class="headerlink" title="四、为Eureka注册中心添加安全访问认证"></a>四、为Eureka注册中心添加安全访问认证</h2><p>1、创建一个eureka-security-server模块，在pom.xml中添加以下依赖</p>
<pre><code>&lt;dependency&gt;
     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
     &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
 &lt;/dependency&gt;</code></pre><p>2、添加application.yml配置文件—主要是配置了登录注册中心的用户名和密码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8004</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: eureka-security-server</span><br><span class="line">  security:</span><br><span class="line">    user:</span><br><span class="line">      <span class="comment"># 配置spring security登录用户名和密码</span></span><br><span class="line">      name: root</span><br><span class="line">      password: root</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost</span><br><span class="line">  client:</span><br><span class="line">    fetch-registry: <span class="literal">false</span></span><br><span class="line">    register-with-eureka: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>3、新建Java配置WebSecurityConfig类：</p>
<blockquote>
<p>PS:默认情况下添加SpringSecurity依赖的应用每个请求都需要添加CSRF<br>token才能访问，Eureka客户端注册时并不会添加，所以需要配置/eureka/**路径不需要CSRF token。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.csrf().ignoringAntMatchers(<span class="string">"/eureka/**"</span>);</span><br><span class="line">        <span class="keyword">super</span>.configure(http);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、运行eureka-security-server，访问<a href="http://localhost:8004" target="_blank" rel="noopener">http://localhost:8004</a> 发现需要登录认证：</p>
<p><img src="https://img-blog.csdnimg.cn/20200429100208836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">5、eureka-client注册到有登录认证的注册中心</p>
<p>配置文件中需要修改注册中心地址格式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://<span class="variable">$&#123;username&#125;</span>:<span class="variable">$&#123;password&#125;</span>@<span class="variable">$&#123;hostname&#125;</span>:<span class="variable">$&#123;port&#125;</span>/eureka/</span><br></pre></td></tr></table></figure>

<p>6、添加application-security.yml配置文件，按格式修改用户名和密码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定运行端口</span></span><br><span class="line">server:</span><br><span class="line">  port: 8103</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定服务名称</span></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: eureka-client</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    <span class="comment"># 注册到Eureka的注册中心</span></span><br><span class="line">    register-with-eureka: <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 获取注册实例列表</span></span><br><span class="line">    fetch-registry: <span class="literal">true</span></span><br><span class="line">    service-url:</span><br><span class="line">      <span class="comment"># 配置注册中心地址</span></span><br><span class="line">      defaultZone: http://root:root@localhost:8004/eureka/</span><br></pre></td></tr></table></figure>

<p>以application-security.yml配置运行eureka-client，可以在注册中心界面看到eureka-client已经成功注册</p>
<p><img src="https://img-blog.csdnimg.cn/20200429100615475.png#pic_center" alt="在这里插入图片描述"><br>Eureka用到的配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client: <span class="comment">#eureka客户端配置</span></span><br><span class="line">    register-with-eureka: <span class="literal">true</span> <span class="comment">#是否将自己注册到eureka服务端上去</span></span><br><span class="line">    fetch-registry: <span class="literal">true</span> <span class="comment">#是否获取eureka服务端上注册的服务列表</span></span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://localhost:8001/eureka/ <span class="comment"># 指定注册中心地址</span></span><br><span class="line">    enabled: <span class="literal">true</span> <span class="comment"># 启用eureka客户端</span></span><br><span class="line">    registry-fetch-interval-seconds: 30 <span class="comment">#定义去eureka服务端获取服务列表的时间间隔</span></span><br><span class="line">  instance: <span class="comment">#eureka客户端实例配置</span></span><br><span class="line">    lease-renewal-interval-in-seconds: 30 <span class="comment">#定义服务多久去注册中心续约</span></span><br><span class="line">    lease-expiration-duration-in-seconds: 90 <span class="comment">#定义服务多久不去续约认为服务失效</span></span><br><span class="line">    metadata-map:</span><br><span class="line">      zone: guangdong <span class="comment">#所在区域</span></span><br><span class="line">    hostname: localhost <span class="comment">#服务主机名称</span></span><br><span class="line">    prefer-ip-address: <span class="literal">false</span> <span class="comment">#是否优先使用ip来作为主机名</span></span><br><span class="line">  server: <span class="comment">#eureka服务端配置</span></span><br><span class="line">    <span class="built_in">enable</span>-self-preservation: <span class="literal">false</span> <span class="comment">#关闭eureka服务端的保护机制</span></span><br></pre></td></tr></table></figure>

<h2><a name="t25"></a><a name="t25"></a><a id="_542"></a>项目源码地址</h2>
<p><a href="https://github.com/chfsun/springcloud-learning" target="_blank" rel="noopener">GitHub项目源码地址</a></p>]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>cloud Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud（03）之 Ribbon服务消费者</title>
    <url>/myblog/spring-cloud/Spring-Cloud%EF%BC%8803%EF%BC%89%E4%B9%8B-Ribbon%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85/</url>
    <content><![CDATA[<h2 id="Ribbon简介"><a href="#Ribbon简介" class="headerlink" title="Ribbon简介"></a>Ribbon简介</h2><p>目前主流的负载方案分为以下两种：</p>
<blockquote>
<p>   1、集中式负载均衡，在消费者和服务提供方中间使用独立的代理方式进行负载，有硬件的（比如 F5），也有软件的（比如 Nginx）。<br>2、客户端自己做负载均衡，根据自己的请求情况做负载，Ribbon 就属于客户端自己做负载。</p>
</blockquote>
<a id="more"></a>
<p>Spring Cloud Ribbon 是一个基于 HTTP 和 TCP 的客户端负载均衡工具，它基于 Netflix Ribbon 实现。通过 Spring Cloud 的封装，可以让我们轻松地将面向服务的 REST 模版请求自动转换成客户端负载均衡的服务调用。</p>
<p>Spring Cloud Ribbon 虽然只是一个工具类框架，它不像服务注册中心、配置中心、API 网关那样需要独立部署，但是它几乎存在于每一个 Spring Cloud 构建的微服务和基础设施中。因为微服务间的调用，API 网关的请求转发等内容，实际上都是通过 Ribbon 来实现的（<a href="https://github.com/Netflix/ribbon）。" target="_blank" rel="noopener">https://github.com/Netflix/ribbon）。</a></p>
<h2 id="Ribbon-模块"><a href="#Ribbon-模块" class="headerlink" title="Ribbon 模块"></a>Ribbon 模块</h2><table>
<caption>
Ribbon 模块介绍</caption>
<tbody>
<tr>
<th>
名&nbsp; 称</th>
<th>
说&nbsp; &nbsp; 明</th>
</tr>
<tr>
<td>
ribbon-loadbalancer</td>
<td>
负载均衡模块，可独立使用，也可以和别的模块一起使用。</td>
</tr>
<tr>
<td>
Ribbon</td>
<td>
内置的负载均衡算法都实现在其中。</td>
</tr>
<tr>
<td>
ribbon-eureka</td>
<td>
基于 Eureka 封装的模块，能够快速、方便地集成 Eureka。</td>
</tr>
<tr>
<td>
ribbon-transport</td>
<td>
基于 Netty 实现多协议的支持，比如 HTTP、Tcp、Udp 等。</td>
</tr>
<tr>
<td>
ribbon-httpclient</td>
<td>
基于 Apache HttpClient 封装的 REST 客户端，集成了负载均衡模块，可以直接在项目中使用来调用接口。</td>
</tr>
<tr>
<td>
ribbon-example</td>
<td>
Ribbon 使用代码示例，通过这些示例能够让你的学习事半功倍。</td>
</tr>
<tr>
<td>
ribbon-core</td>
<td>
一些比较核心且具有通用性的代码，客户端 API 的一些配置和其他 API 的定义。</td>
</tr>
</tbody>
</table>


<p>在微服务架构中，很多服务都会部署多个，其他服务去调用该服务的时候，如何保证负载均衡是个不得不去考虑的问题。负载均衡可以增加系统的可用性和扩展性，当我们使用RestTemplate来调用其他服务时，Ribbon可以很方便的实现负载均衡功能。</p>

<h2 id="RestTemplate的使用"><a href="#RestTemplate的使用" class="headerlink" title="RestTemplate的使用"></a>RestTemplate的使用</h2><blockquote>
<p>RestTemplate是一个HTTP客户端，使用它我们可以方便的调用HTTP接口，支持GET、POST、PUT、DELETE等方法。</p>
</blockquote>
<h2 id="GET请求方法"><a href="#GET请求方法" class="headerlink" title="GET请求方法"></a>GET请求方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">T <span class="title">getForObject</span><span class="params">(String url, Class&lt;T&gt; responseType, Object... uriVariables)</span></span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getForObject</span><span class="params">(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span></span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getForObject</span><span class="params">(URI url, Class&lt;T&gt; responseType)</span></span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">ResponseEntity&lt;T&gt; <span class="title">getForEntity</span><span class="params">(String url, Class&lt;T&gt; responseType, Object... uriVariables)</span></span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">ResponseEntity&lt;T&gt; <span class="title">getForEntity</span><span class="params">(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span></span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">ResponseEntity&lt;T&gt; <span class="title">getForEntity</span><span class="params">(URI var1, Class&lt;T&gt; responseType)</span></span>;</span><br></pre></td></tr></table></figure>



<h2 id="getForObject方法"><a href="#getForObject方法" class="headerlink" title="getForObject方法"></a>getForObject方法</h2><p>作用为返回对象为响应体中数据转化成的对象，如下：</p>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">getUser</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(userServiceUrl + <span class="string">"/user/&#123;1&#125;"</span>, Result<span class="class">.<span class="keyword">class</span>, <span class="title">id</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="getForEntity方法"><a href="#getForEntity方法" class="headerlink" title="getForEntity方法"></a>getForEntity方法</h2><p>作用为返回对象为ResponseEntity对象，包含了响应中的一些重要信息，比如响应头、响应状态码、响应体等。如下：</p>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/getEntityByUsername"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">getEntityByUsername</span><span class="params">(@RequestParam String username)</span> </span>&#123;</span><br><span class="line">    ResponseEntity&lt;Result&gt; entity = restTemplate.getForEntity(userServiceUrl + <span class="string">"/user/getByUsername?username=&#123;1&#125;"</span>, Result<span class="class">.<span class="keyword">class</span>, <span class="title">username</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (entity.getStatusCode().is2xxSuccessful()) &#123;</span><br><span class="line">        <span class="keyword">return</span> entity.getBody();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="string">"操作失败"</span>, <span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="POST请求方法"><a href="#POST请求方法" class="headerlink" title="POST请求方法"></a>POST请求方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">T <span class="title">postForObject</span><span class="params">(String url, @Nullable Object request, Class&lt;T&gt; responseType, Object... uriVariables)</span></span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">postForObject</span><span class="params">(String url, @Nullable Object request, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span></span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">postForObject</span><span class="params">(URI url, @Nullable Object request, Class&lt;T&gt; responseType)</span></span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">ResponseEntity&lt;T&gt; <span class="title">postForEntity</span><span class="params">(String url, @Nullable Object request, Class&lt;T&gt; responseType, Object... uriVariables)</span></span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">ResponseEntity&lt;T&gt; <span class="title">postForEntity</span><span class="params">(String url, @Nullable Object request, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span></span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">ResponseEntity&lt;T&gt; <span class="title">postForEntity</span><span class="params">(URI url, @Nullable Object request, Class&lt;T&gt; responseType)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="postForObject示例"><a href="#postForObject示例" class="headerlink" title="postForObject示例"></a>postForObject示例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/insert"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">insert</span><span class="params">(@RequestBody User user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.postForObject(userServiceUrl + <span class="string">"/user/insert"</span>, user, Result<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="postForEntity示例"><a href="#postForEntity示例" class="headerlink" title="postForEntity示例"></a>postForEntity示例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/insert"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">insert</span><span class="params">(@RequestBody User user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.postForEntity(userServiceUrl + <span class="string">"/user/insert"</span>, user, Result<span class="class">.<span class="keyword">class</span>).<span class="title">getBody</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="PUT请求方法"><a href="#PUT请求方法" class="headerlink" title="PUT请求方法"></a>PUT请求方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, @Nullable Object request, Object... uriVariables)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, @Nullable Object request, Map&lt;String, ?&gt; uriVariables)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(URI url, @Nullable Object request)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="PUT请求示例"><a href="#PUT请求示例" class="headerlink" title="PUT请求示例"></a>PUT请求示例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PutMapping</span>(<span class="string">"/update"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">update</span><span class="params">(@RequestBody User user)</span> </span>&#123;</span><br><span class="line">    restTemplate.put(userServiceUrl + <span class="string">"/user/update"</span>, user);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="string">"操作成功"</span>,<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DELETE请求方法"><a href="#DELETE请求方法" class="headerlink" title="DELETE请求方法"></a>DELETE请求方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(String url, Object... uriVariables)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(String url, Map&lt;String, ?&gt; uriVariables)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(URI url)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="DELETE请求示例"><a href="#DELETE请求示例" class="headerlink" title="DELETE请求示例"></a>DELETE请求示例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DeleteMapping</span>(<span class="string">"/delete/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">delete</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</span><br><span class="line">   restTemplate.delete(userServiceUrl + <span class="string">"/user/delete/&#123;1&#125;"</span>, <span class="keyword">null</span>, id);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="string">"操作成功"</span>,<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="demo示例："><a href="#demo示例：" class="headerlink" title="demo示例："></a><strong>demo示例：</strong></h2><blockquote>
<p>技术点：spring boot、mybatis、mysql、eureka、ribbon</p>
</blockquote>
<h2 id="一、创建一个eureka注册中心模块"><a href="#一、创建一个eureka注册中心模块" class="headerlink" title="一、创建一个eureka注册中心模块"></a>一、创建一个eureka注册中心模块</h2><blockquote>
<p>具体操作请参考上一章：Spring Cloud之Eureka服务注册与发现</p>
</blockquote>
<h2 id="二、创建一个ribbon-orcl-server-service-模块"><a href="#二、创建一个ribbon-orcl-server-service-模块" class="headerlink" title="二、创建一个ribbon-orcl-server-service 模块"></a>二、创建一个ribbon-orcl-server-service 模块</h2><blockquote>
<p>用于给Ribbon提供服务调用，可视为服务提供者，较为简单。</p>
</blockquote>
<p>1、pom.xml文件参考：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">     &lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;2.1.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">	&lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>


<p>2、配置文件application.yml参考：</p>
<blockquote>
<p>主要是配置了端口和注册中心地址。</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">server</span>:</span><br><span class="line">  <span class="selector-tag">port</span>: 8201</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">spring</span>:</span><br><span class="line">  <span class="selector-tag">application</span>:</span><br><span class="line">    <span class="selector-tag">name</span>: <span class="selector-tag">ribbon-orcl-server-service</span></span><br><span class="line">  #数据库相关配置</span><br><span class="line">  <span class="selector-tag">datasource</span>:</span><br><span class="line">     <span class="selector-tag">driver-class-name</span>: <span class="selector-tag">com</span><span class="selector-class">.mysql</span><span class="selector-class">.cj</span><span class="selector-class">.jdbc</span><span class="selector-class">.Driver</span></span><br><span class="line">     url: jdbc:mysql://localhost:3306/orcl?useUnicode=true&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC</span><br><span class="line">     <span class="selector-tag">username</span>: <span class="selector-tag">root</span></span><br><span class="line">     <span class="selector-tag">password</span>: 123456</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">eureka</span>:</span><br><span class="line">  <span class="selector-tag">client</span>:</span><br><span class="line">    <span class="selector-tag">register-with-eureka</span>: <span class="selector-tag">true</span></span><br><span class="line">    <span class="selector-tag">fetch-registry</span>: <span class="selector-tag">true</span></span><br><span class="line">    <span class="selector-tag">service-url</span>:</span><br><span class="line">      defaultZone: http://localhost:8001/eureka/</span><br></pre></td></tr></table></figure>


<p>3、创建实体类Dept和统一返回前端的响应类Result<br>3.1、实体类Dept</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dept</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Integer deptNo;</span><br><span class="line">	<span class="keyword">private</span> String deptName;</span><br><span class="line">	<span class="keyword">private</span> String localtion;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">getDeptNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> deptNo;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDeptNo</span><span class="params">(Integer deptNo)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.deptNo = deptNo;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getDeptName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> deptName;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDeptName</span><span class="params">(String deptName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.deptName = deptName;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getLocaltion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> localtion;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocaltion</span><span class="params">(String localtion)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.localtion = localtion;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 省略setter和getter方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>3.2、统一返回前端的响应类Result</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Result</span><span class="params">(T data, String message, <span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Result</span><span class="params">(String message, Integer code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, message, code);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Result</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(data, <span class="string">"操作成功"</span>, <span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略setter和getter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、mapper层基于注解操作数据库，此处省略DeptMapper及DeptService代码，DeptController层代码如下：</p>
<blockquote>
<p>DeptController类定义了对Dept对象常用的CRUD接口。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/dept"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(DeptController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> DeptService deptService;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Value</span>(<span class="string">"$&#123;server.port&#125;"</span>)</span><br><span class="line">	<span class="keyword">private</span> String port;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@PostMapping</span>(<span class="string">"/insert"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Result <span class="title">insert</span><span class="params">(@RequestBody Dept dept)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> rs = deptService.insert(dept);</span><br><span class="line">		<span class="keyword">if</span> (rs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="string">"操作成功"</span>, <span class="number">200</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="string">"操作失败"</span>, -<span class="number">200</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/&#123;deptNo&#125;"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Result&lt;Dept&gt; <span class="title">getDept</span><span class="params">(@PathVariable Integer deptNo)</span> </span>&#123;</span><br><span class="line">		Dept dept = deptService.getDeptInfo(deptNo);</span><br><span class="line">		LOGGER.info(<span class="string">"当前端口为:"</span> + port + <span class="string">"，根据deptNo获取部门信息，部门名称为：&#123;&#125;"</span>, dept.getDeptName());</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Result&lt;Dept&gt;(dept);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/listDept"</span>)</span><br><span class="line">	<span class="keyword">public</span> Result&lt;List&lt;Dept&gt;&gt; listDept() &#123;</span><br><span class="line">		List&lt;Dept&gt; deptList = deptService.queryList();</span><br><span class="line">		LOGGER.info(<span class="string">"获取部门列表总数为：&#123;&#125;"</span>, deptList.size());</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Result&lt;List&lt;Dept&gt;&gt;(deptList);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@PostMapping</span>(<span class="string">"/update"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Result <span class="title">update</span><span class="params">(@RequestBody Dept dept)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> rs = deptService.update(dept);</span><br><span class="line">		<span class="keyword">if</span> (rs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="string">"操作成功"</span>, <span class="number">200</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="string">"操作失败"</span>, -<span class="number">200</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@PostMapping</span>(<span class="string">"/delete/&#123;deptNo&#125;"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Result <span class="title">delete</span><span class="params">(@PathVariable Integer deptNo)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> rs = deptService.del(deptNo);</span><br><span class="line">		<span class="keyword">if</span> (rs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="string">"操作成功"</span>, <span class="number">200</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="string">"操作失败"</span>, -<span class="number">200</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<h2 id="三、创建一个ribbon-orcl-client-service模块"><a href="#三、创建一个ribbon-orcl-client-service模块" class="headerlink" title="三、创建一个ribbon-orcl-client-service模块"></a>三、创建一个ribbon-orcl-client-service模块</h2><blockquote>
<p>ribbon-orcl-client-service模块来调用ribbon-orcl-server-service模块演示负载均衡的服务调用，可视为消费者。</p>
</blockquote>
<p>1、pom.xml文件参考：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">      &lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>


<p>2、配置文件application.yml参考：</p>
<blockquote>
<p>配置了端口、注册中心地址及ribbon-orcl-server-service的调用路径。</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">server</span>:</span><br><span class="line">  <span class="selector-tag">port</span>: 8301</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">spring</span>:</span><br><span class="line">  <span class="selector-tag">application</span>:</span><br><span class="line">    <span class="selector-tag">name</span>: <span class="selector-tag">ribbon-orcl-client-service</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">eureka</span>:</span><br><span class="line">  <span class="selector-tag">client</span>:</span><br><span class="line">    <span class="selector-tag">register-with-eureka</span>: <span class="selector-tag">true</span></span><br><span class="line">    <span class="selector-tag">fetch-registry</span>: <span class="selector-tag">true</span></span><br><span class="line">    <span class="selector-tag">service-url</span>:</span><br><span class="line">      defaultZone: http://localhost:8001/eureka/</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">service-url</span>:</span><br><span class="line">  dept-service: http://ribbon-orcl-server-service</span><br></pre></td></tr></table></figure>


<p>3、使用@LoadBalanced注解赋予RestTemplate负载均衡的能力</p>
<blockquote>
<p>使用Ribbon的负载均衡功能非常简单，和直接使用RestTemplate没什么两样，只需给RestTemplate添加一个@LoadBalanced即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、创建DeptRibbonController类</p>
<blockquote>
<p>注入RestTemplate，使用其调用user-service中提供的相关接口，这里对GET和POST调用进行了演示，其他方法调用均可参考。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/dept"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptRibbonController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Value</span>(<span class="string">"$&#123;service-url.dept-service&#125;"</span>)</span><br><span class="line">	<span class="keyword">private</span> String deptServiceUrl;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/&#123;deptNo&#125;"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Result <span class="title">getDept</span><span class="params">(@PathVariable Integer deptNo)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> restTemplate.getForObject(deptServiceUrl + <span class="string">"/dept/&#123;1&#125;"</span>, Result<span class="class">.<span class="keyword">class</span>, <span class="title">deptNo</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@PostMapping</span>(<span class="string">"/insert"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Result <span class="title">insert</span><span class="params">(@RequestBody Dept dept)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> restTemplate.postForObject(deptServiceUrl + <span class="string">"/dept/insert"</span>, dept, Result<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@PostMapping</span>(<span class="string">"/update"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Result <span class="title">update</span><span class="params">(@RequestBody Dept dept)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> restTemplate.postForObject(deptServiceUrl + <span class="string">"/dept/update"</span>, dept, Result<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@PostMapping</span>(<span class="string">"/delete/&#123;id&#125;"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Result <span class="title">delete</span><span class="params">(@PathVariable Integer deptNo)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> restTemplate.postForObject(deptServiceUrl + <span class="string">"/dept/delete/&#123;1&#125;"</span>, <span class="keyword">null</span>, Result<span class="class">.<span class="keyword">class</span>, <span class="title">deptNo</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="负载均衡功能演示"><a href="#负载均衡功能演示" class="headerlink" title="负载均衡功能演示"></a>负载均衡功能演示</h2><p>1、启动你的注册中心模块于8001端口；<br>2、启动ribbon-orcl-server-service端口8201的服务；<br>3、启动ribbon-orcl-server-service端口8202的服务（可以通过修改Eclipse或者IDEA中的SpringBoot的启动配置实现）<br>4、启动ribbon-orcl-client-service端口为8301的服务</p>
<p><strong>此时运行中的服务如下</strong>：<br><img src="https://img-blog.csdnimg.cn/20200504175151620.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>调用接口进行测试</strong>：<a href="http://localhost:8301/dept/1" target="_blank" rel="nofollow noopener">http://localhost:8301/dept/1</a><br><img src="https://img-blog.csdnimg.cn/20200504175252933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>可以发现运行在8201和8202的user-service控制台交替打印如下信息：<br><img src="https://img-blog.csdnimg.cn/20200504175946101.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200504180035212.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="Ribbon的常用配置"><a href="#Ribbon的常用配置" class="headerlink" title="Ribbon的常用配置"></a>Ribbon的常用配置</h2><p>1、全局配置</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ribbon</span>:</span><br><span class="line">  <span class="selector-tag">ConnectTimeout</span>: 1000 #服务请求连接超时时间（毫秒）</span><br><span class="line">  <span class="selector-tag">ReadTimeout</span>: 3000 #服务请求处理超时时间（毫秒）</span><br><span class="line">  <span class="selector-tag">OkToRetryOnAllOperations</span>: <span class="selector-tag">true</span> #对超时请求启用重试机制</span><br><span class="line">  <span class="selector-tag">MaxAutoRetriesNextServer</span>: 1 #切换重试实例的最大个数</span><br><span class="line">  <span class="selector-tag">MaxAutoRetries</span>: 1 # 切换实例后重试最大次数</span><br><span class="line">  <span class="selector-tag">NFLoadBalancerRuleClassName</span>: <span class="selector-tag">com</span><span class="selector-class">.netflix</span><span class="selector-class">.loadbalancer</span><span class="selector-class">.RandomRule</span> #修改负载均衡算法</span><br></pre></td></tr></table></figure>


<p>2、指定服务进行配置</p>
<blockquote>
<p>与全局配置的区别就是ribbon节点挂在服务名称下面，如下是对ribbon-service调用user-service时的单独配置。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">dept-service</span>:</span><br><span class="line">  <span class="selector-tag">ribbon</span>:</span><br><span class="line">    <span class="selector-tag">ConnectTimeout</span>: 1000 #服务请求连接超时时间（毫秒）</span><br><span class="line">    <span class="selector-tag">ReadTimeout</span>: 3000 #服务请求处理超时时间（毫秒）</span><br><span class="line">    <span class="selector-tag">OkToRetryOnAllOperations</span>: <span class="selector-tag">true</span> #对超时请求启用重试机制</span><br><span class="line">    <span class="selector-tag">MaxAutoRetriesNextServer</span>: 1 #切换重试实例的最大个数</span><br><span class="line">    <span class="selector-tag">MaxAutoRetries</span>: 1 # 切换实例后重试最大次数</span><br><span class="line">    <span class="selector-tag">NFLoadBalancerRuleClassName</span>: <span class="selector-tag">com</span><span class="selector-class">.netflix</span><span class="selector-class">.loadbalancer</span><span class="selector-class">.RandomRule</span> #修改负载均衡算法</span><br></pre></td></tr></table></figure>

<h2 id="Ribbon的负载均衡策略"><a href="#Ribbon的负载均衡策略" class="headerlink" title="Ribbon的负载均衡策略"></a>Ribbon的负载均衡策略</h2><blockquote>
<p>所谓的负载均衡策略，就是当A服务调用B服务时，此时B服务有多个实例，这时A服务以何种方式来选择调用的B实例，ribbon可以选择以下几种负载均衡策略:</p>
</blockquote>
<ul>
<li>com.netflix.loadbalancer.RandomRule：从提供服务的实例中以随机的方式；</li>
<li>com.netflix.loadbalancer.RoundRobinRule：以线性轮询的方式，就是维护一个计数器，从提供服务的实例中按顺序选取，第一次选第一个，第二次选第二个，以此类推，到最后一个以后再从头来过；</li>
<li>com.netflix.loadbalancer.RetryRule：在RoundRobinRule的基础上添加重试机制，即在指定的重试时间内，反复使用线性轮询策略来选择可用实例；</li>
<li>com.netflix.loadbalancer.WeightedResponseTimeRule：对RoundRobinRule的扩展，响应速度越快的实例选择权重越大，越容易被选择；</li>
<li>com.netflix.loadbalancer.BestAvailableRule：选择并发较小的实例；</li>
<li>com.netflix.loadbalancer.AvailabilityFilteringRule：先过滤掉故障实例，再选择并发较小的实例；</li>
<li>com.netflix.loadbalancer.ZoneAwareLoadBalancer：采用双重过滤，同时过滤不是同一区域的实例和故障实例，选择并发较小的实例。</li>
</ul>
<p>本章使用到的模块：</p>
<p>springcloud-ribbon<br>├── ribbon-eureka-server– eureka注册中心<br>├── ribbon-orcl-server-service – 服务提供者<br>└── ribbon-orcl-client-service – ribbon服务调用的消费者</p>
<p><strong><a href="https://github.com/chfsun/springcloud-learning" target="_blank" rel="noopener">GitHub项目源码地址</a></strong></p>
<p>原文部分参考：<a href="https://blog.csdn.net/ThinksWon/article/details/102729080" target="_blank" rel="noopener">https://blog.csdn.net/ThinksWon/article/details/102729080</a></p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>cloud Ribbon</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud（04）之 Hystrix断路器</title>
    <url>/myblog/spring-cloud/Spring-Cloud%EF%BC%8804%EF%BC%89%E4%B9%8B-Hystrix%E6%96%AD%E8%B7%AF%E5%99%A8/</url>
    <content><![CDATA[<h2 id="雪崩效应"><a href="#雪崩效应" class="headerlink" title="雪崩效应"></a>雪崩效应</h2><p>在微服务架构中通常会有多个服务层调用，基础服务的故障可能会导致级联故障，进而造成整个系统不可用的情况，这种现象被称为服务雪崩效应。</p>
<a id="more"></a>
<p>服务雪崩效应是一种因“服务提供者”的不可用导致“服务消费者”的不可用,并将不可用逐渐放大的过程。</p>
<p>如果下图所示：A作为服务提供者，B为A的服务消费者，C和D是B的服务消费者。A不可用引起了B的不可用，并将不可用像滚雪球一样放大到C和D时，雪崩效应就形成了。</p>
<p><img src="https://img-blog.csdnimg.cn/20200506113254302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="熔断器"><a href="#熔断器" class="headerlink" title="熔断器"></a>熔断器</h2><p>熔断器的原理很简单，如同电力过载保护器。它可以实现快速失败，如果它在一段时间内侦测到许多类似的错误，会强迫其以后的多个调用快速失败，不再访问远程服务器，从而防止应用程序不断地尝试执行可能会失败的操作，使得应用程序继续执行而不用等待修正错误，或者浪费CPU时间去等到长时间的超时产生。熔断器也可以使应用程序能够诊断错误是否已经修正，如果已经修正，应用程序会再次尝试调用操作。</p>
<p>熔断器模式就像是那些容易导致错误的操作的一种代理。这种代理能够记录最近调用发生错误的次数，然后决定使用允许操作继续，或者立即返回错误。 熔断器开关相互转换的逻辑如下图：<br><img src="https://img-blog.csdnimg.cn/20200506113439895.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>熔断器就是保护服务高可用的最后一道防线。</p>
<h2 id="Hystrix特性"><a href="#Hystrix特性" class="headerlink" title="Hystrix特性"></a>Hystrix特性</h2><p>在微服务架构中，服务与服务之间通过远程调用的方式进行通信，一旦某个被调用的服务发生了故障，其依赖服务也会发生故障，此时就会发生故障的蔓延，最终导致系统瘫痪。Hystrix实现了断路器模式，当某个服务发生故障时，通过断路器的监控，给调用方返回一个错误响应，而不是长时间的等待，这样就不会使得调用方由于长时间得不到响应而占用线程，从而防止故障的蔓延。Hystrix具备服务降级、服务熔断、线程隔离、请求缓存、请求合并及服务监控等强大功能。</p>
<p>1.断路器机制</p>
<p>断路器很好理解, 当Hystrix Command请求后端服务失败数量超过一定比例(默认50%), 断路器会切换到开路状态(Open). 这时所有请求会直接失败而不会发送到后端服务. 断路器保持在开路状态一段时间后(默认5秒), 自动切换到半开路状态(HALF-OPEN). 这时会判断下一次请求的返回情况, 如果请求成功, 断路器切回闭路状态(CLOSED), 否则重新切换到开路状态(OPEN). Hystrix的断路器就像我们家庭电路中的保险丝, 一旦后端服务不可用, 断路器会直接切断请求链, 避免发送大量无效请求影响系统吞吐量, 并且断路器有自我检测并恢复的能力.</p>
<p>2.Fallback</p>
<p>Fallback相当于是降级操作. 对于查询操作, 我们可以实现一个fallback方法, 当请求后端服务出现异常的时候, 可以使用fallback方法返回的值. fallback方法的返回值一般是设置的默认值或者来自缓存.</p>
<p>3.资源隔离</p>
<p>在Hystrix中, 主要通过线程池来实现资源隔离. 通常在使用的时候我们会根据调用的远程服务划分出多个线程池. 例如调用产品服务的Command放入A线程池, 调用账户服务的Command放入B线程池. 这样做的主要优点是运行环境被隔离开了. 这样就算调用服务的代码存在bug或者由于其他原因导致自己所在线程池被耗尽时, 不会对系统的其他服务造成影响. 但是带来的代价就是维护多个线程池会对系统带来额外的性能开销. 如果是对性能有严格要求而且确信自己调用服务的客户端代码不会出问题的话, 可以使用Hystrix的信号模式(Semaphores)来隔离资源.</p>
<h2 id="demo示例："><a href="#demo示例：" class="headerlink" title="demo示例："></a>demo示例：</h2><blockquote>
<p>技术点：Eureka、Ribbon、Hystrix</p>
</blockquote>
<h2 id="一、基于之前的Eureka注册中心"><a href="#一、基于之前的Eureka注册中心" class="headerlink" title="一、基于之前的Eureka注册中心"></a>一、基于之前的Eureka注册中心</h2><blockquote>
<p>参考第2章</p>
</blockquote>
<h2 id="二、Ribbon负载均衡"><a href="#二、Ribbon负载均衡" class="headerlink" title="二、Ribbon负载均衡"></a>二、Ribbon负载均衡</h2><blockquote>
<p>基于上一章所创建的Ribbon示例，作为服务提供者</p>
</blockquote>
<h2 id="三、Hystrix断路器"><a href="#三、Hystrix断路器" class="headerlink" title="三、Hystrix断路器"></a>三、Hystrix断路器</h2><blockquote>
<p>理论上可在上一章的基础上，对服务消费者模块进行更改整合，此处为加深学习，我们重新创建个模块作为新的消费者</p>
</blockquote>
<p>1、创建 hystrix-orcl-client-service 项目模块<br>2、pom文件中加入hystrix：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">  &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>3、配置文件–同上一章ribbon消费者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8401</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: ribbon-orcl-client-service</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: <span class="keyword">true</span></span><br><span class="line">    fetch-registry: <span class="keyword">true</span></span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//localhost:8001/eureka/</span></span><br><span class="line">      </span><br><span class="line">service-url:</span><br><span class="line">   dept-service: http:<span class="comment">//ribbon-orcl-server-service</span></span><br></pre></td></tr></table></figure>

<p>4、添加Ribbon初始化文件–同上一章ribbon消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonConfig</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@LoadBalanced</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、创建一个controller控制层 DeptController</p>
<blockquote>
<p>此处我们稍作调整：控制层去调用业务逻辑层service来实现功能，不再写在一个类中</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hystrix"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptController</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> DeptService deptService;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/dept/&#123;deptNo&#125;"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Result <span class="title">getDeptInfo</span><span class="params">(@PathVariable Integer deptNo)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> deptService.getDeptOne(deptNo);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6、创建一个业务逻辑层 DeptService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptService</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Value</span>(<span class="string">"$&#123;service-url.dept-service&#125;"</span>)</span><br><span class="line">	<span class="keyword">private</span> String deptServiceUrl;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Result <span class="title">getDeptOne</span><span class="params">(Integer deptNo)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> restTemplate.getForObject(deptServiceUrl + <span class="string">"/dept/&#123;deptNo&#125;"</span>, Result<span class="class">.<span class="keyword">class</span>, <span class="title">deptNo</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7、依次启动服务中心、服务提供者、服务消费者</p>
<p>8、页面访问，发现可以正常输出：<br><img src="https://img-blog.csdnimg.cn/20200507000827598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">9、此时我们可做如下模拟测试：</p>
<blockquote>
<p>9.1、输入一个数据库不存在的编号来访问<br>       <a href="http://localhost:8401/hystrix/dept/100" target="_blank" rel="noopener">http://localhost:8401/hystrix/dept/100</a></p>
</blockquote>
<blockquote>
<p>9.2、结束服务提供者的服务</p>
</blockquote>
<p>此时，我们能发现不管是第一种还是第二种测试下，页面在执行之后都会显示错误信息，后端控制台报错，并且服务停止。</p>
<p>那么有没有一种好的机制，当某个服务发生故障时，通过某种方式，给调用方返回一个错误响应，而不是长时间的等待，这样就不会使得调用方由于长时间得不到响应而占用线程，从而防止故障的蔓延呢？Hystrix。</p>
<p>10、更改消费者模块中的代码，使用Hystrix，完成 <strong>服务降级</strong><br>   10.1：改造DeptService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptService</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Value</span>(<span class="string">"$&#123;service-url.dept-service&#125;"</span>)</span><br><span class="line">	<span class="keyword">private</span> String deptServiceUrl;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"fallbackfail"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Result <span class="title">getDeptOne</span><span class="params">(Integer deptNo)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> restTemplate.getForObject(deptServiceUrl + <span class="string">"/dept/&#123;deptNo&#125;"</span>, Result<span class="class">.<span class="keyword">class</span>, <span class="title">deptNo</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 注意：声明的参数需要包含controller的声明参数</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> deptNo</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Result <span class="title">fallbackfail</span><span class="params">(@PathVariable Integer deptNo)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="string">"服务调用失败！"</span>, deptNo);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>10.2：启动文件启用Hystrix</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableCircuitBreaker</span><br><span class="line">@EnableEurekaClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class HystrixOrclClientServiceApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(HystrixOrclClientServiceApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>11、再次启动当前消费者模块<br>重复9.2步骤的测试：<br>11.1 地址栏输入<a href="http://localhost:8401/hystrix/dept/100" target="_blank" rel="noopener">http://localhost:8401/hystrix/dept/100</a> 时候，浏览器响应为：</p>
<p><img src="https://img-blog.csdnimg.cn/20200507002427583.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">11.2、再次在地址栏输入一个数据库存在的编号<br><a href="http://localhost:8401/hystrix/dept/1，发现又可以正常响应数据，服务没有宕机" target="_blank" rel="noopener">http://localhost:8401/hystrix/dept/1，发现又可以正常响应数据，服务没有宕机</a></p>
<p><img src="https://img-blog.csdnimg.cn/20200507002638615.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">11.3：停止服务提供方服务<br><img src="https://img-blog.csdnimg.cn/20200507002921758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">11.4：再次启动服务提供者服务,发现又可以正常响应数据，服务没有宕机</p>
<p><img src="https://img-blog.csdnimg.cn/20200507003134429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="HystrixCommand详解"><a href="#HystrixCommand详解" class="headerlink" title="@HystrixCommand详解"></a>@HystrixCommand详解</h2><h2 id="1、-HystrixCommand中的常用参数"><a href="#1、-HystrixCommand中的常用参数" class="headerlink" title="1、@HystrixCommand中的常用参数"></a>1、@HystrixCommand中的常用参数</h2><blockquote>
<p>fallbackMethod：指定服务降级处理方法；</p>
</blockquote>
<blockquote>
<p>  ignoreExceptions：忽略某些异常，不发生服务降级；</p>
</blockquote>
<blockquote>
<p>  commandKey：命令名称，用于区分不同的命令；</p>
</blockquote>
<blockquote>
<p>   groupKey：分组名称，Hystrix会根据不同的分组来统计命令的告警及仪<br>   表盘信息；</p>
</blockquote>
<blockquote>
<p>  threadPoolKey：线程池名称，用于划分线程池。</p>
</blockquote>
<p>在DeptService中改造代码实现功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptService</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Value</span>(<span class="string">"$&#123;service-url.dept-service&#125;"</span>)</span><br><span class="line">	<span class="keyword">private</span> String deptServiceUrl;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"fallbackfail"</span>, </span><br><span class="line">	commandKey = <span class="string">"getUserCommand"</span>, </span><br><span class="line">	groupKey = <span class="string">"getUserGroup"</span>, </span><br><span class="line">	threadPoolKey = <span class="string">"getUserThreadPool"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Result <span class="title">getDeptOne</span><span class="params">(Integer deptNo)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> restTemplate.getForObject(deptServiceUrl + <span class="string">"/dept/&#123;deptNo&#125;"</span>, Result<span class="class">.<span class="keyword">class</span>, <span class="title">deptNo</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 声明的参数需要包含controller的声明参数</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> deptNo</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Result <span class="title">fallbackfail</span><span class="params">(@PathVariable Integer deptNo)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="string">"服务调用失败！"</span>, deptNo);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、使用ignoreExceptions忽略某些异常降级"><a href="#2、使用ignoreExceptions忽略某些异常降级" class="headerlink" title="2、使用ignoreExceptions忽略某些异常降级"></a>2、使用ignoreExceptions忽略某些异常降级</h2><p>2.1 DeptController中添加请求方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/exception/&#123;deptNo&#125;"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Result <span class="title">getDeptInfoException</span><span class="params">(@PathVariable Integer deptNo)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> deptService.getDeptInfoException(deptNo);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>2.2：在DeptService中添加实现方法，这里忽略了NullPointerException，当id为100时抛出IndexOutOfBoundsException并服务降级，id为2时抛出NullPointerException忽略，不进行服务降级：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里忽略了NullPointerException，当id为100时抛出IndexOutOfBoundsException，id为2时抛出NullPointerException：</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> deptNo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"fallbackfailException"</span>, ignoreExceptions = &#123; NullPointerException<span class="class">.<span class="keyword">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">Result</span> <span class="title">getDeptInfoException</span>(<span class="title">Integer</span> <span class="title">deptNo</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (deptNo == <span class="number">100</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (deptNo == <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> restTemplate.getForObject(deptServiceUrl + <span class="string">"/dept/&#123;deptNo&#125;"</span>, Result<span class="class">.<span class="keyword">class</span>, <span class="title">deptNo</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">fallbackfailException</span><span class="params">(@PathVariable Integer deptNo, Throwable e)</span> </span>&#123;</span><br><span class="line">	LOGGER.error(<span class="string">"id &#123;&#125;,throwable class:&#123;&#125;"</span>, deptNo, e.getClass());</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="string">"服务调用失败"</span>, <span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.3 浏览器模拟请求 <a href="http://localhost:8401/hystrix/exception/100" target="_blank" rel="noopener">http://localhost:8401/hystrix/exception/100</a><br><img src="https://img-blog.csdnimg.cn/20200507183443919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">2.4 浏览器模拟请求 <a href="http://localhost:8401/hystrix/exception/2，发现服务未降级，异常忽略" target="_blank" rel="noopener">http://localhost:8401/hystrix/exception/2，发现服务未降级，异常忽略</a><br><img src="https://img-blog.csdnimg.cn/20200507183906231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="Hystrix缓存"><a href="#Hystrix缓存" class="headerlink" title="Hystrix缓存"></a>Hystrix缓存</h2><blockquote>
<p>当系统并发量越来越大时，可以考虑使用缓存来优化系统，达到减轻并发请求线程数，提高响应速度的效果</p>
</blockquote>
<p>主要使用以下几个注解完成：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@CacheResult：开启缓存，默认所有参数作为缓存的key，cacheKeyMethod可以通过返回String类型的方法指定key；</span><br><span class="line"></span><br><span class="line">@CacheKey：指定缓存的key，可以指定参数或指定参数中的属性值为缓存key，cacheKeyMethod还可以通过返回String类型的方法指定；</span><br><span class="line"></span><br><span class="line">@CacheRemove：移除缓存，需要指定commandKey。</span><br></pre></td></tr></table></figure>

<p>1、DeptController中添加请求方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 模拟缓存</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> deptNo</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/cache/&#123;deptNo&#125;"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Result <span class="title">getDeptInfoByCache</span><span class="params">(@PathVariable Integer deptNo)</span> </span>&#123;</span><br><span class="line">		HystrixRequestContext.initializeContext();<span class="comment">// 初始化请求上下文</span></span><br><span class="line"></span><br><span class="line">		deptService.getDeptInfoByCache(deptNo);</span><br><span class="line">		deptService.getDeptInfoByCache(deptNo);</span><br><span class="line">		deptService.getDeptInfoByCache(deptNo);</span><br><span class="line">		deptService.getDeptInfoByCache(deptNo);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="string">"操作成功"</span>, <span class="number">200</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>PS: </p>
<blockquote>
<p>HystrixRequestContext.initializeContext();// 初始化请求上下文</p>
</blockquote>
<p> 这只是测试环境下这样初始化，真正的web项目是在filter中进行初始化的（有两种方式：首先都要要实现filter重写其方法，一种是采用注解的方式@WebFilter，别忘了在启动类上添加@ServletComponentScan注解,另一种是Java代码注册的方式会用到FilterRegistrationBean这个类).</p>
<p>现在上下文初始化好了，不过这里有一个坑:我以为缓存对每次request请求都生效（当然前提是没有清除缓存），我每调用一次controller，下一次你再调用这个controller就会从缓存中取，我理解错了，并不是这样的，因为你每请求一次controller就会走一次filter，上下文又会初始化一次，前面缓存的就失效了，又得重新来。所以你要是想测试缓存，你得在一次controller请求中多次调用那个加了缓存的service或HystrixCommand命令，看来hystrix的请求缓存和redis等存储不一样。所以仔细它的定义：<strong>在同一用户请求的上下文中，相同依赖服务的返回数据始终保持一致。在当次请求内对同一个依赖进行重复调用，只会真实调用一次。在当次请求内数据可以保证一致性</strong>。我还是感觉有点鸡肋。<strong>后面会给出解决方案</strong>，下面先继续这个功能吧。</p>
<p>2、DeptService中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 模拟缓存</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> deptNo</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@CacheResult</span>(cacheKeyMethod = <span class="string">"getCacheKey"</span>)</span><br><span class="line">	<span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"fallbackfail"</span>, commandKey = <span class="string">"getDeptInfoByCache"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Result <span class="title">getDeptInfoByCache</span><span class="params">(Integer deptNo)</span> </span>&#123;</span><br><span class="line">		LOGGER.info(<span class="string">"getDeptInfoByCache deptNo:&#123;&#125;"</span>, deptNo);</span><br><span class="line">		<span class="keyword">return</span> restTemplate.getForObject(deptServiceUrl + <span class="string">"/dept/&#123;deptNo&#125;"</span>, Result<span class="class">.<span class="keyword">class</span>, <span class="title">deptNo</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 为缓存生成key的方法</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getCacheKey</span><span class="params">(Integer deptNo)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> String.valueOf(deptNo);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>3、浏览器访问 <a href="http://localhost:8401/hystrix/cache/1：" target="_blank" rel="noopener">http://localhost:8401/hystrix/cache/1：</a></p>
<p><img src="https://img-blog.csdnimg.cn/2020050719325916.png#pic_center" alt="在这里插入图片描述">从控制台中信息可发现：这个接口中调用了四次getDeptInfoByCache方法，但是只打印了一次日志，说明有三次走的是缓存</p>
<h2 id="移除缓存"><a href="#移除缓存" class="headerlink" title="移除缓存"></a>移除缓存</h2><p>1、改造DeptController </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 模拟缓存</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> deptNo</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/cache/&#123;deptNo&#125;"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Result <span class="title">getDeptInfoByCache</span><span class="params">(@PathVariable Integer deptNo)</span> </span>&#123;</span><br><span class="line">		HystrixRequestContext.initializeContext();<span class="comment">// 初始化请求上下文</span></span><br><span class="line"></span><br><span class="line">		deptService.getDeptInfoByCache(deptNo);</span><br><span class="line">		deptService.getDeptInfoByCache(deptNo);</span><br><span class="line">		deptService.removeCache(deptNo);<span class="comment">// 移除缓存</span></span><br><span class="line">		deptService.getDeptInfoByCache(deptNo);</span><br><span class="line">		deptService.getDeptInfoByCache(deptNo);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="string">"操作成功"</span>, <span class="number">200</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>2、DeptService 添加移除缓存方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span></span><br><span class="line">	<span class="meta">@CacheRemove</span>(commandKey = <span class="string">"getDeptInfoByCache"</span>, cacheKeyMethod = <span class="string">"getCacheKey"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Result <span class="title">removeCache</span><span class="params">(Integer deptNo)</span> </span>&#123;</span><br><span class="line">		LOGGER.info(<span class="string">"removeCache deptNo:&#123;&#125;"</span>, deptNo);</span><br><span class="line">		<span class="keyword">return</span> restTemplate.getForObject(deptServiceUrl + <span class="string">"/dept/&#123;deptNo&#125;"</span>, Result<span class="class">.<span class="keyword">class</span>, <span class="title">deptNo</span>)</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>3、访问 <a href="http://localhost:8401/hystrix/cache/1" target="_blank" rel="noopener">http://localhost:8401/hystrix/cache/1</a><br><img src="https://img-blog.csdnimg.cn/20200507194143535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="HystrixRequestContext进行初始化和关闭"><a href="#HystrixRequestContext进行初始化和关闭" class="headerlink" title="HystrixRequestContext进行初始化和关闭"></a>HystrixRequestContext进行初始化和关闭</h2><p>1、在缓存使用过程中，我们需要在每次使用缓存的请求前后对HystrixRequestContext进行初始化和关闭，否则会出现如下异常：</p>
<blockquote>
<p>Request caching is not available. Maybe you need to initialize the<br>HystrixRequestContext?</p>
</blockquote>
<p>2、这里我们通过使用过滤器，在每个请求前后初始化和关闭HystrixRequestContext来解决该问题，在模块中添加如下代码，不再使用<strong>HystrixRequestContext.initializeContext();</strong>// 初始化请求上下文：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@WebFilter</span>(urlPatterns = <span class="string">"/*"</span>, asyncSupported = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixRequestContextFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HystrixRequestContext context = HystrixRequestContext.initializeContext();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            context.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="请求合并"><a href="#请求合并" class="headerlink" title="请求合并"></a>请求合并</h2><blockquote>
<p>微服务系统中的服务间通信，需要通过远程调用来实现，随着调用次数越来越多，占用线程资源也会越来越多。<br>Hystrix中提供了@HystrixCollapser用于合并请求，从而达到减少通信消耗及线程数量的效果。</p>
</blockquote>
<p><strong>@HystrixCollapser的常用属性</strong></p>
<blockquote>
<pre><code>batchMethod：用于设置请求合并的方法

collapserProperties：请求合并属性，用于控制实例属性，有很多

timerDelayInMilliseconds：collapserProperties中的属性，用于控制每隔多少时间合并一次请求</code></pre></blockquote>
<p>1、DeptController 新增合并请求方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/queryByCollapser"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">queryByCollapser</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">	Future&lt;Dept&gt; future1 = deptService.getDeptInfo(<span class="number">1</span>);</span><br><span class="line">	Future&lt;Dept&gt; future2 = deptService.getDeptInfo(<span class="number">3</span>);</span><br><span class="line">	future1.get();</span><br><span class="line">	future2.get();</span><br><span class="line">	ThreadUtil.safeSleep(<span class="number">200</span>);</span><br><span class="line">	Future&lt;Dept&gt; future3 = deptService.getDeptInfo(<span class="number">6</span>);</span><br><span class="line">	future3.get();</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="string">"操作成功"</span>, <span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS: 使用到的 关键点：<br>1.1、Java中的<strong>Future</strong>  可参考学习 <a href="https://www.jianshu.com/p/b8952f07ee5d" target="_blank" rel="noopener">java中的Future</a></p>
<p>1.2、<strong>ThreadUtil.safeSleep</strong><br>pom文件中引入即可使用：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>2、DeptService 中新增方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用<span class="doctag">@HystrixCollapser</span>实现请求合并</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> deptNo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@HystrixCollapser</span>(batchMethod = <span class="string">"listDeptByDeptNos"</span>, collapserProperties = &#123;</span><br><span class="line">		<span class="meta">@HystrixProperty</span>(name = <span class="string">"timerDelayInMilliseconds"</span>, value = <span class="string">"100"</span>) &#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Dept&gt; <span class="title">getDeptInfo</span><span class="params">(Integer deptNo)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> AsyncResult&lt;Dept&gt;() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Dept <span class="title">invoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			Result result = restTemplate.getForObject(deptServiceUrl + <span class="string">"/dept/&#123;deptNo&#125;"</span>, Result<span class="class">.<span class="keyword">class</span>, <span class="title">deptNo</span>)</span>;</span><br><span class="line">			Map data = (Map) result.getData();</span><br><span class="line">			Dept dept = BeanUtil.mapToBean(data, Dept<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>)</span>;</span><br><span class="line">			LOGGER.info(<span class="string">"getDeptInfo deptName:&#123;&#125;"</span>, dept.getDeptName());</span><br><span class="line">			<span class="keyword">return</span> dept;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@HystrixCommand</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Dept&gt; <span class="title">listDeptByDeptNos</span><span class="params">(List&lt;Integer&gt; deptNos)</span> </span>&#123;</span><br><span class="line">	LOGGER.info(<span class="string">"listDeptByDeptNos:&#123;&#125;"</span>, deptNos);</span><br><span class="line">	Result result = restTemplate.getForObject(deptServiceUrl + <span class="string">"/dept/queryListByDeptNos?deptNos=&#123;1&#125;"</span>, Result<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line">			CollUtil.join(deptNos, ","));</span><br><span class="line">	<span class="keyword">return</span> (List&lt;Dept&gt;) result.getData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、执行  <a href="http://localhost:8401/hystrix/queryByCollapser后，控制台可发现" target="_blank" rel="noopener">http://localhost:8401/hystrix/queryByCollapser后，控制台可发现</a><br><img src="https://img-blog.csdnimg.cn/20200507233154962.png#pic_center" alt="在这里插入图片描述">由于我们设置了100毫秒进行一次请求合并，前两次被合并，最后一次自己单独合并。</p>
<h2 id="Hystrix的常用配置"><a href="#Hystrix的常用配置" class="headerlink" title="Hystrix的常用配置"></a>Hystrix的常用配置</h2><p>1、全局配置</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">hystrix:</span><br><span class="line">  command: #用于控制HystrixCommand的行为</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      execution:</span><br><span class="line">        isolation:</span><br><span class="line">          strategy: THREAD #控制HystrixCommand的隔离策略，THREAD-&gt;线程池隔离策略(默认)，SEMAPHORE-&gt;信号量隔离策略</span><br><span class="line">          thread:</span><br><span class="line">            timeoutInMilliseconds: 1000 #配置HystrixCommand执行的超时时间，执行超过该时间会进行服务降级处理</span><br><span class="line">            interruptOnTimeout: true #配置HystrixCommand执行超时的时候是否要中断</span><br><span class="line">            interruptOnCancel: true #配置HystrixCommand执行被取消的时候是否要中断</span><br><span class="line">          timeout:</span><br><span class="line">            enabled: true #配置HystrixCommand的执行是否启用超时时间</span><br><span class="line">          semaphore:</span><br><span class="line">            maxConcurrentRequests: 10 #当使用信号量隔离策略时，用来控制并发量的大小，超过该并发量的请求会被拒绝</span><br><span class="line">      fallback:</span><br><span class="line">        enabled: true #用于控制是否启用服务降级</span><br><span class="line">      circuitBreaker: #用于控制HystrixCircuitBreaker的行为</span><br><span class="line">        enabled: true #用于控制断路器是否跟踪健康状况以及熔断请求</span><br><span class="line">        requestVolumeThreshold: 20 #超过该请求数的请求会被拒绝</span><br><span class="line">        forceOpen: false #强制打开断路器，拒绝所有请求</span><br><span class="line">        forceClosed: false #强制关闭断路器，接收所有请求</span><br><span class="line">      requestCache:</span><br><span class="line">        enabled: true #用于控制是否开启请求缓存</span><br><span class="line">  collapser: #用于控制HystrixCollapser的执行行为</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      maxRequestsInBatch: 100 #控制一次合并请求合并的最大请求数</span><br><span class="line">      timerDelayinMilliseconds: 10 #控制多少毫秒内的请求会被合并成一个</span><br><span class="line">      requestCache:</span><br><span class="line">        enabled: true #控制合并请求是否开启缓存</span><br><span class="line">  threadpool: #用于控制HystrixCommand执行所在线程池的行为</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      coreSize: 10 #线程池的核心线程数</span><br><span class="line">      maximumSize: 10 #线程池的最大线程数，超过该线程数的请求会被拒绝</span><br><span class="line">      maxQueueSize: -1 #用于设置线程池的最大队列大小，-1采用SynchronousQueue，其他正数采用LinkedBlockingQueue</span><br><span class="line">      queueSizeRejectionThreshold: 5 #用于设置线程池队列的拒绝阀值，由于LinkedBlockingQueue不能动态改版大小，使用时需要用该参数来控制线程数</span><br></pre></td></tr></table></figure>

<p>2、实例配置</p>
<blockquote>
<p>实例配置只需要将全局配置中的default换成与之对应的key即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hystrix:</span><br><span class="line">  command:</span><br><span class="line">    HystrixComandKey: #将default换成HystrixComrnandKey</span><br><span class="line">      execution:</span><br><span class="line">        isolation:</span><br><span class="line">          strategy: THREAD</span><br><span class="line">  collapser:</span><br><span class="line">    HystrixCollapserKey: #将default换成HystrixCollapserKey</span><br><span class="line">      maxRequestsInBatch: <span class="number">100</span></span><br><span class="line">  threadpool:</span><br><span class="line">    HystrixThreadPoolKey: #将default换成HystrixThreadPoolKey</span><br><span class="line">      coreSize: <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>3、配置文件中相关key的说明</p>
<ul>
<li>HystrixComandKey对应@HystrixCommand中的commandKey属性；</li>
<li>HystrixCollapserKey对应@HystrixCollapser注解中的collapserKey属性；</li>
<li>HystrixThreadPoolKey对应@HystrixCommand中的threadPoolKey属性。</li>
</ul>
<h2 id="本章模块"><a href="#本章模块" class="headerlink" title="本章模块"></a>本章模块</h2><p>springcloud-learning<br>├── eureka-cloud-server – eureka注册中心<br>├── ribbon-orcl-server-service – 提供Dept对象CRUD接口的服务—提供者<br>└── hystrix-orcl-client-service – hystrix服务调用—-消费者</p>
<p><strong><a href="https://github.com/chfsun/springcloud-learning" target="_blank" rel="noopener">GitHub项目源码地址</a></strong></p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>cloud</tag>
        <tag>Hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud（05）之 Hystrix Dashboard与Turbine断路器监控</title>
    <url>/myblog/spring-cloud/Spring-Cloud%EF%BC%8805%EF%BC%89%E4%B9%8B-Hystrix-Dashboard%E4%B8%8ETurbine%E6%96%AD%E8%B7%AF%E5%99%A8%E7%9B%91%E6%8E%A7/</url>
    <content><![CDATA[<h2 id="Hystrix-Dashboard"><a href="#Hystrix-Dashboard" class="headerlink" title="Hystrix Dashboard"></a>Hystrix Dashboard</h2><p>Hystrix提供了Hystrix Dashboard来实时监控HystrixCommand方法的执行情况。 Hystrix Dashboard可以有效地反映出每个Hystrix实例的运行情况，帮助我们快速发现系统中的问题，从而采取对应措施。</p>
<a id="more"></a>
<h2 id="一、Hystrix-单个实例监控"><a href="#一、Hystrix-单个实例监控" class="headerlink" title="一、Hystrix 单个实例监控"></a>一、Hystrix 单个实例监控</h2><p>我们先通过使用Hystrix Dashboard监控单个Hystrix实例来了解下它的使用方法。</p>
<p>新建一个hystrix-dashboard模块</p>
<pre><code>用来监控hystrix实例的执行情况。</code></pre><p>1、pom.xml中添加相关依赖：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">dependency</span>&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;<span class="selector-tag">dependency</span>&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;<span class="selector-tag">dependency</span>&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2、application.yml配置文件：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">server</span>:</span><br><span class="line">  <span class="selector-tag">port</span>: 8501</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">spring</span>:</span><br><span class="line">  <span class="selector-tag">application</span>:</span><br><span class="line">    <span class="selector-tag">name</span>: <span class="selector-tag">hystrix-dashboard</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">eureka</span>:</span><br><span class="line">  <span class="selector-tag">client</span>:</span><br><span class="line">    <span class="selector-tag">register-with-eureka</span>: <span class="selector-tag">true</span></span><br><span class="line">    <span class="selector-tag">fetch-registry</span>: <span class="selector-tag">true</span></span><br><span class="line">    <span class="selector-tag">service-url</span>:</span><br><span class="line">      defaultZone: http://localhost:8001/eureka/</span><br></pre></td></tr></table></figure>

<p>3、在启动类上添加@EnableHystrixDashboard来启用监控功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixDashboardApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(HystrixDashboardApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、依次启动相关服务后访问注册中心可看到相应服务：</p>
<p><img src="https://img-blog.csdnimg.cn/20200507235207831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="Hystrix实例监控演示"><a href="#Hystrix实例监控演示" class="headerlink" title="Hystrix实例监控演示"></a>Hystrix实例监控演示</h2><p>1、访问Hystrix Dashboard：<a href="http://localhost:8501/hystrix" target="_blank" rel="noopener">http://localhost:8501/hystrix</a></p>
<p><img src="https://img-blog.csdnimg.cn/2020050723533779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">2、图中会有一些提示：</p>
<blockquote>
<p>Cluster via Turbine (default cluster):<br><a href="http://turbine-hostname:port/turbine.stream">http://turbine-hostname:port/turbine.stream</a> Cluster via Turbine<br>(custom cluster):<br><a href="http://turbine-hostname:port/turbine.stream?cluster=[clusterName]">http://turbine-hostname:port/turbine.stream?cluster=[clusterName]</a><br>Single Hystrix App: <a href="http://hystrix-app:port/hystrix.stream">http://hystrix-app:port/hystrix.stream</a></p>
</blockquote>
<p><strong>大概意思就是如果查看默认集群使用第一个url,查看指定集群使用第二个url,单个应用的监控使用最后一个</strong>，我们暂时只演示单个应用的</p>
<p>3、<strong>还有一点值得注意</strong>的是，<br>3.1 被监控的服务需要开启Actuator的hystrix.stream端点，配置信息如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        #暴露hystrix监控端点</span><br><span class="line">        include: <span class="string">'hystrix.stream'</span></span><br></pre></td></tr></table></figure>
<p>3.2 坑点，我在备课时遇到了hystrix dashboard Unable to connect to Command Metric Stream的问题，折腾了好久，翻看源码才发现：</p>
<p><img src="https://img-blog.csdnimg.cn/20200508223628498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">被监控的服务同时还需要实例化HystrixMetricsStreamServlet、ServletRegistrationBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">getServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	HystrixMetricsStreamServlet streamServlet = <span class="keyword">new</span> HystrixMetricsStreamServlet();</span><br><span class="line">	ServletRegistrationBean registrationBean = <span class="keyword">new</span> ServletRegistrationBean(streamServlet);</span><br><span class="line">	registrationBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">	registrationBean.addUrlMappings(<span class="string">"/actuator/hystrix.stream"</span>);</span><br><span class="line">	registrationBean.setName(<span class="string">"HystrixMetricsStreamServlet"</span>);</span><br><span class="line">	<span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、填写 <a href="http://localhost:8401/actuator/hystrix.stream" target="_blank" rel="noopener">http://localhost:8401/actuator/hystrix.stream</a> 信息后点击监控按钮，这里我们需要<strong>注意</strong>的是：由于我们本地不支持https，所以我们的地址需要填入的是http，否则会无法获取监控信息；<br><img src="https://img-blog.csdnimg.cn/2020050822473061.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>5、填写好信息后，点击下方Monitor Steam 按钮进入监控界面：<br><img src="https://img-blog.csdnimg.cn/20200508224200657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>初始界面一切数据为零，调用几次hystrix-orcl-client-service的接口后：</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200508225326167.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">可以发现曾经我们在@HystrixCommand中添加的commandKey和threadPoolKey属性都显示在上面了，而执行有6次调用都成功了。</p>
<h2 id="Hystrix-Dashboard-图表解读"><a href="#Hystrix-Dashboard-图表解读" class="headerlink" title="Hystrix Dashboard 图表解读"></a>Hystrix Dashboard 图表解读</h2><p><img src="https://img-blog.csdnimg.cn/20200508230814570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="二、Hystrix-集群实例监控"><a href="#二、Hystrix-集群实例监控" class="headerlink" title="二、Hystrix 集群实例监控"></a>二、Hystrix 集群实例监控</h2><blockquote>
<p>这里我们使用Turbine来聚合hystrix -turbine-service服务的监控信息，然后我们的hystrix-dashboard服务就可以从Turbine获取聚合好的监控信息展示给我们了。</p>
</blockquote>
<p>1、创建一个hystrix-turbine-service模块</p>
<blockquote>
<p>用来聚合hystrix-orcl-client-service的监控信息。</p>
</blockquote>
<p>2、pom文件相关依赖</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-netflix-turbine&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>3、application.yml配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8601</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: hystrix-turbine-service</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: <span class="keyword">true</span></span><br><span class="line">    fetch-registry: <span class="keyword">true</span></span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//localhost:8001/eureka/</span></span><br><span class="line"></span><br><span class="line">turbine:</span><br><span class="line">  # 指定需要收集信息的服务名称</span><br><span class="line">  app-config: hystrix-orcl-client-service</span><br><span class="line">  # 指定服务所属集群</span><br><span class="line">  cluster-name-expression: <span class="keyword">new</span> String(<span class="string">'default'</span>)</span><br><span class="line">  # 以主机名和端口号区分服务</span><br><span class="line">  combine-host-port: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>4、启动类设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableTurbine</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixTurbineServiceApplication</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(HystrixTurbineServiceApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、使用application-r1.yml、application-r2.yml配置再启动一个hystrix-orcl-client-service服务。依次启动相关服务(实在分不清就按端口号由小到大顺序启动)：</p>
<blockquote>
<p>注册中心、服务提供者、服务消费者、实例监控、集群实例监控</p>
</blockquote>
<p>此时注册中心显示如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200509215209515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>6、查看Hystrix集群</p>
<p>  6.1、访问Hystrix Dashboard：<a href="http://localhost:8501/hystrix" target="_blank" rel="noopener">http://localhost:8501/hystrix</a></p>
<p><img src="https://img-blog.csdnimg.cn/20200509220152855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">6.2、设置好后点击按钮进入监控界面：<br><img src="https://img-blog.csdnimg.cn/20200509220341294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">此时为loading，等待监控信息状态</p>
<p>6.3、调用几次hystrix-orcl-client-service的2个不同端口的接口。再次查看界面，可发现Hystrix实例数量变成了两个：</p>
<blockquote>
<p>例如：<br><a href="http://localhost:8401/hystrix/dept/1" target="_blank" rel="noopener">http://localhost:8401/hystrix/dept/1</a><br>以及<a href="http://localhost:8402/hystrix/dept/1" target="_blank" rel="noopener">http://localhost:8402/hystrix/dept/1</a></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200509220925823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="三、本章示例模块"><a href="#三、本章示例模块" class="headerlink" title="三、本章示例模块"></a>三、本章示例模块</h2><p>springcloud-learning<br>├── eureka-cloud-server – eureka注册中心<br>├── ribbon-orcl-server-service – 服务提供者<br>├── hystrix-orcl-client-service – 服务消费者<br>├── hystrix-dashboard – 展示hystrix实例监控信息的仪表盘<br>└── hystrix-turbine-service – 聚合收集hystrix实例监控信息的服务</p>
<p><strong><a href="https://github.com/chfsun/springcloud-learning" target="_blank" rel="noopener">GitHub项目源码地址</a></strong></p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>cloud</tag>
        <tag>Hystrix</tag>
        <tag>Dashboard</tag>
        <tag>turbine</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud（07）之 Zuul服务网关</title>
    <url>/myblog/spring-cloud/Spring-Cloud%EF%BC%8807%EF%BC%89%E4%B9%8B-Zuul%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3/</url>
    <content><![CDATA[<h2 id="一、Zuul简介"><a href="#一、Zuul简介" class="headerlink" title="一、Zuul简介"></a>一、Zuul简介</h2><p>Spring Cloud Zuul 是Spring Cloud Netflix 子项目的核心组件之一，可以作为微服务架构中的API网关使用，支持动态路由与过滤功能。</p>
<a id="more"></a>
<p>API网关为微服务架构中的服务提供了统一的访问入口，客户端通过API网关访问相关服务。API网关的定义类似于设计模式中的门面模式，它相当于整个微服务架构中的门面，所有客户端的访问都通过它来进行路由及过滤。它实现了请求路由、负载均衡、校验过滤、服务容错、服务聚合等功能。</p>
<h2 id="二、示例Demo"><a href="#二、示例Demo" class="headerlink" title="二、示例Demo"></a>二、示例Demo</h2><blockquote>
<p>路由功能负责将外部请求转发到具体的服务实例上去，是实现统一访问入口的基础</p>
</blockquote>
<p><strong>1、新建zuul-orcl-proxy模块</strong></p>
<blockquote>
<p>使用当前模块来路由到其它服务提供者或者服务消费者</p>
</blockquote>
<p>2、pom文件：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>3、配置文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8801</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: zuul-orcl-proxy</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: <span class="keyword">true</span></span><br><span class="line">    fetch-registry: <span class="keyword">true</span></span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//localhost:8001/eureka/</span></span><br></pre></td></tr></table></figure>
<p>4、配置文件中路由规则设置：</p>
<blockquote>
<p>路由设置可分为：指定路由规则和默认路由规则：</p>
</blockquote>
<blockquote>
<p>1、指定路由规则<br>我们可以通过修改application.yml中的配置来配置路由规则，这里我们将匹配/hystrixClient/<strong>的请求路由到hystrix-orcl-client-service服务上去，匹配/feignService/</strong>的请求路由到feign-service上去。</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">zuul</span>:</span><br><span class="line">  <span class="selector-tag">routes</span>:</span><br><span class="line">    # 给服务配置路由</span><br><span class="line">    <span class="selector-tag">hystrix-orcl-client-service</span>:</span><br><span class="line">      path: /hystrixClient/**</span><br><span class="line">    <span class="selector-tag">feign-service</span>:</span><br><span class="line">      path: /feignService/**</span><br></pre></td></tr></table></figure>
<blockquote>
<p>2、默认路由规则：<br>Zuul和Eureka结合使用，可以实现路由的自动配置，自动配置的路由以服务名称为匹配路径，相当于如下配置</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">zuul</span>:</span><br><span class="line">  <span class="selector-tag">routes</span>:</span><br><span class="line">    # 给服务配置路由</span><br><span class="line">    <span class="selector-tag">hystrix-orcl-client-service</span>:</span><br><span class="line">      path: /hystrix-orcl-client-service/**</span><br><span class="line">    <span class="selector-tag">feign-service</span>:</span><br><span class="line">      path: /feign-service/**</span><br></pre></td></tr></table></figure>
<blockquote>
<p>3、如果不想使用默认的路由规则，可以添加以下配置来忽略默认路由配置：</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">zuul</span>:</span><br><span class="line">  #关闭默认路由配置</span><br><span class="line">  <span class="selector-tag">ignored-services</span>: <span class="selector-tag">hystrix-orcl-client-service</span>,<span class="selector-tag">feign-service</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>4、配置访问前缀<br>可以通过以下配置来给网关路径添加前缀，假定添加了/proxy前缀，这样我们需要访问<a href="http://localhost:8801/proxy/hystrix-orcl-client-service/hystrix/dept/1才能访问到hystrix-orcl-client-service中的接口。" target="_blank" rel="noopener">http://localhost:8801/proxy/hystrix-orcl-client-service/hystrix/dept/1才能访问到hystrix-orcl-client-service中的接口。</a></p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">zuul</span>:</span><br><span class="line">  #给网关路由添加前缀</span><br><span class="line">  prefix: /proxy</span><br></pre></td></tr></table></figure>
<blockquote>
<p>5、Header过滤及重定向添加Host:<br>Zuul在请求路由时，默认会过滤掉一些敏感的头信息，以下配置可以防止路由时的Cookie及Authorization的丢失：</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">zuul</span>:</span><br><span class="line">  #配置过滤敏感的请求头信息，设置为空就不会过滤</span><br><span class="line">  <span class="selector-tag">sensitive-headers</span>: <span class="selector-tag">Cookie</span>,<span class="selector-tag">Set-Cookie</span>,<span class="selector-tag">Authorization</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>6、Zuul在请求路由时，不会设置最初的host头信息，以下配置可以解决：</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">zuul</span>:</span><br><span class="line">  #设置为<span class="selector-tag">true</span>重定向是会添加<span class="selector-tag">host</span>请求头</span><br><span class="line">  <span class="selector-tag">add-host-header</span>: <span class="selector-tag">true</span></span><br></pre></td></tr></table></figure>


<p>5、启动类上添加 @EnableZuulProxy 注解来启用Zuul的API网关功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulOrclProxyApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(ZuulOrclProxyApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6、依次启动相关服务后：<br><img src="https://img-blog.csdnimg.cn/20200512194739131.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">7、路由测试：</p>
<p>访问<a href="http://localhost:8801/hystrixClient/hystrix/dept/6可以发现请求路由到了hystrix-orcl-client-service上了；" target="_blank" rel="noopener">http://localhost:8801/hystrixClient/hystrix/dept/6可以发现请求路由到了hystrix-orcl-client-service上了；</a></p>
<p>访问<a href="http://localhost:8801/feignService/feign/1可以发现请求路由到了feign-service上了。" target="_blank" rel="noopener">http://localhost:8801/feignService/feign/1可以发现请求路由到了feign-service上了。</a></p>
<p>8、查看Hystrix实例监控信息：<br><img src="https://img-blog.csdnimg.cn/20200512201253322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="三、SpringBoot-Actuator查看路由信息"><a href="#三、SpringBoot-Actuator查看路由信息" class="headerlink" title="三、SpringBoot Actuator查看路由信息"></a>三、SpringBoot Actuator查看路由信息</h2><p>1、pom.xml中添加相关依赖：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">dependency</span>&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2、application.yaml配置文件，开启查看路由的端点：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">management</span>:</span><br><span class="line">  <span class="selector-tag">endpoints</span>:</span><br><span class="line">    <span class="selector-tag">web</span>:</span><br><span class="line">      <span class="selector-tag">exposure</span>:</span><br><span class="line">        include: 'routes'</span><br></pre></td></tr></table></figure>
<p>3、通过访问<a href="http://localhost:8801/actuator/routes查看简单路由信息：" target="_blank" rel="noopener">http://localhost:8801/actuator/routes查看简单路由信息：</a><br><img src="https://img-blog.csdnimg.cn/20200512203402771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">4、通过访问<a href="http://localhost:8801/actuator/routes/details查看详细路由信息：" target="_blank" rel="noopener">http://localhost:8801/actuator/routes/details查看详细路由信息：</a><br><img src="https://img-blog.csdnimg.cn/20200512203513859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="四、Zuul过滤器"><a href="#四、Zuul过滤器" class="headerlink" title="四、Zuul过滤器"></a>四、Zuul过滤器</h2><blockquote>
<p>路由与过滤是Zuul的两大核心功能，路由功能负责将外部请求转发到具体的服务实例上去，是实现统一访问入口的基础，过滤功能负责对请求过程进行额外的处理，是请求校验过滤及服务聚合的基础。</p>
</blockquote>
<p>1、典型的过滤器类型</p>
<blockquote>
<p>   1、pre：在请求被路由到目标服务前执行，比如权限校验、打印日志等功能；</p>
</blockquote>
<blockquote>
<p>  2、 routing：在请求被路由到目标服务时执行，这是使用Apache HttpClient或Netflix Ribbon构建和发送原始HTTP请求的地方；</p>
</blockquote>
<blockquote>
<p>   3、post：在请求被路由到目标服务后执行，比如给目标服务的响应添加头信息，收集统计数据等功能；</p>
</blockquote>
<blockquote>
<p>   4、error：请求在其他阶段发生错误时执行;</p>
</blockquote>
<p>2、过滤器的生命周期：<br><img src="https://img-blog.csdnimg.cn/20200512204913798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>3、自定义过滤器</p>
<p>3.1、 新建一个PreLogFilter类继承ZuulFilter</p>
<blockquote>
<p>这是一个前置过滤器，用于在请求路由到目标服务前打印请求日志</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreLogFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(PreLogFilter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 指定过滤器类型 可选pre、routing、post、error四种。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"pre"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 过滤器执行顺序，数值越小优先级越高。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 是否进行过滤，返回true会执行过滤。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 自定义的过滤器逻辑，当shouldFilter()返回true时会执行。 模拟一个登录过滤</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">		RequestContext currentContext = RequestContext.getCurrentContext();</span><br><span class="line">		HttpServletRequest request = currentContext.getRequest();</span><br><span class="line"></span><br><span class="line">		String remoteHost = request.getRemoteHost();</span><br><span class="line">		String method = request.getMethod();</span><br><span class="line">		String requestURI = request.getRequestURI();</span><br><span class="line"></span><br><span class="line">		LOGGER.info(<span class="string">"Remote host:&#123;&#125;,method:&#123;&#125;,uri:&#123;&#125;"</span>, remoteHost, method, requestURI);</span><br><span class="line">		String name = request.getParameter(<span class="string">"name"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (StringUtils.isNotEmpty(name) &amp;&amp; name.equals(<span class="string">"chfsun"</span>)) &#123;</span><br><span class="line">			currentContext.setSendZuulResponse(<span class="keyword">true</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			currentContext.setSendZuulResponse(<span class="keyword">false</span>);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				HttpServletResponse res = currentContext.getResponse();</span><br><span class="line">				res.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">				res.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">				res.getWriter().write(<span class="string">"用户校验不通过！！！"</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>覆盖方法解释：</p>
<p>   filterType：返回过滤器的类型。有pre、route、post、error等几种取值，分别对应上文的几种过滤器。详细可以参考com.netflix.zuul.ZuulFilter.filterType()中的注释。</p>
<p>   filterOrder：返回一个int值来指定过滤器的执行顺序，不同的过滤器允许返回相同的数字。</p>
<p>   shouldFilter：返回一个boolean值来判断该过滤器是否要执行，true表示执行，false表示不执行</p>
<p>   run：过滤器的具体逻辑</p>
<p>3.2、功能测试：</p>
<p>添加过滤器后，我们访问 <a href="http://localhost:8801/hystrixClient/hystrix/dept/6" target="_blank" rel="noopener">http://localhost:8801/hystrixClient/hystrix/dept/6</a>测试下，会打印如下日志信息：</p>
<p><img src="https://img-blog.csdnimg.cn/20200512205811634.png#pic_center" alt="在这里插入图片描述">浏览器中在name验证错误时：<br><img src="https://img-blog.csdnimg.cn/20200513001759643.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">输入一个正确name后：<br><img src="https://img-blog.csdnimg.cn/20200513001823829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>4、禁用过滤器</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">zuul</span>:</span><br><span class="line">  <span class="selector-tag">filterClassName</span>:</span><br><span class="line">    <span class="selector-tag">filter</span>:</span><br><span class="line">      <span class="selector-tag">disable</span>: <span class="selector-tag">true</span></span><br></pre></td></tr></table></figure>

<p>例如：禁用PreLogFilter的示例配置：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">zuul</span>:</span><br><span class="line">  <span class="selector-tag">PreLogFilter</span>:</span><br><span class="line">    <span class="selector-tag">pre</span>:</span><br><span class="line">      <span class="selector-tag">disable</span>: <span class="selector-tag">true</span></span><br></pre></td></tr></table></figure>

<h2 id="五、Ribbon和Hystrix的支持"><a href="#五、Ribbon和Hystrix的支持" class="headerlink" title="五、Ribbon和Hystrix的支持"></a>五、Ribbon和Hystrix的支持</h2><blockquote>
<p>由于Zuul自动集成了Ribbon和Hystrix，所以Zuul天生就有负载均衡和服务容错能力，我们可以通过Ribbon和Hystrix的配置来配置Zuul中的相应功能。</p>
</blockquote>
<ul>
<li>可以使用Hystrix的配置来设置路由转发时HystrixCommand的执行超时时间：</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">hystrix</span>:</span><br><span class="line">  # 用于控制<span class="selector-tag">HystrixCommand</span>的行为</span><br><span class="line">  <span class="selector-tag">command</span>:</span><br><span class="line">    <span class="selector-tag">default</span>:</span><br><span class="line">      <span class="selector-tag">execution</span>:</span><br><span class="line">        <span class="selector-tag">isolation</span>:</span><br><span class="line">          <span class="selector-tag">thread</span>:</span><br><span class="line">            # 配置<span class="selector-tag">HystrixCommand</span>执行的超时时间，执行超过该时间会进行服务降级处理</span><br><span class="line">            <span class="selector-tag">timeoutInMilliseconds</span>: 1000</span><br></pre></td></tr></table></figure>


<ul>
<li>可以使用Ribbon的配置来设置路由转发时请求连接及处理的超时时间：</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ribbon</span>:</span><br><span class="line">  # 服务请求连接超时时间（毫秒）</span><br><span class="line">  <span class="selector-tag">ConnectTimeout</span>: 1000</span><br><span class="line">  # 服务请求处理超时时间（毫秒）</span><br><span class="line">  <span class="selector-tag">ReadTimeout</span>: 3000</span><br></pre></td></tr></table></figure>

<h2 id="六、Zull常用配置"><a href="#六、Zull常用配置" class="headerlink" title="六、Zull常用配置"></a>六、Zull常用配置</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">zuul</span>:</span><br><span class="line">  <span class="selector-tag">routes</span>: #给服务配置路由</span><br><span class="line">    <span class="selector-tag">hystrix-orcl-client-service</span>:</span><br><span class="line">      path: /hystrixClient/**</span><br><span class="line">    <span class="selector-tag">feign-service</span>:</span><br><span class="line">      path: /feignService/**</span><br><span class="line">  <span class="selector-tag">ignored-services</span>: <span class="selector-tag">hystrix-orcl-client-service</span>,<span class="selector-tag">feign-service</span> #关闭默认路由配置</span><br><span class="line">  prefix: /proxy #给网关路由添加前缀</span><br><span class="line">  <span class="selector-tag">sensitive-headers</span>: <span class="selector-tag">Cookie</span>,<span class="selector-tag">Set-Cookie</span>,<span class="selector-tag">Authorization</span> #配置过滤敏感的请求头信息，设置为空就不会过滤</span><br><span class="line">  <span class="selector-tag">add-host-header</span>: <span class="selector-tag">true</span> #设置为<span class="selector-tag">true</span>重定向是会添加<span class="selector-tag">host</span>请求头</span><br><span class="line">  <span class="selector-tag">retryable</span>: <span class="selector-tag">true</span> # 关闭重试机制</span><br><span class="line">  <span class="selector-tag">PreLogFilter</span>:</span><br><span class="line">    <span class="selector-tag">pre</span>:</span><br><span class="line">      <span class="selector-tag">disable</span>: <span class="selector-tag">false</span> #控制是否启用过滤器</span><br></pre></td></tr></table></figure>

<h2 id="七、本章示例使用到的模块"><a href="#七、本章示例使用到的模块" class="headerlink" title="七、本章示例使用到的模块"></a>七、本章示例使用到的模块</h2><p>springcloud-learning<br>├── eureka-server – eureka注册中心<br>├── ribbon-orcl-server-service – 服务提供者<br>├── feign-service – 服务消费者<br>└── zuul-orcl-proxy – 作为路由网关的zuul</p>
<p><strong><a href="https://github.com/chfsun/springcloud-learning" target="_blank" rel="noopener">GitHub项目源码地址</a></strong></p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>cloud</tag>
        <tag>Zuul</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud（06）之 OpenFeign服务消费者</title>
    <url>/myblog/spring-cloud/Spring-Cloud%EF%BC%8806%EF%BC%89%E4%B9%8B-OpenFeign%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85/</url>
    <content><![CDATA[<h2 id="Feign简介"><a href="#Feign简介" class="headerlink" title="Feign简介"></a>Feign简介</h2><p>Spring Cloud OpenFeign 是声明式的服务调用工具，它整合了Ribbon和Hystrix，拥有负载均衡和服务容错功能。</p>
<a id="more"></a>
<p>Feign是声明式的服务调用工具，我们只需创建一个接口并用注解的方式来配置它，就可以实现对某个服务接口的调用，简化了直接使用RestTemplate来调用服务接口的开发量。Feign具备可插拔的注解支持，同时支持Feign注解、JAX-RS注解及SpringMvc注解。当使用Feign时，Spring Cloud集成了Ribbon和Eureka以提供负载均衡的服务调用及基于Hystrix的服务容错保护功能。</p>
<h2 id="模块Demo"><a href="#模块Demo" class="headerlink" title="模块Demo"></a>模块Demo</h2><h2 id="一、创建一个-feign-service-模块"><a href="#一、创建一个-feign-service-模块" class="headerlink" title="一、创建一个 feign-service 模块"></a>一、创建一个 feign-service 模块</h2><blockquote>
<p>通过feign-service模块作为消费者，来调用提供者的接口</p>
</blockquote>
<p>1、pom文件：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">      &lt;<span class="selector-tag">dependency</span>&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;<span class="selector-tag">dependency</span>&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;<span class="selector-tag">dependency</span>&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2、配置文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8701</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: feign-service</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: <span class="keyword">true</span></span><br><span class="line">    fetch-registry: <span class="keyword">true</span></span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//localhost:8001/eureka/</span></span><br></pre></td></tr></table></figure>

<p>3、创建一个service接口，通过协议来调用提供者的服务：</p>
<blockquote>
<p>不需要配置文件通过service-url.dept-service: <a href="http://ribbon-orcl-server-service这种形式。" target="_blank" rel="noopener">http://ribbon-orcl-server-service这种形式。</a><br>通过@FeignClient 注解实现了一个Feign客户端，其中的value值为：ribbon-orcl-server-service 表示这是对ribbon-orcl-server-service服务的接口调用。</p>
</blockquote>
<blockquote>
<p>接口代码为调用的提供者的controller控制层代码，只需将其改为接口，保留原来的SpringMvc注解即可，此处需要注意控制层的命名空间，必须加上不然会出现报错异常，访问不到提供者的接口方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"ribbon-orcl-server-service"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DeptService</span> </span>&#123;</span><br><span class="line">	<span class="meta">@PostMapping</span>(<span class="string">"/dept/insert"</span>)</span><br><span class="line">	<span class="function">Result <span class="title">insert</span><span class="params">(@RequestBody Dept dept)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/dept/&#123;deptNo&#125;"</span>)</span><br><span class="line">	<span class="function">Result&lt;Dept&gt; <span class="title">getDept</span><span class="params">(@PathVariable Integer deptNo)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/dept/listDept"</span>)</span><br><span class="line">	Result&lt;List&lt;Dept&gt;&gt; listDept();</span><br><span class="line"></span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/dept/queryListByDeptNos"</span>)</span><br><span class="line">	Result&lt;List&lt;Dept&gt;&gt; queryListByDeptNos(<span class="meta">@RequestParam</span> List&lt;Integer&gt; deptNos);</span><br><span class="line"></span><br><span class="line">	<span class="meta">@PostMapping</span>(<span class="string">"/dept/update"</span>)</span><br><span class="line">	<span class="function">Result <span class="title">update</span><span class="params">(@RequestBody Dept dept)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@PostMapping</span>(<span class="string">"/dept/delete/&#123;deptNo&#125;"</span>)</span><br><span class="line">	<span class="function">Result <span class="title">delete</span><span class="params">(@PathVariable Integer deptNo)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、DeptFeignController 控制层：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/feign"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptFeignController</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> DeptService deptService;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@PostMapping</span>(<span class="string">"/insert"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Result <span class="title">insert</span><span class="params">(@RequestBody Dept dept)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> deptService.insert(dept);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/&#123;deptNo&#125;"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Result&lt;Dept&gt; <span class="title">getDept</span><span class="params">(@PathVariable Integer deptNo)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> deptService.getDept(deptNo);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/listDept"</span>)</span><br><span class="line">	<span class="keyword">public</span> Result&lt;List&lt;Dept&gt;&gt; listDept() &#123;</span><br><span class="line">		<span class="keyword">return</span> deptService.listDept();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/queryListByDeptNos"</span>)</span><br><span class="line">	<span class="keyword">public</span> Result&lt;List&lt;Dept&gt;&gt; queryListByDeptNos(<span class="meta">@RequestParam</span> List&lt;Integer&gt; deptNos) &#123;</span><br><span class="line">		<span class="keyword">return</span> deptService.queryListByDeptNos(deptNos);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@PostMapping</span>(<span class="string">"/update"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Result <span class="title">update</span><span class="params">(@RequestBody Dept dept)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> deptService.update(dept);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@PostMapping</span>(<span class="string">"/delete/&#123;deptNo&#125;"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Result <span class="title">delete</span><span class="params">(@PathVariable Integer deptNo)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> deptService.delete(deptNo);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、启动类上添加@EnableFeignClients注解来启用Feign的客户端功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignServiceApplication</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(FeignServiceApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6、依次启动注册中心、服务提供者的集群、消费者：</p>
<p><img src="https://img-blog.csdnimg.cn/20200511225619751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">7、负载均衡测试：</p>
<blockquote>
<p>多次调用 localhost:8701/feign/1 进行测试，可以发现运行在8201和8202的提供者服务交替打印如下信息：</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200511225914852.png#pic_center" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200511225923144.png#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>和hystrix一样实现了负载均衡效果</p>
</blockquote>
<h2 id="二、Feign中的实现服务降级"><a href="#二、Feign中的实现服务降级" class="headerlink" title="二、Feign中的实现服务降级"></a>二、Feign中的实现服务降级</h2><blockquote>
<p>Feign中的服务降级使用起来非常方便，只需要为Feign客户端定义的接口添加一个服务降级处理的实现类即可，下面我们为DeptService接口添加一个服务降级实现类。</p>
</blockquote>
<p>1、新建类DeptFallbackService：</p>
<blockquote>
<p>此处仅做演示用，因此服务降级信息未做更多考虑</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptFallbackService</span> <span class="keyword">implements</span> <span class="title">DeptService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Result <span class="title">insert</span><span class="params">(Dept dept)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="string">"调用失败，服务被降级"</span>, <span class="number">500</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Result&lt;Dept&gt; <span class="title">getDept</span><span class="params">(Integer deptNo)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="string">"调用失败，服务被降级"</span>, <span class="number">500</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Result&lt;List&lt;Dept&gt;&gt; listDept() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="string">"调用失败，服务被降级"</span>, <span class="number">500</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Result&lt;List&lt;Dept&gt;&gt; queryListByDeptNos(List&lt;Integer&gt; deptNos) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="string">"调用失败，服务被降级"</span>, <span class="number">500</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Result <span class="title">update</span><span class="params">(Dept dept)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="string">"调用失败，服务被降级"</span>, <span class="number">500</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Result <span class="title">delete</span><span class="params">(Integer deptNo)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="string">"调用失败，服务被降级"</span>, <span class="number">500</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、更改DeptService类，在@FeignClient注解中添加fallback信息,设置异常情况下服务降级处理类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"ribbon-orcl-server-service"</span>, fallback = DeptFallbackService<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">DeptService</span> </span>&#123;</span><br><span class="line">	<span class="meta">@PostMapping</span>(<span class="string">"/dept/insert"</span>)</span><br><span class="line">	<span class="function">Result <span class="title">insert</span><span class="params">(@RequestBody Dept dept)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/dept/&#123;deptNo&#125;"</span>)</span><br><span class="line">	<span class="function">Result&lt;Dept&gt; <span class="title">getDept</span><span class="params">(@PathVariable Integer deptNo)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/dept/listDept"</span>)</span><br><span class="line">	Result&lt;List&lt;Dept&gt;&gt; listDept();</span><br><span class="line"></span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/dept/queryListByDeptNos"</span>)</span><br><span class="line">	Result&lt;List&lt;Dept&gt;&gt; queryListByDeptNos(<span class="meta">@RequestParam</span> List&lt;Integer&gt; deptNos);</span><br><span class="line"></span><br><span class="line">	<span class="meta">@PostMapping</span>(<span class="string">"/dept/update"</span>)</span><br><span class="line">	<span class="function">Result <span class="title">update</span><span class="params">(@RequestBody Dept dept)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@PostMapping</span>(<span class="string">"/dept/delete/&#123;deptNo&#125;"</span>)</span><br><span class="line">	<span class="function">Result <span class="title">delete</span><span class="params">(@PathVariable Integer deptNo)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、重启当前模块</p>
<p>4、服务降级测试：</p>
<blockquote>
<p>查询一个数据库不存在的编号信息，或者停止服务提供者服务：</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200511231829814.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="三、日志功能"><a href="#三、日志功能" class="headerlink" title="三、日志功能"></a>三、日志功能</h2><blockquote>
<p>Feign提供了日志打印功能，我们可以通过配置来调整日志级别，从而了解Feign中Http请求的细节。</p>
</blockquote>
<p><strong>日志级别</strong></p>
<pre><code>NONE：默认的，不显示任何日志；
BASIC：仅记录请求方法、URL、响应状态码及执行时间；
HEADERS：除了BASIC中定义的信息之外，还有请求和响应的头信息；
FULL：除了HEADERS中定义的信息之外，还有请求和响应的正文及元数据。</code></pre><p><strong>通过配置开启更为详细的日志</strong></p>
<p>1、创建一个FeignConfig 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> feign.Logger;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignConfig</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	Logger.<span class="function">Level <span class="title">level</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、配置文件中需要开启日志的Feign客户端：</p>
<blockquote>
<p>配置ribbon-orcl-server-service的日志级别为debug:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    cn.chfsun.service: debug</span><br></pre></td></tr></table></figure>

<p>3、查看日志信息：</p>
<p><img src="https://img-blog.csdnimg.cn/20200511234909519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="四、常用配置"><a href="#四、常用配置" class="headerlink" title="四、常用配置"></a>四、常用配置</h2><p><strong>1、Feign自己的配置：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">feign:</span><br><span class="line">  hystrix:</span><br><span class="line">    enabled: true #在Feign中开启Hystrix</span><br><span class="line">  compression:</span><br><span class="line">    request:</span><br><span class="line">      enabled: false #是否对请求进行GZIP压缩</span><br><span class="line">      mime-types: text/xml,application/xml,application/json #指定压缩的请求数据类型</span><br><span class="line">      min-request-size: 2048 #超过该大小的请求会被压缩</span><br><span class="line">    response:</span><br><span class="line">      enabled: false #是否对响应进行GZIP压缩</span><br><span class="line">##修改日志级别</span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    cn.chfsun.service: debug</span><br></pre></td></tr></table></figure>

<p><strong>2、Feign中的Hystrix配置</strong></p>
<p>在Feign中配置Hystrix可以直接使用Hystrix的配置，具体可以参考spring cloud 之 Hystrix</p>
<p><strong>3、Feign中的Ribbon配置</strong></p>
<p>在Feign中配置Ribbon可以直接使用Ribbon的配置，具体可以参考  spring cloud 之 Ribbon</p>
<h2 id="五、本章模块"><a href="#五、本章模块" class="headerlink" title="五、本章模块"></a>五、本章模块</h2><p>springcloud-learning<br>├── eureka-server – eureka注册中心<br>├── ribbon-orcl-server-service – 服务提供者<br>└── feign-service – 服务消费者</p>
<p><strong><a href="https://github.com/chfsun/springcloud-learning" target="_blank" rel="noopener">GitHub项目源码地址</a></strong></p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>cloud</tag>
        <tag>OpenFeign</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud（08）之 Config分布式配置中心</title>
    <url>/myblog/spring-cloud/Spring-Cloud%EF%BC%8808%EF%BC%89%E4%B9%8B-Config%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
    <content><![CDATA[<h2 id="一、Spring-Cloud-Config-简介"><a href="#一、Spring-Cloud-Config-简介" class="headerlink" title="一、Spring Cloud Config 简介"></a>一、Spring Cloud Config 简介</h2><p>Spring Cloud Config 可以为微服务架构中的应用提供集中化的外部配置支持，它分为服务端和客户端两个部分。</p>
<p>服务端被称为分布式配置中心，它是个独立的应用，可以从配置仓库获取配置信息并提供给客户端使用。</p>
<a id="more"></a>
<p>客户端可以通过配置中心来获取配置信息，在启动时加载配置。</p>
<p>Spring Cloud Config 的配置中心默认采用Git来存储配置信息，所以天然就支持配置信息的版本管理，并且可以使用Git客户端来方便地管理和访问配置信息。</p>
<h2 id="二、准备配置信息"><a href="#二、准备配置信息" class="headerlink" title="二、准备配置信息"></a>二、准备配置信息</h2><blockquote>
<p>因为考虑到网络访问效率及识别度问题，此处我们使用码云gitee作为存储配置信息的Git仓库，配置文件信息仅做测试用例，无需复杂信息，简单即可</p>
</blockquote>
<p>1、仓库目录：<br><img src="https://img-blog.csdnimg.cn/20200513222512630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>1.1、master分支下的配置信息：</strong></p>
<p>config-dev.yml:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">config</span>:</span><br><span class="line">  <span class="selector-tag">info</span>: "<span class="selector-tag">config</span> <span class="selector-tag">info</span> <span class="selector-tag">for</span> <span class="selector-tag">dev</span>(<span class="selector-tag">master</span>)"</span><br></pre></td></tr></table></figure>

<p>config-test.yml:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">config</span>:</span><br><span class="line">  <span class="selector-tag">info</span>: "<span class="selector-tag">config</span> <span class="selector-tag">info</span> <span class="selector-tag">for</span> <span class="selector-tag">test</span>(<span class="selector-tag">master</span>)"</span><br></pre></td></tr></table></figure>

<p>config-prod.yml:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">config</span>:</span><br><span class="line">  <span class="selector-tag">info</span>: "<span class="selector-tag">config</span> <span class="selector-tag">info</span> <span class="selector-tag">for</span> <span class="selector-tag">prod</span>(<span class="selector-tag">master</span>)"</span><br></pre></td></tr></table></figure>

<p><strong>1.2、dev分支下的配置信息</strong><br>config-dev.yml:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">config</span>:</span><br><span class="line">  <span class="selector-tag">info</span>: "<span class="selector-tag">config</span> <span class="selector-tag">info</span> <span class="selector-tag">for</span> <span class="selector-tag">dev</span>(<span class="selector-tag">dev</span>)"</span><br></pre></td></tr></table></figure>

<p>config-test.yml:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">config</span>:</span><br><span class="line">  <span class="selector-tag">info</span>: "<span class="selector-tag">config</span> <span class="selector-tag">info</span> <span class="selector-tag">for</span> <span class="selector-tag">test</span>(<span class="selector-tag">dev</span>)"</span><br></pre></td></tr></table></figure>

<p>config-prod.yml:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">config</span>:</span><br><span class="line">  <span class="selector-tag">info</span>: "<span class="selector-tag">config</span> <span class="selector-tag">info</span> <span class="selector-tag">for</span> <span class="selector-tag">prod</span>(<span class="selector-tag">dev</span>)"</span><br></pre></td></tr></table></figure>

<p>1.3、config子目录下的配置同上，为做区分内容上做下改变：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">config</span>:</span><br><span class="line">  <span class="selector-tag">info</span>: "<span class="selector-tag">config</span> <span class="selector-tag">info</span> <span class="selector-tag">for</span> <span class="selector-tag">config</span> <span class="selector-tag">dir</span> <span class="selector-tag">dev</span>(<span class="selector-tag">master</span>)"</span><br></pre></td></tr></table></figure>
<p>余下部分省略,自行补充……</p>
<h2 id="示例Demo"><a href="#示例Demo" class="headerlink" title="示例Demo"></a>示例Demo</h2><h2 id="三、config-server服务端"><a href="#三、config-server服务端" class="headerlink" title="三、config-server服务端"></a>三、config-server服务端</h2><p>1、创建<strong>config-server</strong>模块</p>
<p>2、pom.xml文件：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>3、配置文件：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">server</span>:</span><br><span class="line">  <span class="selector-tag">port</span>: 8901</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">spring</span>:</span><br><span class="line">  <span class="selector-tag">application</span>:</span><br><span class="line">    <span class="selector-tag">name</span>: <span class="selector-tag">config-server</span></span><br><span class="line">  <span class="selector-tag">cloud</span>:</span><br><span class="line">    <span class="selector-tag">config</span>:</span><br><span class="line">      <span class="selector-tag">server</span>:</span><br><span class="line">        <span class="selector-tag">git</span>:</span><br><span class="line">          # 配置存储配置信息的<span class="selector-tag">Git</span>仓库</span><br><span class="line">          uri: https://gitee.com/xxx/springcloud-config.git  # 你的gitee仓库地址</span><br><span class="line">          <span class="selector-tag">username</span>: <span class="selector-tag">xxxx</span></span><br><span class="line">          <span class="selector-tag">password</span>: <span class="selector-tag">xxxxxx</span></span><br><span class="line">          # 开启启动时直接从<span class="selector-tag">git</span>获取配置</span><br><span class="line">          <span class="selector-tag">clone-on-start</span>: <span class="selector-tag">true</span></span><br><span class="line">          # 获取子目录下的配置</span><br><span class="line">          #search-paths: '&#123;application&#125;'</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">eureka</span>:</span><br><span class="line">  <span class="selector-tag">client</span>:</span><br><span class="line">    <span class="selector-tag">register-with-eureka</span>: <span class="selector-tag">true</span></span><br><span class="line">    <span class="selector-tag">fetch-registry</span>: <span class="selector-tag">true</span></span><br><span class="line">    <span class="selector-tag">service-url</span>:</span><br><span class="line">      defaultZone: http://localhost:8001/eureka/</span><br></pre></td></tr></table></figure>

<p>4、启动类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerApplication</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(ConfigServerApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、依次启动服务中心、config-server模块</p>
<p>6、测试获取获取配置信息：</p>
<p>6.1、获取配置文件信息的访问格式：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># 获取配置信息</span><br><span class="line">/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;</span><br><span class="line"># 获取配置文件信息</span><br><span class="line">/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.yml</span><br></pre></td></tr></table></figure>
<p>占位符相关解释：</p>
<blockquote>
<p>application：代表应用名称，默认为配置文件中的spring.application.name，如果配置了spring.cloud.config.name，则为该名称；</p>
</blockquote>
<blockquote>
<p>label：代表分支名称，对应配置文件中的spring.cloud.config.label；</p>
</blockquote>
<blockquote>
<p>profile：代表环境名称，对应配置文件中的spring.cloud.config.profile</p>
</blockquote>
<p>6.2、访问 <a href="http://localhost:8901/master/config-dev" target="_blank" rel="noopener">http://localhost:8901/master/config-dev</a> 来获取master分支上dev环境的配置信息；<br><img src="https://img-blog.csdnimg.cn/20200513224306379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">6.3、访问 <a href="http://localhost:8901/master/config-dev.yml" target="_blank" rel="noopener">http://localhost:8901/master/config-dev.yml</a> 来获取master分支上dev环境的配置文件信息，对比上面信息，可以看出配置信息和配置文件信息并不是同一个概念，显示如下：<br><img src="https://img-blog.csdnimg.cn/20200513224540720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>6.4、访问<a href="http://localhost:8901/master/config-test.yml来获取master分支上test环境的配置文件信息" target="_blank" rel="noopener">http://localhost:8901/master/config-test.yml来获取master分支上test环境的配置文件信息</a>:<br><img src="https://img-blog.csdnimg.cn/20200513224618818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="四、config-client客户端"><a href="#四、config-client客户端" class="headerlink" title="四、config-client客户端"></a>四、config-client客户端</h2><p>1、创建config-client模块</p>
<p>2、pom文件：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2、配置文件bootstrap.yml：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">server</span>:</span><br><span class="line">  <span class="selector-tag">port</span>: 9001</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">spring</span>:</span><br><span class="line">  <span class="selector-tag">application</span>:</span><br><span class="line">    <span class="selector-tag">name</span>: <span class="selector-tag">config-client</span></span><br><span class="line">  <span class="selector-tag">cloud</span>:</span><br><span class="line">    # <span class="selector-tag">config</span>客户端配置</span><br><span class="line">    <span class="selector-tag">config</span>:</span><br><span class="line">      # 分支名称</span><br><span class="line">      <span class="selector-tag">label</span>: <span class="selector-tag">master</span></span><br><span class="line">      # 启用配置后缀名称</span><br><span class="line">      <span class="selector-tag">profile</span>: <span class="selector-tag">dev</span></span><br><span class="line">      # 配置文件名称</span><br><span class="line">      <span class="selector-tag">name</span>: <span class="selector-tag">config</span></span><br><span class="line">      # 配置中心地址</span><br><span class="line">      uri: http://localhost:8901</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">eureka</span>:</span><br><span class="line">  <span class="selector-tag">client</span>:</span><br><span class="line">    <span class="selector-tag">register-with-eureka</span>: <span class="selector-tag">true</span></span><br><span class="line">    <span class="selector-tag">fetch-registry</span>: <span class="selector-tag">true</span></span><br><span class="line">    <span class="selector-tag">service-url</span>:</span><br><span class="line">      defaultZone: http://localhost:8001/eureka/</span><br></pre></td></tr></table></figure>

<p>3、新建控制层 ConfigClientController类用于获取配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;config.info&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/configInfo"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConfigInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、依次启动eureka-server、config-server、config-client服务</p>
<p>5、测试：</p>
<p>5.1、访问<a href="http://localhost:9001/configInfo，可以获取到dev分支下dev环境的配置：" target="_blank" rel="noopener">http://localhost:9001/configInfo，可以获取到dev分支下dev环境的配置：</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">config info <span class="keyword">for</span> dev(master)</span><br></pre></td></tr></table></figure>

<p>5.2、获取子目录下的配置</p>
<blockquote>
<p>我们不仅可以把每个项目的配置放在不同的Git仓库存储，也可以在一个Git仓库中存储多个项目的配置，此时就会用到在子目录中搜索配置信息的配置。</p>
</blockquote>
<p>首先我们需要在config-server中添加相关配置，用于搜索子目录中的配置，这里我们用到了application占位符，表示对于不同的应用，我们从对应应用名称的子目录中搜索配置，比如config子目录中的配置对应config应用:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">spring</span>:</span><br><span class="line">  <span class="selector-tag">cloud</span>:</span><br><span class="line">    <span class="selector-tag">config</span>:</span><br><span class="line">      <span class="selector-tag">server</span>:</span><br><span class="line">        <span class="selector-tag">git</span>: </span><br><span class="line">          search-paths: '&#123;application&#125;'</span><br></pre></td></tr></table></figure>
<p>访问<a href="http://localhost:9001/configInfo进行测试，可以发现获取的是config子目录下的配置信息" target="_blank" rel="noopener">http://localhost:9001/configInfo进行测试，可以发现获取的是config子目录下的配置信息</a>:<br><img src="https://img-blog.csdnimg.cn/20200513225718992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="五、配置中心添加安全认证"><a href="#五、配置中心添加安全认证" class="headerlink" title="五、配置中心添加安全认证"></a>五、配置中心添加安全认证</h2><blockquote>
<p>以通过整合SpringSecurity来为配置中心添加安全认证</p>
</blockquote>
<p>1、创建config-security-server模块</p>
<p>2、pom文件：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">      &lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>3、配置文件：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">server</span>:</span><br><span class="line">  <span class="selector-tag">port</span>: 8905</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">spring</span>:</span><br><span class="line">  <span class="selector-tag">application</span>:</span><br><span class="line">    <span class="selector-tag">name</span>: <span class="selector-tag">config-security-server</span></span><br><span class="line">  <span class="selector-tag">cloud</span>:</span><br><span class="line">    <span class="selector-tag">config</span>:</span><br><span class="line">      <span class="selector-tag">server</span>:</span><br><span class="line">        <span class="selector-tag">git</span>:</span><br><span class="line">          uri: https://gitee.com/xxxx/xxxxx.git</span><br><span class="line">          <span class="selector-tag">username</span>: <span class="selector-tag">xxxx</span></span><br><span class="line">          <span class="selector-tag">password</span>: <span class="selector-tag">xxxxxxxx</span></span><br><span class="line">          <span class="selector-tag">clone-on-start</span>: <span class="selector-tag">true</span></span><br><span class="line">  <span class="selector-tag">security</span>:</span><br><span class="line">    <span class="selector-tag">user</span>:</span><br><span class="line">      # 配置用户名和密码</span><br><span class="line">      <span class="selector-tag">name</span>: <span class="selector-tag">root</span></span><br><span class="line">      <span class="selector-tag">password</span>: 123456</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">eureka</span>:</span><br><span class="line">  <span class="selector-tag">client</span>:</span><br><span class="line">    <span class="selector-tag">register-with-eureka</span>: <span class="selector-tag">true</span></span><br><span class="line">    <span class="selector-tag">fetch-registry</span>: <span class="selector-tag">true</span></span><br><span class="line">    <span class="selector-tag">service-url</span>:</span><br><span class="line">      defaultZone: http://localhost:8001/eureka/</span><br></pre></td></tr></table></figure>

<p>4、在config-client中添加一个新的配置文件bootstrap-security.yml:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">server</span>:</span><br><span class="line">  <span class="selector-tag">port</span>: 9002</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">spring</span>:</span><br><span class="line">  <span class="selector-tag">application</span>:</span><br><span class="line">    <span class="selector-tag">name</span>: <span class="selector-tag">config-client</span></span><br><span class="line">  <span class="selector-tag">cloud</span>:</span><br><span class="line">    # <span class="selector-tag">config</span>客户端配置</span><br><span class="line">    <span class="selector-tag">config</span>:</span><br><span class="line">      # 分支名称</span><br><span class="line">      <span class="selector-tag">label</span>: <span class="selector-tag">master</span></span><br><span class="line">      # 启用配置后缀名称</span><br><span class="line">      <span class="selector-tag">profile</span>: <span class="selector-tag">dev</span></span><br><span class="line">      # 配置文件名称</span><br><span class="line">      <span class="selector-tag">name</span>: <span class="selector-tag">config</span></span><br><span class="line">      # 配置中心地址</span><br><span class="line">      uri: http://localhost:8905</span><br><span class="line">      <span class="selector-tag">username</span>: <span class="selector-tag">root</span></span><br><span class="line">      <span class="selector-tag">password</span>: 123456</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">eureka</span>:</span><br><span class="line">  <span class="selector-tag">client</span>:</span><br><span class="line">    <span class="selector-tag">register-with-eureka</span>: <span class="selector-tag">true</span></span><br><span class="line">    <span class="selector-tag">fetch-registry</span>: <span class="selector-tag">true</span></span><br><span class="line">    <span class="selector-tag">service-url</span>:</span><br><span class="line">      defaultZone: http://localhost:8001/eureka/</span><br></pre></td></tr></table></figure>

<p>5、依次启动项目 eureka-server、config-security-server、config-client服务：</p>
<blockquote>
<p>此时测试可发现，如果账号或密码错误时无法正常启动项目的</p>
</blockquote>
<p>6、测试</p>
<blockquote>
<p>使用bootstrap-security.yml启动config-client服务；</p>
</blockquote>
<p>访问<a href="http://localhost:9002/configInfo进行测试，发现可以获取到配置信息" target="_blank" rel="noopener">http://localhost:9002/configInfo进行测试，发现可以获取到配置信息</a>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">config info <span class="keyword">for</span> dev(master)</span><br></pre></td></tr></table></figure>

<h2 id="六、config-sever集群搭建"><a href="#六、config-sever集群搭建" class="headerlink" title="六、config-sever集群搭建"></a>六、config-sever集群搭建</h2><blockquote>
<p>在微服务架构中，所有服务都从配置中心获取配置，配置中心一旦宕机，会发生很严重的问题，下面我们搭建一个双节点的配置中心集群来解决该问题。</p>
</blockquote>
<p>1、启动两个config-server分别运行在8902和8903端口上</p>
<p>2、添加一个新的config-client的配置文件bootstrap-cluster.yml，此处我们使用service-id赋值模块名称的方式，来代替配置中心uri的配置：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">server</span>:</span><br><span class="line">  <span class="selector-tag">port</span>: 9003</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">spring</span>:</span><br><span class="line">  <span class="selector-tag">application</span>:</span><br><span class="line">    <span class="selector-tag">name</span>: <span class="selector-tag">config-client</span></span><br><span class="line">  <span class="selector-tag">cloud</span>:</span><br><span class="line">    # <span class="selector-tag">config</span>客户端配置</span><br><span class="line">    <span class="selector-tag">config</span>:</span><br><span class="line">      # 分支名称</span><br><span class="line">      <span class="selector-tag">label</span>: <span class="selector-tag">master</span></span><br><span class="line">      # 启用配置后缀名称</span><br><span class="line">      <span class="selector-tag">profile</span>: <span class="selector-tag">dev</span></span><br><span class="line">      # 配置文件名称</span><br><span class="line">      <span class="selector-tag">name</span>: <span class="selector-tag">config</span></span><br><span class="line">      # <span class="selector-tag">config-sever</span>集群搭建</span><br><span class="line">      <span class="selector-tag">discovery</span>:</span><br><span class="line">        <span class="selector-tag">enabled</span>: <span class="selector-tag">true</span></span><br><span class="line">        <span class="selector-tag">service-id</span>: <span class="selector-tag">config-server</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">eureka</span>:</span><br><span class="line">  <span class="selector-tag">client</span>:</span><br><span class="line">    <span class="selector-tag">register-with-eureka</span>: <span class="selector-tag">true</span></span><br><span class="line">    <span class="selector-tag">fetch-registry</span>: <span class="selector-tag">true</span></span><br><span class="line">    <span class="selector-tag">service-url</span>:</span><br><span class="line">      defaultZone: http://localhost:8001/eureka/</span><br></pre></td></tr></table></figure>

<p>3、以bootstrap-cluster.yml启动config-client服务，访问<a href="http://localhost:9003/configInfo，发现config-client可以获取到配置信息如下：" target="_blank" rel="noopener">http://localhost:9003/configInfo，发现config-client可以获取到配置信息如下：</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">config info <span class="keyword">for</span> config dir dev(master)</span><br></pre></td></tr></table></figure>

<h2 id="七、本章用到的模块"><a href="#七、本章用到的模块" class="headerlink" title="七、本章用到的模块"></a>七、本章用到的模块</h2><p>springcloud-learning<br>├── eureka-server – eureka注册中心<br>├── config-server – 配置中心服务<br>├── config-security-server – 带安全认证的配置中心服务<br>└── config-client – 测试获取配置的客户端服务</p>
<p><strong><a href="https://github.com/chfsun/springcloud-learning" target="_blank" rel="noopener">GitHub项目源码地址</a></strong></p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>cloud</tag>
        <tag>config</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud（09）之 Bus消息总线</title>
    <url>/myblog/spring-cloud/Spring-Cloud%EF%BC%8809%EF%BC%89%E4%B9%8B-Bus%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF/</url>
    <content><![CDATA[<h2 id="一、Spring-Cloud-Bus-简介"><a href="#一、Spring-Cloud-Bus-简介" class="headerlink" title="一、Spring Cloud Bus 简介"></a>一、Spring Cloud Bus 简介</h2><p>Spring Cloud Bus 使用轻量级的消息代理来连接微服务架构中的各个服务，可以将其用于广播状态更改（例如配置中心配置更改）或其他管理指令。</p>
<a id="more"></a>
<p>我们通常会使用消息代理来构建一个主题，然后把微服务架构中的所有服务都连接到这个主题上去，当我们向该主题发送消息时，所有订阅该主题的服务都会收到消息并进行消费。使用 Spring Cloud Bus 可以方便地构建起这套机制，所以 Spring Cloud Bus 又被称为消息总线。Spring Cloud Bus 配合 Spring Cloud Config 使用可以实现配置的动态刷新。</p>
<p>目前 Spring Cloud Bus 支持两种消息代理：RabbitMQ 和 Kafka，kafka我们已经学习过了，下面以 RabbitMQ 为例来演示下使用Spring Cloud Bus 动态刷新配置的功能。</p>
<h2 id="二、安装RabbitMQ"><a href="#二、安装RabbitMQ" class="headerlink" title="二、安装RabbitMQ"></a>二、安装RabbitMQ</h2><p>1、首先需要安装Erlang，下载地址：<a href="http://erlang.org/download/otp_win64_22.2.exe" target="_blank" rel="nofollow noopener">http://erlang.org/download…</a><br>下载好后，直接运行安装到一个不需要智商的磁盘即可。</p>
<p>2、安装RabbitMQ，下载地址：<a href="https://dl.bintray.com/rabbitmq/all/rabbitmq-server/3.8.2/rabbitmq-server-3.8.2.exe" target="_blank" rel="nofollow noopener">https://dl.bintray.com/rabbitmq…</a><br>下载好后，直接运行安装到一个不需要智商的磁盘即可。</p>
<p>3、安装完成后，进入RabbitMQ安装目录下的sbin目录：<br><img src="https://img-blog.csdnimg.cn/20200514102852433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">4、使用你的右手cmd到dos命令窗口下，输入以下命令启动：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200514103055217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>5、打开一个专业点的浏览器，访问 ：<a href="http://localhost:15672/" target="_blank" rel="noopener">http://localhost:15672/</a>   如果你的操作比较专业就能看到下面界面：</p>
<p><img src="https://img-blog.csdnimg.cn/20200514103744109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>输入账号密码并登录：guest guest</p>
</blockquote>
<h2 id="三、动态刷新配置"><a href="#三、动态刷新配置" class="headerlink" title="三、动态刷新配置"></a>三、动态刷新配置</h2><blockquote>
<p>使用 Spring Cloud Bus 动态刷新配置需要配合 Spring Cloud Config 一起使用，我们使用上一节中的config-server、config-client模块来测试下该功能。</p>
</blockquote>
<p>1、给config-server的pom文件添加消息总线支持：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2、添加配置文件application-amqp.yml，主要是添加了RabbitMQ的配置及暴露了刷新配置的Actuator端点：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">server</span>:</span><br><span class="line">  <span class="selector-tag">port</span>: 8904</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">spring</span>:</span><br><span class="line">  <span class="selector-tag">application</span>:</span><br><span class="line">    <span class="selector-tag">name</span>: <span class="selector-tag">config-server</span></span><br><span class="line">  <span class="selector-tag">cloud</span>:</span><br><span class="line">    <span class="selector-tag">config</span>:</span><br><span class="line">      <span class="selector-tag">server</span>:</span><br><span class="line">        <span class="selector-tag">git</span>:</span><br><span class="line">          # 配置存储配置信息的<span class="selector-tag">Git</span>仓库</span><br><span class="line">          uri: https://gitee.com/xxxxx/xxxxx.git</span><br><span class="line">          <span class="selector-tag">username</span>: <span class="selector-tag">xxxxx</span></span><br><span class="line">          <span class="selector-tag">password</span>: <span class="selector-tag">xxxxxxxx</span></span><br><span class="line">          # 开启启动时直接从<span class="selector-tag">git</span>获取配置</span><br><span class="line">          <span class="selector-tag">clone-on-start</span>: <span class="selector-tag">true</span></span><br><span class="line">          # 获取子目录下的配置</span><br><span class="line">          #search-paths: '&#123;application&#125;'</span><br><span class="line">  <span class="selector-id">#rabbitmq</span>相关配置</span><br><span class="line">  <span class="selector-tag">rabbitmq</span>:</span><br><span class="line">    <span class="selector-tag">host</span>: <span class="selector-tag">localhost</span></span><br><span class="line">    <span class="selector-tag">port</span>: 5672</span><br><span class="line">    <span class="selector-tag">username</span>: <span class="selector-tag">guest</span></span><br><span class="line">    <span class="selector-tag">password</span>: <span class="selector-tag">guest</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">eureka</span>:</span><br><span class="line">  <span class="selector-tag">client</span>:</span><br><span class="line">    <span class="selector-tag">register-with-eureka</span>: <span class="selector-tag">true</span></span><br><span class="line">    <span class="selector-tag">fetch-registry</span>: <span class="selector-tag">true</span></span><br><span class="line">    <span class="selector-tag">service-url</span>:</span><br><span class="line">      defaultZone: http://localhost:8001/eureka/</span><br><span class="line"></span><br><span class="line"># 暴露<span class="selector-tag">bus</span>刷新配置的端点</span><br><span class="line"><span class="selector-tag">management</span>:</span><br><span class="line">  <span class="selector-tag">endpoints</span>:</span><br><span class="line">    <span class="selector-tag">web</span>:</span><br><span class="line">      <span class="selector-tag">exposure</span>:</span><br><span class="line">        include: 'bus-refresh'</span><br></pre></td></tr></table></figure>

<p>3、config-client添加消息总线支持：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>4、添加配置文件bootstrap-amqp1.yml及bootstrap-amqp2.yml用于启动两个不同的config-client，两个配置文件只有端口号不同：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">server</span>:</span><br><span class="line">  <span class="selector-tag">port</span>: 9004</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">spring</span>:</span><br><span class="line">  <span class="selector-tag">application</span>:</span><br><span class="line">    <span class="selector-tag">name</span>: <span class="selector-tag">config-client</span></span><br><span class="line">  <span class="selector-tag">cloud</span>:</span><br><span class="line">    # <span class="selector-tag">config</span>客户端配置</span><br><span class="line">    <span class="selector-tag">config</span>:</span><br><span class="line">      # 分支名称</span><br><span class="line">      <span class="selector-tag">label</span>: <span class="selector-tag">master</span></span><br><span class="line">      # 启用配置后缀名称</span><br><span class="line">      <span class="selector-tag">profile</span>: <span class="selector-tag">dev</span></span><br><span class="line">      # 配置文件名称</span><br><span class="line">      <span class="selector-tag">name</span>: <span class="selector-tag">config</span></span><br><span class="line">      <span class="selector-tag">discovery</span>:</span><br><span class="line">        <span class="selector-tag">enabled</span>: <span class="selector-tag">true</span></span><br><span class="line">        <span class="selector-tag">service-id</span>: <span class="selector-tag">config-server</span></span><br><span class="line">  # <span class="selector-tag">rabbitmq</span>配置</span><br><span class="line">  <span class="selector-tag">rabbitmq</span>:</span><br><span class="line">    <span class="selector-tag">host</span>: <span class="selector-tag">localhost</span></span><br><span class="line">    <span class="selector-tag">port</span>: 5672</span><br><span class="line">    <span class="selector-tag">username</span>: <span class="selector-tag">guest</span></span><br><span class="line">    <span class="selector-tag">password</span>: <span class="selector-tag">guest</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">eureka</span>:</span><br><span class="line">  <span class="selector-tag">client</span>:</span><br><span class="line">    <span class="selector-tag">register-with-eureka</span>: <span class="selector-tag">true</span></span><br><span class="line">    <span class="selector-tag">fetch-registry</span>: <span class="selector-tag">true</span></span><br><span class="line">    <span class="selector-tag">service-url</span>:</span><br><span class="line">      defaultZone: http://localhost:8001/eureka/</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">management</span>:</span><br><span class="line">  <span class="selector-tag">endpoints</span>:</span><br><span class="line">    <span class="selector-tag">web</span>:</span><br><span class="line">      <span class="selector-tag">exposure</span>:</span><br><span class="line">        include: 'refresh'</span><br></pre></td></tr></table></figure>

<p>5、动态刷新配置测试</p>
<p>依次启动模块：eureka-server，以application-amqp.yml为配置启动config-server，以bootstrap-amqp1.yml为配置启动config-client，以bootstrap-amqp2.yml为配置再启动一个config-client，启动后注册中心显示如下</p>
<p><img src="https://img-blog.csdnimg.cn/2020051410571325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">6、此时我们登录RabbitMQ的控制台可以发现 Spring Cloud Bus 创建了一个叫springCloudBus的交换机及三个以 springCloudBus.anonymous开头的队列：</p>
<p><img src="https://img-blog.csdnimg.cn/20200514110041916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200514110138951.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">7、调用  <a href="http://localhost:9004/configInfo" target="_blank" rel="noopener">http://localhost:9004/configInfo</a>  ，结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">config info <span class="keyword">for</span> <span class="title">dev</span><span class="params">(master)</span></span></span><br></pre></td></tr></table></figure>

<p>8、修改Gitee仓库中master分支下的config-dev.yml配置文件：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">修改前信息</span><br><span class="line"><span class="selector-tag">config</span>:</span><br><span class="line">  <span class="selector-tag">info</span>: "<span class="selector-tag">config</span> <span class="selector-tag">info</span> <span class="selector-tag">for</span> <span class="selector-tag">dev</span>(<span class="selector-tag">master</span>)"</span><br><span class="line"></span><br><span class="line"># 修改后信息</span><br><span class="line"><span class="selector-tag">config</span>:</span><br><span class="line">  <span class="selector-tag">info</span>: "<span class="selector-tag">update</span> <span class="selector-tag">config</span> <span class="selector-tag">info</span> <span class="selector-tag">for</span> <span class="selector-tag">dev</span>(<span class="selector-tag">master</span>)"</span><br></pre></td></tr></table></figure>

<p>9、在控制层添加刷新的注解后，调用注册中心的接口刷新所有配置：<a href="http://localhost:8904/actuator/bus-refresh" target="_blank" rel="noopener">http://localhost:8904/actuator/bus-refresh</a>  ，此处最好使用专业的测试工具：</p>
<p><img src="https://img-blog.csdnimg.cn/20200514111149950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>10、刷新后再分别调用 <a href="http://localhost:9004/configInfo" target="_blank" rel="noopener">http://localhost:9004/configInfo</a> 和 <a href="http://localhost:9005/configInfo" target="_blank" rel="noopener">http://localhost:9005/configInfo</a> 获取配置信息，发现都已经刷新了：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">update</span> <span class="selector-tag">config</span> <span class="selector-tag">info</span> <span class="selector-tag">for</span> <span class="selector-tag">dev</span>(<span class="selector-tag">master</span>)</span><br></pre></td></tr></table></figure>
<p>11、如果只需要刷新指定实例的配置可以使用以下格式进行刷新：<a href="http://localhost:8904/actuator/bus-refresh/{destination}" target="_blank" rel="noopener">http://localhost:8904/actuator/bus-refresh/{destination}</a> ，</p>
<p>例如：这里以刷新运行在9004端口上的config-client为例<a href="http://localhost:8904/actuator/bus-refresh/config-client:9004" target="_blank" rel="noopener">http://localhost:8904/actuator/bus-refresh/config-client:9004</a></p>
<h2 id="四、使用码云的WebHooks"><a href="#四、使用码云的WebHooks" class="headerlink" title="四、使用码云的WebHooks"></a>四、使用码云的WebHooks</h2><blockquote>
<p>WebHooks相当于是一个钩子函数，我们可以配置当向Git仓库push代码时触发这个钩子函数，这里以Gitee为例来介绍下其使用方式，这里当我们向配置仓库push代码时就会自动刷新服务配置了。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200514113027185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="五、本章模块"><a href="#五、本章模块" class="headerlink" title="五、本章模块"></a>五、本章模块</h2><p>springcloud-learning<br>├── eureka-server – eureka注册中心<br>├── config-server – 配置中心服务<br>└── config-client – 获取配置的客户端服务</p>
<p><strong><a href="https://github.com/chfsun/springcloud-learning" target="_blank" rel="noopener">GitHub项目源码地址</a></strong></p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>cloud</tag>
        <tag>bus</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud（10）之 Sleuth服务链路跟踪</title>
    <url>/myblog/spring-cloud/Spring-Cloud%EF%BC%8810%EF%BC%89%E4%B9%8B-Sleuth%E6%9C%8D%E5%8A%A1%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AA/</url>
    <content><![CDATA[<h2 id="一、Spring-Cloud-Sleuth-简介"><a href="#一、Spring-Cloud-Sleuth-简介" class="headerlink" title="一、Spring Cloud Sleuth 简介"></a>一、Spring Cloud Sleuth 简介</h2><p>随着我们的系统越来越庞大，各个服务间的调用关系也变得越来越复杂。当客户端发起一个请求时，这个请求经过多个服务后，最终返回了结果，经过的每一个服务都有可能发生延迟或错误，从而导致请求失败。这时候我们就需要请求链路跟踪工具来帮助我们，理清请求调用的服务链路，解决问题。</p>
<a id="more"></a>
<p>Sleuth 是分布式系统中跟踪服务间调用的工具，它可以直观地展示出一次请求的调用过程。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h2 id="二、整合Zipkin获取及分析日志"><a href="#二、整合Zipkin获取及分析日志" class="headerlink" title="二、整合Zipkin获取及分析日志"></a>二、整合Zipkin获取及分析日志</h2><p>1、为服务添加请求链路跟踪</p>
<blockquote>
<p>在原有项目模块基础上，通过ribbon-orcl-server-service 和 ribbon-orcl-client-service 之间的服务调用来演示该功能，这里我们调用 ribbon-orcl-client-service 的接口时，ribbon-orcl-client-service 会通过RestTemplate来调用ribbon-orcl-server-service 提供的接口。</p>
</blockquote>
<p>为ribbon-orcl-server-service和ribbon-orcl-server-service 添加相关依赖：</p>
<p>pom文件：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>配置文件配置收集日志的zipkin-server访问地址：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">server</span>:</span><br><span class="line">  <span class="selector-tag">port</span>: 8201</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">spring</span>:</span><br><span class="line">  <span class="selector-tag">application</span>:</span><br><span class="line">    <span class="selector-tag">name</span>: <span class="selector-tag">ribbon-orcl-server-service</span></span><br><span class="line"><span class="selector-tag">zipkin</span>:</span><br><span class="line">  base-url: http://localhost:9411</span><br><span class="line">   #设置<span class="selector-tag">Sleuth</span>的抽样收集概率</span><br><span class="line">  <span class="selector-tag">sleuth</span>:</span><br><span class="line">    <span class="selector-tag">sampler</span>:</span><br><span class="line">      <span class="selector-tag">probability</span>: 0<span class="selector-class">.1</span></span><br></pre></td></tr></table></figure>

<p>2、整合Zipkin获取及分析日志</p>
<blockquote>
<p>Zipkin是Twitter的一个开源项目，可以用来获取和分析Spring Cloud Sleuth 中产生的请求链路跟踪日志，它提供了Web界面来帮助我们直观地查看请求链路跟踪信息</p>
</blockquote>
<p>SpringBoot 2.0以上版本已经不需要自行搭建zipkin-server，我们可以从该地址下载zipkin-server：<a href="https://repo1.maven.org/maven2/io/zipkin/java/zipkin-server/2.12.9/zipkin-server-2.12.9-exec.jar" target="_blank" rel="nofollow noopener">repo1.maven.org/maven2/io/z…</a></p>
<p>下载完成后使用以下命令运行zipkin-server：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -jar zipkin-server-<span class="number">2.12</span><span class="number">.9</span>-exec.jar</span><br></pre></td></tr></table></figure>

<p>Zipkin页面访问地址：<a href="http://localhost:9411" target="_blank" rel="noopener">http://localhost:9411</a></p>
<p><img src="https://img-blog.csdnimg.cn/20200517112059843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">3、依次启动模块 启动eureka-sever，ribbon-orcl-server-service，ribbon-orcl-client-service</p>
<p><img src="https://img-blog.csdnimg.cn/2020051711233250.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>4、多次调用（Sleuth为抽样收集）ribbon-orcl-client-service<br>的接口 <a href="http://localhost:8301/ribbon/1，调用完后查看Zipkin首页发现已经有请求链路跟踪信息了：" target="_blank" rel="noopener">http://localhost:8301/ribbon/1，调用完后查看Zipkin首页发现已经有请求链路跟踪信息了：</a></p>
<p><img src="https://img-blog.csdnimg.cn/20200517112737606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>点击查看详情可以直观地看到请求调用链路和通过每个服务的耗时：</p>
<p><img src="https://img-blog.csdnimg.cn/20200517112828927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="三、使用Elasticsearch存储跟踪信息"><a href="#三、使用Elasticsearch存储跟踪信息" class="headerlink" title="三、使用Elasticsearch存储跟踪信息"></a>三、使用Elasticsearch存储跟踪信息</h2><blockquote>
<p>如果我们把zipkin-server重启一下就会发现刚刚的存储的跟踪信息全部丢失了，可见其是存储在内存中的，有时候我们需要将所有信息存储下来，这里以存储到Elasticsearch为例，来演示下该功能:</p>
</blockquote>
<p>1、配置好es、bibana并启动，如果不知道怎么使用可看 <a href="https://chfsun.gitee.io/myblog/spring-cloud/lasticsearch-6-2-2-kibana-6-2-2-windows-x86-64%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/">es、kibana使用</a></p>
<p>2、修改Zipkin启动参数将信息存储到Elasticsearch：</p>
<blockquote>
<p>STORAGE_TYPE：表示存储类型 ES_HOSTS：表示ES的访问地址</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -jar zipkin-server-<span class="number">2.12</span><span class="number">.9</span>-exec.jar --STORAGE_TYPE=elasticsearch --ES_HOSTS=localhost:<span class="number">9200</span></span><br></pre></td></tr></table></figure>
<p>3、重新启动ribbon-orcl-server-service和ribbon-orcl-server-service才能生效，重启后多次调用ribbon-service的接口 <a href="http://localhost:8301/ribbon/1：" target="_blank" rel="noopener">http://localhost:8301/ribbon/1：</a></p>
<p>4、打开 <a href="http://localhost:5601/，可查看到界面信息：" target="_blank" rel="noopener">http://localhost:5601/，可查看到界面信息：</a></p>
<p><img src="https://img-blog.csdnimg.cn/2020051711503599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200517115121447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>5、此时即使关闭zipkin，再重新启动，发现数据依然存在</p>
<h2 id="四、本章使用到的模块"><a href="#四、本章使用到的模块" class="headerlink" title="四、本章使用到的模块"></a>四、本章使用到的模块</h2><p>springcloud-learning<br>├── eureka-server – eureka注册中心<br>├── ribbon-orcl-server-service – 服务提供者<br>└── ribbon-orcl-client-service– 服务调用者</p>
<p><strong><a href="https://github.com/chfsun/springcloud-learning" target="_blank" rel="noopener">GitHub项目源码地址</a></strong></p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>cloud</tag>
        <tag>sleuth</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud（12）之 Gateway服务网关</title>
    <url>/myblog/spring-cloud/Spring-Cloud%EF%BC%8812%EF%BC%89%E4%B9%8B-Gateway%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3/</url>
    <content><![CDATA[<h2 id="Spring-Cloud-Gateway简介"><a href="#Spring-Cloud-Gateway简介" class="headerlink" title="Spring Cloud Gateway简介"></a>Spring Cloud Gateway简介</h2><p>Gateway是在Spring生态系统之上构建的API网关服务，基于Spring 5，Spring Boot 2和 Project Reactor等技术。Gateway旨在提供一种简单而有效的方式来对API进行路由，以及提供一些强大的过滤器功能， 例如：熔断、限流、重试等。</p>
<a id="more"></a>
<p>在SpringCloud微服务体系中，有个很重要的组件就是网关，在1.x版本中都是采用的Zuul网关；但在2.x版本中，zuul的升级一直跳票，SpringCloud最后自己研发了一个网关替代Zuul，那就是SpringCloud Gateway</p>
<p>我们为什么选择Gateway？</p>
<p>一方面因为Zuul已经进入了维护阶段，而且Gateway是SpringCloud团队研发的，是“亲儿子”产品，值得信赖。而且很多功能Zuul都没有；用起来也非常的简单便捷。</p>
<p>网上很多地方都说Zuul是阻塞的，Gateway是非阻塞的，这么说是不严谨的，准确的讲Zuul1.x是阻塞的，而在2.x的版本中，Zuul也是基于Netty，也是非阻塞的，如果一定要说性能，其实这个真没多大差距。</p>
<blockquote>
<p>Gateway是基于异步非阻塞模型上进行开发的，性能方面不需要担心。虽然Netflix 早就发布了最新的 Zuul 2.x，但 Spring Cloud 貌似没有整合计划。而且Netflix相关组件都宣布进入维护期；不知前景如何？</p>
</blockquote>
<p>多方面综合考虑Gateway是很理想的网关选择</p>
<p>Spring Cloud Gateway 具有如下特性：</p>
<ul>
<li>基于Spring Framework 5, Project Reactor 和 Spring Boot 2.0 进行构建；   <ul>
<li>动态路由：能够匹配任何请求属性；   </li>
<li>可以对路由指定 Predicate（断言）和 Filter（过滤器）；   </li>
<li>集成Hystrix的断路器功能；    <ul>
<li>集成 Spring Cloud 服务发现功能；    </li>
</ul>
</li>
<li>易于编写的 Predicate（断言）和 Filter（过滤器）；    </li>
<li>请求限流功能；    <ul>
<li>支持路径重写。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p><img src="https://img-blog.csdnimg.cn/20200517204613100.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>上图中是核心的流程图，最主要的就是Route、Predicates 和 Filters 作用于特定路由</p>
<ul>
<li><p>Route（路由）：路由是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如果断言为true则匹配该路由；</p>
</li>
<li><p>Predicate（断言）：指的是Java 8 的 Function Predicate。 输入类型是Spring框架中的ServerWebExchange。 这使开发人员可以匹配HTTP请求中的所有内容，例如请求头或请求参数。如果请求与断言相匹配，则进行路由；</p>
</li>
<li><p>Filter（过滤器）：指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前后对请求进行修改。</p>
</li>
</ul>
<h2 id="Demo示例"><a href="#Demo示例" class="headerlink" title="Demo示例"></a>Demo示例</h2><h2 id="一、模块创建"><a href="#一、模块创建" class="headerlink" title="一、模块创建"></a>一、模块创建</h2><p>1、创建gateway-api 模块</p>
<p>2、pom主要文件：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>3、application.yml配置文件：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-tag">server</span>:</span><br><span class="line">  <span class="selector-tag">port</span>: 9201</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="selector-tag">eureka</span>:</span><br><span class="line">  <span class="selector-tag">client</span>:</span><br><span class="line">    <span class="selector-tag">register-with-eureka</span>: <span class="selector-tag">true</span></span><br><span class="line">    <span class="selector-tag">fetch-registry</span>: <span class="selector-tag">true</span></span><br><span class="line">    <span class="selector-tag">service-url</span>:</span><br><span class="line">      defaultZone: http://localhost:8001/eureka/</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">service-url</span>:</span><br><span class="line">  hystrix-orcl-client-service: http://localhost:8401</span><br><span class="line">  feign-service: http://localhost:8701</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">spring</span>:</span><br><span class="line">  <span class="selector-tag">application</span>:</span><br><span class="line">    <span class="selector-tag">name</span>: <span class="selector-tag">gateway-api</span></span><br><span class="line">  <span class="selector-tag">cloud</span>:</span><br><span class="line">    <span class="selector-tag">gateway</span>:</span><br><span class="line">      <span class="selector-tag">routes</span>:</span><br><span class="line">          # 路由的<span class="selector-tag">ID</span></span><br><span class="line">        <span class="selector-tag">-</span> <span class="selector-tag">id</span>: <span class="selector-tag">dept_service_route</span></span><br><span class="line">          # 匹配后路由地址</span><br><span class="line">          uri: $&#123;service-url.hystrix-orcl-client-service&#125;/hystrix/*/*</span><br><span class="line">          <span class="selector-tag">predicates</span>:</span><br><span class="line">              # 断言，路径相匹配的进行路由</span><br><span class="line">            - Path=/hystrix/*/*</span><br><span class="line">        <span class="selector-tag">-</span> <span class="selector-tag">id</span>: <span class="selector-tag">feign_service_route</span></span><br><span class="line">          # 匹配后路由地址</span><br><span class="line">          uri: http://localhost:8701/feign/*</span><br><span class="line">          <span class="selector-tag">predicates</span>:</span><br><span class="line">              # 断言，路径相匹配的进行路由</span><br><span class="line">            - Path=/feign/*</span><br></pre></td></tr></table></figure>

<p>4、依次启动 启动eureka-server、ribbon-orcl-server-service、hystrix-orcl-client-service、feign-service 和gateway-api服务，并调用该地址测试：<a href="http://localhost:9201/feign/listDept、http://localhost:9201/hystrix/dept/1" target="_blank" rel="noopener">http://localhost:9201/feign/listDept、http://localhost:9201/hystrix/dept/1</a></p>
<p>我们发现该请求都能被路由到相应的模块请求中，并显示数据：</p>
<p><img src="https://img-blog.csdnimg.cn/20200517210151919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="二、Route-Predicate-的使用"><a href="#二、Route-Predicate-的使用" class="headerlink" title="二、Route Predicate 的使用"></a>二、Route Predicate 的使用</h2><p>Spring Cloud Gateway将路由匹配作为Spring WebFlux HandlerMapping基础架构的一部分。 Spring Cloud Gateway包括许多内置的Route Predicate工厂。 所有这些Predicate都与HTTP请求的不同属性匹配。 多个Route Predicate工厂可以进行组合，下面我们来介绍下一些常用的Route Predicate。</p>
<blockquote>
<p>PS：Predicate中提到的配置都在application-predicate.yml文件中进行修改，并用该配置启动gateway-api服务模块。</p>
</blockquote>
<p><strong>1、After Route Predicate</strong></p>
<blockquote>
<p>在指定时间之后的请求会匹配该路由</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: after_route</span><br><span class="line">          uri: <span class="variable">$&#123;service-url.feign-service&#125;</span></span><br><span class="line">          predicates:</span><br><span class="line">            - After=2020-05-17T18:30:00+08:00[Asia/Shanghai]</span><br></pre></td></tr></table></figure>

<p><strong>2、Before Route Predicate</strong></p>
<blockquote>
<p>在指定时间之前的请求会匹配该路由。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: before_route</span><br><span class="line">          uri: <span class="variable">$&#123;service-url.feign-service&#125;</span></span><br><span class="line">          predicates:</span><br><span class="line">            - Before=2019-12-29T18:30:00+08:00[Asia/Shanghai]</span><br></pre></td></tr></table></figure>

<p><strong>3、Between Route Predicate</strong></p>
<blockquote>
<p>在指定时间区间内的请求会匹配该路由</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: before_route</span><br><span class="line">          uri: <span class="variable">$&#123;service-url.feign-service&#125;</span></span><br><span class="line">          predicates:</span><br><span class="line">            - Between=2019-12-29T18:30:00+08:00[Asia/Shanghai], 2019-12-30T18:30:00+08:00[Asia/Shanghai]</span><br></pre></td></tr></table></figure>

<p><strong>4、Cookie Route Predicate</strong></p>
<blockquote>
<p>带有指定Cookie的请求会匹配该路由</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: cookie_route</span><br><span class="line">          uri: <span class="variable">$&#123;service-url.feign-service&#125;</span></span><br><span class="line">          predicates:</span><br><span class="line">            - Cookie=username,chfsun</span><br></pre></td></tr></table></figure>

<p>使用curl工具发送带有cookie为username=chfsun的请求可以匹配该路由：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://localhost:9202/feign/listDept --cookie <span class="string">"username=chfsun"</span></span><br></pre></td></tr></table></figure>
<p><strong>5、Header Route Predicate</strong></p>
<blockquote>
<p>带有指定请求头的请求会匹配该路由</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: header_route</span><br><span class="line">        uri: <span class="variable">$&#123;service-url.feign-service&#125;</span></span><br><span class="line">        predicates:</span><br><span class="line">        - Header=X-Request-Id, \d+</span><br></pre></td></tr></table></figure>
<p>使用curl工具发送带有请求头为X-Request-Id:123的请求可以匹配该路由:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://localhost:9202/feign/1 -H <span class="string">"X-Request-Id:123"</span></span><br></pre></td></tr></table></figure>

<p><strong>6、Host Route Predicate</strong></p>
<blockquote>
<p>带有指定Host的请求会匹配该路由</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: host_route</span><br><span class="line">          uri: <span class="variable">$&#123;service-url.feign-service&#125;</span></span><br><span class="line">          predicates:</span><br><span class="line">            - Host=**.chfsun.com</span><br></pre></td></tr></table></figure>
<p>使用curl工具发送带有请求头为Host:<a href="http://www.chfsun.com的请求可以匹配该路由：">www.chfsun.com的请求可以匹配该路由：</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://localhost:9202/feign/1 -H <span class="string">"Host:www.chfsun.com"</span></span><br></pre></td></tr></table></figure>


<p><strong>7、Method Route Predicate</strong></p>
<blockquote>
<p>发送指定方法的请求会匹配该路由</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: method_route</span><br><span class="line">        uri: <span class="variable">$&#123;service-url.feign-service&#125;</span></span><br><span class="line">        predicates:</span><br><span class="line">          - Method=GET</span><br></pre></td></tr></table></figure>
<p>7.1、使用curl工具发送GET请求可以匹配该路由</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://localhost:9202/feign/1</span><br></pre></td></tr></table></figure>

<p>7.2、使用curl工具发送POST请求无法匹配该路由</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X POST http://localhost:9202/feign/1</span><br></pre></td></tr></table></figure>

<p><strong>8、Path Route Predicate</strong></p>
<blockquote>
<p>发送指定路径的请求会匹配该路由</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: path_route</span><br><span class="line">          uri: <span class="variable">$&#123;service-url.feign-service&#125;</span>/feign/&#123;id&#125;</span><br><span class="line">          predicates:</span><br><span class="line">            - Path=/feign/&#123;id&#125;</span><br></pre></td></tr></table></figure>
<p>8.1、使用curl工具发送/feign/1路径请求可以匹配该路由</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://localhost:9201/feign/1</span><br></pre></td></tr></table></figure>

<p>8.2、使用curl工具发送/abc/1路径请求无法匹配该路由</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://localhost:9201/abc/1</span><br></pre></td></tr></table></figure>

<p><strong>9、Query Route Predicate</strong></p>
<blockquote>
<p>带指定查询参数的请求可以匹配该路由</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: query_route</span><br><span class="line">        uri: <span class="variable">$&#123;service-url.feign-service&#125;</span>/feign/getByName</span><br><span class="line">        predicates:</span><br><span class="line">        - Query=deptName</span><br></pre></td></tr></table></figure>
<p>9.1、使用curl工具发送带  deptName=开发部  查询参数的请求可以匹配该路由：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://localhost:9202/feign/getByName?deptName=开发部</span><br></pre></td></tr></table></figure>
<p>9.2、使用curl工具发送带不带查询参数的请求无法匹配该路由</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://localhost:9201/feign/getByName</span><br></pre></td></tr></table></figure>

<p><strong>10、RemoteAddr Route Predicate</strong></p>
<blockquote>
<p>从指定远程地址发起的请求可以匹配该路由</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: remoteaddr_route</span><br><span class="line">        uri: <span class="variable">$&#123;service-url.feign-service&#125;</span></span><br><span class="line">        predicates:</span><br><span class="line">          - RemoteAddr=192.168.1.1/24</span><br></pre></td></tr></table></figure>
<p>使用curl工具从192.168.1.1发起请求可以匹配该路由：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://192.168.1.1:9202/feign/1</span><br></pre></td></tr></table></figure>

<p><strong>11、Weight Route Predicate</strong></p>
<blockquote>
<p>使用权重来路由相应请求，以下表示有80%的请求会被路由到localhost:8201，20%会被路由到localhost:8202</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: weight_high</span><br><span class="line">        uri: http://localhost:8201</span><br><span class="line">        predicates:</span><br><span class="line">        - Weight=group1, 8</span><br><span class="line">      - id: weight_low</span><br><span class="line">        uri: http://localhost:8202</span><br><span class="line">        predicates:</span><br><span class="line">        - Weight=group1, 2</span><br></pre></td></tr></table></figure>

<h2 id="三、Route-Filter-的使用"><a href="#三、Route-Filter-的使用" class="headerlink" title="三、Route Filter 的使用"></a>三、Route Filter 的使用</h2><blockquote>
<p>路由过滤器可用于修改进入的HTTP请求和返回的HTTP响应，路由过滤器只能指定路由进行使用。Spring Cloud Gateway 内置了多种路由过滤器，他们都由GatewayFilter的工厂类来产生，下面我们介绍下常用路由过滤器的用法</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200519222131726.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>PS：Filter 中提到的配置都在 application-filter.yml  文件中进行修改，并用该配置启动gateway-api服务模块。</p>
</blockquote>
<p><strong>1、AddRequestParameter GatewayFilter</strong></p>
<blockquote>
<p>给请求添加参数的过滤器</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: add_request_parameter_route</span><br><span class="line">          uri: <span class="variable">$&#123;service-url.feign-service&#125;</span></span><br><span class="line">          filters:</span><br><span class="line">            - AddRequestParameter=deptName, <span class="built_in">test</span></span><br><span class="line">          predicates:</span><br><span class="line">            - Method=GET</span><br></pre></td></tr></table></figure>

<p>以上配置会对GET请求添加 deptName=开发部  的请求参数，通过curl工具使用以下命令进行测试:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://localhost:9203/feign/getByName</span><br></pre></td></tr></table></figure>
<p>相当于发起该请求:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://localhost:8701/feign/getByName?deptName=<span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p><strong>2、StripPrefix GatewayFilter</strong></p>
<blockquote>
<p>对指定数量的路径前缀进行去除的过滤器</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: gateway-api</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: feign_service_route</span><br><span class="line">          <span class="comment"># 匹配后路由地址</span></span><br><span class="line">          uri: <span class="variable">$&#123;service-url.feign-service&#125;</span></span><br><span class="line">          filters:</span><br><span class="line">            - StripPrefix=2</span><br><span class="line">          predicates:</span><br><span class="line">            - Method=GET</span><br></pre></td></tr></table></figure>
<p>以上配置会把以/user-service/开头的请求的路径去除两位，通过curl工具使用以下命令进行测试:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://localhost:9203/hystrix-service/a/feign/1</span><br></pre></td></tr></table></figure>
<p>相当于发起该请求：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://localhost:8701/feign/1</span><br></pre></td></tr></table></figure>


<p><strong>3、PrefixPath GatewayFilter</strong></p>
<blockquote>
<p>与StripPrefix过滤器恰好相反，会对原有路径进行增加操作的过滤器</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: gateway-api</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">	   routes:</span><br><span class="line">        - id: feign_service_route</span><br><span class="line">          <span class="comment"># 匹配后路由地址</span></span><br><span class="line">          uri: <span class="variable">$&#123;service-url.feign-service&#125;</span></span><br><span class="line">          filters:</span><br><span class="line">	            - PrefixPath=/feign</span><br><span class="line">          predicates:</span><br><span class="line">            - Method=GET</span><br></pre></td></tr></table></figure>
<p>以上配置会对所有GET请求添加/user路径前缀，通过curl工具使用以下命令进行测试:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://localhost:9203/1</span><br></pre></td></tr></table></figure>
<p>相当于发起该请求：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://localhost:8701/feign/1</span><br></pre></td></tr></table></figure>

<p><strong>4、Hystrix GatewayFilter</strong></p>
<blockquote>
<p>Hystrix 过滤器允许你将断路器功能添加到网关路由中，使你的服务免受级联故障的影响，并提供服务降级处理</p>
</blockquote>
<p>4.1、要开启断路器功能，我们需要在pom.xml中添加Hystrix的相关依赖：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>4.2、然后添加相关服务降级的处理类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FallbackController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/fallback"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">fallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        result.put(<span class="string">"data"</span>,<span class="keyword">null</span>);</span><br><span class="line">        result.put(<span class="string">"message"</span>,<span class="string">"Get request fallback!"</span>);</span><br><span class="line">        result.put(<span class="string">"code"</span>,<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.3、application-filter.yml中添加相关配置，当路由出错时会转发到服务降级处理的控制器上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: gateway-api</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">	   routes:</span><br><span class="line">        - id: feign_service_route</span><br><span class="line">          <span class="comment"># 匹配后路由地址</span></span><br><span class="line">          uri: <span class="variable">$&#123;service-url.feign-service&#125;</span></span><br><span class="line">          predicates:</span><br><span class="line">            - Method=GET</span><br><span class="line">          filters:</span><br><span class="line">            - name: Hystrix</span><br><span class="line">              args:</span><br><span class="line">                name: fallbackcmd</span><br><span class="line">                fallback-uri: forward:/fallback</span><br></pre></td></tr></table></figure>

<p>4.4、测试：关闭user-service，调用该地址进行测试：<a href="http://localhost:9201/user/1" target="_blank" rel="noopener">http://localhost:9201/user/1</a> ，发现已经返回了服务降级的处理信息</p>
<p><img src="https://img-blog.csdnimg.cn/20200519202337363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>5、RequestRateLimiter GatewayFilter</strong></p>
<blockquote>
<p>RequestRateLimiter 过滤器可以用于限流，使用RateLimiter实现来确定是否允许当前请求继续进行，如果请求太大默认会返回HTTP 429-过多请求状态</p>
</blockquote>
<p>5.1、pom.xml中添加相关依赖：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis-reactive&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>5.2、添加限流策略的配置类，这里有两种策略一种是根据请求参数中的deptNo进行限流，另一种是根据访问IP进行限流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisRateLimiterConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KeyResolver <span class="title">deptKeyResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exchange -&gt; Mono.just(exchange.getRequest().getQueryParams().getFirst(<span class="string">"deptNo"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KeyResolver <span class="title">ipKeyResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exchange -&gt; Mono.just(exchange.getRequest().getRemoteAddress().getHostName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.3、测试<br>使用Redis来进行限流，所以需要添加Redis和RequestRateLimiter的配置，这里对所有的GET请求都进行了按IP来限流的操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: localhost</span><br><span class="line">    password: 123456</span><br><span class="line">    port: 6379</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: requestratelimiter_route</span><br><span class="line">          uri: http://localhost:8201</span><br><span class="line">          filters:</span><br><span class="line">            - name: RequestRateLimiter</span><br><span class="line">              args:</span><br><span class="line">                <span class="comment"># 每秒允许处理的请求数量</span></span><br><span class="line">                redis-rate-limiter.replenishRate: 1</span><br><span class="line">                <span class="comment"># 每秒最大处理的请求数量</span></span><br><span class="line">                redis-rate-limiter.burstCapacity: 2</span><br><span class="line">                <span class="comment"># 限流策略，对应策略的Bean</span></span><br><span class="line">                key-resolver: <span class="string">"#&#123;@ipKeyResolver&#125;"</span></span><br><span class="line">          predicates:</span><br><span class="line">            - Method=GET</span><br><span class="line"></span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    org.springframework.cloud.gateway: debug</span><br></pre></td></tr></table></figure>

<p>多次请求该地址：<a href="http://localhost:9203/feign/1" target="_blank" rel="noopener">http://localhost:9203/feign/1</a> ，会返回状态码为429的错误：</p>
<p><img src="https://img-blog.csdnimg.cn/20200519204340175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>6、Retry GatewayFilter</strong></p>
<blockquote>
<p>对路由请求进行重试的过滤器，可以根据路由请求返回的HTTP状态码来确定是否进行重试</p>
</blockquote>
<blockquote>
<p>有坑，降版本能使用，后续补充</p>
</blockquote>
<p>6.1、修改配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: gateway-api</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: feign_service_route</span><br><span class="line">          <span class="comment"># 匹配后路由地址</span></span><br><span class="line">          uri: <span class="variable">$&#123;service-url.feign-service&#125;</span></span><br><span class="line">        predicates:</span><br><span class="line">         - Method=GET</span><br><span class="line">        filters:</span><br><span class="line">         - name: Retry</span><br><span class="line">         args:</span><br><span class="line">            retries: 1 <span class="comment">#需要进行重试的次数</span></span><br><span class="line">            statuses: BAD_GATEWAY <span class="comment">#返回哪个状态码需要进行重试，返回状态码为5XX进行重试</span></span><br><span class="line">            backoff:</span><br><span class="line">              firstBackoff: 10ms</span><br><span class="line">              maxBackoff: 50ms</span><br><span class="line">              factor: 2</span><br><span class="line">              basedOnPreviousValue: <span class="literal">false</span></span><br></pre></td></tr></table></figure>






<h2 id="四、结合注册中心使用"><a href="#四、结合注册中心使用" class="headerlink" title="四、结合注册中心使用"></a>四、结合注册中心使用</h2><blockquote>
<p>上次讲到 <strong><em>Spring Cloud之-Zuul 服务网关</em></strong> 结合注册中心进行使用时，默认情况下Zuul会根据注册中心注册的服务列表，以服务名为路径创建动态路由，Gateway同样也实现了该功能。下面我们演示下Gateway结合注册中心如何使用默认的动态路由和过滤器</p>
</blockquote>
<p><strong>1、使用动态路由</strong><br>1.1、pom.xml中添加eureka-client相关依赖：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>1.2、添加application-eureka.yml配置文件：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">server</span>:</span><br><span class="line">  <span class="selector-tag">port</span>: 9204</span><br><span class="line"><span class="selector-tag">spring</span>:</span><br><span class="line">  <span class="selector-tag">application</span>:</span><br><span class="line">    <span class="selector-tag">name</span>: <span class="selector-tag">gateway-api</span></span><br><span class="line">  <span class="selector-tag">cloud</span>:</span><br><span class="line">    <span class="selector-tag">gateway</span>:</span><br><span class="line">      <span class="selector-tag">discovery</span>:</span><br><span class="line">        <span class="selector-tag">locator</span>:</span><br><span class="line">          #开启从注册中心动态创建路由的功能</span><br><span class="line">          <span class="selector-tag">enabled</span>: <span class="selector-tag">true</span> </span><br><span class="line">          #使用小写服务名，默认是大写</span><br><span class="line">          <span class="selector-tag">lower-case-service-id</span>: <span class="selector-tag">true</span> </span><br><span class="line"><span class="selector-tag">eureka</span>:</span><br><span class="line">  <span class="selector-tag">client</span>:</span><br><span class="line">    <span class="selector-tag">service-url</span>:</span><br><span class="line">      defaultZone: http://localhost:8001/eureka/</span><br><span class="line"><span class="selector-tag">logging</span>:</span><br><span class="line">  <span class="selector-tag">level</span>:</span><br><span class="line">    <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.cloud</span><span class="selector-class">.gateway</span>: <span class="selector-tag">debug</span></span><br></pre></td></tr></table></figure>

<p>测试：使用application-eureka.yml配置文件启动  gateway-api  服务，访问<a href="http://localhost:9204/feign-service/feign/1，可以路由到" target="_blank" rel="noopener">http://localhost:9204/feign-service/feign/1，可以路由到</a> feign-service 的<a href="http://localhost:8701/feign/1处" target="_blank" rel="noopener">http://localhost:8701/feign/1处</a></p>
<p><strong>2、使用过滤器</strong></p>
<blockquote>
<p>在结合注册中心使用过滤器的时候，我们需要注意的是uri的协议为<strong>lb</strong>，这样才能启用Gateway的负载均衡功能</p>
</blockquote>
<p>修改application-eureka.yml文件，使用了PrefixPath过滤器，会为所有GET请求路径添加 /feign 路径并路由:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">server</span>:</span><br><span class="line">  <span class="selector-tag">port</span>: 9204</span><br><span class="line"><span class="selector-tag">spring</span>:</span><br><span class="line">  <span class="selector-tag">application</span>:</span><br><span class="line">    <span class="selector-tag">name</span>: <span class="selector-tag">gateway-api</span></span><br><span class="line">  <span class="selector-tag">cloud</span>:</span><br><span class="line">    <span class="selector-tag">gateway</span>:</span><br><span class="line">      <span class="selector-tag">discovery</span>:</span><br><span class="line">        <span class="selector-tag">locator</span>:</span><br><span class="line">          #开启从注册中心动态创建路由的功能</span><br><span class="line">          <span class="selector-tag">enabled</span>: <span class="selector-tag">true</span> </span><br><span class="line">          #使用小写服务名，默认是大写</span><br><span class="line">          <span class="selector-tag">lower-case-service-id</span>: <span class="selector-tag">true</span> </span><br><span class="line">      <span class="selector-tag">routes</span>:</span><br><span class="line">        <span class="selector-tag">-</span> <span class="selector-tag">id</span>: <span class="selector-tag">prefixpath_route</span></span><br><span class="line">          #此处需要使用<span class="selector-tag">lb</span>协议</span><br><span class="line">          uri: lb://feign-service </span><br><span class="line">          <span class="selector-tag">predicates</span>:</span><br><span class="line">            - Method=GET</span><br><span class="line">          <span class="selector-tag">filters</span>:</span><br><span class="line">            - PrefixPath=/feign</span><br><span class="line"><span class="selector-tag">eureka</span>:</span><br><span class="line">  <span class="selector-tag">client</span>:</span><br><span class="line">    <span class="selector-tag">service-url</span>:</span><br><span class="line">      defaultZone: http://localhost:8001/eureka/</span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">logging</span>:</span><br><span class="line">  <span class="selector-tag">level</span>:</span><br><span class="line">    <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.cloud</span><span class="selector-class">.gateway</span>: <span class="selector-tag">debug</span></span><br></pre></td></tr></table></figure>

<p>使用application-eureka.yml配置文件启动api-gateway服务，访问<a href="http://localhost:9201/1" target="_blank" rel="noopener">http://localhost:9201/1</a> ，可以路由到feign-service的<a href="http://localhost:8701/feign/1" target="_blank" rel="noopener">http://localhost:8701/feign/1</a> 处</p>
<h2 id="五、使用到的模块"><a href="#五、使用到的模块" class="headerlink" title="五、使用到的模块"></a>五、使用到的模块</h2><p>springcloud-learning<br>├── eureka-server – eureka注册中心<br>├── ribbon-orcl-server-service – 服务提供者<br>├── feign-service – 服务消费者<br>├── hystrix-orcl-client-service – 服务消费者<br>└── gateway-api – gateway作为网关的测试服务</p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>cloud</tag>
        <tag>gateway</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud（13）之 Oauth2授权的使用</title>
    <url>/myblog/spring-cloud/Spring-Cloud%EF%BC%8814%EF%BC%89%E4%B9%8B-Oauth2%E6%8E%88%E6%9D%83%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="OAuth-2-0-的一个简单认识"><a href="#OAuth-2-0-的一个简单认识" class="headerlink" title="OAuth 2.0 的一个简单认识"></a>OAuth 2.0 的一个简单认识</h1><h2 id="为什么需要-OAuth2"><a href="#为什么需要-OAuth2" class="headerlink" title="为什么需要 OAuth2"></a>为什么需要 OAuth2</h2><p>什么是OAuth2？<br>OAuth 2.0 是目前最流行的授权机制，用来授权第三方应用，获取用户数据。</p>
<a id="more"></a>
<p>关于我们为什么需要 OAuth2 的问题，网上的文章很多，我们常见的第三方登录就是一个 OAuth2 的典型应用，阮一峰大佬之前有一篇文章非常形象的解释了这个问题。我们先看一个生活中的例子：</p>
<h3 id="一、生活场景—快递员进小区"><a href="#一、生活场景—快递员进小区" class="headerlink" title="一、生活场景—快递员进小区"></a>一、生活场景—快递员进小区</h3><p>我住在一个大型的居民小区中：</p>
<p><img src="https://img-blog.csdnimg.cn/20200520192352632.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>小区有门禁系统：</p>
<p><img src="https://img-blog.csdnimg.cn/2020052019242362.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>进入的时候需要输入密码：</p>
<p><img src="https://img-blog.csdnimg.cn/20200520192442997.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>我经常网购和外卖，每天都有快递员来送货。我必须找到一个办法，让快递员通过门禁系统，进入小区，不用我自己每次都跑来跑去：</p>
<p><img src="https://img-blog.csdnimg.cn/20200520192529136.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>如果我把自己的密码，告诉快递员，他就拥有了与我同样的权限，这样好像不太合适。万一我想取消他进入小区的权力，也很麻烦，我自己的密码也得跟着改了，还得通知其他的快递员。</p>
<p>有没有一种办法，让快递员能够自由进入小区，又不必知道小区居民的密码，而且他的唯一权限就是送货，其他需要密码的场合，他都没有权限？</p>
<h3 id="二、授权机制的设计"><a href="#二、授权机制的设计" class="headerlink" title="二、授权机制的设计"></a>二、授权机制的设计</h3><p>于是，我设计了一套授权机制。</p>
<p>第一步：</p>
<blockquote>
<p>门禁系统的密码输入器下面，增加一个按钮，叫做”获取授权”。快递员需要首先按这个按钮，去申请授权。</p>
</blockquote>
<p>第二步：</p>
<blockquote>
<p>他按下按钮以后，屋主（也就是我）的手机就会跳出对话框：有人正在要求授权。系统还会显示该快递员的姓名、工号和所属的快递公司。</p>
</blockquote>
<blockquote>
<p>我确认请求属实，就点击按钮，告诉门禁系统，我同意给予他进入小区的授权。</p>
</blockquote>
<p>第三步：</p>
<blockquote>
<p>门禁系统得到我的确认以后，向快递员显示一个进入小区的令牌（access<br>token）。令牌就是类似密码的一串数字，只在短期内（比如七天）有效。</p>
</blockquote>
<p>第四步：</p>
<blockquote>
<p>快递员向门禁系统输入令牌，进入小区。</p>
</blockquote>
<p>有人可能会问，为什么不是远程为快递员开门，而要为他单独生成一个令牌？这是因为快递员可能每天都会来送货，第二天他还可以复用这个令牌。另外，有的小区有多重门禁，快递员可以使用同一个令牌通过它们。</p>
<h3 id="三、互联网场景"><a href="#三、互联网场景" class="headerlink" title="三、互联网场景"></a>三、互联网场景</h3><p>我们把上面的例子搬到互联网，就是 OAuth 的设计了。</p>
<p>首先，居民小区就是储存用户数据的网络服务。比如，微信储存了我的好友信息，获取这些信息，就必须经过微信的”门禁系统”。</p>
<p>其次，快递员（或者说快递公司）就是第三方应用，想要穿过门禁系统，进入小区。</p>
<p>最后，我就是用户本人，同意授权第三方应用进入小区，获取我的数据。</p>
<p><strong>简单说，OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用</strong>。</p>
<h3 id="四、令牌与密码"><a href="#四、令牌与密码" class="headerlink" title="四、令牌与密码"></a>四、令牌与密码</h3><p>令牌（token）与密码（password）的作用是一样的，都可以进入系统，但是有三点差异。</p>
<ol>
<li>令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。</li>
<li>令牌可以被数据所有者撤销，会立即失效。以上例而言，屋主可以随时取消快递员的令牌。密码一般不允许被他人撤销。</li>
<li>令牌有权限范围（scope），比如只能进小区的二号门。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。</li>
</ol>
<p>上面这些设计，保证了令牌既可以让第三方应用获得权限，同时又随时可控，不会危及系统安全。这就是 OAuth 2.0 的优点。</p>
<p>注意，只要知道了令牌，就能进入系统。系统一般不会再次确认身份，所以令牌必须保密，泄漏令牌与泄漏密码的后果是一样的。 这也是为什么令牌的有效期，一般都设置得很短的原因。</p>
<p>OAuth 2.0 对于如何颁发令牌的细节，规定得非常详细。具体来说，一共分成四种授权类型（authorization grant），即四种颁发令牌的方式，适用于不同的互联网场景。</p>
<h2 id="OAuth-2-0-的四种方式"><a href="#OAuth-2-0-的四种方式" class="headerlink" title="OAuth 2.0 的四种方式"></a>OAuth 2.0 的四种方式</h2><h4 id="RFC-6749"><a href="#RFC-6749" class="headerlink" title="RFC 6749"></a>RFC 6749</h4><p>OAuth 2.0 的标准是 RFC 6749 文件。该文件先解释了 OAuth 是什么：</p>
<blockquote>
<p>OAuth 引入了一个授权层，用来分离两种不同的角色：客户端和资源所有者。……资源所有者同意以后，资源服务器可以向客户端颁发令牌。客户端通过令牌，去请求数据</p>
</blockquote>
<p>这段话的意思就是，OAuth 的核心就是向第三方应用颁发令牌。然后，RFC 6749 接着写道：</p>
<blockquote>
<p>（由于互联网有多种场景，）本标准定义了获得令牌的四种授权方式（authorization grant ）</p>
</blockquote>
<p>也就是说，OAuth 2.0 规定了四种获得令牌的流程。你可以选择最适合自己的那一种，向第三方应用颁发令牌。下面就是这四种授权方式:</p>
<blockquote>
<p>1、授权码（authorization-code）<br>2、隐藏式（implicit）<br>3、密码式（password）：<br>4、客户端凭证（client credentials）</p>
</blockquote>
<p>注意，不管哪一种授权方式，第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：<strong>客户端 ID（client ID）</strong>和<strong>客户端密钥（client secret）</strong>。这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的</p>
<p>下面我们分别讲解下四种授权方式：</p>
<h4 id="第一种授权方式：授权码方式"><a href="#第一种授权方式：授权码方式" class="headerlink" title="第一种授权方式：授权码方式"></a>第一种授权方式：授权码方式</h4><p>授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。</p>
<p>这种方式是最常用的流程，安全性也最高，它<strong>适用于那些有后端的 Web 应用</strong>。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。</p>
<p><strong>第一步</strong>，A 网站提供一个链接，用户点击后就会跳转到 B 网站，授权用户数据给 A 网站使用。下面就是 A 网站跳转 B 网站的一个示意链接。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://b.com/oauth/authorize?</span><br><span class="line">  response_type=code&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  redirect_uri=CALLBACK_URL&amp;</span><br><span class="line">  scope=<span class="built_in">read</span></span><br></pre></td></tr></table></figure>
<p>上面 URL 中：</p>
<p><strong>response_type参数</strong>: 表示要求返回授权码（code）</p>
<p><strong>client_id参数</strong>让 B 知道是谁在请求</p>
<p><strong>redirect_uri参数</strong>是 B 接受或拒绝请求后的跳转网址</p>
<p><strong>scope参数</strong>表示要求的授权范围（这里是只读）。</p>
<p><img src="https://img-blog.csdnimg.cn/20200520200803170.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><strong>第二步</strong>，用户跳转后，B 网站会要求用户登录，然后询问是否同意给予 A 网站授权。用户表示同意，这时 B 网站就会跳回redirect_uri参数指定的网址。跳转时，会传回一个授权码，就像下面这样:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://a.com/callback?code=AUTHORIZATION_CODE</span><br></pre></td></tr></table></figure>

<p>上面 URL 中，code参数就是授权码</p>
<p><img src="https://img-blog.csdnimg.cn/20200520200922296.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>第三步</strong>，A 网站拿到授权码以后，就可以在后端，向 B 网站请求令牌:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://b.com/oauth/token?</span><br><span class="line"> client_id=CLIENT_ID&amp;</span><br><span class="line"> client_secret=CLIENT_SECRET&amp;</span><br><span class="line"> grant_type=authorization_code&amp;</span><br><span class="line"> code=AUTHORIZATION_CODE&amp;</span><br><span class="line"> redirect_uri=CALLBACK_URL</span><br></pre></td></tr></table></figure>
<p>上面 URL 中:<br><strong>client_id</strong>参数和<strong>client_secret</strong>参数用来让 B 确认 A 的身份（client_secret参数是保密的，因此只能在后端发请求）</p>
<p><strong>grant_type</strong>参数的值是AUTHORIZATION_CODE，表示采用的授权方式是授权码</p>
<p><strong>code</strong>参数是上一步拿到的授权码</p>
<p><strong>redirect_uri</strong>参数是令牌颁发后的回调网址</p>
<p><img src="https://img-blog.csdnimg.cn/20200520201143677.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><strong>第四步</strong>，B 网站收到请求以后，就会颁发令牌。具体做法是向redirect_uri指定的网址，发送一段 JSON 数据:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">  <span class="string">"access_token"</span>:<span class="string">"ACCESS_TOKEN"</span>,</span><br><span class="line">  <span class="string">"token_type"</span>:<span class="string">"bearer"</span>,</span><br><span class="line">  <span class="string">"expires_in"</span>:2592000,</span><br><span class="line">  <span class="string">"refresh_token"</span>:<span class="string">"REFRESH_TOKEN"</span>,</span><br><span class="line">  <span class="string">"scope"</span>:<span class="string">"read"</span>,</span><br><span class="line">  <span class="string">"uid"</span>:100101,</span><br><span class="line">  <span class="string">"info"</span>:&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面 JSON 数据中，<strong>access_token</strong>字段就是令牌，A 网站在后端拿到了</p>
<p><img src="https://img-blog.csdnimg.cn/20200520201318397.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="第二种方式：隐藏式"><a href="#第二种方式：隐藏式" class="headerlink" title="第二种方式：隐藏式"></a>第二种方式：隐藏式</h4><p>有些 Web 应用是<strong>纯前端应用</strong>，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。RFC 6749 就规定了第二种方式，允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）”隐藏式”（implicit）。</p>
<p><strong>第一步</strong>，A 网站提供一个链接，要求用户跳转到 B 网站，授权用户数据给 A 网站使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://b.com/oauth/authorize?</span><br><span class="line">  response_type=token&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  redirect_uri=CALLBACK_URL&amp;</span><br><span class="line">  scope=<span class="built_in">read</span></span><br></pre></td></tr></table></figure>
<p><strong>上面 URL 中：</strong>response_type参数为token，表示要求直接返回令牌。</p>
<p><strong>第二步</strong>，用户跳转到 B 网站，登录后同意给予 A 网站授权。这时，B 网站就会跳回redirect_uri参数指定的跳转网址，并且把令牌作为 URL 参数，传给 A 网站。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://a.com/callback<span class="comment">#token=ACCESS_TOKEN</span></span><br></pre></td></tr></table></figure>

<p>上面 URL 中：<strong>token</strong>参数就是令牌，A 网站因此直接在前端拿到令牌。</p>
<p>注意，<strong>令牌的位置是 URL 锚点（fragment），而不是查询字符串</strong>（querystring），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在”中间人攻击”的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。</p>
<p><img src="https://img-blog.csdnimg.cn/20200520201655751.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">这种方式把令牌直接传给前端，<strong>是很不安全</strong>的。因此，只能用于一些安全要求不高的场景，并且令牌的有效期必须非常短，通常就是会话期间（session）有效，浏览器关掉，令牌就失效了。</p>
<h4 id="第三种方式：密码式"><a href="#第三种方式：密码式" class="headerlink" title="第三种方式：密码式"></a>第三种方式：密码式</h4><p>如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为”密码式”（password）。</p>
<p><strong>第一步</strong>，A 网站要求用户提供 B 网站的用户名和密码。拿到以后，A 就直接向 B 请求令牌。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://oauth.b.com/token?</span><br><span class="line">  grant_type=password&amp;</span><br><span class="line">  username=USERNAME&amp;</span><br><span class="line">  password=PASSWORD&amp;</span><br><span class="line">  client_id=CLIENT_ID</span><br></pre></td></tr></table></figure>

<p>上面 URL 中：<br><strong>grant_type</strong>参数是授权方式，这里的<strong>password</strong>表示”密码式”，<strong>username</strong>和<strong>password</strong>是 B 的用户名和密码。</p>
<p><strong>第二步</strong>，B 网站验证身份通过后，直接给出令牌。注意，这时不需要跳转，而是把令牌放在 JSON 数据里面，作为 HTTP 回应，A 因此拿到令牌。</p>
<p>这种方式需要用户给出自己的用户名/密码，显然<strong>风险很大，因此只适用于其他授权方式都无法采用的情况，而且必须是用户高度信任的应用</strong>。</p>
<h4 id="第四种方式：凭证式"><a href="#第四种方式：凭证式" class="headerlink" title="第四种方式：凭证式"></a>第四种方式：凭证式</h4><p>凭证式（client credentials），<strong>适用于没有前端的命令行应用，即在命令行下请求令牌</strong>。</p>
<p><strong>第一步</strong>，A 应用在命令行向 B 发出请求。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://oauth.b.com/token?</span><br><span class="line">    grant_type=client_credentials&amp;</span><br><span class="line">    client_id=CLIENT_ID&amp;</span><br><span class="line">    client_secret=CLIENT_SECRET</span><br></pre></td></tr></table></figure>

<p>上面 URL 中：<br><strong>grant_type</strong>参数等于client_credentials表示采用凭证式，</p>
<p><strong>client_id</strong>和<strong>client_secret</strong>用来让 B 确认 A 的身份。</p>
<p><strong>第二步</strong>，B 网站验证通过以后，直接返回令牌。</p>
<p>这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即<strong>有可能多个用户共享同一个令牌</strong>。</p>
<h2 id="令牌的使用"><a href="#令牌的使用" class="headerlink" title="令牌的使用"></a>令牌的使用</h2><p>A 网站拿到令牌以后，就可以向 B 网站的 API 请求数据了。</p>
<p>此时，每个发到 API 的请求，都必须带有令牌。具体做法是在请求的头信息，加上一个Authorization字段，令牌就放在这个字段里面。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -H <span class="string">"Authorization: Bearer ACCESS_TOKEN"</span> \</span><br><span class="line"> <span class="string">"https://api.b.com"</span></span><br></pre></td></tr></table></figure>

<p>上面命令中，<strong>ACCESS_TOKEN</strong>就是拿到的令牌。</p>
<h2 id="更新令牌"><a href="#更新令牌" class="headerlink" title="更新令牌"></a>更新令牌</h2><p>令牌的有效期到了，如果让用户重新走一遍上面的流程，再申请一个新的令牌，很可能体验不好，而且也没有必要。OAuth 2.0 允许用户自动更新令牌。</p>
<p>具体方法是，B 网站颁发令牌的时候，一次性颁发两个令牌，一个用于获取数据，另一个用于获取新的令牌（refresh token 字段）。令牌到期前，用户使用 refresh token 发一个请求，去更新令牌。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://b.com/oauth/token?</span><br><span class="line">     grant_type=refresh_token&amp;</span><br><span class="line">     client_id=CLIENT_ID&amp;</span><br><span class="line">     client_secret=CLIENT_SECRET&amp;</span><br><span class="line">     refresh_token=REFRESH_TOKEN</span><br></pre></td></tr></table></figure>

<p>上面 URL 中：</p>
<p><strong>grant_type参数</strong>为refresh_token表示要求更新令牌</p>
<p><strong>client_id参数</strong>和<strong>client_secret参数</strong>用于确认身份</p>
<p><strong>refresh_token参数</strong>就是用于更新令牌的令牌</p>
<p>B 网站验证通过以后，就会颁发新的令牌。</p>
<h2 id="简化版demo"><a href="#简化版demo" class="headerlink" title="简化版demo"></a>简化版demo</h2><h5 id="1、创建oauth2-server模块"><a href="#1、创建oauth2-server模块" class="headerlink" title="1、创建oauth2-server模块"></a>1、创建oauth2-server模块</h5><blockquote>
<p>仅作为授权服务器来使用</p>
</blockquote>
<h5 id="2、pom文件"><a href="#2、pom文件" class="headerlink" title="2、pom文件"></a>2、pom文件</h5><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h5 id="3、application-yml配置文件："><a href="#3、application-yml配置文件：" class="headerlink" title="3、application.yml配置文件："></a>3、application.yml配置文件：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">9401</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: oauth2-server</span><br></pre></td></tr></table></figure>
<p>4、实体类User：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">UserDetails</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5427258497676274736L</span>;</span><br><span class="line">	<span class="keyword">private</span> String username;</span><br><span class="line">	<span class="keyword">private</span> String password;</span><br><span class="line">	<span class="keyword">private</span> List&lt;GrantedAuthority&gt; authorities;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, String password, List&lt;GrantedAuthority&gt; authorities)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.username = username;</span><br><span class="line">		<span class="keyword">this</span>.password = password;</span><br><span class="line">		<span class="keyword">this</span>.authorities = authorities;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">		<span class="keyword">return</span> authorities;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> password;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> username;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、新建一个UserService实现UserDetailsService接口，用于加载用户信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;User&gt; userList;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String password = passwordEncoder.encode(<span class="string">"123456"</span>);</span><br><span class="line">        userList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="string">"chfsun"</span>,password, AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">"admin"</span>)));</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="string">"andy"</span>,password, AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">"client"</span>)));</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="string">"mark"</span>,password, AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">"client"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        List&lt;User&gt; findUserList = userList.stream().filter(user -&gt; user.getUsername().equals(username)).collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(findUserList)) &#123;</span><br><span class="line">            <span class="keyword">return</span> findUserList.get(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UsernameNotFoundException(<span class="string">"用户名或密码错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6、添加授权服务器配置，使用@EnableAuthorizationServer注解开启：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationServerConfig</span> <span class="keyword">extends</span> <span class="title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用密码模式需要配置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endpoints</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        endpoints.authenticationManager(authenticationManager)</span><br><span class="line">                .userDetailsService(userService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        clients.inMemory()</span><br><span class="line">                <span class="comment">// 配置client_id</span></span><br><span class="line">                .withClient(<span class="string">"admin"</span>)</span><br><span class="line">                <span class="comment">// 配置client_secret</span></span><br><span class="line">                .secret(passwordEncoder.encode(<span class="string">"admin123456"</span>))</span><br><span class="line">                <span class="comment">// 配置访问token的有效期</span></span><br><span class="line">                .accessTokenValiditySeconds(<span class="number">3600</span>)</span><br><span class="line">                <span class="comment">// 配置刷新token的有效期</span></span><br><span class="line">                .refreshTokenValiditySeconds(<span class="number">864000</span>)</span><br><span class="line">                <span class="comment">// 配置redirect_uri,用于授权成功后的跳转</span></span><br><span class="line">                .redirectUris(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">                <span class="comment">// 配置申请的权限范围</span></span><br><span class="line">                .scopes(<span class="string">"all"</span>)</span><br><span class="line">                <span class="comment">// 配置grant_type,表示授权类型</span></span><br><span class="line">                .authorizedGrantTypes(<span class="string">"authorization_code"</span>, <span class="string">"password"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7、添加资源服务器配置，使用@EnableResourceServer注解开启：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableResourceServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceServerConfig</span> <span class="keyword">extends</span> <span class="title">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .anyRequest()</span><br><span class="line">                .authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .requestMatchers()</span><br><span class="line">                <span class="comment">// 配置需要保护的资源路径</span></span><br><span class="line">                .antMatchers(<span class="string">"/user/**"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8、添加SpringSecurity配置，允许授权相关路径的访问及表单登录：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthenticationManager <span class="title">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.csrf()</span><br><span class="line">                .disable()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">"/oauth/**"</span>, <span class="string">"/login/**"</span>, <span class="string">"logout/**"</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .anyRequest()</span><br><span class="line">                .authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .permitAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>9、添加需要登录的接口用于测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/getCurrentUser"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getCurrentUser</span><span class="params">(Authentication authentication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> authentication.getPrincipal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="授权码模式使用"><a href="#授权码模式使用" class="headerlink" title="授权码模式使用"></a>授权码模式使用</h3><p>启动oauth2-server服务；</p>
<p>1、在浏览器访问该地址进行登录授权，你也可以换成页面的超链接：</p>
<p><a href="http://localhost:9401/oauth/authorize?response_type=code&client_id=admin&redirect_uri=http://www.baidu.com&scope=all&state=normal" target="_blank" rel="noopener">http://localhost:9401/oauth/authorize?response_type=code&amp;client_id=admin&amp;redirect_uri=http://www.baidu.com&amp;scope=all&amp;state=normal</a></p>
<p>2、输入账号密码进行登录操作：<br><img src="https://img-blog.csdnimg.cn/20200521010506973.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">3、登录后进行授权操作：<br><img src="https://img-blog.csdnimg.cn/20200521010642201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">4、之后会浏览器会带着授权码跳转到我们指定的路径：<br><img src="https://img-blog.csdnimg.cn/2020052101075654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>5、使用授权码请求该地址获取访问令牌：<a href="http://localhost:9401/oauth/token" target="_blank" rel="noopener">http://localhost:9401/oauth/token</a><br>主要是使用Basic授权通过client_id和client_secret构造一个Authorization头信息：<br><img src="https://img-blog.csdnimg.cn/20200521011000292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>6、在body中添加以下参数信息，注意code的值，通过POST请求获取访问令牌：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">grant_type</span><span class="selector-pseudo">:authorization_code</span></span><br><span class="line"><span class="selector-tag">code</span><span class="selector-pseudo">:0AYFyy</span></span><br><span class="line"><span class="selector-tag">client_id</span><span class="selector-pseudo">:admin</span></span><br><span class="line">redirect_uri:http://www.baidu.com</span><br><span class="line"><span class="selector-tag">scope</span><span class="selector-pseudo">:all</span></span><br></pre></td></tr></table></figure>

<p>6.1、<br><img src="https://img-blog.csdnimg.cn/20200521011213140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">6.2、点击send后：<br><img src="https://img-blog.csdnimg.cn/20200521011352888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">7、在请求头中添加访问令牌，访问需要登录授权的接口进行测试，发现已经可以成功访问：<a href="http://localhost:9401/user/getCurrentUser" target="_blank" rel="noopener">http://localhost:9401/user/getCurrentUser</a><br><img src="https://img-blog.csdnimg.cn/20200521154927769.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h2><p>使用密码请求该地址获取访问令牌：<a href="http://localhost:9401/oauth/token" target="_blank" rel="noopener">http://localhost:9401/oauth/token</a></p>
<p>1、使用Basic授权通过client_id和client_secret构造一个Authorization头信息<br><img src="https://img-blog.csdnimg.cn/20200521011953550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">2、在body中添加以下参数信息，通过POST请求获取访问令牌：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">grant_type</span><span class="selector-pseudo">:password</span></span><br><span class="line"><span class="selector-tag">username</span><span class="selector-pseudo">:chfsun</span></span><br><span class="line"><span class="selector-tag">password</span><span class="selector-pseudo">:123456</span></span><br><span class="line"><span class="selector-tag">scope</span><span class="selector-pseudo">:all</span></span><br></pre></td></tr></table></figure>
<p>3、换取后的令牌<br><img src="https://img-blog.csdnimg.cn/2020052101221360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">使用到的模块</p>
<p>springcloud-learning<br>└── oauth2-server – oauth2授权测试服务</p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>cloud</tag>
        <tag>OAuth2</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud（15）之 Oauth2授权之JWT集成</title>
    <url>/myblog/spring-cloud/Spring-Cloud%EF%BC%8815%EF%BC%89%E4%B9%8B-Oauth2%E6%8E%88%E6%9D%83%E4%B9%8BJWT%E9%9B%86%E6%88%90/</url>
    <content><![CDATA[<h2 id="JWT简介"><a href="#JWT简介" class="headerlink" title="JWT简介"></a>JWT简介</h2><blockquote>
<p>JWT是JSON WEB TOKEN的缩写，它是基于 RFC 7519 标准定义的一种可以安全传输的的JSON对象，由于使用了数字签名，所以是可信任和安全的。</p>
</blockquote>
<p>简单地说，基于JWT的用户验证方案一般都会采用Oauth2的简化方式。通常是认证服务器签发accesstoken，客户端持有accesstoken后就能向资源服务器发起申请。这个做法好处在于无论是认证服务器还是资源服务器都不需要存储用户Token，假设JWT用的算法是对称加密如，那么资源服务器端和认证服务器端持有同样的key即可。</p>
<a id="more"></a>
<p>这种场景非常适合微服务的场景下，将鉴权部分抽象出来作为基础模块，这样每次创建一个新的业务服务时只要调用这个鉴权算法并且持有与认证服务器相同的key即可。这样做的好处在于你JWT可以通过cookie或者是header，完全避免了跨域问题和客户端平台问题。另外一方面这种做法的不足之处持有key的客户端可以无穷端登录或者狂刷你的接口，所以如果使用JWT想要避免这些问题的话也要去做接口防刷与多端登录的方案，如再增加一个redis查询token的环节。</p>
<h4 id="JWT的组成"><a href="#JWT的组成" class="headerlink" title="JWT的组成"></a>JWT的组成</h4><p>JWT token的格式：header+payload+signature</p>
<h6 id="header-中用于存放签名的生成算法："><a href="#header-中用于存放签名的生成算法：" class="headerlink" title="header 中用于存放签名的生成算法："></a><strong>header</strong> 中用于存放签名的生成算法：</h6><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "alg": "HS256",</span><br><span class="line">  "<span class="selector-tag">typ</span>": "<span class="selector-tag">JWT</span>"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="payload-中用于存放数据，比如过期时间、用户名、用户所拥有的权限等："><a href="#payload-中用于存放数据，比如过期时间、用户名、用户所拥有的权限等：" class="headerlink" title="payload 中用于存放数据，比如过期时间、用户名、用户所拥有的权限等："></a><strong>payload</strong> 中用于存放数据，比如过期时间、用户名、用户所拥有的权限等：</h6><p>{<br>  “user_name”: “chfsun”,<br>  “scope”: [<br>    “all”<br>  ],<br>  “exp”: 1577678449,<br>  “authorities”: [<br>    “admin”<br>  ],<br>  “jti”: “618cda6a-dfce-4966-b0df-00607f693ab5”,<br>  “client_id”: “admin”<br>}</p>
<h6 id="signature-为以header和payload生成的签名，一旦header和payload被篡改，验证将失败"><a href="#signature-为以header和payload生成的签名，一旦header和payload被篡改，验证将失败" class="headerlink" title="signature 为以header和payload生成的签名，一旦header和payload被篡改，验证将失败"></a><strong>signature</strong> 为以header和payload生成的签名，一旦header和payload被篡改，验证将失败</h6><h3 id="oauth2中存储令牌的方式"><a href="#oauth2中存储令牌的方式" class="headerlink" title="oauth2中存储令牌的方式:"></a>oauth2中存储令牌的方式:</h3><blockquote>
<p>在上一节中我们都是把令牌存储在内存中的，这样如果部署多个服务，就会导致无法使用令牌的问题。 Spring Cloud Security中有两种存储令牌的方式可用于解决该问题，一种是使用Redis来存储，另一种是使用JWT来存储。</p>
</blockquote>
<p><strong>1、JWT</strong>: 生成并发给客户端之后，后台是不用存储，客户端访问时会验证其签名、过期时间等再取出里面的信息（如username），再使用该信息直接查询用户信息完成登录验证。jwt自带签名、过期等校验，后台不用存储，缺陷是一旦下发，服务后台无法拒绝携带该jwt的请求（如踢除用户）</p>
<p><strong>理论上jwt可以应用在庞大的系统 或者 各自独立的系统 或者 不同人开发的系统；</strong></p>
<p><strong>2、token+redis</strong>： 是自己生成个32位的key，value为用户信息，访问时判断redis里是否有该token，如果有，则加载该用户信息完成登录。服务需要存储下发的每个token及对应的value，维持其过期时间，好处是随时可以删除某个token，阻断该token继续使用</p>
<p><strong>理论上token+redis可以应用在中小的系统里 或者 各系统连系紧密 或者 同一批人开发的系统</strong></p>
<h2 id="示例Demo"><a href="#示例Demo" class="headerlink" title="示例Demo"></a>示例Demo</h2><blockquote>
<p>该模块只是对oauth2-server模块的扩展，直接复制过来在原有基础上扩展下即可</p>
</blockquote>
<h3 id="使用Redis存储令牌"><a href="#使用Redis存储令牌" class="headerlink" title="使用Redis存储令牌"></a>使用Redis存储令牌</h3><p>1、pom.xml中添加Redis相关依赖</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2、配置文件设置：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">server</span>:</span><br><span class="line">  <span class="selector-tag">port</span>: 9401</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">spring</span>:</span><br><span class="line">  <span class="selector-tag">application</span>:</span><br><span class="line">    <span class="selector-tag">name</span>: <span class="selector-tag">oauth2-jwt-server</span></span><br><span class="line">  <span class="selector-tag">redis</span>:</span><br><span class="line">    # <span class="selector-tag">redis</span>相关配置</span><br><span class="line">    <span class="selector-tag">host</span>: <span class="selector-tag">localhost</span></span><br><span class="line">    <span class="selector-tag">database</span>: 0</span><br><span class="line">    <span class="selector-tag">port</span>: 6379</span><br></pre></td></tr></table></figure>

<p>3、添加在Redis中存储令牌的配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTokenStoreConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> RedisConnectionFactory redisConnectionFactory;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> TokenStore <span class="title">redisTokenStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> RedisTokenStore(redisConnectionFactory);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、在授权服务器配置中指定令牌的存储策略为Redis：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationServerConfig</span> <span class="keyword">extends</span> <span class="title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="meta">@Qualifier</span>(<span class="string">"redisTokenStore"</span>)</span><br><span class="line">	<span class="keyword">private</span> TokenStore tokenStore;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 使用密码模式需要配置</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> </span>&#123;</span><br><span class="line">		endpoints.authenticationManager(authenticationManager).userDetailsService(userService)</span><br><span class="line">				<span class="comment">// 配置令牌存储策略</span></span><br><span class="line">				.tokenStore(tokenStore);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//省略代码..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、测试：<br>运行项目后使用最简单的密码模式来获取令牌，访问如下地址：<a href="http://localhost:9401/oauth/token" target="_blank" rel="noopener">http://localhost:9401/oauth/token</a></p>
<p><img src="https://img-blog.csdnimg.cn/20200522154732515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>6、打开ridis，可以发现令牌已经被存储到Redis中：</p>
<p><img src="https://img-blog.csdnimg.cn/20200522154911344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="使用JWT存储令牌"><a href="#使用JWT存储令牌" class="headerlink" title="使用JWT存储令牌"></a>使用JWT存储令牌</h3><p>1、添加使用JWT存储令牌的配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtTokenStoreConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@Primary</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> TokenStore <span class="title">jwtTokenStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> JwtTokenStore(jwtAccessTokenConverter());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> JwtAccessTokenConverter <span class="title">jwtAccessTokenConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		JwtAccessTokenConverter jwtAccessTokenConverter = <span class="keyword">new</span> JwtAccessTokenConverter();</span><br><span class="line">		<span class="comment">// 配置jwt使用的密钥</span></span><br><span class="line">		jwtAccessTokenConverter.setSigningKey(<span class="string">"test_key"</span>);</span><br><span class="line">		<span class="keyword">return</span> jwtAccessTokenConverter;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、在授权服务器配置中指定令牌的存储策略为JWT：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationServerConfig</span> <span class="keyword">extends</span> <span class="title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * @Autowired</span></span><br><span class="line"><span class="comment">	 * @Qualifier("redisTokenStore") </span></span><br><span class="line"><span class="comment">	 * private TokenStore tokenStore;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="meta">@Qualifier</span>(<span class="string">"jwtTokenStore"</span>)</span><br><span class="line">	<span class="keyword">private</span> TokenStore tokenStore;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> JwtAccessTokenConverter jwtAccessTokenConverter;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 使用密码模式需要配置</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> </span>&#123;</span><br><span class="line">		endpoints.authenticationManager(authenticationManager).userDetailsService(userService)</span><br><span class="line">				<span class="comment">// 配置令牌存储策略</span></span><br><span class="line">				.tokenStore(tokenStore)</span><br><span class="line">				.accessTokenConverter(jwtAccessTokenConverter);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//省略代码..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、运行项目后使用密码模式来获取令牌，访问如下地址：<a href="http://localhost:9401/oauth/token" target="_blank" rel="noopener">http://localhost:9401/oauth/token</a>：</p>
<p><img src="https://img-blog.csdnimg.cn/20200522162850936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>4、发现获取到的令牌已经变成了JWT令牌，将access_token拿到<a href="http://jwt.calebb.net/" target="_blank" rel="noopener">http://jwt.calebb.net/</a> 或者 <a href="https://jwt.io/" target="_blank" rel="noopener">https://jwt.io/</a>  网站上去解析下可以获得其中内容：</p>
<p><img src="https://img-blog.csdnimg.cn/20200522163128620.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="JWT中存储内容的扩展"><a href="#JWT中存储内容的扩展" class="headerlink" title="JWT中存储内容的扩展"></a>JWT中存储内容的扩展</h3><blockquote>
<p>有时候我们需要扩展JWT中存储的内容，这里我们在JWT中扩展一个key为app_id，value为 123456 的数据</p>
</blockquote>
<p>1、继承TokenEnhancer实现一个JWT内容增强器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtTokenEnhancer</span> <span class="keyword">implements</span> <span class="title">TokenEnhancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> OAuth2AccessToken <span class="title">enhance</span><span class="params">(OAuth2AccessToken oAuth2AccessToken, OAuth2Authentication oAuth2Authentication)</span> </span>&#123;</span><br><span class="line">		Map&lt;String, Object&gt; info = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		info.put(<span class="string">"app_id"</span>, <span class="string">"123456"</span>);</span><br><span class="line"></span><br><span class="line">		((DefaultOAuth2AccessToken) oAuth2AccessToken).setAdditionalInformation(info);</span><br><span class="line">		<span class="keyword">return</span> oAuth2AccessToken;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、添加一个JwtTokenEnhancer实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtTokenStoreConfig</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略代码...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JwtTokenEnhancer <span class="title">jwtTokenEnhancer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JwtTokenEnhancer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、在授权服务器配置中配置JWT的内容增强器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationServerConfig</span> <span class="keyword">extends</span> <span class="title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"jwtTokenStore"</span>)</span><br><span class="line">    <span class="keyword">private</span> TokenStore tokenStore;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtAccessTokenConverter jwtAccessTokenConverter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtTokenEnhancer jwtTokenEnhancer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用密码模式需要配置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endpoints</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        TokenEnhancerChain tokenEnhancerChain = <span class="keyword">new</span> TokenEnhancerChain();</span><br><span class="line">        List&lt;TokenEnhancer&gt; delegates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 配置jwt内容增强器</span></span><br><span class="line">        delegates.add(jwtTokenEnhancer);</span><br><span class="line">        delegates.add(jwtAccessTokenConverter);</span><br><span class="line">        tokenEnhancerChain.setTokenEnhancers(delegates);</span><br><span class="line"></span><br><span class="line">        endpoints.authenticationManager(authenticationManager)</span><br><span class="line">                .userDetailsService(userService)</span><br><span class="line">                <span class="comment">// 配置令牌存储策略</span></span><br><span class="line">                .tokenStore(tokenStore)</span><br><span class="line">                .accessTokenConverter(jwtAccessTokenConverter)</span><br><span class="line">                .tokenEnhancer(tokenEnhancerChain);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、运行项目后使用密码模式来获取令牌，之后对令牌进行解析，发现已经包含扩展的内容：</p>
<p><img src="https://img-blog.csdnimg.cn/20200522170343596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="Java中解析JWT中的内容"><a href="#Java中解析JWT中的内容" class="headerlink" title="Java中解析JWT中的内容"></a>Java中解析JWT中的内容</h2><blockquote>
<p>如果我们需要获取JWT中的信息，可以使用一个叫jjwt的工具包</p>
</blockquote>
<p>1、pom.xml中添加相关依赖：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--解析JWT中的内容--&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;jjwt&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;0.9.1&lt;/version&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"> &lt;!--工具包--&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;5.1.0&lt;/version&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2、修改UserController类，使用jjwt工具类来解析Authorization头中存储的JWT内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/getCurrentUser"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getCurrentUser</span><span class="params">(Authentication authentication, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        String header = request.getHeader(<span class="string">"Authorization"</span>);</span><br><span class="line">        String token = StrUtil.subAfter(header, <span class="string">"bearer"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Jwts.parser()</span><br><span class="line">                .setSigningKey(<span class="string">"test_key"</span>.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">                .parseClaimsJws(token)</span><br><span class="line">                .getBody();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、将令牌放入Authorization头中，访问如下地址获取信息：<a href="http://localhost:9401/user/getCurrentUser：" target="_blank" rel="noopener">http://localhost:9401/user/getCurrentUser：</a></p>
<p><img src="https://img-blog.csdnimg.cn/20200522171138757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="刷新令牌"><a href="#刷新令牌" class="headerlink" title="刷新令牌"></a>刷新令牌</h2><blockquote>
<p>在Spring Cloud Security 中使用oauth2时，如果令牌失效了，可以使用刷新令牌通过refresh_token的授权模式再次获取access_token</p>
</blockquote>
<p>1、只需修改授权服务器的配置，添加refresh_token的授权模式即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 省略代码</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	clients.inMemory()</span><br><span class="line">			<span class="comment">// 配置client_id</span></span><br><span class="line">			.withClient(<span class="string">"admin"</span>)</span><br><span class="line">			<span class="comment">// 配置client_secret</span></span><br><span class="line">			.secret(passwordEncoder.encode(<span class="string">"admin123456"</span>))</span><br><span class="line">			<span class="comment">// 配置访问token的有效期</span></span><br><span class="line">			.accessTokenValiditySeconds(<span class="number">3600</span>)</span><br><span class="line">			<span class="comment">// 配置刷新token的有效期</span></span><br><span class="line">			.refreshTokenValiditySeconds(<span class="number">864000</span>)</span><br><span class="line">			<span class="comment">// 配置redirect_uri,用于授权成功后的跳转</span></span><br><span class="line">			.redirectUris(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">			<span class="comment">// 自动授权配置</span></span><br><span class="line">			.autoApprove(<span class="keyword">true</span>)</span><br><span class="line">			<span class="comment">// 配置申请的权限范围</span></span><br><span class="line">			.scopes(<span class="string">"all"</span>)</span><br><span class="line">			<span class="comment">// 配置grant_type,表示授权类型</span></span><br><span class="line">			.authorizedGrantTypes(<span class="string">"authorization_code"</span>, <span class="string">"password"</span>, <span class="string">"refresh_token"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略代码</span></span><br></pre></td></tr></table></figure>


<p>2、使用刷新令牌模式来获取新的令牌，访问如下地址：<a href="http://localhost:9401/oauth/token：" target="_blank" rel="noopener">http://localhost:9401/oauth/token：</a></p>
<p><img src="https://img-blog.csdnimg.cn/20200522173211893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>执行后可发现新的令牌已经更新</p>
<h2 id="使用到的模块"><a href="#使用到的模块" class="headerlink" title="使用到的模块"></a>使用到的模块</h2><p>springcloud-learning<br>└── oauth2-jwt-server – 使用jwt的oauth2授权测试服务</p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>cloud</tag>
        <tag>JWT</tag>
        <tag>oauth2</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud（16）之 Oauth2授权之基于JWT完成单点登录</title>
    <url>/myblog/spring-cloud/Spring-Cloud%EF%BC%8816%EF%BC%89%E4%B9%8B-Oauth2%E6%8E%88%E6%9D%83%E4%B9%8B%E5%9F%BA%E4%BA%8EJWT%E5%AE%8C%E6%88%90%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<h2 id="单点登录简介"><a href="#单点登录简介" class="headerlink" title="单点登录简介"></a>单点登录简介</h2><p>单点登录(SingleSign-On，SSO)，就是通过用户的一次性鉴别登录。当用户在身份认证服务器上登录一次以后，即可获得访问单点登录系统中其他关联系统和应用软件的权限，同时这种实现是不需要管理员对用户的登录状态或其他信息进行修改的，这意味着在多个应用系统中，用户只需一次登录就可以访问所有相互信任的应用系统。这种方式减少了由登录产生的时间消耗，辅助了用户管理，是目前比较流行的</p>
<a id="more"></a>
<p>在日常生活中，很多人由于忘记某些网站的登录密码而烦恼，因为大多数用户都要记忆不少于10个用户名和相应密码。</p>
<p>为了便于记忆，很多人都在不同的站点使用相同的用户名和密码，虽然这样可以减少负担，但是同时也降低了安全性，而且使用不同的站点同样要进行多次登录。</p>
<p>同时，随着信息化飞速发展，大型企业和政府部门等都开始使用电子系统进行办公，而且整个办公系统由多个不同的子系统构成，如办公自动化(OA)系统，财务管理系统，档案管理系统，信息查询系统等。如果每个系统都使用独立的登录和验证机制，那么每天工作人员都要登录不同的系统进行办公。用户登录的频繁操作，降低了员工的工作效率，造成工作成本的浪费。</p>
<p>而大量的密码和用户名的记忆时间长了也会出现问题，忘记密码或者混淆密码都会造成很大的麻烦。基于以上原因，为用户提供一个畅通的登录通道变得十分重要。</p>
<p>单点登录(SingleSign-On，SSO)是一种帮助用户快捷访问网络中多个站点的安全通信技术。单点登录系统基于一种安全的通信协议，该协议通过多个系统之间的用户身份信息的交换来实现单点登录。使用单点登录系统时，用户只需要登录一次，就可以访问多个系统，不需要记忆多个口令密码。单点登录使用户可以快速访问网络，从而提高工作效率，同时也能帮助提高系统的安全性。</p>
<p>当然，我们这里主要讨论的是Web系统，确切地讲，应该叫Web SSO。</p>
<h2 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h2><p>我们可以看下阿里生态：</p>
<p>阿里目前给用户提供的服务很庞大，种类也很繁多，我们看几个典型系统应用：淘宝应用、 天猫应用、阿里旅游。这些应用，当用户访问时，都需要登录。</p>
<p>显然，对用户来说，他不希望每个子应用分别登录，因为这都是阿里服务，在用户看来，就相当于一个大系统。</p>
<p>当我在一个应用如淘宝上登录后，再访问阿里旅游、天猫等其它系统，我们发现，系统都显示已登录状态。</p>
<p>当在任意一系统退出登录后，再刷新访问其它系统，均已显示登出状态。</p>
<p>可以看出，阿里实现了SSO。实际上，几乎所有提供复杂服务的互联网公司，都实现了SSO，如阿里、百度、新浪、网易、腾讯、58…</p>
<p><strong>SSO问题，是大中型Web应用经常碰到的问题，</strong><strong>是Java架构师需要掌握的必备技能之一</strong>。中高级以上Web工程师都应对它有个了解。</p>
<p><strong>应用缺点</strong><br>1）不利于重构</p>
<blockquote>
<p>因为涉及到的系统很多，要重构必须要兼容所有的系统，可能很耗时</p>
</blockquote>
<p>2） 无人看守桌面</p>
<blockquote>
<p>因为只需要登录一次，所有的授权的应用系统都可以访问，可能导致一些很重要的信息泄露。</p>
</blockquote>
<h2 id="Demo-示例"><a href="#Demo-示例" class="headerlink" title="Demo 示例"></a>Demo 示例</h2><p>这里我们创建一个oauth2-client服务作为需要登录的客户端服务，使用上一节中的oauth2-jwt-server服务作为授权服务，当我们在oauth2-jwt-server服务上登录以后，就可以直接访问oauth2-client需要登录的接口，来演示下SSO功能</p>
<p>1、创建模块 oauth2-client </p>
<p>2、pom.xml中添加相关依赖：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency</span><br></pre></td></tr></table></figure>
<p>3、application.yml中配置：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">server</span>:</span><br><span class="line">  <span class="selector-tag">port</span>: 9501</span><br><span class="line">  <span class="selector-tag">servlet</span>:</span><br><span class="line">    <span class="selector-tag">session</span>:</span><br><span class="line">      <span class="selector-tag">cookie</span>:</span><br><span class="line">        # 防止<span class="selector-tag">cookie</span>冲突，冲突会导致登录验证不通过</span><br><span class="line">        <span class="selector-tag">name</span>: <span class="selector-tag">OAUTH2-CLIENT-SESSIONID</span></span><br><span class="line"></span><br><span class="line">oauth2-jwt-server-url: http://localhost:9401</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">spring</span>:</span><br><span class="line">  <span class="selector-tag">application</span>:</span><br><span class="line">    <span class="selector-tag">name</span>: <span class="selector-tag">oauth2-client</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">security</span>:</span><br><span class="line">  # 与<span class="selector-tag">oauth2-server</span>对应的配置</span><br><span class="line">  <span class="selector-tag">oauth2</span>:</span><br><span class="line">    <span class="selector-tag">client</span>:</span><br><span class="line">      <span class="selector-tag">client-id</span>: <span class="selector-tag">admin</span></span><br><span class="line">      <span class="selector-tag">client-secret</span>: <span class="selector-tag">admin123456</span></span><br><span class="line">      user-authorization-uri: $&#123;oauth2-jwt-server-url&#125;/oauth/authorize</span><br><span class="line">      access-token-uri: $&#123;oauth2-jwt-server-url&#125;/oauth/token</span><br><span class="line">    <span class="selector-tag">resource</span>:</span><br><span class="line">      <span class="selector-tag">jwt</span>:</span><br><span class="line">        key-uri: $&#123;oauth2-jwt-server-url&#125;/oauth/token_key</span><br></pre></td></tr></table></figure>

<p>4、新建接口用于获取当前登录用户信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/getCurrentUser"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getCurrentUser</span><span class="params">(Authentication authentication)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> authentication;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、修改授权服务器配置：</p>
<blockquote>
<p>修改oauth2-jwt-server模块中的AuthorizationServerConfig类，将绑定的跳转路径为<a href="http://localhost:9501/login，并添加获取秘钥时的身份认证" target="_blank" rel="noopener">http://localhost:9501/login，并添加获取秘钥时的身份认证</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationServerConfig</span> <span class="keyword">extends</span> <span class="title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//以上省略一堆代码...</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        clients.inMemory()</span><br><span class="line">                <span class="comment">// 配置client_id</span></span><br><span class="line">                .withClient(<span class="string">"admin"</span>)</span><br><span class="line">                <span class="comment">// 配置client_secret</span></span><br><span class="line">                .secret(passwordEncoder.encode(<span class="string">"admin123456"</span>))</span><br><span class="line">                <span class="comment">// 配置访问token的有效期</span></span><br><span class="line">                .accessTokenValiditySeconds(<span class="number">3600</span>)</span><br><span class="line">                <span class="comment">// 配置刷新token的有效期</span></span><br><span class="line">                .refreshTokenValiditySeconds(<span class="number">864000</span>)</span><br><span class="line">                <span class="comment">// 配置redirect_uri,用于授权成功后的跳转</span></span><br><span class="line">                <span class="comment">// .redirectUris("http://www.baidu.com")</span></span><br><span class="line">                <span class="comment">// 单点登录时配置</span></span><br><span class="line">                .redirectUris(<span class="string">"http://localhost:9501/login"</span>)</span><br><span class="line">                <span class="comment">// 配置申请的权限范围</span></span><br><span class="line">                .scopes(<span class="string">"all"</span>)</span><br><span class="line">                <span class="comment">// 配置grant_type,表示授权类型</span></span><br><span class="line">                .authorizedGrantTypes(<span class="string">"authorization_code"</span>, <span class="string">"password"</span>, <span class="string">"refresh_token"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerSecurityConfigurer security)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取密钥需要身份认证，使用单点登录时必须配置</span></span><br><span class="line">        security.tokenKeyAccess(<span class="string">"isAuthenticated()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6、在启动类上添加@EnableOAuth2Sso注解来启用单点登录功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableOAuth</span>2Sso</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Oauth2ClientApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(Oauth2ClientApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7、网页单点登录测试：</p>
<p>启动oauth2-jwt-server服务和oauth2-client服务：</p>
<p>访问客户端需要授权的接口  <a href="http://localhost:9501/user/getCurrentUser" target="_blank" rel="noopener">http://localhost:9501/user/getCurrentUser</a> 会跳转到授权服务的登录界面</p>
<p><img src="https://img-blog.csdnimg.cn/20200524220551769.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200524220636614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">)PS:如果需要跳过授权操作进行自动授权可以添加autoApprove(true)配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	clients.inMemory()</span><br><span class="line">			<span class="comment">// 配置client_id</span></span><br><span class="line">			.withClient(<span class="string">"admin"</span>)</span><br><span class="line">			<span class="comment">// 配置client_secret</span></span><br><span class="line">			.secret(passwordEncoder.encode(<span class="string">"admin123456"</span>))</span><br><span class="line">			<span class="comment">// 配置访问token的有效期</span></span><br><span class="line">			.accessTokenValiditySeconds(<span class="number">3600</span>)</span><br><span class="line">			<span class="comment">// 配置刷新token的有效期</span></span><br><span class="line">			.refreshTokenValiditySeconds(<span class="number">864000</span>)</span><br><span class="line">			<span class="comment">// 配置redirect_uri,用于授权成功后的跳转</span></span><br><span class="line">			<span class="comment">// .redirectUris("http://www.baidu.com")</span></span><br><span class="line">			.redirectUris(<span class="string">"http://localhost:9501/login"</span>)</span><br><span class="line">			<span class="comment">// 自动授权配置</span></span><br><span class="line">			.autoApprove(<span class="keyword">true</span>)</span><br><span class="line">			<span class="comment">// 配置申请的权限范围</span></span><br><span class="line">			.scopes(<span class="string">"all"</span>)</span><br><span class="line">			<span class="comment">// 配置grant_type,表示授权类型</span></span><br><span class="line">			.authorizedGrantTypes(<span class="string">"authorization_code"</span>, <span class="string">"password"</span>, <span class="string">"refresh_token"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="调用接口单点登录演示"><a href="#调用接口单点登录演示" class="headerlink" title="调用接口单点登录演示"></a>调用接口单点登录演示</h5><p>访问客户端需要登录的接口：<a href="http://localhost:9501/user/getCurrentUser" target="_blank" rel="noopener">http://localhost:9501/user/getCurrentUser</a></p>
<blockquote>
<p>这里我们使用postman，当然也可以使用postwoman</p>
</blockquote>
<p>使用Oauth2认证方式获取访问令牌：<br>1、<br><img src="https://img-blog.csdnimg.cn/20200524221423434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">2、<br><img src="https://img-blog.csdnimg.cn/20200524221922173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>3、<br><img src="https://img-blog.csdnimg.cn/20200524221824740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">4、登录并且成功后：<br><img src="https://img-blog.csdnimg.cn/20200524222107617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>5、最后请求接口可以获取到如下信息：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "authorities": [</span><br><span class="line">        &#123;</span><br><span class="line">            "authority": "admin"</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    "<span class="selector-tag">details</span>": &#123;</span><br><span class="line">        "remoteAddress": "0:0:0:0:0:0:0:1",</span><br><span class="line">        "<span class="selector-tag">sessionId</span>": "5<span class="selector-tag">E09C9C71104B13454AAF495B797DF98</span>",</span><br><span class="line">        "<span class="selector-tag">tokenValue</span>": "<span class="selector-tag">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</span><span class="selector-class">.eyJ1c2VyX25hbWUiOiJjaGZzdW4iLCJzY29wZSI6WyJhbGwiXSwiZXhwIjoxNTkwMzMzNzk0LCJhcHBfaWQiOiIxMjM0NTYiLCJhdXRob3JpdGllcyI6WyJhZG1pbiJdLCJqdGkiOiI3MTdjYzgzMC0wMThkLTRhOGItYmE2ZC00MGQ3YmExYzVmYTgiLCJjbGllbnRfaWQiOiJhZG1pbiJ9</span><span class="selector-class">.w-HuqHioMrB-ynKzggDw7g9rNZ5FYdZfAG5JwcG71B0</span>",</span><br><span class="line">        "<span class="selector-tag">tokenType</span>": "<span class="selector-tag">bearer</span>",</span><br><span class="line">        "<span class="selector-tag">decodedDetails</span>": <span class="selector-tag">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    "<span class="selector-tag">authenticated</span>": <span class="selector-tag">true</span>,</span><br><span class="line">    "<span class="selector-tag">userAuthentication</span>": &#123;</span><br><span class="line">        "authorities": [</span><br><span class="line">            &#123;</span><br><span class="line">                "authority": "admin"</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        "<span class="selector-tag">details</span>": <span class="selector-tag">null</span>,</span><br><span class="line">        "<span class="selector-tag">authenticated</span>": <span class="selector-tag">true</span>,</span><br><span class="line">        "<span class="selector-tag">principal</span>": "<span class="selector-tag">chfsun</span>",</span><br><span class="line">        "credentials": "N/A",</span><br><span class="line">        "<span class="selector-tag">name</span>": "<span class="selector-tag">chfsun</span>"</span><br><span class="line">    &#125;,</span><br><span class="line">    "<span class="selector-tag">principal</span>": "<span class="selector-tag">chfsun</span>",</span><br><span class="line">    "<span class="selector-tag">credentials</span>": "",</span><br><span class="line">    "<span class="selector-tag">clientOnly</span>": <span class="selector-tag">false</span>,</span><br><span class="line">    "<span class="selector-tag">oauth2Request</span>": &#123;</span><br><span class="line">        "clientId": "admin",</span><br><span class="line">        "scope": [</span><br><span class="line">            "<span class="selector-tag">all</span>"</span><br><span class="line">        ],</span><br><span class="line">        "<span class="selector-tag">requestParameters</span>": &#123;</span><br><span class="line">            "client_id": "admin"</span><br><span class="line">        &#125;,</span><br><span class="line">        "<span class="selector-tag">resourceIds</span>": <span class="selector-attr">[]</span>,</span><br><span class="line">        "<span class="selector-tag">authorities</span>": <span class="selector-attr">[]</span>,</span><br><span class="line">        "<span class="selector-tag">approved</span>": <span class="selector-tag">true</span>,</span><br><span class="line">        "<span class="selector-tag">refresh</span>": <span class="selector-tag">false</span>,</span><br><span class="line">        "<span class="selector-tag">redirectUri</span>": <span class="selector-tag">null</span>,</span><br><span class="line">        "<span class="selector-tag">responseTypes</span>": <span class="selector-attr">[]</span>,</span><br><span class="line">        "<span class="selector-tag">extensions</span>": &#123;&#125;,</span><br><span class="line">        "<span class="selector-tag">grantType</span>": <span class="selector-tag">null</span>,</span><br><span class="line">        "<span class="selector-tag">refreshTokenRequest</span>": <span class="selector-tag">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    "<span class="selector-tag">name</span>": "<span class="selector-tag">chfsun</span>"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="oauth2-client添加权限校验"><a href="#oauth2-client添加权限校验" class="headerlink" title="oauth2-client添加权限校验"></a>oauth2-client添加权限校验</h5><p>1、添加配置开启基于方法的权限校验：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@Order</span>(<span class="number">101</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、在UserController中添加需要admin权限的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/getCurrentUser"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getCurrentUser</span><span class="params">(Authentication authentication)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> authentication;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@PreAuthorize</span>(<span class="string">"hasAuthority('admin')"</span>)</span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/auth/admin"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">adminAuth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Has admin auth!"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、测试：<br>3.1 访问具有 admin 权限的接口：<a href="http://localhost:9501/user/auth/admin" target="_blank" rel="noopener">http://localhost:9501/user/auth/admin</a></p>
<p><img src="https://img-blog.csdnimg.cn/20200524223943156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">3.2、使用没有admin权限的帐号，比如andy:123456获取令牌后访问该接口，会发现没有权限访问：</p>
<p><img src="https://img-blog.csdnimg.cn/2020052423080655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="补充-CAS原理"><a href="#补充-CAS原理" class="headerlink" title="补充 CAS原理"></a>补充 CAS原理</h2><p>说到单点登录，就肯定会见到这个名词：CAS （Central Authentication Service），下面说说CAS是怎么搞的。</p>
<p>如果已经将登录单独抽取成系统出来，我们还能这样做。现在我们有两个系统，分别是<a href="http://www.1.com和www.2.com，一个SSO" target="_blank" rel="noopener">www.1.com和www.2.com，一个SSO</a> <a href="http://www.sso.com" target="_blank" rel="noopener">www.sso.com</a></p>
<p><img src="https://img-blog.csdnimg.cn/20200524234331122.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>首先，用户想要访问系统A  <a href="http://www.1.com受限的资源(比如说购物车功能，购物车功能需要登录后才能访问)，系统A" target="_blank" rel="noopener">www.1.com受限的资源(比如说购物车功能，购物车功能需要登录后才能访问)，系统A</a> <a href="http://www.1.com发现用户并没有登录，于是重定向到sso认证中心，并将自己的地址作为参数。请求的地址如下：">www.1.com发现用户并没有登录，于是重定向到sso认证中心，并将自己的地址作为参数。请求的地址如下：</a></p>
<pre><code>www.sso.com?service=www.1.com</code></pre><p>sso认证中心发现用户未登录，将用户引导至登录页面，用户进行输入用户名和密码进行登录，用户与认证中心建立全局会话（生成一份Token，写到Cookie中，保存在浏览器上）</p>
<p><img src="https://img-blog.csdnimg.cn/20200524234352603.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>随后，认证中心重定向回系统A，并把Token携带过去给系统A，重定向的地址如下：</p>
<pre><code>www.1.com?token=xxxxxxx</code></pre><p>接着，系统A去sso认证中心验证这个Token是否正确，如果正确，则系统A和用户建立局部会话（创建Session）。到此，系统A和用户已经是登录状态了。</p>
<p><img src="https://img-blog.csdnimg.cn/20200524234414526.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>此时，用户想要访问系统B <a href="http://www.2.com受限的资源(比如说订单功能，订单功能需要登录后才能访问)，系统B" target="_blank" rel="noopener">www.2.com受限的资源(比如说订单功能，订单功能需要登录后才能访问)，系统B</a> <a href="http://www.2.com发现用户并没有登录，于是重定向到sso认证中心，并将自己的地址作为参数。请求的地址如下：">www.2.com发现用户并没有登录，于是重定向到sso认证中心，并将自己的地址作为参数。请求的地址如下：</a></p>
<pre><code>www.sso.com?service=www.java4y.com</code></pre><p>注意，因为之前用户与认证中心<a href="http://www.sso.com已经建立了全局会话（当时已经把Cookie保存到浏览器上了），所以这次系统B重定向到认证中心www.sso.com是可以带上Cookie的。" target="_blank" rel="noopener">www.sso.com已经建立了全局会话（当时已经把Cookie保存到浏览器上了），所以这次系统B重定向到认证中心www.sso.com是可以带上Cookie的。</a></p>
<p>认证中心根据带过来的Cookie发现已经与用户建立了全局会话了，认证中心重定向回系统B，并把Token携带过去给系统B，重定向的地址如下：</p>
<pre><code>www.2.com?token=xxxxxxx</code></pre><p>接着，系统B去sso认证中心验证这个Token是否正确，如果正确，则系统B和用户建立局部会话（创建Session）。到此，系统B和用户已经是登录状态了。</p>
<p><img src="https://img-blog.csdnimg.cn/20200524234431613.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>看到这里，其实SSO认证中心就类似一个中转站。</p>
<h2 id="使用到的模块"><a href="#使用到的模块" class="headerlink" title="使用到的模块"></a>使用到的模块</h2><p>springcloud-learning<br>├── oauth2-jwt-server – 使用jwt的oauth2认证测试服务<br>└── oauth2-client – SSO的oauth2客户端服务</p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>cloud</tag>
        <tag>oauth2</tag>
        <tag>SSO</tag>
        <tag>CAS</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud入门（17）之 Nacos实现注册和配置中心</title>
    <url>/myblog/spring-cloud/Spring-Cloud%EF%BC%8817%EF%BC%89%E4%B9%8B-Nacos%E5%AE%9E%E7%8E%B0%E6%B3%A8%E5%86%8C%E5%92%8C%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
    <content><![CDATA[<h2 id="Nacos简介"><a href="#Nacos简介" class="headerlink" title="Nacos简介"></a>Nacos简介</h2><p>Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案，Nacos 作为其核心组件之一，可以作为注册中心和配置中心使用，Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。</p>
<a id="more"></a>
<p>参考：<a href="http://dubbo.apache.org/zh-cn/docs/user/references/registry/nacos.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/user/references/registry/nacos.html</a></p>
<h6 id="Nacos-具有如下特性"><a href="#Nacos-具有如下特性" class="headerlink" title="Nacos 具有如下特性:"></a>Nacos 具有如下特性:</h6><ul>
<li>服务发现和服务健康监测：支持基于DNS和基于RPC的服务发现，支持对服务的实时的健康检查，阻止向不健康的主机或服务实例发送请求；</li>
<li>动态配置服务：动态配置服务可以让您以中心化、外部化和动态化的方式管理所有环境的应用配置和服务配置；</li>
<li>动态 DNS 服务：动态 DNS 服务支持权重路由，让您更容易地实现中间层负载均衡、更灵活的路由策略、流量控制以及数据中心内网的简单DNS解析服务；</li>
<li>服务及其元数据管理：支持从微服务平台建设的视角管理数据中心的所有服务及元数据</li>
</ul>
<h3 id="使用Nacos作为注册中心"><a href="#使用Nacos作为注册中心" class="headerlink" title="使用Nacos作为注册中心"></a>使用Nacos作为注册中心</h3><h4 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h4><p>1、安装并运行Nacos<br>从官网下载Nacos，这里下载的是最新版本 nacos-server-1.2.1.zip 文件，下载地址：<a href="https://github.com/alibaba/nacos/releases" target="_blank" rel="noopener">https://github.com/alibaba/nacos/releases</a></p>
<p>注意：<em>首先要保证你已经配置好JAVA_HOME环境变量，不配置会导致无法运行Nacos；</em></p>
<p>2、解压安装包，直接运行bin目录下的startup.cmd；</p>
<p>运行成功后，访问  <a href="http://localhost:8848/nacos" target="_blank" rel="noopener">http://localhost:8848/nacos</a>  可以查看Nacos的主页，默认账号密码都是nacos</p>
<p><img src="https://img-blog.csdnimg.cn/20200525212728199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h5 id="二、创建应用注册到Nacos"><a href="#二、创建应用注册到Nacos" class="headerlink" title="二、创建应用注册到Nacos"></a>二、创建应用注册到Nacos</h5><p>1、创建 nacos-orcl-service 模块和 nacos-orcl-robbon-service 模块</p>
<p>2、pom文件：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">  &lt;<span class="selector-tag">dependency</span>&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;<span class="selector-tag">dependency</span>&gt;</span><br><span class="line">	&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>注意：如果要使用Spring Cloud Alibaba 的组件都需要在pom.xml中添加有如下的配置，STS一般会自动生成：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">dependencyManagement</span>&gt;</span><br><span class="line">		&lt;<span class="selector-tag">dependencies</span>&gt;</span><br><span class="line">			&lt;<span class="selector-tag">dependency</span>&gt;</span><br><span class="line">				&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;</span><br><span class="line">				&lt;version&gt;$&#123;spring-cloud-alibaba.version&#125;&lt;/version&gt;</span><br><span class="line">				&lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">			&lt;/dependency&gt;</span><br><span class="line">		&lt;/dependencies&gt;</span><br><span class="line">	&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>

<p>3、配置文件：</p>
<blockquote>
<p>这一步，只是演示注册中心，两个模块只要端口不同即可，如服务提供者端口为8206、8207，服务消费者端口为8308</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">server</span>:</span><br><span class="line">  <span class="selector-tag">port</span>: 8206</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">spring</span>:</span><br><span class="line">  <span class="selector-tag">application</span>:</span><br><span class="line">    <span class="selector-tag">name</span>: <span class="selector-tag">nacos-orcl-service</span></span><br><span class="line">  <span class="selector-tag">cloud</span>:</span><br><span class="line">    <span class="selector-tag">nacos</span>:</span><br><span class="line">      <span class="selector-tag">discovery</span>:</span><br><span class="line">        # 配置<span class="selector-tag">Nacos</span>地址</span><br><span class="line">        server-addr: http://localhost:8848</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">management</span>:</span><br><span class="line">  <span class="selector-tag">endpoints</span>:</span><br><span class="line">    <span class="selector-tag">web</span>:</span><br><span class="line">      <span class="selector-tag">exposure</span>:</span><br><span class="line">        include: '*'</span><br></pre></td></tr></table></figure>

<p>4、分别启动两个模块，在Nacos页面上的服务列表中可以看到如下信息：</p>
<p><img src="https://img-blog.csdnimg.cn/20200525221243898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>4.1、点击右侧的详情：</p>
<p><img src="https://img-blog.csdnimg.cn/20200525221431888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h5 id="三、负载均衡功能"><a href="#三、负载均衡功能" class="headerlink" title="三、负载均衡功能"></a>三、负载均衡功能</h5><blockquote>
<p>参考之前的模块 ribbon-orcl-server-service ，完善后启动服务提供者的服务集群</p>
</blockquote>
<blockquote>
<p>参考之前的模块 ribbon-orcl-client-service ，完善后启动服务消费者</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200525223221481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h6 id="负载均衡功能测试："><a href="#负载均衡功能测试：" class="headerlink" title="负载均衡功能测试："></a>负载均衡功能测试：</h6><p>多次调用接口：<a href="http://localhost:8308/ribbon/1" target="_blank" rel="noopener">http://localhost:8308/ribbon/1</a> ，可以发现两个nacos-orcl-service 的控制台交替打印如下信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cn.chfsun.controller.DeptController      : 当前端口为:<span class="number">8207</span>，根据deptNo获取部门信息，部门名称为：开发部</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cn.chfsun.controller.DeptController      : 当前端口为:<span class="number">8206</span>，根据deptNo获取部门信息，部门名称为：开发部</span><br></pre></td></tr></table></figure>


<h5 id="四、使用Nacos作为配置中心"><a href="#四、使用Nacos作为配置中心" class="headerlink" title="四、使用Nacos作为配置中心"></a>四、使用Nacos作为配置中心</h5><p>参考链接：<a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-config" target="_blank" rel="noopener">https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-config</a></p>
<blockquote>
<p>创建nacos-config-client模块，并在Nacos页面中添加配置信息来演示下配置管理的功能</p>
</blockquote>
<p>1、创建nacos-config-client模块</p>
<p>2、pom.xml中相关依赖：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>3、添加配置文件application.yml，启用的是dev环境的配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br></pre></td></tr></table></figure>

<p>4、添加配置文件bootstrap.yml，主要是对Nacos的作为配置中心的功能进行配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">9101</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: nacos-config-client</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        # Nacos地址</span><br><span class="line">        server-addr: http:<span class="comment">//localhost:8848</span></span><br><span class="line">      config:</span><br><span class="line">        # Nacos地址</span><br><span class="line">        server-addr: http:<span class="comment">//localhost:8848</span></span><br><span class="line">        # 这里我们获取的yaml格式的配置</span><br><span class="line">        file-extension: yaml</span><br></pre></td></tr></table></figure>

<p>5、新建ConfigClientController，从Nacos配置中心中获取配置信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Value</span>(<span class="string">"$&#123;config.info&#125;"</span>)</span><br><span class="line">	<span class="keyword">private</span> String configInfo;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/configInfo"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getConfigInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> configInfo;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6、在Nacos中添加配置<br> 6.1、我们先来讲下Nacos中的dataid的组成格式及与SpringBoot配置文件中的属性对应关系：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span><br></pre></td></tr></table></figure>

<p>比如说我们现在要获取应用名称为nacos-config-client的应用在dev环境下的yaml配置，dataid如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">nacos-config-client-dev.yaml</span><br></pre></td></tr></table></figure>
<p>按照以上dataid添加如下配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">config:</span><br><span class="line">  info: <span class="string">"config info for dev"</span></span><br></pre></td></tr></table></figure>

<p>6.2、填写配置示意图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200525225404417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">6.3、</p>
<p><img src="https://img-blog.csdnimg.cn/20200525225421511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">7、启动nacos-config-client，调用接口查看配置信息：<a href="http://localhost:9101/configInfo" target="_blank" rel="noopener">http://localhost:9101/configInfo</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">config info <span class="keyword">for</span> dev</span><br></pre></td></tr></table></figure>

<h5 id="Nacos的动态刷新配置"><a href="#Nacos的动态刷新配置" class="headerlink" title="Nacos的动态刷新配置"></a>Nacos的动态刷新配置</h5><p>我们只要修改下Nacos中的配置信息，再次调用查看配置的接口，就会发现配置已经刷新，Nacos和Consul一样都支持动态刷新配置。当我们在Nacos页面上修改配置并发布后，应用会刷新配置并打印如下信息：</p>
<p><img src="https://img-blog.csdnimg.cn/20200525225753561.png#pic_center" alt="在这里插入图片描述"><br>参考链接：<a href="https://github.com/alibaba/spring-cloud-alibaba/wiki" target="_blank" rel="noopener">https://github.com/alibaba/spring-cloud-alibaba/wiki</a></p>
<h4 id="本章示例使用到的模块"><a href="#本章示例使用到的模块" class="headerlink" title="本章示例使用到的模块"></a>本章示例使用到的模块</h4><p>springcloud-learning<br>├── nacos-config-client – 用于演示nacos作为配置中心的nacos客户端<br>├── nacos-orcl-service – 注册到nacos的服务提供者<br>└── nacos-orcl-robbon-service – 注册到nacos的ribbon服务消费者</p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>cloud</tag>
        <tag>nacos</tag>
        <tag>注册中心</tag>
        <tag>配置中心</tag>
        <tag>Alibaba</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud（18）之 Sentinel实现服务限流、熔断与降级</title>
    <url>/myblog/spring-cloud/Spring-Cloud%EF%BC%8818%EF%BC%89%E4%B9%8B-Sentinel%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E9%99%90%E6%B5%81%E3%80%81%E7%86%94%E6%96%AD%E4%B8%8E%E9%99%8D%E7%BA%A7/</url>
    <content><![CDATA[<h2 id="Sentinel是什么"><a href="#Sentinel是什么" class="headerlink" title="Sentinel是什么"></a>Sentinel是什么</h2><p>Sentinel的官方标题是：分布式系统的流量防卫兵。</p>
<a id="more"></a>
<p>从名字上来看，很容易就能猜到它是用来作服务稳定性保障的。对于服务稳定性保障组件，如果熟悉Spring Cloud的用户，第一反应应该就是Hystrix。但是比较可惜的是Netflix已经宣布对Hystrix停止更新。那么，在未来我们还有什么更好的选择呢？除了Spring Cloud官方推荐的resilience4j之外，目前Spring Cloud Alibaba下整合的Sentinel也是用户可以重点考察和选型的目标。</p>
<p>Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案，Sentinel 作为其核心组件之一，以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p>
<p>Sentinel具有如下特性:</p>
<ul>
<li><p>丰富的应用场景：承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀，可以实时熔断下游不可用应用；</p>
</li>
<li><p>完备的实时监控：同时提供实时的监控功能。可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况；</p>
</li>
<li><p>广泛的开源生态：提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合；</p>
</li>
<li><p>完善的 SPI 扩展点：提供简单易用、完善的 SPI 扩展点。您可以通过实现扩展点，快速的定制逻辑。</p>
</li>
</ul>
<h3 id="安装Sentinel控制台"><a href="#安装Sentinel控制台" class="headerlink" title="安装Sentinel控制台"></a>安装Sentinel控制台</h3><blockquote>
<p>Sentinel控制台是一个轻量级的控制台应用，它可用于实时查看单机资源监控及集群资源汇总，并提供了一系列的规则管理功能，如流控规则、降级规则、热点规则等。</p>
</blockquote>
<p>官网下载Sentinel，本示例下载的是sentinel-dashboard-1.7.1.jar文件，下载地址：<a href="https://github.com/alibaba/Sentinel/releases" target="_blank" rel="noopener">https://github.com/alibaba/Sentinel/releases</a></p>
<p>下载完成后在命令行输入如下命令运行Sentinel控制台：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -jar sentinel-dashboard-<span class="number">1.7</span><span class="number">.1</span>.jar</span><br></pre></td></tr></table></figure>

<p>Sentinel控制台默认运行在8080端口上，登录账号密码均为sentinel，通过如下地址可以进行访问：<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></p>
<p><img src="https://img-blog.csdnimg.cn/20200526171113223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="示例Demo"><a href="#示例Demo" class="headerlink" title="示例Demo"></a>示例Demo</h3><p>1、创建sentinel-service模块</p>
<blockquote>
<p>创建一个sentinel-service模块，用于演示Sentinel的熔断与限流功能</p>
</blockquote>
<p>2、pom文件依赖：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2、application.yml中相关配置，主要是配置了Nacos和Sentinel控制台的地址：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">server</span>:</span><br><span class="line">  <span class="selector-tag">port</span>: 8401</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">spring</span>:</span><br><span class="line">  <span class="selector-tag">application</span>:</span><br><span class="line">    <span class="selector-tag">name</span>: <span class="selector-tag">sentinel-service</span></span><br><span class="line">  <span class="selector-tag">cloud</span>:</span><br><span class="line">    <span class="selector-tag">nacos</span>:</span><br><span class="line">      # 配置<span class="selector-tag">Nacos</span>地址</span><br><span class="line">      server-addr: http://localhost:8848</span><br><span class="line">    <span class="selector-tag">sentinel</span>:</span><br><span class="line">      <span class="selector-tag">transport</span>:</span><br><span class="line">        # 配置<span class="selector-tag">Sentinel</span> <span class="selector-tag">dashborad</span>地址</span><br><span class="line">        dashboard: http://localhost:8080</span><br><span class="line">        <span class="selector-tag">port</span>: 8719</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">service-url</span>:</span><br><span class="line">  dept-service: http://nacos-orcl-service</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">management</span>:</span><br><span class="line">  <span class="selector-tag">endpoints</span>:</span><br><span class="line">    <span class="selector-tag">web</span>:</span><br><span class="line">      <span class="selector-tag">exposure</span>:</span><br><span class="line">        include: '*'</span><br></pre></td></tr></table></figure>

<h4 id="限流功能"><a href="#限流功能" class="headerlink" title="限流功能"></a>限流功能</h4><blockquote>
<p>Sentinel Starter 默认为所有的 HTTP 服务提供了限流埋点，我们也可以通过使用@SentinelResource来自定义一些限流行为</p>
</blockquote>
<p>@SentinelResource注解的属性：</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">作用</th>
<th style="text-align:left">是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">value</td>
<td style="text-align:left">资源名称</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">entryType</td>
<td style="text-align:left">entry类型，标记流量的方向，取值IN/OUT，默认是OUT</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">blockHandler</td>
<td style="text-align:left">处理BlockException的函数名称</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">blockHandlerClass</td>
<td style="text-align:left">存放blockHandler的类。对应的处理函数必须static修饰，否则无法解析，其他要求：同blockHandler</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">fallback</td>
<td style="text-align:left">用于在抛出异常的时候提供fallback处理逻辑。fallback函数可以针对所有类型的异常（除了<code>exceptionsToIgnore</code> 里面排除掉的异常类型）进行处理</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">fallbackClass【1.6支持】</td>
<td style="text-align:left">存放fallback的类。对应的处理函数必须static修饰，否则无法解析，其他要求：同fallback</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">defaultFallback【1.6支持】</td>
<td style="text-align:left">用于通用的 fallback 逻辑。默认fallback函数可以针对所有类型的异常（除了<code>exceptionsToIgnore</code> 里面排除掉的异常类型）进行处理。若同时配置了 fallback 和 defaultFallback，以fallback为准</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">exceptionsToIgnore【1.6支持】</td>
<td style="text-align:left">指定排除掉哪些异常。排除的异常不会计入异常统计，也不会进入fallback逻辑，而是原样抛出</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">exceptionsToTrace</td>
<td style="text-align:left">需要trace的异常</td>
<td style="text-align:left"><code>Throwable</code></td>
</tr>
</tbody>
</table>

<p>blockHandler，处理BlockException函数的要求：</p>
<pre><code>必须是public
返回类型与原方法一致
参数类型需要和原方法相匹配，并在最后加BlockException类型的参数
默认需和原方法在同一个类中。若希望使用其他类的函数，可配置 blockHandlerClass ，并指定blockHandlerClass里面的方法</code></pre><p>fallback函数要求：</p>
<pre><code>返回类型与原方法一致
参数类型需要和原方法相匹配，Sentinel 1.6开始，也可在方法最后加Throwable类型的参数
默认需和原方法在同一个类中。若希望使用其他类的函数，可配置 fallbackClass ，并指定fallbackClass里面的方法</code></pre><p>defaultFallback函数要求：</p>
<pre><code>返回类型与原方法一致
方法参数列表为空，或者有一个Throwable类型的参数
默认需要和原方法在同一个类中。若希望使用其他类的函数，可配置 fallbackClass ，并指定 fallbackClass 里面的方法</code></pre><p>参考链接：<a href="https://github.com/alibaba/Sentinel/blob/1.6.2/sentinel-extension/sentinel-annotation-aspectj/src/test/java/com/alibaba/csp/sentinel/annotation/aspectj/integration/service/FooService.java" target="_blank" rel="noopener">https://github.com/alibaba/Sentinel/blob/1.6.2/sentinel-extension/sentinel-annotation-aspectj/src/test/java/com/alibaba/csp/sentinel/annotation/aspectj/integration/service/FooService.java</a></p>
<p>3、创建RateLimitController类，用于测试熔断和限流功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/rateLimit"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimitController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按资源名称限流，需要指定限流处理逻辑</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/byResource"</span>)</span><br><span class="line">    <span class="meta">@SentinelResource</span>(value = <span class="string">"byResource"</span>, blockHandler = <span class="string">"handleException"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">byResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="string">"按资源名称限流"</span>, <span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按url限流，有默认的限流处理逻辑</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"byUrl"</span>)</span><br><span class="line">    <span class="meta">@SentinelResource</span>(value = <span class="string">"byUrl"</span>, blockHandler = <span class="string">"handleException"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">byUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="string">"按url限流"</span>, <span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">handleException</span><span class="params">(BlockException exception)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result(exception.getClass().getCanonicalName(), <span class="number">200</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h4 id="根据资源名称限流"><a href="#根据资源名称限流" class="headerlink" title="根据资源名称限流"></a>根据资源名称限流</h4><blockquote>
<p>我们可以根据@SentinelResource注解中定义的value（资源名称）来进行限流操作，但是需要指定限流处理逻辑</p>
</blockquote>
<p>流控规则可以在Sentinel控制台进行配置，由于我们使用了Nacos注册中心，我们先启动Nacos和sentinel-service</p>
<p>由于Sentinel采用的懒加载规则，需要我们先访问下接口，Sentinel控制台中才会有对应服务信息，我们先访问下该接口：<a href="http://localhost:8401/rateLimit/byResource" target="_blank" rel="noopener">http://localhost:8401/rateLimit/byResource</a></p>
<p>在Sentinel控制台配置流控规则，根据@SentinelResource注解的value值：</p>
<p><img src="https://img-blog.csdnimg.cn/20200526180354685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h6 id="限流测试"><a href="#限流测试" class="headerlink" title="限流测试"></a>限流测试</h6><p>快速访问上面的接口，可以发现返回了自己定义的限流处理信息：</p>
<p><img src="https://img-blog.csdnimg.cn/20200526180557947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="根据URL限流"><a href="#根据URL限流" class="headerlink" title="根据URL限流"></a>根据URL限流</h4><blockquote>
<p>我们还可以通过访问的URL来限流，会返回默认的限流处理信息</p>
</blockquote>
<p>1、在Sentinel控制台配置流控规则，使用访问的URL：</p>
<p><img src="https://img-blog.csdnimg.cn/20200526181039435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">2、测试，多次访问该接口，会返回默认的限流处理结果：<a href="http://localhost:8401/rateLimit/byUrl" target="_blank" rel="noopener">http://localhost:8401/rateLimit/byUrl</a> </p>
<p><img src="https://img-blog.csdnimg.cn/20200526181113951.png#pic_center" alt="在这里插入图片描述"></p>
<h4 id="自定义限流处理逻辑"><a href="#自定义限流处理逻辑" class="headerlink" title="自定义限流处理逻辑"></a>自定义限流处理逻辑</h4><blockquote>
<p>我们可以自定义通用的限流处理逻辑，然后在@SentinelResource中指定</p>
</blockquote>
<p>1、新建CustomBlockHandler类用于自定义限流处理逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomBlockHandler</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">handleException</span><span class="params">(BlockException exception)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="string">"自定义限流信息"</span>, <span class="number">200</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、在RateLimitController中使用自定义限流处理逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 省略代码</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 自定义通用的限流处理逻辑</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/customBlockHandler"</span>)</span><br><span class="line">	<span class="meta">@SentinelResource</span>(value = <span class="string">"customBlockHandler"</span>, blockHandler = <span class="string">"handleException"</span>, blockHandlerClass = CustomBlockHandler<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">	<span class="title">public</span> <span class="title">Result</span> <span class="title">customBlockHandler</span>() </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="string">"限流成功"</span>, <span class="number">200</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略代码</span></span><br></pre></td></tr></table></figure>
<p>3、在Sentinel控制台配置流控规则，测试结果：</p>
<p><img src="https://img-blog.csdnimg.cn/20200526185501154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="熔断功能"><a href="#熔断功能" class="headerlink" title="熔断功能"></a>熔断功能</h4><blockquote>
<p>Sentinel 支持对服务间调用进行保护，对故障应用进行熔断操作，这里我们使用RestTemplate来调用nacos-orcl-service服务所提供的接口来演示下该功能</p>
</blockquote>
<blockquote>
<p>可参考 模块 ribbon-orcl-client-service</p>
</blockquote>
<p>1、使用@SentinelRestTemplate来包装下RestTemplate实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonConfig</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@LoadBalanced</span></span><br><span class="line">	<span class="meta">@SentinelRestTemplate</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、新建控制层DeptController ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/breaker"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(DeptController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Value</span>(<span class="string">"$&#123;service-url.dept-service&#125;"</span>)</span><br><span class="line">	<span class="keyword">private</span> String deptServiceUrl;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/fallback/&#123;deptNo&#125;"</span>)</span><br><span class="line">	<span class="meta">@SentinelResource</span>(value = <span class="string">"fallback"</span>, fallback = <span class="string">"handleFallback"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Result <span class="title">getDept</span><span class="params">(@PathVariable Integer deptNo)</span> </span>&#123;</span><br><span class="line">		Result forObject = restTemplate.getForObject(deptServiceUrl + <span class="string">"/dept/&#123;1&#125;"</span>, Result<span class="class">.<span class="keyword">class</span>, <span class="title">deptNo</span>)</span>;</span><br><span class="line">		System.out.println(forObject);</span><br><span class="line">		<span class="keyword">return</span> forObject;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/fallbackException/&#123;deptNo&#125;"</span>)</span><br><span class="line">	<span class="meta">@SentinelResource</span>(value = <span class="string">"fallbackException"</span>, fallback = <span class="string">"handleFallback2"</span>, exceptionsToIgnore = &#123;</span><br><span class="line">			NullPointerException<span class="class">.<span class="keyword">class</span> &#125;)</span></span><br><span class="line"><span class="class">	<span class="title">public</span> <span class="title">Result</span> <span class="title">fallbackException</span>(@<span class="title">PathVariable</span> <span class="title">Integer</span> <span class="title">deptNo</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (deptNo == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (deptNo == <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> restTemplate.getForObject(deptServiceUrl + <span class="string">"/dept/&#123;1&#125;"</span>, Result<span class="class">.<span class="keyword">class</span>, <span class="title">deptNo</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Result <span class="title">handleFallback</span><span class="params">(Integer deptNo)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="string">"服务降级返回"</span>, <span class="number">200</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Result <span class="title">handleFallback2</span><span class="params">(Integer deptNo, Throwable e)</span> </span>&#123;</span><br><span class="line">		LOGGER.error(<span class="string">"handleFallback2 id:&#123;&#125;,throwable class:&#123;&#125;"</span>, deptNo, e.getClass());</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="string">"服务降级返回"</span>, <span class="number">200</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、依次启动 nacos-orcl-service、sentinel-service 模块，测试如下：</p>
<p>3.1、浏览器访问 <a href="http://localhost:8401/breaker/fallback/1：" target="_blank" rel="noopener">http://localhost:8401/breaker/fallback/1：</a></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;Result&gt;</span><br><span class="line">&lt;data&gt;</span><br><span class="line">&lt;deptNo&gt;1&lt;/deptNo&gt;</span><br><span class="line">&lt;deptName&gt;开发部&lt;/deptName&gt;</span><br><span class="line">&lt;localtion&gt;西区&lt;/localtion&gt;</span><br><span class="line">&lt;/data&gt;</span><br><span class="line">&lt;message&gt;操作成功&lt;/message&gt;</span><br><span class="line">&lt;code&gt;200&lt;/code&gt;</span><br><span class="line">&lt;/Result&gt;</span><br></pre></td></tr></table></figure>
<p>3.2、浏览器访问 <a href="http://localhost:8401/breaker/fallback/2" target="_blank" rel="noopener">http://localhost:8401/breaker/fallback/2</a>  ：<br>因为数据库并没有2这个编号的数据，因此：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;Result&gt;</span><br><span class="line">&lt;data/&gt;</span><br><span class="line">&lt;message&gt;服务降级返回&lt;/message&gt;</span><br><span class="line">&lt;code&gt;200&lt;/code&gt;</span><br><span class="line">&lt;/Result&gt;</span><br></pre></td></tr></table></figure>
<p>3.3、浏览器访问 <a href="http://localhost:8401/breaker/fallbackException/2" target="_blank" rel="noopener">http://localhost:8401/breaker/fallbackException/2</a><br>由于我们使用了exceptionsToIgnore参数忽略了NullPointerException，所以我们访问接口报空指针时不会发生服务降级，会直接显示：<br><img src="https://img-blog.csdnimg.cn/20200526222044993.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="与Feign结合使用"><a href="#与Feign结合使用" class="headerlink" title="与Feign结合使用"></a>与Feign结合使用</h4><blockquote>
<p>Sentinel也适配了Feign组件，我们使用Feign来进行服务间调用时，也可以使用它来进行熔断</p>
</blockquote>
<blockquote>
<p>可参考 feign-service 模块</p>
</blockquote>
<p>1、pom.xml中添加Feign相关依赖：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>2、application.yml中添加Sentinel对Feign的支持：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 打开sentinel对feign的支持</span><br><span class="line">feign:</span><br><span class="line">  sentinel:</span><br><span class="line">    enabled: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>3、创建一个DeptService接口，用于定义对nacos-orcl-service服务提供者的调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"nacos-orcl-service"</span>, fallback = DeptFallbackService<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">DeptService</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 代码省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、创建DeptFallbackService类实现UserService接口，用于处理服务降级逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptFallbackService</span> <span class="keyword">implements</span> <span class="title">DeptService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 代码省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、新建DeptFeignController类，使用DeptService通过Feign调用nacos-orcl-service服务中的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/feign"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptFeignController</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> DeptService deptService;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 代码省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6、在启动类SentinelServiceApplication添加@EnableFeignClients注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SentinelServiceApplication</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(SentinelServiceApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7、测试<br>调用如下接口会发生服务降级，返回服务降级处理信息：<a href="http://localhost:8401/feign/2" target="_blank" rel="noopener">http://localhost:8401/feign/2</a></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;Result&gt;</span><br><span class="line">&lt;data/&gt;</span><br><span class="line">&lt;message&gt;调用失败，服务被降级&lt;/message&gt;</span><br><span class="line">&lt;code&gt;500&lt;/code&gt;</span><br><span class="line">&lt;/Result&gt;</span><br></pre></td></tr></table></figure>


<h4 id="使用Nacos存储规则"><a href="#使用Nacos存储规则" class="headerlink" title="使用Nacos存储规则"></a>使用Nacos存储规则</h4><blockquote>
<p>默认情况下，当我们在Sentinel控制台中配置规则时，控制台推送规则方式是通过API将规则推送至客户端并直接更新到内存中。一旦我们重启应用，规则将消失。下面我们介绍下如何将配置规则进行持久化，以存储到Nacos为例</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200526223848210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>首先我们直接在配置中心创建规则，配置中心将规则推送到客户端；</p>
<p>Sentinel控制台也从配置中心去获取配置信息。</p>
<h6 id="功能演示"><a href="#功能演示" class="headerlink" title="功能演示"></a>功能演示</h6><p>1、pom文件添加依赖：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2、application.yml配置文件，添加Nacos数据源配置：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">server</span>:</span><br><span class="line">  <span class="selector-tag">port</span>: 8401</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">spring</span>:</span><br><span class="line">  <span class="selector-tag">application</span>:</span><br><span class="line">    <span class="selector-tag">name</span>: <span class="selector-tag">sentinel-service</span></span><br><span class="line">  <span class="selector-tag">cloud</span>:</span><br><span class="line">    <span class="selector-tag">nacos</span>:</span><br><span class="line">      # 配置<span class="selector-tag">Nacos</span>地址</span><br><span class="line">      server-addr: http://localhost:8848</span><br><span class="line">    <span class="selector-tag">sentinel</span>:</span><br><span class="line">      <span class="selector-tag">transport</span>:</span><br><span class="line">        # 配置<span class="selector-tag">Sentinel</span> <span class="selector-tag">dashborad</span>地址</span><br><span class="line">        dashboard: http://localhost:8080</span><br><span class="line">        <span class="selector-tag">port</span>: 8719</span><br><span class="line">      # 添加<span class="selector-tag">Nacos</span>数据源配置</span><br><span class="line">      <span class="selector-tag">datasource</span>:</span><br><span class="line">        <span class="selector-tag">ds1</span>:</span><br><span class="line">          <span class="selector-tag">nacos</span>:</span><br><span class="line">            <span class="selector-tag">server-addr</span>: <span class="selector-tag">localhost</span><span class="selector-pseudo">:8848</span></span><br><span class="line">            dataId: $&#123;spring.application.name&#125;-sentinel</span><br><span class="line">            <span class="selector-tag">groupId</span>: <span class="selector-tag">DEFAULT_GROUP</span></span><br><span class="line">            <span class="selector-tag">data-type</span>: <span class="selector-tag">json</span></span><br><span class="line">            <span class="selector-tag">rule-type</span>: <span class="selector-tag">flow</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">service-url</span>:</span><br><span class="line">  dept-service: http://nacos-orcl-service</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 打开<span class="selector-tag">sentinel</span>对<span class="selector-tag">feign</span>的支持</span><br><span class="line"><span class="selector-tag">feign</span>:</span><br><span class="line">  <span class="selector-tag">sentinel</span>:</span><br><span class="line">    <span class="selector-tag">enabled</span>: <span class="selector-tag">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">management</span>:</span><br><span class="line">  <span class="selector-tag">endpoints</span>:</span><br><span class="line">    <span class="selector-tag">web</span>:</span><br><span class="line">      <span class="selector-tag">exposure</span>:</span><br><span class="line">        include: '*'</span><br></pre></td></tr></table></figure>

<p>3、在Nacos中添加配置：</p>
<p><img src="https://img-blog.csdnimg.cn/20200526224535896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>3.1、信息如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        "resource": "/rateLimit/byUrl",</span><br><span class="line">        "<span class="selector-tag">limitApp</span>": "<span class="selector-tag">default</span>",</span><br><span class="line">        "<span class="selector-tag">grade</span>": 1,</span><br><span class="line">        "<span class="selector-tag">count</span>": 1,</span><br><span class="line">        "<span class="selector-tag">strategy</span>": 0,</span><br><span class="line">        "<span class="selector-tag">controlBehavior</span>": 0,</span><br><span class="line">        "<span class="selector-tag">clusterMode</span>": <span class="selector-tag">false</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong><em>相关参数解释：</em></strong></p>
<ul>
<li><p>resource：资源名称；</p>
</li>
<li><p>limitApp：来源应用；</p>
</li>
<li><p>grade：阈值类型，0表示线程数，1表示QPS；</p>
</li>
<li><p>count：单机阈值；</p>
</li>
<li><p>strategy：流控模式，0表示直接，1表示关联，2表示链路；</p>
</li>
<li><p>controlBehavior：流控效果，0表示快速失败，1表示Warm Up，2表示排队等待；</p>
</li>
<li><p>clusterMode：是否集群。</p>
</li>
</ul>
<p>发现Sentinel控制台已经有了如下限流规则：</p>
<p><img src="https://img-blog.csdnimg.cn/20200526225356433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h6 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h6><p>浏览器快速访问 <a href="http://localhost:8401/rateLimit/byUrl" target="_blank" rel="noopener">http://localhost:8401/rateLimit/byUrl</a><br><img src="https://img-blog.csdnimg.cn/20200526225620512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">)参考资料链接：<a href="https://github.com/alibaba/spring-cloud-alibaba/wiki" target="_blank" rel="noopener">https://github.com/alibaba/spring-cloud-alibaba/wiki</a></p>
<h4 id="本章示例使用到的模块"><a href="#本章示例使用到的模块" class="headerlink" title="本章示例使用到的模块"></a>本章示例使用到的模块</h4><p>springcloud-learning<br>├── nacos-orcl-service – 注册到nacos的服务提供者<br>└── sentinel-service – 注册到nacos的sentinel功能测试服务消费者</p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>cloud</tag>
        <tag>Alibaba</tag>
        <tag>Sentinel</tag>
        <tag>限流</tag>
        <tag>熔断</tag>
        <tag>降级</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud（19）之 Seata处理分布式事务问题</title>
    <url>/myblog/spring-cloud/Spring-Cloud%EF%BC%8819%EF%BC%89%E4%B9%8B-Seata%E5%A4%84%E7%90%86%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="什么是分布式事务？"><a href="#什么是分布式事务？" class="headerlink" title="什么是分布式事务？"></a>什么是分布式事务？</h2><p>分布式事务用于在分布式系统中保证不同节点之间的数据一致性。分布式事务的实现有很多种，最具有代表性的是由Oracle Tuxedo系统提出的XA分布式事务协议。</p>
<a id="more"></a>

<p>XA协议包含两阶段提交（2PC）和三阶段提交（3PC）两种实现，这里我们重点介绍两阶段提交的具体过程。</p>
<p>XA协议的运作方式和游戏中的团队协作有些相似</p>
<p>以魔兽世界（WOW）为例。</p>
<p>在魔兽世界这款游戏中，副本组团打BOSS的时候，为了更方便队长与队员们之间的协作，队长可以发起一个“就位确认”的操作：</p>
<p><img src="https://img-blog.csdnimg.cn/20200528225347735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">当队员收到就位确认提示后，如果已经就位，就选择“是”，如果还没就位，就选择“否”：</p>
<p><img src="https://img-blog.csdnimg.cn/20200528225412112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>当队长收到了所有人的就位确认，就会向所有队员们发布消息，告诉他们开始打BOSS：</p>
<p><img src="https://img-blog.csdnimg.cn/20200528225440786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>相应的，在队长发起就位确认的时候，有可能某些队员还并没有就位：</p>
<p><img src="https://img-blog.csdnimg.cn/2020052822551668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200528225523901.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200528225544443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">以上就是魔兽世界当中组团打BOSS的确认流程。这个流程和XA分布式事务协议的两阶段提交非常相似。</p>
<p>那么XA协议究竟是什么样子呢？在XA协议中包含着两个角色：事务协调者和事务参与者。让我们来看一看他们之间的交互流程：</p>
<p>第一阶段：<br>在XA分布式事务的第一阶段，作为事务协调者的节点会首先向所有的参与者节点发送Prepare请求。<br><img src="https://img-blog.csdnimg.cn/20200528225826237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>在接到Prepare请求之后，每一个参与者节点会各自执行与事务有关的数据更新，写入Undo Log和Redo Log。如果参与者执行成功，暂时不提交事务，而是向事务协调节点返回“完成”消息。</p>
<p>当事务协调者接到了所有参与者的返回消息，整个分布式事务将会进入第二阶段。</p>
<p>第二阶段：</p>
<p><img src="https://img-blog.csdnimg.cn/20200528225857882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>在XA分布式事务的第二阶段，如果事务协调节点在之前所收到都是正向返回，那么它将会向所有事务参与者发出Commit请求。</p>
<p>接到Commit请求之后，事务参与者节点会各自进行本地的事务提交，并释放锁资源。当本地事务完成提交后，将会向事务协调者返回“完成”消息。</p>
<p>当事务协调者接收到所有事务参与者的“完成”反馈，整个分布式事务完成。</p>
<p>以上所描述的是XA两阶段提交的正向流程，接下来我们看一看失败情况的处理流程：</p>
<p>第一阶段：</p>
<p><img src="https://img-blog.csdnimg.cn/20200528225925302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>第二阶段：</p>
<p><img src="https://img-blog.csdnimg.cn/20200528225933296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>在XA的第一阶段，如果某个事务参与者反馈失败消息，说明该节点的本地事务执行不成功，必须回滚。</p>
<p>于是在第二阶段，事务协调节点向所有的事务参与者发送Abort请求。接收到Abort请求之后，各个事务参与者节点需要在本地进行事务的回滚操作，回滚操作依照Undo Log来进行。</p>
<p>以上就是XA两阶段提交协议的详细过程。</p>
<h3 id="XA两阶段提交的不足"><a href="#XA两阶段提交的不足" class="headerlink" title="XA两阶段提交的不足"></a>XA两阶段提交的不足</h3><p>XA两阶段提交究竟有哪些不足呢？</p>
<h6 id="1-性能问题"><a href="#1-性能问题" class="headerlink" title="1.性能问题"></a>1.性能问题</h6><p>XA协议遵循强一致性。在事务执行过程中，各个节点占用着数据库资源，只有当所有节点准备完毕，事务协调者才会通知提交，参与者提交后释放资源。这样的过程有着非常明显的性能问题。</p>
<h6 id="2-协调者单点故障问题"><a href="#2-协调者单点故障问题" class="headerlink" title="2.协调者单点故障问题"></a>2.协调者单点故障问题</h6><p>事务协调者是整个XA模型的核心，一旦事务协调者节点挂掉，参与者收不到提交或是回滚通知，参与者会一直处于中间状态无法完成事务。</p>
<h6 id="3-丢失消息导致的不一致问题。"><a href="#3-丢失消息导致的不一致问题。" class="headerlink" title="3.丢失消息导致的不一致问题。"></a>3.丢失消息导致的不一致问题。</h6><p>在XA协议的第二个阶段，如果发生局部网络问题，一部分事务参与者收到了提交消息，另一部分事务参与者没收到提交消息，那么就导致了节点之间数据的不一致。</p>
<p>如果<strong>避免</strong>XA两阶段提交的种种问题呢？有许多其他的分布式事务方案可供选择：</p>
<h6 id="1-XA三阶段提交"><a href="#1-XA三阶段提交" class="headerlink" title="1.XA三阶段提交"></a>1.XA三阶段提交</h6><p>XA三阶段提交在两阶段提交的基础上增加了CanCommit阶段，并且引入了超时机制。一旦事物参与者迟迟没有接到协调者的commit请求，会自动进行本地commit。这样有效解决了协调者单点故障的问题。但是性能问题和不一致的问题仍然没有根本解决。</p>
<h6 id="2-MQ事务"><a href="#2-MQ事务" class="headerlink" title="2.MQ事务"></a>2.MQ事务</h6><p>利用消息中间件来异步完成事务的后一半更新，实现系统的最终一致性。这个方式避免了像XA协议那样的性能问题。</p>
<h6 id="3-TCC事务"><a href="#3-TCC事务" class="headerlink" title="3.TCC事务"></a>3.TCC事务</h6><p>TCC事务是Try、Commit、Cancel三种指令的缩写，其逻辑模式类似于XA两阶段提交，但是实现方式是在代码层面来人为实现。</p>
<h2 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h2><p>在微服务架构中由于全局数据一致性没法保证产生的问题就是分布式事务问题。简单来说，一次业务操作需要操作多个数据源或需要进行远程调用，就会产生分布式事务问题。</p>
<p>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。</p>
<h6 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h6><ul>
<li>官网：<a href="https://seata.io/zh-cn/index.html" target="_blank" rel="noopener">https://seata.io/zh-cn/index.html</a></li>
<li>seata-server下载链接：<a href="https://github.com/seata/seata/releases/tag/v1.2.0" target="_blank" rel="noopener">https://github.com/seata/seata/releases/tag/v1.2.0</a></li>
<li>seata-server配置官方相关文档：<a href="https://github.com/seata/seata-samples/tree/master/springcloud-nacos-seata" target="_blank" rel="noopener">https://github.com/seata/seata-samples/tree/master/springcloud-nacos-seata</a></li>
<li>官方demo：<a href="https://github.com/seata/seata-samples/tree/master" target="_blank" rel="noopener">https://github.com/seata/seata-samples/tree/master</a></li>
<li>Seata官方文档：<a href="https://github.com/seata/seata/wiki" target="_blank" rel="noopener">https://github.com/seata/seata/wiki</a></li>
</ul>
<h4 id="Seata原理和设计"><a href="#Seata原理和设计" class="headerlink" title="Seata原理和设计"></a>Seata原理和设计</h4><h6 id="定义一个分布式事务"><a href="#定义一个分布式事务" class="headerlink" title="定义一个分布式事务"></a>定义一个分布式事务</h6><p>我们可以把一个分布式事务理解成一个包含了若干分支事务的全局事务，全局事务的职责是协调其下管辖的分支事务达成一致，要么一起成功提交，要么一起失败回滚。此外，通常分支事务本身就是一个满足ACID的本地事务。这是我们对分布式事务结构的基本认识，与 XA 是一致的。</p>
<p>协议分布式事务处理过程的三个组件：</p>
<ul>
<li>Transaction Coordinator (TC)： 事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚；</li>
<li>Transaction Manager ™： 控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议；</li>
<li>Resource Manager (RM)： 控制分支事务，负责分支注册、状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200528230643502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h6 id="一个典型的分布式事务过程"><a href="#一个典型的分布式事务过程" class="headerlink" title="一个典型的分布式事务过程"></a>一个典型的分布式事务过程</h6><ul>
<li>TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的 XID；</li>
<li>XID 在微服务调用链路的上下文中传播；</li>
<li>RM 向 TC 注册分支事务，将其纳入 XID 对应全局事务的管辖；</li>
<li>TM 向 TC 发起针对 XID 的全局提交或回滚决议；</li>
<li>TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200528230803818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="示例版本信息"><a href="#示例版本信息" class="headerlink" title="示例版本信息"></a>示例版本信息</h4><p>JDK : 1.8.0<br>Springboot: 2.2.7.RELEASE<br>Nacos: 2.2.1.RELEASE<br>OpenFeign: 2.2.2.RELEASE<br>Mybatis: 2.1.2</p>
<h6 id="Nacos-及-Seata-版本"><a href="#Nacos-及-Seata-版本" class="headerlink" title="Nacos 及 Seata 版本"></a>Nacos 及 Seata 版本</h6><p>Nacos: 1.2.1<br>Seata: 1.2.0</p>
<h6 id="项目相关其他Jar版本"><a href="#项目相关其他Jar版本" class="headerlink" title="项目相关其他Jar版本"></a>项目相关其他Jar版本</h6><p>Sentinel-dashboard: 1.7.2<br>spring-cloud-starter-alibaba-sentinel: 2.2.1.RELEASE<br>druid: 1.1.22</p>
<p>注意：seata 自v1.0.0起以后的版本压缩包中缺少部分执行文件，自行解决即可</p>
<h4 id="seata-server的安装与配置"><a href="#seata-server的安装与配置" class="headerlink" title="seata-server的安装与配置"></a>seata-server的安装与配置</h4><p>我们先从官网下载seata-server，这里下载的是seata-server-1.2.0.zip，下载地址：<a href="https://github.com/seata/seata/releases" target="_blank" rel="noopener">https://github.com/seata/seata/releases</a></p>
<p>这里我们使用Nacos作为注册中心，具体使用步骤，参考之前项目，此处略过</p>
<p>解压seata-server安装包到指定目录，解压后修改三个配置文件. file.conf, file.conf.example, registry.conf.</p>
<p>file.conf 修改mode=‘db’, 下方Seata数据库地址账号密码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## transaction log store, only used in seata-server</span></span><br><span class="line">store &#123;</span><br><span class="line">  <span class="comment">## store mode: file、db</span></span><br><span class="line">  mode = <span class="string">"db"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## file store property</span></span><br><span class="line">  file &#123;</span><br><span class="line">    <span class="comment">## store location dir</span></span><br><span class="line">    dir = <span class="string">"sessionStore"</span></span><br><span class="line">    <span class="comment"># branch session size , if exceeded first try compress lockkey, still exceeded throws exceptions</span></span><br><span class="line">    maxBranchSessionSize = 16384</span><br><span class="line">    <span class="comment"># globe session size , if exceeded throws exceptions</span></span><br><span class="line">    maxGlobalSessionSize = 512</span><br><span class="line">    <span class="comment"># file buffer size , if exceeded allocate new buffer</span></span><br><span class="line">    fileWriteBufferCacheSize = 16384</span><br><span class="line">    <span class="comment"># when recover batch read size</span></span><br><span class="line">    sessionReloadReadSize = 100</span><br><span class="line">    <span class="comment"># async, sync</span></span><br><span class="line">    flushDiskMode = async</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">## database store property</span></span><br><span class="line">  db &#123;</span><br><span class="line">    <span class="comment">## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp) etc.</span></span><br><span class="line">    datasource = <span class="string">"druid"</span></span><br><span class="line">    <span class="comment">## mysql/oracle/postgresql/h2/oceanbase etc.</span></span><br><span class="line">    dbType = <span class="string">"mysql"</span></span><br><span class="line">    driverClassName = <span class="string">"com.mysql.jdbc.Driver"</span></span><br><span class="line">    url = <span class="string">"jdbc:mysql://127.0.0.1:3306/seata"</span></span><br><span class="line">    user = <span class="string">"mysql"</span></span><br><span class="line">    password = <span class="string">"mysql"</span></span><br><span class="line">    minConn = 5</span><br><span class="line">    maxConn = 30</span><br><span class="line">    globalTable = <span class="string">"global_table"</span></span><br><span class="line">    branchTable = <span class="string">"branch_table"</span></span><br><span class="line">    lockTable = <span class="string">"lock_table"</span></span><br><span class="line">    queryLimit = 100</span><br><span class="line">    maxWait = 5000</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>file.conf.example 修改mode=‘db’, 下方Seata数据库地址账号密码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">transport &#123;</span><br><span class="line">  <span class="comment"># tcp udt unix-domain-socket</span></span><br><span class="line">  <span class="built_in">type</span> = <span class="string">"TCP"</span></span><br><span class="line">  <span class="comment">#NIO NATIVE</span></span><br><span class="line">  server = <span class="string">"NIO"</span></span><br><span class="line">  <span class="comment">#enable heartbeat</span></span><br><span class="line">  heartbeat = <span class="literal">true</span></span><br><span class="line">  <span class="comment"># the client batch send request enable</span></span><br><span class="line">  enableClientBatchSendRequest = <span class="literal">false</span></span><br><span class="line">  <span class="comment">#thread factory for netty</span></span><br><span class="line">  threadFactory &#123;</span><br><span class="line">    bossThreadPrefix = <span class="string">"NettyBoss"</span></span><br><span class="line">    workerThreadPrefix = <span class="string">"NettyServerNIOWorker"</span></span><br><span class="line">    serverExecutorThreadPrefix = <span class="string">"NettyServerBizHandler"</span></span><br><span class="line">    shareBossWorker = <span class="literal">false</span></span><br><span class="line">    clientSelectorThreadPrefix = <span class="string">"NettyClientSelector"</span></span><br><span class="line">    clientSelectorThreadSize = 1</span><br><span class="line">    clientWorkerThreadPrefix = <span class="string">"NettyClientWorkerThread"</span></span><br><span class="line">    <span class="comment"># netty boss thread size,will not be used for UDT</span></span><br><span class="line">    bossThreadSize = 1</span><br><span class="line">    <span class="comment">#auto default pin or 8</span></span><br><span class="line">    workerThreadSize = <span class="string">"default"</span></span><br><span class="line">  &#125;</span><br><span class="line">  shutdown &#123;</span><br><span class="line">    <span class="comment"># when destroy server, wait seconds</span></span><br><span class="line">    <span class="built_in">wait</span> = 3</span><br><span class="line">  &#125;</span><br><span class="line">  serialization = <span class="string">"seata"</span></span><br><span class="line">  compressor = <span class="string">"none"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">## transaction log store, only used in server side</span></span><br><span class="line">store &#123;</span><br><span class="line">  <span class="comment">## store mode: file、db</span></span><br><span class="line">  mode = <span class="string">"db"</span></span><br><span class="line">  <span class="comment">## file store property</span></span><br><span class="line">  file &#123;</span><br><span class="line">    <span class="comment">## store location dir</span></span><br><span class="line">    dir = <span class="string">"sessionStore"</span></span><br><span class="line">    <span class="comment"># branch session size , if exceeded first try compress lockkey, still exceeded throws exceptions</span></span><br><span class="line">    maxBranchSessionSize = 16384</span><br><span class="line">    <span class="comment"># globe session size , if exceeded throws exceptions</span></span><br><span class="line">    maxGlobalSessionSize = 512</span><br><span class="line">    <span class="comment"># file buffer size , if exceeded allocate new buffer</span></span><br><span class="line">    fileWriteBufferCacheSize = 16384</span><br><span class="line">    <span class="comment"># when recover batch read size</span></span><br><span class="line">    sessionReloadReadSize = 100</span><br><span class="line">    <span class="comment"># async, sync</span></span><br><span class="line">    flushDiskMode = async</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">## database store property</span></span><br><span class="line">  db &#123;</span><br><span class="line">    <span class="comment">## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp) etc.</span></span><br><span class="line">    datasource = <span class="string">"druid"</span></span><br><span class="line">    <span class="comment">## mysql/oracle/postgresql/h2/oceanbase etc.</span></span><br><span class="line">    dbType = <span class="string">"mysql"</span></span><br><span class="line">    driverClassName = <span class="string">"com.mysql.jdbc.Driver"</span></span><br><span class="line">    url = <span class="string">"jdbc:mysql://127.0.0.1:3306/seata"</span></span><br><span class="line">    user = <span class="string">"mysql"</span></span><br><span class="line">    password = <span class="string">"mysql"</span></span><br><span class="line">    minConn = 5</span><br><span class="line">    maxConn = 30</span><br><span class="line">    globalTable = <span class="string">"global_table"</span></span><br><span class="line">    branchTable = <span class="string">"branch_table"</span></span><br><span class="line">    lockTable = <span class="string">"lock_table"</span></span><br><span class="line">    queryLimit = 100</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">## server configuration, only used in server side</span></span><br><span class="line">server &#123;</span><br><span class="line">  recovery &#123;</span><br><span class="line">    <span class="comment">#schedule committing retry period in milliseconds</span></span><br><span class="line">    committingRetryPeriod = 1000</span><br><span class="line">    <span class="comment">#schedule asyn committing retry period in milliseconds</span></span><br><span class="line">    asynCommittingRetryPeriod = 1000</span><br><span class="line">    <span class="comment">#schedule rollbacking retry period in milliseconds</span></span><br><span class="line">    rollbackingRetryPeriod = 1000</span><br><span class="line">    <span class="comment">#schedule timeout retry period in milliseconds</span></span><br><span class="line">    timeoutRetryPeriod = 1000</span><br><span class="line">  &#125;</span><br><span class="line">  undo &#123;</span><br><span class="line">    logSaveDays = 7</span><br><span class="line">    <span class="comment">#schedule delete expired undo_log in milliseconds</span></span><br><span class="line">    logDeletePeriod = 86400000</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">#unit ms,s,m,h,d represents milliseconds, seconds, minutes, hours, days, default permanent</span></span><br><span class="line">  maxCommitRetryTimeout = <span class="string">"-1"</span></span><br><span class="line">  maxRollbackRetryTimeout = <span class="string">"-1"</span></span><br><span class="line">  rollbackRetryTimeoutUnlockEnable = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">## metrics configuration, only used in server side</span></span><br><span class="line">metrics &#123;</span><br><span class="line">  enabled = <span class="literal">false</span></span><br><span class="line">  registryType = <span class="string">"compact"</span></span><br><span class="line">  <span class="comment"># multi exporters use comma divided</span></span><br><span class="line">  exporterList = <span class="string">"prometheus"</span></span><br><span class="line">  exporterPrometheusPort = 9898</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>registry.conf registry.type=‘nacos’ 并标明nacos端口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">registry &#123;</span><br><span class="line">  <span class="comment"># file 、nacos 、eureka、redis、zk、consul、etcd3、sofa</span></span><br><span class="line">  <span class="built_in">type</span> = <span class="string">"nacos"</span></span><br><span class="line"></span><br><span class="line">  nacos &#123;</span><br><span class="line">    application = <span class="string">"seata-server"</span></span><br><span class="line">    serverAddr = <span class="string">"localhost:8848"</span></span><br><span class="line">    namespace = <span class="string">""</span></span><br><span class="line">    cluster = <span class="string">"default"</span></span><br><span class="line">    username = <span class="string">""</span></span><br><span class="line">    password = <span class="string">""</span></span><br><span class="line">  &#125;</span><br><span class="line">  eureka &#123;</span><br><span class="line">    serviceUrl = <span class="string">"http://localhost:8761/eureka"</span></span><br><span class="line">    application = <span class="string">"default"</span></span><br><span class="line">    weight = <span class="string">"1"</span></span><br><span class="line">  &#125;</span><br><span class="line">  redis &#123;</span><br><span class="line">    serverAddr = <span class="string">"localhost:6379"</span></span><br><span class="line">    db = 0</span><br><span class="line">    password = <span class="string">""</span></span><br><span class="line">    cluster = <span class="string">"default"</span></span><br><span class="line">    timeout = 0</span><br><span class="line">  &#125;</span><br><span class="line">  zk &#123;</span><br><span class="line">    cluster = <span class="string">"default"</span></span><br><span class="line">    serverAddr = <span class="string">"127.0.0.1:2181"</span></span><br><span class="line">    sessionTimeout = 6000</span><br><span class="line">    connectTimeout = 2000</span><br><span class="line">    username = <span class="string">""</span></span><br><span class="line">    password = <span class="string">""</span></span><br><span class="line">  &#125;</span><br><span class="line">  consul &#123;</span><br><span class="line">    cluster = <span class="string">"default"</span></span><br><span class="line">    serverAddr = <span class="string">"127.0.0.1:8500"</span></span><br><span class="line">  &#125;</span><br><span class="line">  etcd3 &#123;</span><br><span class="line">    cluster = <span class="string">"default"</span></span><br><span class="line">    serverAddr = <span class="string">"http://localhost:2379"</span></span><br><span class="line">  &#125;</span><br><span class="line">  sofa &#123;</span><br><span class="line">    serverAddr = <span class="string">"127.0.0.1:9603"</span></span><br><span class="line">    application = <span class="string">"default"</span></span><br><span class="line">    region = <span class="string">"DEFAULT_ZONE"</span></span><br><span class="line">    datacenter = <span class="string">"DefaultDataCenter"</span></span><br><span class="line">    cluster = <span class="string">"default"</span></span><br><span class="line">    group = <span class="string">"SEATA_GROUP"</span></span><br><span class="line">    addressWaitTime = <span class="string">"3000"</span></span><br><span class="line">  &#125;</span><br><span class="line">  file &#123;</span><br><span class="line">    name = <span class="string">"file.conf"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">config &#123;</span><br><span class="line">  <span class="comment"># file、nacos 、apollo、zk、consul、etcd3</span></span><br><span class="line">  <span class="built_in">type</span> = <span class="string">"file"</span></span><br><span class="line"></span><br><span class="line">  nacos &#123;</span><br><span class="line">    serverAddr = <span class="string">"localhost"</span></span><br><span class="line">    namespace = <span class="string">""</span></span><br><span class="line">    group = <span class="string">"SEATA_GROUP"</span></span><br><span class="line">    username = <span class="string">""</span></span><br><span class="line">    password = <span class="string">""</span></span><br><span class="line">  &#125;</span><br><span class="line">  consul &#123;</span><br><span class="line">    serverAddr = <span class="string">"127.0.0.1:8500"</span></span><br><span class="line">  &#125;</span><br><span class="line">  apollo &#123;</span><br><span class="line">    appId = <span class="string">"seata-server"</span></span><br><span class="line">    apolloMeta = <span class="string">"http://192.168.1.204:8801"</span></span><br><span class="line">    namespace = <span class="string">"application"</span></span><br><span class="line">  &#125;</span><br><span class="line">  zk &#123;</span><br><span class="line">    serverAddr = <span class="string">"127.0.0.1:2181"</span></span><br><span class="line">    sessionTimeout = 6000</span><br><span class="line">    connectTimeout = 2000</span><br><span class="line">    username = <span class="string">""</span></span><br><span class="line">    password = <span class="string">""</span></span><br><span class="line">  &#125;</span><br><span class="line">  etcd3 &#123;</span><br><span class="line">    serverAddr = <span class="string">"http://localhost:2379"</span></span><br><span class="line">  &#125;</span><br><span class="line">  file &#123;</span><br><span class="line">    name = <span class="string">"file.conf"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>启动Nacos, 启动Seata, 若Seata运行无报错且Nacos服务列表存在Seata服务则第一步成功.</p>
<p>Seata数据库配置, 创建表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-- the table to store GlobalSession data</span><br><span class="line">drop table <span class="keyword">if</span> exists `global_table`;</span><br><span class="line">create table `global_table` (</span><br><span class="line">  `xid` varchar(128)  not null,</span><br><span class="line">  `transaction_id` bigint,</span><br><span class="line">  `status` tinyint not null,</span><br><span class="line">  `application_id` varchar(32),</span><br><span class="line">  `transaction_service_group` varchar(32),</span><br><span class="line">  `transaction_name` varchar(128),</span><br><span class="line">  `timeout` int,</span><br><span class="line">  `begin_time` bigint,</span><br><span class="line">  `application_data` varchar(2000),</span><br><span class="line">  `gmt_create` datetime,</span><br><span class="line">  `gmt_modified` datetime,</span><br><span class="line">  primary key (`xid`),</span><br><span class="line">  key `idx_gmt_modified_status` (`gmt_modified`, `status`),</span><br><span class="line">  key `idx_transaction_id` (`transaction_id`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- the table to store BranchSession data</span><br><span class="line">drop table <span class="keyword">if</span> exists `branch_table`;</span><br><span class="line">create table `branch_table` (</span><br><span class="line">  `branch_id` bigint not null,</span><br><span class="line">  `xid` varchar(128) not null,</span><br><span class="line">  `transaction_id` bigint ,</span><br><span class="line">  `resource_group_id` varchar(32),</span><br><span class="line">  `resource_id` varchar(256) ,</span><br><span class="line">  `lock_key` varchar(128) ,</span><br><span class="line">  `branch_type` varchar(8) ,</span><br><span class="line">  `status` tinyint,</span><br><span class="line">  `client_id` varchar(64),</span><br><span class="line">  `application_data` varchar(2000),</span><br><span class="line">  `gmt_create` datetime,</span><br><span class="line">  `gmt_modified` datetime,</span><br><span class="line">  primary key (`branch_id`),</span><br><span class="line">  key `idx_xid` (`xid`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- the table to store lock data</span><br><span class="line">drop table <span class="keyword">if</span> exists `lock_table`;</span><br><span class="line">create table `lock_table` (</span><br><span class="line">  `row_key` varchar(128) not null,</span><br><span class="line">  `xid` varchar(96),</span><br><span class="line">  `transaction_id` long ,</span><br><span class="line">  `branch_id` long,</span><br><span class="line">  `resource_id` varchar(256) ,</span><br><span class="line">  `table_name` varchar(32) ,</span><br><span class="line">  `pk` varchar(36) ,</span><br><span class="line">  `gmt_create` datetime ,</span><br><span class="line">  `gmt_modified` datetime,</span><br><span class="line">  primary key(`row_key`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>其他各服务数据库添加undo_log表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-- the table to store seata xid data</span><br><span class="line">-- 0.7.0+ add context</span><br><span class="line">-- you must to init this sql <span class="keyword">for</span> you business databese. the seata server not need it.</span><br><span class="line">-- 此脚本必须初始化在你当前的业务数据库中，用于AT 模式XID记录。与server端无关（注：业务数据库）</span><br><span class="line">-- 注意此处0.3.0+ 增加唯一索引 ux_undo_log</span><br><span class="line">drop table `undo_log`;</span><br><span class="line">CREATE TABLE `undo_log` (</span><br><span class="line">  `id` bigint(20) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `branch_id` bigint(20) NOT NULL,</span><br><span class="line">  `xid` varchar(100) NOT NULL,</span><br><span class="line">  `context` varchar(128) NOT NULL,</span><br><span class="line">  `rollback_info` longblob NOT NULL,</span><br><span class="line">  `log_status` int(11) NOT NULL,</span><br><span class="line">  `log_created` datetime NOT NULL,</span><br><span class="line">  `log_modified` datetime NOT NULL,</span><br><span class="line">  `ext` varchar(100) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>


<h6 id="客户端服务配置"><a href="#客户端服务配置" class="headerlink" title="客户端服务配置"></a>客户端服务配置</h6><p>对seata-order-service、seata-storage-service和seata-account-service三个seata的客户端进行配置，它们配置大致相同，我们下面以seata-order-service的配置为例。</p>
<p>pom.xml 导入Jar. 每个服务都需导入相关包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">		&lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">		&lt;spring-cloud-alibaba.version&gt;2.2.1.RELEASE&lt;/spring-cloud-alibaba.version&gt;</span><br><span class="line">		&lt;spring-cloud.version&gt;Hoxton.SR4&lt;/spring-cloud.version&gt;</span><br><span class="line">	&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;!--Seata 包--&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">		   &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">		   &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt;</span><br><span class="line">		   &lt;version&gt;2.2.1.RELEASE&lt;/version&gt;</span><br><span class="line">		   &lt;exclusions&gt;</span><br><span class="line">		       &lt;exclusion&gt;</span><br><span class="line">		           &lt;groupId&gt;io.seata&lt;/groupId&gt;</span><br><span class="line">		           &lt;artifactId&gt;seata-all&lt;/artifactId&gt;</span><br><span class="line">		       &lt;/exclusion&gt;</span><br><span class="line">		       &lt;exclusion&gt;</span><br><span class="line">		           &lt;groupId&gt;io.seata&lt;/groupId&gt;</span><br><span class="line">		           &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">		       &lt;/exclusion&gt;</span><br><span class="line">		   &lt;/exclusions&gt;</span><br><span class="line">		  &lt;/dependency&gt;</span><br><span class="line">		  &lt;dependency&gt;</span><br><span class="line">		      &lt;groupId&gt;io.seata&lt;/groupId&gt;</span><br><span class="line">		      &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">		      &lt;version&gt;1.2.0&lt;/version&gt;</span><br><span class="line">		  &lt;/dependency&gt;</span><br><span class="line">		  &lt;dependency&gt;</span><br><span class="line">		      &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">		      &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">		      &lt;version&gt;1.1.22&lt;/version&gt;</span><br><span class="line">		  &lt;/dependency&gt;</span><br><span class="line">		&lt;!--Sentinel-Nacos动态配置--&gt;</span><br><span class="line">		  &lt;dependency&gt;</span><br><span class="line">		      &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;</span><br><span class="line">		      &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;</span><br><span class="line">		      &lt;version&gt;1.7.2&lt;/version&gt;</span><br><span class="line">		  &lt;/dependency&gt;</span><br><span class="line">		 &lt;!--ORM--&gt;</span><br><span class="line">		 &lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;2.1.2&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		 &lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">			&lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;cn.chfsun&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;result-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;1.0&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">			&lt;scope&gt;<span class="built_in">test</span>&lt;/scope&gt;</span><br><span class="line">			&lt;exclusions&gt;</span><br><span class="line">				&lt;exclusion&gt;</span><br><span class="line">					&lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;</span><br><span class="line">					&lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;</span><br><span class="line">				&lt;/exclusion&gt;</span><br><span class="line">			&lt;/exclusions&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">	&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencyManagement&gt;</span><br><span class="line">		&lt;dependencies&gt;</span><br><span class="line">			&lt;dependency&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">				&lt;version&gt;<span class="variable">$&#123;spring-cloud.version&#125;</span>&lt;/version&gt;</span><br><span class="line">				&lt;<span class="built_in">type</span>&gt;pom&lt;/<span class="built_in">type</span>&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">			&lt;/dependency&gt;</span><br><span class="line">			&lt;dependency&gt;</span><br><span class="line">				&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;</span><br><span class="line">				&lt;version&gt;<span class="variable">$&#123;spring-cloud-alibaba.version&#125;</span>&lt;/version&gt;</span><br><span class="line">				&lt;<span class="built_in">type</span>&gt;pom&lt;/<span class="built_in">type</span>&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">			&lt;/dependency&gt;</span><br><span class="line">		&lt;/dependencies&gt;</span><br><span class="line">	&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>

<h6 id="配置文件设置："><a href="#配置文件设置：" class="headerlink" title="配置文件设置："></a>配置文件设置：</h6><p>bootstrap.yml：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  nacos-host: localhost</span><br><span class="line">  nacos-port: 8848</span><br><span class="line">  application:</span><br><span class="line">    name: xxx-server</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: <span class="variable">$&#123;spring.nacos-host&#125;</span>:<span class="variable">$&#123;spring.nacos-port&#125;</span></span><br><span class="line">      config:</span><br><span class="line">        server-addr: <span class="variable">$&#123;spring.nacos-host&#125;</span>:<span class="variable">$&#123;spring.nacos-port&#125;</span></span><br><span class="line">        file-extension: yaml</span><br><span class="line">    <span class="comment">#Sentinel-Nacos 配置</span></span><br><span class="line">    sentinel:</span><br><span class="line">      datasource:</span><br><span class="line">        ds:</span><br><span class="line">          nacos:</span><br><span class="line">            server-addr: <span class="variable">$&#123;spring.nacos-host&#125;</span>:<span class="variable">$&#123;spring.nacos-port&#125;</span></span><br><span class="line">            data-id: <span class="variable">$&#123;spring.application.name&#125;</span>-sentinel</span><br><span class="line">            groupId: FLOW</span><br><span class="line">            rule-type: flow</span><br></pre></td></tr></table></figure>

<p>application.yml：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br></pre></td></tr></table></figure>

<p>application-dev.yml：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8002</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: xxx-server <span class="comment"># 应用名称 自定义</span></span><br><span class="line">    host: localhost</span><br><span class="line">  <span class="comment"># druid 数据源配置</span></span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql://localhost:3308/xxx业务数据库?allowMultiQueries=<span class="literal">true</span>&amp;autoReconnect=<span class="literal">true</span>&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useUnicode=<span class="literal">true</span>&amp;serverTimezone=Asia/Shanghai&amp;nullCatalogMeansCurrent=<span class="literal">true</span></span><br><span class="line">    username: mysql</span><br><span class="line">    password: mysql</span><br><span class="line">    <span class="built_in">type</span>: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    filters: <span class="built_in">stat</span>,wall,slf4j</span><br><span class="line">    maxActive: 20</span><br><span class="line">    initialSize: 5</span><br><span class="line">    maxWait: 60000</span><br><span class="line">    minIdle: 5</span><br><span class="line">    timeBetweenEvictionRunsMillis: 60000</span><br><span class="line">    minEvictableIdleTimeMillis: 300000</span><br><span class="line">    validationQuery: SELECT 1 FROM DUAL</span><br><span class="line">    testWhileIdle: <span class="literal">true</span></span><br><span class="line">    testOnBorrow: <span class="literal">false</span></span><br><span class="line">    testOnReturn: <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 打开PSCache，并且指定每个连接上PSCache的大小</span></span><br><span class="line">    poolPreparedStatements: <span class="literal">true</span></span><br><span class="line">    maxPoolPreparedStatementPerConnectionSize: 20</span><br><span class="line">    <span class="comment"># 通过connectProperties属性来打开mergeSql功能；慢SQL记录</span></span><br><span class="line">    connectionProperties: druid.stat.mergeSql=<span class="literal">true</span>;druid.stat.slowSqlMillis=5000</span><br><span class="line"></span><br><span class="line">  main:</span><br><span class="line">    allow-bean-definition-overriding: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 连接控制台</span></span><br><span class="line">  cloud:</span><br><span class="line">    sentinel:</span><br><span class="line">      transport:</span><br><span class="line">        port: 7001</span><br><span class="line">        dashboard: <span class="variable">$&#123;spring.application.host&#125;</span>:8080</span><br><span class="line"></span><br><span class="line">mybatis-plus:</span><br><span class="line">  global-config:</span><br><span class="line">    db-config:</span><br><span class="line">      id-type: auto</span><br><span class="line">      <span class="comment"># 表名前缀</span></span><br><span class="line">      table-prefix: <span class="string">'xxx'</span></span><br><span class="line">  configuration:</span><br><span class="line">    <span class="comment"># 驼峰下划线映射</span></span><br><span class="line">    map-underscore-to-camel-case: <span class="literal">true</span></span><br><span class="line">    cache-enabled: <span class="literal">false</span></span><br><span class="line">  <span class="comment">#  config-location: classpath:mybatis/mybatis.cfg.xml</span></span><br><span class="line">  mapper-locations: classpath:mapper/*.xml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启Sentinel熔断器</span></span><br><span class="line">feign:</span><br><span class="line">  sentinel:</span><br><span class="line">    enabled: <span class="literal">true</span></span><br><span class="line"><span class="comment"># 饿加载开启 Feign 预加载, 防止第一次请求超时</span></span><br><span class="line">ribbon:</span><br><span class="line">  eager-load:</span><br><span class="line">    enabled: <span class="literal">true</span></span><br><span class="line">    clients: xxx-server, xxx-server</span><br><span class="line"></span><br><span class="line">seata:</span><br><span class="line">  application-id: <span class="variable">$&#123;spring.application.name&#125;</span> <span class="comment"># Seata 应用名称，默认使用 $&#123;spring.application.name&#125;</span></span><br><span class="line">  tx-service-group: default <span class="comment"># Seata 事务组, 高版本没找到相关配置, 是否可配置未知 选用默认default</span></span><br><span class="line">  <span class="comment"># 服务配置项</span></span><br><span class="line">  service:</span><br><span class="line">    <span class="comment"># 虚拟组和分组的映射 1.0.0以上好像将vgroup-mapping 改为 vgroupMapping, 此处是否影响未测试</span></span><br><span class="line">    vgroupMapping:</span><br><span class="line">      <span class="comment"># 此处Key对应 tx-service-group 的 Value, 此处 value 默认 default</span></span><br><span class="line">      default: default</span><br><span class="line">    <span class="comment"># 分组和 Seata 服务的映射 默认端口8091</span></span><br><span class="line">    grouplist:</span><br><span class="line">      default: 127.0.0.1:8091</span><br></pre></td></tr></table></figure>

<p>功能代码开发，可使用mybatis或者MP都可，部分代码：</p>
<p>使用@GlobalTransactional注解开启分布式事务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(OrderServiceImpl<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderMapper orderMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StorageService storageService; <span class="comment">// 使用feign远程调用</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService; <span class="comment">// 使用feign远程调用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建订单-&gt;调用库存服务扣减库存-&gt;调用账户服务扣减账户余额-&gt;修改订单状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@GlobalTransactional</span>(name = <span class="string">"my-test-create-order"</span>,rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">void</span> <span class="title">create</span>(<span class="title">Order</span> <span class="title">order</span>) </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"-------&gt;下单开始"</span>);</span><br><span class="line">        <span class="comment">//本应用创建订单</span></span><br><span class="line">        orderMapper.create(order);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//远程调用库存服务扣减库存</span></span><br><span class="line">        LOGGER.info(<span class="string">"-------&gt;order-service中扣减库存开始"</span>);</span><br><span class="line">        storageService.decrease(order.getProductId(),order.getCount());</span><br><span class="line">        LOGGER.info(<span class="string">"-------&gt;order-service中扣减库存结束"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//远程调用账户服务扣减余额</span></span><br><span class="line">        LOGGER.info(<span class="string">"-------&gt;order-service中扣减余额开始"</span>);</span><br><span class="line">        accountService.decrease(order.getUserId(),order.getMoney());</span><br><span class="line">        LOGGER.info(<span class="string">"-------&gt;order-service中扣减余额结束"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改订单状态为已完成</span></span><br><span class="line">        LOGGER.info(<span class="string">"-------&gt;order-service中修改订单状态开始"</span>);</span><br><span class="line">        orderMapper.update(order.getUserId(),<span class="number">0</span>);</span><br><span class="line">        LOGGER.info(<span class="string">"-------&gt;order-service中修改订单状态结束"</span>);</span><br><span class="line"></span><br><span class="line">        LOGGER.info(<span class="string">"-------&gt;下单结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS:其余代码因为过于简单，使用之前的知识即可解决，此处省略。</p>
<h6 id="分布式事务功能演示"><a href="#分布式事务功能演示" class="headerlink" title="分布式事务功能演示"></a>分布式事务功能演示</h6><p>运行seata-order-service、seata-storage-service和seata-account-service三个服务；</p>
<p>seata-server和上面三个服务启动成功后，nacos的服务列表如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200530163055750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>seata-server控制台的界面如下：<br><img src="https://img-blog.csdnimg.cn/2020053016330655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">数据库初始信息状态：</p>
<p><img src="https://img-blog.csdnimg.cn/20200530163443725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">调用接口进行下单操作后查看数据库：<a href="http://localhost:8180/order/create?userId=1&amp;productId=1&amp;count=10&amp;money=100" target="_blank" rel="noopener">http://localhost:8180/order/create?userId=1&amp;productId=1&amp;count=10&amp;money=100</a></p>
<p>返回信息：</p>
<p><img src="https://img-blog.csdnimg.cn/20200530163527792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200530163631156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>继续测试，在seata-account-service中制造一个超时异常后，调用下单接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(AccountService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 创建订单-&gt;调用库存服务扣减库存-&gt;调用账户服务扣减账户余额-&gt;修改订单状态</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@GlobalTransactional</span>(name = <span class="string">"my-test-decrease-account"</span>, rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">	<span class="title">public</span> <span class="title">void</span> <span class="title">decrease</span>(<span class="title">Long</span> <span class="title">userId</span>, <span class="title">BigDecimal</span> <span class="title">money</span>) </span>&#123;</span><br><span class="line">		LOGGER.info(<span class="string">"-------&gt;account-service中扣减账户余额开始"</span>);</span><br><span class="line">		<span class="comment">// 模拟超时异常，全局事务回滚</span></span><br><span class="line">	    <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">30</span>*<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">	     &#125;</span><br><span class="line">		accountMapper.update(userId, money);</span><br><span class="line">		LOGGER.info(<span class="string">"-------&gt;account-service中扣减账户余额结束"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时我们可以发现下单后数据库数据并没有任何改变：</p>
<p><img src="https://img-blog.csdnimg.cn/20200530163949731.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>继续测试，在seata-order-service中注释掉@GlobalTransactional来看看没有Seata的分布式事务管理会发生什么情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(OrderService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Resource</span></span><br><span class="line">	<span class="keyword">private</span> AccountService accountService;</span><br><span class="line">	<span class="meta">@Resource</span></span><br><span class="line">	<span class="keyword">private</span> StorageService storageService;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> OrderMapper orderMapper;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 创建订单-&gt;调用库存服务扣减库存-&gt;调用账户服务扣减账户余额-&gt;修改订单状态</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//@GlobalTransactional(name = "fsp-create-order", rollbackFor = Exception.class)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">		LOGGER.info(<span class="string">"-------&gt;下单开始"</span>);</span><br><span class="line">		<span class="comment">// 本应用创建订单</span></span><br><span class="line">		orderMapper.insert(order);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 远程调用库存服务扣减库存</span></span><br><span class="line">		LOGGER.info(<span class="string">"-------&gt;order-service中扣减库存开始"</span>);</span><br><span class="line">		storageService.decrease(order.getProductId(), order.getCount());</span><br><span class="line">		LOGGER.info(<span class="string">"-------&gt;order-service中扣减库存结束"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 远程调用账户服务扣减余额</span></span><br><span class="line">		LOGGER.info(<span class="string">"-------&gt;order-service中扣减余额开始"</span>);</span><br><span class="line">		accountService.decrease(order.getUserId(), order.getMoney());</span><br><span class="line">		LOGGER.info(<span class="string">"-------&gt;order-service中扣减余额结束"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 修改订单状态为已完成</span></span><br><span class="line">		LOGGER.info(<span class="string">"-------&gt;order-service中修改订单状态开始"</span>);</span><br><span class="line">		orderMapper.update(order.getUserId(), <span class="number">0</span>);</span><br><span class="line">		LOGGER.info(<span class="string">"-------&gt;order-service中修改订单状态结束"</span>);</span><br><span class="line"></span><br><span class="line">		LOGGER.info(<span class="string">"-------&gt;下单结束"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于seata-account-service的超时会导致当库存和账户金额扣减后订单状态并没有设置为已经完成，而且由于远程调用的重试机制，账户余额还会被多次扣减:</p>
<p><img src="https://img-blog.csdnimg.cn/20200530164241989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="本章示例使用到的模块"><a href="#本章示例使用到的模块" class="headerlink" title="本章示例使用到的模块"></a>本章示例使用到的模块</h4><p>springcloud-learning<br>├── seata-order-service – 整合了seata的订单服务<br>├── seata-storage-service – 整合了seata的库存服务<br>└── seata-account-service – 整合了seata的账户服务</p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>cloud</tag>
        <tag>Alibaba</tag>
        <tag>seata</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Data JPA</title>
    <url>/myblog/Spring-Data/Spring-Data-JPA/</url>
    <content><![CDATA[<h4 id="Spring-Data介绍"><a href="#Spring-Data介绍" class="headerlink" title="Spring Data介绍"></a>Spring Data介绍</h4><p>　　Spring  Data项目是从2010年发展起来的，从创立之初SpringData就想提供一个大家熟悉的、一致的、基于Spring的数据访问编程模型，同时仍然保留底层数据存储的特殊特性。它可以轻松地让开发者使用数据访问技术，包括关系数据库、非关系数据库（NoSQL）和基于云的数据服务。　</p>
<a id="more"></a>
<p>　　Spring Data Common是Spring Data所有模块的公用部分，该项目提供跨Spring数据项目的共享基础设施。它包含了技术中立的库接口以及一个坚持java类的元数据模型。</p>
<p>　　Spring Data不仅对传统的数据库访问技术JDBC、Hibernate、JDO、TopLick、JPA、Mybitas做了很好的支持、扩展、抽象、提供方便的API，还对NoSQL等非关系数据做了很好的支持，包括MongoDB、Redis、Apache Solr等.</p>
<h4 id="Spring-Data操作的主要特性"><a href="#Spring-Data操作的主要特性" class="headerlink" title="Spring Data操作的主要特性"></a>Spring Data操作的主要特性</h4><p>　　Spring Data项目旨在为大家提供一种通用的编码模式。数据访问对象实现了对物理数据层的抽象，为编写查询方法提供了方便。通过对象映射，实现域对象和持续化存储之间的转换，而模板提供的是对底层存储实体的访问实现。如图1-4所示。操作上主要有如下特征：</p>
<p>　　提供模板操作，如Spring Data Redis和Spring Data Riak。</p>
<p>　　强大的Repository和定制的数据存储对象的抽象映射。<br>　　对数据访问对象的支持（Auting等）。</p>
<h4 id="Spring-Data-JPA介绍"><a href="#Spring-Data-JPA介绍" class="headerlink" title="Spring Data JPA介绍"></a>Spring Data JPA介绍</h4><p>　　可以理解为JPA规范的再次封装抽象，底层还是使用了Hibernate的JPA技术实现，引用JPQL（Java Persistence Query Language）查询语言，属于Spring整个生态体系的一部分。随着Spring Boot和Spring Cloud在市场上的流行，Spring Data JPA也逐渐进入大家的视野，它们组成有机的整体，使用起来比较方便，加快了开发的效率，使开发者不需要关心和配置更多的东西，完全可以沉浸在Spring的完整生态标准实现下。JPA上手简单，开发效率高，对对象的支持比较好，又有很大的灵活性，市场的认可度越来越高。</p>
<p>　　JPA是Java Persistence API的简称，中文名为Java持久层API，是JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。</p>
<h6 id="JPA包括以下3方面的内容："><a href="#JPA包括以下3方面的内容：" class="headerlink" title="JPA包括以下3方面的内容："></a>JPA包括以下3方面的内容：</h6><p>　　（1）一套API标准。在javax.persistence的包下面，用来操作实体对象，执行CRUD操作，框架在后台替代我们完成所有的事情，开发者从烦琐的JDBC和SQL代码中解脱出来。</p>
<p>　　（2）面向对象的查询语言：Java Persistence QueryLanguage（JPQL）。这是持久化操作中很重要的一个方面，通过面向对象而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密耦合</p>
<p>　　（3）ORM（object/relational metadata）元数据的映射。JPA支持XML和JDK5.0注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中。</p>
<h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><p> 1、首先在spring data jpa中基本的CRUD其实不用自己去做，你只需要</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Integer</span>&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p> 这样就具备了基础的CRUD功能，而且不需要写实现类，spring-data-jpa实现了上面的能力，那他是怎么实现的呢？这里我们通过源代码的方式来呈现他的来龙去脉，这个过程中cglib发挥了杰出的作用。   在spring-data-jpa内部，有一个类，叫做</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleJpaRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt; <span class="keyword">implements</span> <span class="title">JpaRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt;, <span class="title">JpaSpecificationExecutor</span>&lt;<span class="title">T</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到这个类是实现了JpaRepository接口的，事实上如果我们按照上面的配置，在同一个包下面有UserRepository，但是没有UserRepositoryImpl这个类的话，在运行时期UserRepository这个接口的实现就是上面的SimpleJpaRepository这个接口。而如果有UserRepositoryImpl这个文件的话，那么UserRepository的实现类就是UserRepositoryImpl，而UserRepositoryImpl这个类又是SimpleJpaRepository的子类，如此一来就很好的解决了上面的这个不用写implements的问题。我们通过阅读这个类的源代码可以发现，里面包装了entityManager，底层的调用关系是entityManager在进行CRUD。</p>
<p>2、关于自定义接口<br>Spring Data JPA的独特之处就是简单查询根本不用写实现类，直接写接口就好，它能根据你的接口去生成sql，但是需要遵循标准规范</p>
<p>按照方法名解析规则如下：</p>
<p>find+全局修饰+By+实体属性名称+限定词+连接词+（其他实体属性）+OrderBy+排序属性+排序方向：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">findDistinctByFirstNameIgnoreCaseAndLastNameOrderByAgeDesc(String firstName,String lastName)</span><br></pre></td></tr></table></figure>

<p>全局修饰符：distinct,top,first</p>
<p>关键词（限定词+连接词）：IsNull,IsNotNull,Like,NotLike,Containing,In,NotIn,IgnoreCase,Between,Equals,</p>
<p>LessThan,GreaterThan,After,Before</p>
<p>排序方向：Asc,Desc</p>
<p>嵌套实体方法命名规则：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;Person&gt; <span class="title">findByAddress_ZipCode</span><span class="params">(ZipCode zipCode)</span></span></span><br></pre></td></tr></table></figure>

<p>构词法：主实体中的子实体名称+_+子实体属性名称</p>
<p>通过关键词构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">// 对应sql：  select * from user where phone like '136%' and address like '%路%'</span></span><br><span class="line">findByPhoneStartingWithAndAdressContaining(String phone, String address);</span><br></pre></td></tr></table></figure>

<p>所有支持的关键词：请查看官网 <a href="https://docs.spring.io/spring-data/jpa/docs/2.3.3.RELEASE/reference/html/#reference" target="_blank" rel="noopener">https://docs.spring.io/spring-data/jpa/docs/2.3.3.RELEASE/reference/html/#reference</a></p>
<h4 id="基于mysql数据库的快速开发实例"><a href="#基于mysql数据库的快速开发实例" class="headerlink" title="基于mysql数据库的快速开发实例"></a>基于mysql数据库的快速开发实例</h4><p>1、pom文件</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-data-rest&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      </span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      </span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">	&lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>


<p>2.配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8001</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: data-rest-crud-demo</span><br><span class="line">  #数据库相关配置</span><br><span class="line">  datasource:</span><br><span class="line">     driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">     url: jdbc:mysql:<span class="comment">//localhost:3306/orcl?useUnicode=true&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC</span></span><br><span class="line">     username: root</span><br><span class="line">     password: <span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>3.entity</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"dept"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dept</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * dept table</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">9174265336050917155L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Id</span></span><br><span class="line">	<span class="meta">@GeneratedValue</span></span><br><span class="line">	<span class="meta">@Column</span>(name = <span class="string">"deptno"</span>)</span><br><span class="line">	<span class="keyword">private</span> Integer deptNo;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Column</span>(name = <span class="string">"deptname"</span>)</span><br><span class="line">	<span class="keyword">private</span> String deptName;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对于不想暴漏的字段，使用@JsonIgnore即可。</span></span><br><span class="line">	<span class="comment">// @JsonIgnore</span></span><br><span class="line">	<span class="keyword">private</span> String localtion;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">getDeptNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> deptNo;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDeptNo</span><span class="params">(Integer deptNo)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.deptNo = deptNo;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getDeptName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> deptName;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDeptName</span><span class="params">(String deptName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.deptName = deptName;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getLocaltion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> localtion;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocaltion</span><span class="params">(String localtion)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.localtion = localtion;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、dao</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * collectionResourceRel是json的最外层显示名称，path是访问路径</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CHFSUN</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RepositoryRestResource</span>(collectionResourceRel = <span class="string">"list"</span>, path = <span class="string">"dept"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DeptDao</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Dept</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">// 可定义自己的接口</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据名字查询单个</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> deptName</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Dept <span class="title">getOneByDeptName</span><span class="params">(@Param(<span class="string">"deptname"</span>)</span> String deptName)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 对于不需要暴漏的接口，可以使用<span class="doctag">@RestResource</span>(exported = false)隐藏该接口</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@RestResource</span>(exported = <span class="keyword">false</span>)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Dept dept)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、使用接口测试工具 postman测试，发现已经能正常使用crud及分页功能</p>
]]></content>
      <categories>
        <category>Spring Data</category>
      </categories>
      <tags>
        <tag>Spring Data JPA</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot 应用跨域访问解决方案</title>
    <url>/myblog/spring-boot/SpringBoot-%E5%BA%94%E7%94%A8%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<div id="cnblogs_post_body" class="blogpost-body ">
    <h2 id="一什么是跨域访问">一、什么是跨域访问</h2>
    <a id="more"></a>
<p>说到跨域访问，必须先解释一个名词：同源策略。所谓同源策略就是在浏览器端出于安全考量，向服务端发起请求必须满足：协议相同、Host(ip)相同、端口相同的条件，否则访问将被禁止，该访问也就被称为跨域访问。<br>虽然跨域访问被禁止之后，可以在一定程度上提高了应用的安全性，但也为开发带来了一定的麻烦。比如：我们开发一个前后端分离的易用，页面及js部署在一个主机的nginx服务中，后端接口部署在一个tomcat应用容器中，当前端向后端发起请求的时候一定是不符合同源策略的，也就无法访问。那么我们如何解决这个问题？就是本文需要向大家说明的内容。</p>
<h2 id="二跨域访问的解决方案有哪些">二、跨域访问的解决方案有哪些？</h2>
<h3 id="第一类方案前端解决方案">2.1.第一类方案：前端解决方案</h3>
<p>虽然浏览器对于不符合同源策略的访问是禁止的，但是仍然存在例外的情况，如以下资源引用的标签不受同源策略的限制：</p>

<blockquote>
<ul> <li>html的script标签</li> <li>html的link标签</li> <li>html的img标签</li>
<li>html的iframe标签：对于使用jsp、freemarker开发的项目，这是实现跨域访问最常见的方法，</li>

</ul>
</blockquote>
<p>除了基于HTML本身的特性实现跨域访问，我们还可以使用jsonp、window的postMessage实现跨域访问。这些都是前端实现跨域访问的方式。</p>
<h3 id="第二类方案使用代理">2.2.第二类方案：使用代理</h3>
<p>实际上对跨域访问的支持在服务端实现起来更加容易，最常用的方法就是通过代理的方式，如：</p>

<blockquote>
<ul> <li>nginx代理跨域</li> <li>haproxy代理跨域</li> <li>nodejs中间件代理跨域</li>
</ul>
</blockquote>
<p>其实实现代理跨域的逻辑非常简单，就是在不同的资源服务：js资源、html资源、css资源、接口数据资源服务的前端搭建一个中间层，所有的浏览器及客户端访问都通过代理转发。所以在浏览器、客户端看来，它们访问的都是同一个ip、同一个端口的资源，从而符合同源策略实现跨域访问。</p>
<p><img src="https://img2018.cnblogs.com/blog/1815316/201911/1815316-20191111082300677-447204491.png" alt></p>
<h3 id="第三类方案cors">2.3 第三类方案：CORS</h3>
<p>跨域资源共享（CORS）：通过修改Http协议header的方式，实现跨域。说的简单点就是，通过设置HTTP的响应头信息，告知浏览器哪些情况在不符合同源策略的条件下也可以跨域访问，浏览器通过解析Http协议中的Header执行具体判断。具体的Header如下：</p>
<p><strong>CROS跨域常用header</strong></p>
<ul>
<li>Access-Control-Allow-Origin: 允许哪些ip或域名可以跨域访问</li>
<li>Access-Control-Max-Age: 表示在多少秒之内不需要重复校验该请求的跨域访问权限</li>
<li>Access-Control-Allow-Methods: 表示允许跨域请求的HTTP方法，如：GET,POST,PUT,DELETE</li>
<li>Access-Control-Allow-Headers: 表示访问请求中允许携带哪些Header信息，如：<code>Accept</code>、<code>Accept-Language</code>、<code>Content-Language</code>、<code>Content-Type</code></li>

</ul>
<h2 id="三springboot下实现cors的四种方式">三、SpringBoot下实现CORS的四种方式</h2>
<p>为大家介绍四种实现CORS的方法，两种是全局配置，两种是局部接口生效的配置。一般来说，SpringBoot项目采用其中一种方式实现CORS即可。</p>
<h3 id="使用corsfilter进行全局跨域配置">3.1.使用CorsFilter进行全局跨域配置</h3>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalCorsConfig</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Bean</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> CorsFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">         CorsConfiguration config = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">         <span class="comment">//开放哪些ip、端口、域名的访问权限，星号表示开放所有域</span></span><br><span class="line">         config.addAllowedOrigin(<span class="string">"*"</span>);</span><br><span class="line">         <span class="comment">//是否允许发送Cookie信息</span></span><br><span class="line">         config.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">         <span class="comment">//开放哪些Http方法，允许跨域访问</span></span><br><span class="line">         config.addAllowedMethod(<span class="string">"GET"</span>,<span class="string">"POST"</span>, <span class="string">"PUT"</span>, <span class="string">"DELETE"</span>);</span><br><span class="line">         <span class="comment">//允许HTTP请求中的携带哪些Header信息</span></span><br><span class="line">         config.addAllowedHeader(<span class="string">"*"</span>);</span><br><span class="line">         <span class="comment">//暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息）</span></span><br><span class="line">         config.addExposedHeader(<span class="string">"*"</span>);</span><br><span class="line"> </span><br><span class="line">         <span class="comment">//添加映射路径，“/**”表示对所有的路径实行全局跨域访问权限的设置</span></span><br><span class="line">         UrlBasedCorsConfigurationSource configSource = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">         configSource.registerCorsConfiguration(<span class="string">"/**"</span>, config);</span><br><span class="line"> </span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(configSource);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="重写webmvcconfigurer的addcorsmappings方法全局跨域配置">3.2. 重写WebMvcConfigurer的addCorsMappings方法（全局跨域配置）</h3>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalCorsConfig</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> WebMvcConfigurer <span class="title">corsConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> WebMvcConfigurer() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">                    registry.addMapping(<span class="string">"/**"</span>)    <span class="comment">//添加映射路径，“/**”表示对所有的路径实行全局跨域访问权限的设置</span></span><br><span class="line">                            .allowedOrigins(<span class="string">"*"</span>)    <span class="comment">//开放哪些ip、端口、域名的访问权限</span></span><br><span class="line">                            .allowCredentials(<span class="keyword">true</span>)  <span class="comment">//是否允许发送Cookie信息 </span></span><br><span class="line">                            .allowedMethods(<span class="string">"GET"</span>,<span class="string">"POST"</span>, <span class="string">"PUT"</span>, <span class="string">"DELETE"</span>)     <span class="comment">//开放哪些Http方法，允许跨域访问</span></span><br><span class="line">                            .allowedHeaders(<span class="string">"*"</span>)     <span class="comment">//允许HTTP请求中的携带哪些Header信息</span></span><br><span class="line">                            .exposedHeaders(<span class="string">"*"</span>);   <span class="comment">//暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息）</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用crossorigin注解局部跨域配置">3.3.使用CrossOrigin注解（局部跨域配置）</h3>

<blockquote>
<ul>
<li>将CrossOrigin注解加在Controller层的方法上，该方法定义的RequestMapping端点将支持跨域访问</li>
<li>将CrossOrigin注解加在Controller层的类定义处，整个类所有的方法对应的RequestMapping端点都将支持跨域访问</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/cors"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@CrossOrigin</span>(origins = <span class="string">"http://localhost:8080"</span>, maxAge = <span class="number">3600</span>) </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">cors</span><span class="params">( )</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"cors"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者简洁的全局</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@CrossOrigin</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(DeptController <span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用httpservletresponse设置响应头局部跨域配置">3.4 使用HttpServletResponse设置响应头(局部跨域配置)</h3>

<blockquote>
<p>这种方式不建议在SpringBoot项目中使用,纯粹是找事做</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/cors"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">cors</span><span class="params">(HttpServletResponse response)</span></span>&#123;</span><br><span class="line">    <span class="comment">//使用HttpServletResponse定义HTTP请求头，最原始的方法也是最通用的方法</span></span><br><span class="line">    response.addHeader(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"http://localhost:8080"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"cors"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四实现与测试">四、实现与测试</h2>
<p>在SpringBoot<strong>项目外</strong>随便定义一个web项目，发送一个web请求，具体技术可以使用jquery的ajax、fetch、axios等。以下是以Jquery封装的ajax为例请求验证的核心代码：</p>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">     url: <span class="string">'http://localhost:8090/cors'</span>,</span><br><span class="line">     type: <span class="string">"POST"</span>,</span><br><span class="line">     xhrFields: &#123;</span><br><span class="line">        withCredentials: <span class="keyword">true</span>    <span class="comment">//允许发送Cookie信息</span></span><br><span class="line">     &#125;,</span><br><span class="line">     success: function (data) &#123;</span><br><span class="line">         alert(<span class="string">"跨域请求配置成功"</span>)</span><br><span class="line">     &#125;,</span><br><span class="line">     error: function (data) &#123;</span><br><span class="line">         alert(<span class="string">"跨域请求配置失败"</span>)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>
<p>测试可以发现：<br>在没有进行跨域请求时会出现网络请求200,同时能查看到数据：<br><img src="https://img-blog.csdnimg.cn/20200419154311331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">控制台有错误信息：<br><img src="https://img-blog.csdnimg.cn/20200419154408906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">)设置好跨域请求后，控制台不报错同时页面也能正确加载出信息：<img src="https://img-blog.csdnimg.cn/20200419154951283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>本文转载自<a href="https://www.cnblogs.com/zimug/p/11832737.html" target="_blank" rel="noopener">https://www.cnblogs.com/zimug/p/11832737.html</a>并调整</li>
</ul></div>]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>boot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot2.0集成Shiro（二）</title>
    <url>/myblog/spring-boot/SpringBoot2-0%E9%9B%86%E6%88%90Shir%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>Shiro这个Java安全框架我一直都想学会怎么去使用，但每次依照着别人的博客尝试把它配置到自己的项目中，总是出现各种问题，导致一直没有成功。经过不懈努力，这一次终于成功了！从零搭建整个项目，并通过一个简单的用户登录功能来进行说明！</p>
<a id="more"></a>
<p><strong>源码github地址</strong>：<a href="https://github.com/Rhine404/shirodemo" target="_blank" rel="noopener">https://github.com/Rhine404/shirodemo</a></p>
<h2><a name="t2"></a><a name="t2"></a><a id="1__7"></a>1 简介</h2>
<p>推荐阅读<a href="https://www.infoq.com/articles/apache-shiro" target="_blank" rel="nofollow noopener">官方文档</a>去认识Shiro，虽然不是中文的，但绝对是比看各种博客里重复度高、零零散散的资料好。</p>
<p>官方的简介如下：</p>
<blockquote>
<p><strong>Apache Shiro™</strong> is a powerful and easy-to-use Java security framework that performs authentication, authorization, cryptography, and session management. With Shiro’s easy-to-understand API, you can quickly and easily secure any application – from the smallest mobile applications to the largest web and enterprise applications.</p>
</blockquote>
<p>Shiro是一款强大易用的Java安全框架，主要功能是进行认证、授权、加密、会话管理等。与Spring Security相比的话，Shiro是会更加轻量。</p>
<h2><a name="t3"></a><a name="t3"></a><a id="2__17"></a>2 环境搭建</h2>
<h3><a name="t4"></a><a name="t4"></a><a id="21__19"></a>2.1 开发环境</h3>
<ul>
<li>
<p>IDEA或者eclipse</p>
</li>
<li>
<p>HTML/CSS/JavaScript + FreeMarker</p>
</li>
<li>
<p>JDK8 + Maven + Spring Boot + Shiro</p>
</li>
<li>
<p>druid + mybatis + Navicat或者SQLyog + MySQL5.X</p>
</li>
</ul>
<p>这里需要你有预备知识：</p>
<ul>
<li>
<p>熟练使用IDEA或eclipse</p>
</li>
<li>
<p>了解Maven，知道如何配置settings.xml与maven仓库</p>
</li>
<li>
<p>了解Spring Boot，并会使用它搭建Web项目</p>
</li>
<li>
<p>了解FreeMarker/thymeleaf、yaml语法</p>
</li>
</ul>
<p>虽然都是通过Maven构建项目，不过Spring Boot不再使用.xml文件对项目进行配置，所以Shiro的配置类ShiroConfig不太容易理解，对于刚开始接触Spring Boot的同学来说这是一个难点。</p>
<h3><a name="t5"></a><a name="t5"></a><a id="22__38"></a>2.2 创建项目</h3>
<p>这里使用IDEA通过Spring Initializr创建项目（当然也可以通过Maven自己添加所有依赖）。<br>
<img src="https://img-blog.csdnimg.cn/20181211180430453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODAyNDE2,size_16,color_FFFFFF,t_70" alt="选择依赖" width="700"><br>
我们下面要通过这个项目来搭建一个简单的用户系统，系统有两类用户——普通用户和VIP用户，通过shiro来完成登录、登出、权限验证功能，主要在于展示前后端的交互、后端与数据库的交互。</p>
<h3><a name="t6"></a><a name="t6"></a><a id="23__44"></a>2.3 项目文件结构</h3>
<p><img src="https://img-blog.csdnimg.cn/20181211180458263.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODAyNDE2,size_16,color_FFFFFF,t_70" alt="项目结构"><br>
<img src="https://img-blog.csdnimg.cn/2018121118051235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODAyNDE2,size_16,color_FFFFFF,t_70" alt="项目结构2"></p>
<h3><a name="t7"></a><a name="t7"></a><a id="24_pomxml_47"></a>2.4 pom.xml</h3>
<p>新建的项目还需要再手动增加三个依赖项：druid数据库连接池，shiro依赖，log4j依赖</p>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.rhine.blog&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;shirodemo&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line">    &lt;name&gt;shirodemo&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;Spring Boot with Shiro&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;!-- 数据库连接池 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.10&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- Shiro --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- log4j --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>




<h3><a name="t8"></a><a name="t8"></a><a id="25_applicationyml_135"></a>2.5 application.yml</h3>
<p>druid的配置会稍微多些，所以也附上了详细的注释，属性和值之间必须要有":"号。</p>
<pre class="prettyprint"><code class="prism language-yaml has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
    <span class="token key atrule">datasource</span><span class="token punctuation">:</span>
        <span class="token key atrule">url</span><span class="token punctuation">:</span> jdbc<span class="token punctuation">:</span>mysql<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span>3306/lastpass<span class="token punctuation">?</span>useUnicode=true<span class="token important">&amp;characterEncoding</span>=UTF<span class="token punctuation">-</span>8<span class="token important">&amp;useJDBCCompliantTimezoneShift</span>=true<span class="token important">&amp;useLegacyDatetimeCode</span>=false<span class="token important">&amp;serverTimezone</span>=UTC
        <span class="token key atrule">username</span><span class="token punctuation">:</span> root
        <span class="token key atrule">password</span><span class="token punctuation">:</span> abc123456
        <span class="token key atrule">driver-class-name</span><span class="token punctuation">:</span> com.mysql.cj.jdbc.Driver
        <span class="token key atrule">type</span><span class="token punctuation">:</span> com.alibaba.druid.pool.DruidDataSource
        <span class="token comment"># 初始化时建立物理连接连接的个数</span>
        <span class="token key atrule">initialSize</span><span class="token punctuation">:</span> <span class="token number">5</span>
        <span class="token comment"># 最小连接池数量</span>
        <span class="token key atrule">minIdle</span><span class="token punctuation">:</span> <span class="token number">5</span>
        <span class="token comment"># 最大连接池数量</span>
        <span class="token key atrule">maxActive</span><span class="token punctuation">:</span> <span class="token number">20</span>
        <span class="token comment"># 获取连接时最大等待时间(ms)，即60s</span>
        <span class="token key atrule">maxWait</span><span class="token punctuation">:</span> <span class="token number">60000</span>
        <span class="token comment"># 1.Destroy线程会检测连接的间隔时间；2.testWhileIdle的判断依据</span>
        <span class="token key atrule">timeBetweenEvictionRunsMillis</span><span class="token punctuation">:</span> <span class="token number">60000</span>
        <span class="token comment"># 最小生存时间ms</span>
        <span class="token key atrule">minEvictableIdleTimeMillis</span><span class="token punctuation">:</span> <span class="token number">600000</span>
        <span class="token key atrule"># maxEvictableIdleTimeMillis</span><span class="token punctuation">:</span> <span class="token number">900000</span>
        <span class="token comment"># 用来检测连接是否有效的sql</span>
        <span class="token key atrule">validationQuery</span><span class="token punctuation">:</span> SELECT 1 FROM DUAL
        <span class="token comment"># 申请连接时执行validationQuery检测连接是否有效，启用会降低性能</span>
        <span class="token key atrule">testOnBorrow</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
        <span class="token comment"># 归还连接时执行validationQuery检测连接是否有效，启用会降低性能</span>
        <span class="token key atrule">testOnReturn</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
        <span class="token comment"># 申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，</span>
        <span class="token comment"># 执行validationQuery检测连接是否有效，不会降低性能</span>
        <span class="token key atrule">testWhileIdle</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
        <span class="token comment"># 是否缓存preparedStatement，mysql建议关闭</span>
        <span class="token key atrule">poolPreparedStatements</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
        <span class="token comment"># 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙</span>
        <span class="token key atrule">filters</span><span class="token punctuation">:</span> stat<span class="token punctuation">,</span>wall<span class="token punctuation">,</span>log4j
    <span class="token key atrule">freemarker</span><span class="token punctuation">:</span>
        <span class="token key atrule">suffix</span><span class="token punctuation">:</span> .html
        <span class="token key atrule">charset</span><span class="token punctuation">:</span> utf<span class="token punctuation">-</span><span class="token number">8</span>
    <span class="token key atrule">mvc</span><span class="token punctuation">:</span>
        <span class="token comment"># 配置静态资源映射路径，/public、/resources路径失效</span>
        <span class="token key atrule">static-path-pattern</span><span class="token punctuation">:</span> /static/**
<span class="token key atrule">mybatis</span><span class="token punctuation">:</span>
    <span class="token key atrule">mapper-locations</span><span class="token punctuation">:</span> classpath<span class="token punctuation">:</span>mappers/*.xml
    <span class="token comment"># 虽然可以配置这项来进行pojo包扫描，但其实我更倾向于在mapper.xml写全类名</span>
    <span class="token key atrule">type-aliases-package</span><span class="token punctuation">:</span> com.rhine.blog.po

<h2><a name="t9"></a><a name="t9"></a><a id="3__185"></a>3 数据库</h2>
<p>因为我们不仅仅要使用Shiro来进行认证，还要进行授权、加密等操作，所以我们要建立用户表以及权限管理表。</p>
<h3><a name="t10"></a><a name="t10"></a><a id="31__189"></a>3.1 数据库设计</h3>
<p>数据库有用户（user）、角色（role）、权限（permission）三个实体，除了实体表以外，为了实现表间用户与角色、角色与权限多对多的表间关系，所以产生了user_role、role_permission两张关系表。在下图中，使用红线将表的外键标记了出来，但为了方便并没有在表中创建外键，我们手动进行维护。<br>
<img src="https://img-blog.csdnimg.cn/20181211180530621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODAyNDE2,size_16,color_FFFFFF,t_70" alt="表间关系" width="700"></p>
<h3><a name="t11"></a><a name="t11"></a><a id="32__193"></a>3.2 数据库字段</h3>
<p>再简单介绍下数据库字段，user表中name是用户名，password是密码；role表中name是角色名（如user、vip）；permission表中，name是权限名（如会员中心），url是实际的权限字段（user:vip）</p>
<h2><a name="t12"></a><a name="t12"></a><a id="4__197"></a>4 类</h2>
<h3><a name="t13"></a><a name="t13"></a><a id="41_po_199"></a>4.1 po</h3>
<p><strong>Userbean.java</strong></p>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rhine.blog.po;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBean</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;RoleBean&gt; roles = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 省略setter、getter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>RoleBean.java</strong></p>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rhine.blog.po;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 角色类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoleBean</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;PermissionBean&gt; permissions = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略setter、getter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>PermissionBean.java</strong></p>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rhine.blog.po;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 权限类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermissionBean</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略setter、getter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3><a name="t14"></a><a name="t14"></a><a id="42_mapper_250"></a>4.2 mapper</h3>
<p><strong>UserMapper.java</strong></p>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rhine.blog.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询用户信息</span></span><br><span class="line">    <span class="function">UserBean <span class="title">findByName</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">// 查询用户信息、角色、权限</span></span><br><span class="line">    <span class="function">UserBean <span class="title">findById</span><span class="params">(String id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>UserMapper.xml</strong></p>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC <span class="string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">"com.rhine.blog.mapper.UserMapper"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;resultMap id=<span class="string">"userMap"</span> type=<span class="string">"UserBean"</span>&gt;</span><br><span class="line">        &lt;id property=<span class="string">"id"</span> column=<span class="string">"id"</span>/&gt;</span><br><span class="line">        &lt;result property=<span class="string">"name"</span> column=<span class="string">"name"</span>/&gt;</span><br><span class="line">        &lt;result property=<span class="string">"password"</span> column=<span class="string">"password"</span>/&gt;</span><br><span class="line">        &lt;collection property=<span class="string">"roles"</span> ofType=<span class="string">"RoleBean"</span>&gt;</span><br><span class="line">            &lt;id property=<span class="string">"id"</span> column=<span class="string">"roleId"</span>/&gt;</span><br><span class="line">            &lt;result property=<span class="string">"name"</span> column=<span class="string">"roleName"</span>/&gt;</span><br><span class="line">            &lt;collection property=<span class="string">"permissions"</span> ofType=<span class="string">"PermissionBean"</span>&gt;</span><br><span class="line">                &lt;id property=<span class="string">"id"</span> column=<span class="string">"permissionId"</span>/&gt;</span><br><span class="line">                &lt;result property=<span class="string">"name"</span> column=<span class="string">"permissionName"</span>/&gt;</span><br><span class="line">                &lt;result property=<span class="string">"url"</span> column=<span class="string">"permissionUrl"</span>/&gt;</span><br><span class="line">            &lt;/collection&gt;</span><br><span class="line">        &lt;/collection&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=<span class="string">"findByName"</span> parameterType=<span class="string">"String"</span> resultType=<span class="string">"UserBean"</span>&gt;</span><br><span class="line">      SELECT id, name, password</span><br><span class="line">        FROM user</span><br><span class="line">          WHERE NAME = #&#123;name&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=<span class="string">"findById"</span> parameterType=<span class="string">"String"</span> resultMap=<span class="string">"userMap"</span>&gt;</span><br><span class="line">      SELECT user.id, user.name, user.password,</span><br><span class="line">			role.id as roleId, role.name as roleName,</span><br><span class="line">			permission.id as permissionId, </span><br><span class="line">            permission.name as permissionName, </span><br><span class="line">            permission.url as permissionUrl</span><br><span class="line">        FROM user, user_role, role, role_permission, permission</span><br><span class="line">          WHERE user.id = #&#123;id&#125;</span><br><span class="line">            AND user.id = user_role.user_id</span><br><span class="line">            AND user_role.role_id = role.id</span><br><span class="line">            AND role.id = role_permission.role_id</span><br><span class="line">            AND role_permission.permission_id = permission.id</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>


<p>因为在application.yml中配置了 type-aliases-package: com.rhine.blog.po，所以resultType可以不用写全类名。添加新的查询时，一定要区分清楚resultMap和resultType，否则出错不容易发现。</p>
<h3><a name="t15"></a><a name="t15"></a><a id="43_config_313"></a>4.3 config</h3>
<p><strong>DruidConfig.java</strong></p>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rhine.blog.config;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Druid配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource"</span>)</span><br><span class="line">    <span class="meta">@Bean</span>(destroyMethod=<span class="string">"close"</span>, initMethod = <span class="string">"init"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">druid</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  配置监控服务器</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">statViewServlet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ServletRegistrationBean bean = <span class="keyword">new</span> ServletRegistrationBean(</span><br><span class="line">            <span class="keyword">new</span> StatViewServlet(), <span class="string">"/druid/*"</span>);</span><br><span class="line">        Map&lt;String,String&gt; initParams = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// druid后台管理员用户</span></span><br><span class="line">        initParams.put(<span class="string">"loginUsername"</span>,<span class="string">"admin"</span>);</span><br><span class="line">        initParams.put(<span class="string">"loginPassword"</span>,<span class="string">"123456"</span>);</span><br><span class="line">        <span class="comment">// 是否能够重置数据</span></span><br><span class="line">        initParams.put(<span class="string">"resetEnable"</span>, <span class="string">"false"</span>);</span><br><span class="line"></span><br><span class="line">        bean.setInitParameters(initParams);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  配置web监控的过滤器</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">webStatFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        FilterRegistrationBean bean = <span class="keyword">new</span> FilterRegistrationBean(</span><br><span class="line">            <span class="keyword">new</span> WebStatFilter());</span><br><span class="line">        <span class="comment">// 添加过滤规则</span></span><br><span class="line">        bean.addUrlPatterns(<span class="string">"/*"</span>);</span><br><span class="line">        Map&lt;String,String&gt; initParams = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 忽略过滤格式</span></span><br><span class="line">        initParams.put(<span class="string">"exclusions"</span>,<span class="string">"*.js,*.css,*.icon,*.png,*.jpg,/druid/*"</span>);</span><br><span class="line">        bean.setInitParameters(initParams);</span><br><span class="line">        <span class="keyword">return</span>  bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ShiroConfig.java</strong></p>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rhine.blog.config;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Shiro配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"hashedCredentialsMatcher"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HashedCredentialsMatcher <span class="title">hashedCredentialsMatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashedCredentialsMatcher credentialsMatcher = </span><br><span class="line">            <span class="keyword">new</span> HashedCredentialsMatcher();</span><br><span class="line">        <span class="comment">//指定加密方式为MD5</span></span><br><span class="line">        credentialsMatcher.setHashAlgorithmName(<span class="string">"MD5"</span>);</span><br><span class="line">        <span class="comment">//加密次数</span></span><br><span class="line">        credentialsMatcher.setHashIterations(<span class="number">1024</span>);</span><br><span class="line">        credentialsMatcher.setStoredCredentialsHexEncoded(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> credentialsMatcher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"userRealm"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserRealm <span class="title">userRealm</span><span class="params">(@Qualifier(<span class="string">"hashedCredentialsMatcher"</span>)</span> </span></span><br><span class="line"><span class="function">                               HashedCredentialsMatcher matcher) </span>&#123;</span><br><span class="line">        </span><br><span class="line">        UserRealm userRealm = <span class="keyword">new</span> UserRealm();</span><br><span class="line">        userRealm.setCredentialsMatcher(matcher);</span><br><span class="line">        <span class="keyword">return</span> userRealm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShiroFilterFactoryBean <span class="title">shirFilter</span><span class="params">(@Qualifier(<span class="string">"securityManager"</span>)</span></span></span><br><span class="line"><span class="function">                               DefaultWebSecurityManager securityManager) </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ShiroFilterFactoryBean bean = <span class="keyword">new</span> ShiroFilterFactoryBean();</span><br><span class="line">        <span class="comment">// 设置 SecurityManager</span></span><br><span class="line">        bean.setSecurityManager(securityManager);</span><br><span class="line">		<span class="comment">// 设置登录成功跳转Url</span></span><br><span class="line">        bean.setSuccessUrl(<span class="string">"/main"</span>);</span><br><span class="line">        <span class="comment">// 设置登录跳转Url</span></span><br><span class="line">        bean.setLoginUrl(<span class="string">"/toLogin"</span>);</span><br><span class="line">        <span class="comment">// 设置未授权提示Url</span></span><br><span class="line">        bean.setUnauthorizedUrl(<span class="string">"/error/unAuth"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * anon：匿名用户可访问</span></span><br><span class="line"><span class="comment">         * authc：认证用户可访问</span></span><br><span class="line"><span class="comment">         * user：使用rememberMe可访问</span></span><br><span class="line"><span class="comment">         * perms：对应权限可访问</span></span><br><span class="line"><span class="comment">         * role：对应角色权限可访问</span></span><br><span class="line"><span class="comment">         **/</span></span><br><span class="line">        Map&lt;String, String&gt; filterMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        filterMap.put(<span class="string">"/login"</span>,<span class="string">"anon"</span>);</span><br><span class="line">        filterMap.put(<span class="string">"/user/index"</span>,<span class="string">"authc"</span>);</span><br><span class="line">        filterMap.put(<span class="string">"/vip/index"</span>,<span class="string">"roles[vip]"</span>);</span><br><span class="line">        filterMap.put(<span class="string">"/druid/**"</span>, <span class="string">"anon"</span>);</span><br><span class="line">        filterMap.put(<span class="string">"/static/**"</span>,<span class="string">"anon"</span>);</span><br><span class="line"></span><br><span class="line">        filterMap.put(<span class="string">"/**"</span>,<span class="string">"authc"</span>);</span><br><span class="line">        filterMap.put(<span class="string">"/logout"</span>, <span class="string">"logout"</span>);</span><br><span class="line"></span><br><span class="line">        bean.setFilterChainDefinitionMap(filterMap);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入 securityManager</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(name=<span class="string">"securityManager"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultWebSecurityManager <span class="title">getDefaultWebSecurityManager</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        HashedCredentialsMatcher hashedCredentialsMatcher)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        DefaultWebSecurityManager securityManager = </span><br><span class="line">            <span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line">        <span class="comment">// 关联realm.</span></span><br><span class="line">        securityManager.setRealm(userRealm(hashedCredentialsMatcher));</span><br><span class="line">        <span class="keyword">return</span> securityManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3><a name="t16"></a><a name="t16"></a><a id="44_realm_449"></a>4.4 realm</h3>
<h3>UserRealm.java</h3>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rhine.blog.realm;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义Realm，实现授权与认证</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户授权</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        PrincipalCollection principalCollection)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"===执行授权==="</span>);</span><br><span class="line"></span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        UserBean user = (UserBean)subject.getPrincipal();</span><br><span class="line">        <span class="keyword">if</span>(user != <span class="keyword">null</span>)&#123;</span><br><span class="line">            SimpleAuthorizationInfo info = <span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line">            <span class="comment">// 角色与权限字符串集合</span></span><br><span class="line">            Collection&lt;String&gt; rolesCollection = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            Collection&lt;String&gt; premissionCollection = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">			<span class="comment">// 读取并赋值用户角色与权限</span></span><br><span class="line">            Set&lt;RoleBean&gt; roles = user.getRole();</span><br><span class="line">            <span class="keyword">for</span>(RoleBean role : roles)&#123;</span><br><span class="line">                rolesCollection.add(role.getName());</span><br><span class="line">                Set&lt;PermissionBean&gt; permissions = role.getPermissions();</span><br><span class="line">                <span class="keyword">for</span> (PermissionBean permission : permissions)&#123;</span><br><span class="line">                    premissionCollection.add(permission.getUrl());</span><br><span class="line">                &#125;</span><br><span class="line">                info.addStringPermissions(premissionCollection);</span><br><span class="line">            &#125;</span><br><span class="line">            info.addRoles(rolesCollection);</span><br><span class="line">            <span class="keyword">return</span> info;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户认证</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"===执行认证==="</span>);</span><br><span class="line"></span><br><span class="line">        UsernamePasswordToken token = (UsernamePasswordToken)authenticationToken;</span><br><span class="line">        UserBean bean = userService.findByName(token.getUsername());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(bean == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnknownAccountException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ByteSource credentialsSalt = ByteSource.Util.bytes(bean.getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(bean, bean.getPassword(),</span><br><span class="line">                credentialsSalt, getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟Shiro用户加密，假设用户密码为123456</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 用户名</span></span><br><span class="line">        String username = <span class="string">"rhine"</span>;</span><br><span class="line">        <span class="comment">// 用户密码</span></span><br><span class="line">        String password = <span class="string">"123456"</span>;</span><br><span class="line">        <span class="comment">// 加密方式</span></span><br><span class="line">        String hashAlgorithName = <span class="string">"MD5"</span>;</span><br><span class="line">        <span class="comment">// 加密次数</span></span><br><span class="line">        <span class="keyword">int</span> hashIterations = <span class="number">1024</span>;</span><br><span class="line">        ByteSource credentialsSalt = ByteSource.Util.bytes(username);</span><br><span class="line">        Object obj = <span class="keyword">new</span> SimpleHash(hashAlgorithName, password, </span><br><span class="line">                                    credentialsSalt, hashIterations);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><a name="t17"></a><a name="t17"></a><a id="45_service_536"></a>4.5 service</h3>
<p><strong>UserService.java</strong></p>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rhine.blog.service;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UserService抽象接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">UserBean <span class="title">findByName</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3>接口实现</h3>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> UserBean <span class="title">findByName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 查询用户是否存在</span></span><br><span class="line">		UserBean bean = userMapper.findByName(name);</span><br><span class="line">		<span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 查询用户信息、角色、权限</span></span><br><span class="line">			bean = userMapper.findById(bean.getId());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><a name="t18"></a><a name="t18"></a><a id="46_controller_577"></a>4.6 controller</h3>
<p><strong>MainController.java</strong></p>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rhine.blog.controller;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户登录、登出、错误页面跳转控制器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/main"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span>&#123;</span><br><span class="line">        response.setHeader(<span class="string">"root"</span>, request.getContextPath());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/toLogin"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toLogin</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span>&#123;</span><br><span class="line">        response.setHeader(<span class="string">"root"</span>, request.getContextPath());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"login"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span>&#123;</span><br><span class="line">        response.setHeader(<span class="string">"root"</span>, request.getContextPath());</span><br><span class="line">        String userName = request.getParameter(<span class="string">"username"</span>);</span><br><span class="line">        String password = request.getParameter(<span class="string">"password"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.获取Subject</span></span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="comment">// 2.封装用户数据</span></span><br><span class="line">        UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(userName, password);</span><br><span class="line">        <span class="comment">// 3.执行登录方法</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            subject.login(token);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"redirect:/main"</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownAccountException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            request.setAttribute(<span class="string">"msg"</span>,<span class="string">"用户名不存在！"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IncorrectCredentialsException e)&#123;</span><br><span class="line">            request.setAttribute(<span class="string">"msg"</span>,<span class="string">"密码错误！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"login"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/logout"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">logout</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="keyword">if</span> (subject != <span class="keyword">null</span>) &#123;</span><br><span class="line">            subject.logout();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:/main"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/error/unAuth"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">unAuth</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"/error/unAuth"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>UserController.java</strong></p>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rhine.blog.controller;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户页面跳转</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 	 * 个人中心，需认证可访问</span></span><br><span class="line"><span class="comment"> 	 */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/user/index"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">        UserBean bean = (UserBean) SecurityUtils.getSubject().getPrincipal();</span><br><span class="line">        request.setAttribute(<span class="string">"userName"</span>, bean.getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"/user/index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 	 * 会员中心，需认证且角色为vip可访问</span></span><br><span class="line"><span class="comment"> 	 */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/vip/index"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"/vip/index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><a name="t19"></a><a name="t19"></a><a id="5__672"></a>5 页面</h2>
<p><strong>login.html——登录页面</strong></p>
<pre class="prettyprint"><code class="prism language-html has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token doctype">&lt;!DOCTYPE html&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>登录<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>用户登录<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>from<span class="token punctuation">"</span></span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${root!}/login<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>用户名<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>请输入账户名<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>密码<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>请输入密码<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">colspan</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>red<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>${msg!}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">colspan</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>登录<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>reset<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>重置<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>

<p><strong>index.html——首页</strong></p>
<pre class="prettyprint"><code class="prism language-html has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token doctype">&lt;!DOCTYPE html&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>首页<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>首页<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user/index<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>个人中心<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>vip/index<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>会员中心<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>logout<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>退出登录<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>

<p><strong>/user/index.html——用户中心</strong></p>
<pre class="prettyprint"><code class="prism language-html has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token doctype">&lt;!DOCTYPE html&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>用户中心<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>用户中心<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>欢迎${userName!},这里是用户中心<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>

<p><strong>/vip/index.html——会员中心</strong></p>
<pre class="prettyprint"><code class="prism language-html has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token doctype">&lt;!DOCTYPE html&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>会员中心<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>会员中心<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>欢迎来到<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>red<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>会员中心<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>

<p><strong>/error/unAuth.html——未授权提示页面</strong></p>
<pre class="prettyprint"><code class="prism language-html has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token doctype">&lt;!DOCTYPE html&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>未授权提示<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>您还不是<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>red<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>会员<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">&gt;</span></span>，没有权限访问这个页面！<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>

<h2><a name="t20"></a><a name="t20"></a><a id="6__783"></a>6 测试运行</h2>
<h3><a name="t21"></a><a name="t21"></a><a id="61__785"></a>6.1 普通用户登录</h3>
<p><img src="https://img-blog.csdnimg.cn/20181211180559596.gif" alt="普通会员登录" width="600"></p>
<h3><a name="t22"></a><a name="t22"></a><a id="62__787"></a>6.2 会员用户登录</h3>
<p><img src="https://img-blog.csdnimg.cn/20181211180613541.gif" alt="会员用户登录" width="600"></p>
原创 我是你妹她哥


<p>原文链接：<a href="https://blog.csdn.net/bicheng4769/article/details/86668209" target="_blank" rel="noopener">https://blog.csdn.net/bicheng4769/article/details/86668209</a></p>
</code></pre></code></pre></code></pre></code></pre></code></pre></code></pre>]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>boot Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring面试题</title>
    <url>/myblog/interview/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>Spring概述</p>
<a id="more"></a>
<p>什么是spring?</p>
<h5 id="什么是spring"><a href="#什么是spring" class="headerlink" title="什么是spring?"></a>什么是spring?</h5><p>Spring是<strong>一个轻量级Java开发框架</strong>，最早有<strong>Rod Johnson</strong>创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的JavaSE/JavaEE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。</p>
<p>Spring最根本的使命是<strong>解决企业级应用开发的复杂性，即简化Java开发</strong>。</p>
<p>Spring可以做很多事情，它为企业级开发提供给了丰富的功能，但是这些功能的底层都依赖于它的两个核心特性，也就是<strong>依赖注入（dependency injection，DI</strong>）和<strong>面向切面编程（aspect-oriented programming，AOP）</strong>。</p>
<p>为了降低Java开发的复杂性，Spring采取了以下4种关键策略</p>
<ul>
<li>基于POJO的轻量级和最小侵入性编程；</li>
<li>通过依赖注入和面向接口实现松耦合；</li>
<li>基于切面和惯例进行声明式编程；</li>
<li>通过切面和模板减少样板式代码。</li>
</ul>
<h5 id="Spring框架的设计目标，设计理念，和核心是什么"><a href="#Spring框架的设计目标，设计理念，和核心是什么" class="headerlink" title="Spring框架的设计目标，设计理念，和核心是什么"></a>Spring框架的设计目标，设计理念，和核心是什么</h5><p><strong>Spring设计目标</strong>：Spring为开发者提供一个一站式轻量级应用开发平台；</p>
<p><strong>Spring设计理念</strong>：在JavaEE开发中，支持POJO和JavaBean开发方式，使应用面向接口开发，充分支持OO（面向对象）设计方法；Spring通过IoC容器实现对象耦合关系的管理，并实现依赖反转，将对象之间的依赖关系交给IoC容器，实现解耦；</p>
<p><strong>Spring框架的核心：</strong>IoC容器和AOP模块。通过IoC容器管理POJO对象以及他们之间的耦合关系；通过AOP以动态非侵入的方式增强服务。</p>
<p>IoC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。、</p>
<!--more-->

<h5 id="Spring的优缺点是什么？"><a href="#Spring的优缺点是什么？" class="headerlink" title="Spring的优缺点是什么？"></a>Spring的优缺点是什么？</h5><p>优点</p>
<ul>
<li>方便解耦，简化开发</li>
</ul>
<p>Spring就是一个大工厂，可以将所有对象的创建和依赖关系的维护，交给Spring管理。</p>
<ul>
<li>AOP编程的支持</li>
</ul>
<p>Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。</p>
<ul>
<li>声明式事务的支持</li>
</ul>
<p>只需要通过配置就可以完成对事务的管理，而无需手动编程。</p>
<ul>
<li>方便程序的测试</li>
</ul>
<p>Spring对Junit4支持，可以通过注解方便的测试Spring程序。</p>
<ul>
<li>方便集成各种优秀框架</li>
</ul>
<p>Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持（如：Struts、Hibernate、MyBatis等）。</p>
<ul>
<li>降低JavaEE API的使用难度</li>
</ul>
<p>Spring对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低。</p>
<p>缺点</p>
<ul>
<li>Spring明明一个很轻量级的框架，却给人感觉大而全</li>
<li>Spring依赖反射，反射影响性能</li>
<li>使用门槛升高，入门Spring需要较长时间</li>
</ul>
<h5 id="Spring有哪些应用场景"><a href="#Spring有哪些应用场景" class="headerlink" title="Spring有哪些应用场景"></a>Spring有哪些应用场景</h5><p><strong>应用场景</strong>：JavaEE企业应用开发，包括SSH、SSM等</p>
<p><strong>Spring价值：</strong></p>
<ul>
<li>Spring是非侵入式的框架，目标是使应用程序代码对框架依赖最小化；</li>
<li>Spring提供一个一致的编程模型，使应用直接使用POJO开发，与运行环境隔离开来；</li>
<li>Spring推动应用设计风格向面向对象和面向接口开发转变，提高了代码的重用性和可测试性；</li>
</ul>
<h5 id="Spring由哪些模块组成？"><a href="#Spring由哪些模块组成？" class="headerlink" title="Spring由哪些模块组成？"></a>Spring由哪些模块组成？</h5><p>Spring 总共大约有 20 个模块， 由 1300 多个不同的文件构成。 而这些组件被分别整合在核心容器（Core Container） 、 AOP（Aspect Oriented Programming）和设备支持（Instrmentation） 、数据访问与集成（Data Access/Integeration） 、 Web、 消息（Messaging） 、 Test等 6 个模块中。 以下是 Spring 5 的模块结构图：</p>
<p><img src="https://img-blog.csdnimg.cn/2019102923475419.png" alt></p>
<ul>
<li>spring core：提供了框架的基本组成部分，包括控制反转（Inversion of Control，IOC）和依赖注入（Dependency Injection，DI）功能。</li>
<li>spring beans：提供了BeanFactory，是工厂模式的一个经典实现，Spring将管理对象称为Bean。</li>
<li>spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。</li>
<li>spring jdbc：提供了一个JDBC的抽象层，消除了烦琐的JDBC编码和数据库厂商特有的错误代码解析， 用于简化JDBC。</li>
<li>spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。</li>
<li>spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。</li>
<li>spring test：主要为测试提供支持的，支持使用JUnit或TestNG对Spring组件进行单元测试和集成测试。</li>
</ul>
<h5 id="Spring-框架中都用到了哪些设计模式？"><a href="#Spring-框架中都用到了哪些设计模式？" class="headerlink" title="Spring 框架中都用到了哪些设计模式？"></a>Spring 框架中都用到了哪些设计模式？</h5><ul>
<li>工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；</li>
<li>单例模式：Bean默认为单例模式。</li>
<li>代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；</li>
<li>模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</li>
<li>观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。</li>
</ul>
<h5 id="详细讲解一下核心容器（spring-context应用上下文-模块"><a href="#详细讲解一下核心容器（spring-context应用上下文-模块" class="headerlink" title="详细讲解一下核心容器（spring context应用上下文) 模块"></a>详细讲解一下核心容器（spring context应用上下文) 模块</h5><p>这是基本的Spring模块，提供spring 框架的基础功能，BeanFactory 是 任何以spring为基础的应用的核心。Spring 框架建立在此模块之上，它使Spring成为一个容器。</p>
<p>Bean 工厂是工厂模式的一个实现，提供了控制反转功能，用来把应用的配置和依赖从真正的应用代码中分离。最常用的就是org.springframework.beans.factory.xml.XmlBeanFactory ，它根据XML文件中的定义加载beans。该容器从XML 文件读取配置元数据并用它去创建一个完全配置的系统或应用。<br>Spring框架中有哪些不同类型的事件</p>
<h5 id="Spring-提供了以下5种标准的事件："><a href="#Spring-提供了以下5种标准的事件：" class="headerlink" title="Spring 提供了以下5种标准的事件："></a>Spring 提供了以下5种标准的事件：</h5><ol>
<li>上下文更新事件（ContextRefreshedEvent）：在调用ConfigurableApplicationContext 接口中的refresh()方法时被触发。</li>
<li>上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始/重新开始容器时触发该事件。</li>
<li>上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。</li>
<li>上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。</li>
<li>请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。如果一个bean实现了ApplicationListener接口，当一个ApplicationEvent 被发布以后，bean会自动被通知。</li>
</ol>
<h5 id="Spring-应用程序有哪些不同组件？"><a href="#Spring-应用程序有哪些不同组件？" class="headerlink" title="Spring 应用程序有哪些不同组件？"></a>Spring 应用程序有哪些不同组件？</h5><p>Spring 应用一般有以下组件：</p>
<ul>
<li>接口 - 定义功能。</li>
<li>Bean 类 - 它包含属性，setter 和 getter 方法，函数等。</li>
<li>Bean 配置文件 - 包含类的信息以及如何配置它们。</li>
<li>Spring 面向切面编程（AOP） - 提供面向切面编程的功能。</li>
<li>用户程序 - 它使用接口。</li>
</ul>
<h5 id="使用-Spring-有哪些方式？"><a href="#使用-Spring-有哪些方式？" class="headerlink" title="使用 Spring 有哪些方式？"></a>使用 Spring 有哪些方式？</h5><p>使用 Spring 有以下方式：</p>
<ul>
<li>作为一个成熟的 Spring Web 应用程序。</li>
<li>作为第三方 Web 框架，使用 Spring Frameworks 中间层。</li>
<li>作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java Objects）。</li>
<li>用于远程使用。</li>
</ul>
<h4 id="Spring控制反转-IOC"><a href="#Spring控制反转-IOC" class="headerlink" title="Spring控制反转(IOC)"></a>Spring控制反转(IOC)</h4><h5 id="什么是Spring-IOC-容器？"><a href="#什么是Spring-IOC-容器？" class="headerlink" title="什么是Spring IOC 容器？"></a>什么是Spring IOC 容器？</h5><p>控制反转即IoC (Inversion of Control)，它把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。</p>
<p>Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</p>
<h5 id="控制反转-IoC-有什么作用"><a href="#控制反转-IoC-有什么作用" class="headerlink" title="控制反转(IoC)有什么作用"></a>控制反转(IoC)有什么作用</h5><ul>
<li>管理对象的创建和依赖关系的维护。对象的创建并不是一件简单的事，在对象关系比较复杂时，如果依赖关系需要程序猿来维护的话，那是相当头疼的</li>
<li>解耦，由容器去维护具体的对象</li>
<li>托管了类的产生过程，比如我们需要在类的产生过程中做一些处理，最直接的例子就是代理，如果有容器程序可以把这部分处理交给容器，应用程序则无需去关心类是如何完成代理的</li>
</ul>
<h5 id="IOC的优点是什么？"><a href="#IOC的优点是什么？" class="headerlink" title="IOC的优点是什么？"></a>IOC的优点是什么？</h5><ul>
<li>IOC 或 依赖注入把应用的代码量降到最低。</li>
<li>它使应用容易测试，单元测试不再需要单例和JNDI查找机制。</li>
<li>最小的代价和最小的侵入性使松散耦合得以实现。</li>
<li>IOC容器支持加载服务时的饿汉式初始化和懒加载</li>
</ul>
<h5 id="Spring-IoC-的实现机制"><a href="#Spring-IoC-的实现机制" class="headerlink" title="Spring IoC 的实现机制"></a>Spring IoC 的实现机制</h5><p>Spring 中的 IoC 的实现原理就是工厂模式加反射机制。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Apple"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Orange"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">getInstance</span><span class="params">(String ClassName)</span> </span>&#123;</span><br><span class="line">        Fruit f=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f=(Fruit)Class.forName(ClassName).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] a)</span> </span>&#123;</span><br><span class="line">        Fruit f=Factory.getInstance(<span class="string">"io.github.dunwu.spring.Apple"</span>);</span><br><span class="line">        <span class="keyword">if</span>(f!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            f.eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Spring-的-IoC支持哪些功能"><a href="#Spring-的-IoC支持哪些功能" class="headerlink" title="Spring 的 IoC支持哪些功能"></a>Spring 的 IoC支持哪些功能</h5><p>Spring 的 IoC 设计支持以下功能：</p>
<ul>
<li>依赖注入</li>
<li>依赖检查</li>
<li>自动装配</li>
<li>支持集合</li>
<li>指定初始化方法和销毁方法</li>
<li>支持回调某些方法（但是需要实现 Spring 接口，略有侵入）</li>
</ul>
<p>其中，最重要的就是依赖注入，从 XML 的配置上说，即 ref 标签。对应 Spring RuntimeBeanReference 对象。</p>
<p>对于 IoC 来说，最重要的就是容器。容器管理着 Bean 的生命周期，控制着 Bean 的依赖注入。</p>
<h5 id="BeanFactory-和-ApplicationContext有什么区别？"><a href="#BeanFactory-和-ApplicationContext有什么区别？" class="headerlink" title="BeanFactory 和 ApplicationContext有什么区别？"></a>BeanFactory 和 ApplicationContext有什么区别？</h5><p>BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。</p>
<p>依赖关系</p>
<p>BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。</p>
<p>ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：</p>
<ul>
<li>继承MessageSource，因此支持国际化。</li>
<li>统一的资源文件访问方式。</li>
<li>提供在监听器中注册bean的事件。</li>
<li>同时加载多个配置文件。</li>
<li>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</li>
</ul>
<p>加载方式</p>
<p>BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</p>
<p>ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</p>
<p>相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p>
<p>创建方式</p>
<p>BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。</p>
<p>注册方式</p>
<p>BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</p>
<h5 id="Spring-如何设计容器的，BeanFactory和ApplicationContext的关系详解"><a href="#Spring-如何设计容器的，BeanFactory和ApplicationContext的关系详解" class="headerlink" title="Spring 如何设计容器的，BeanFactory和ApplicationContext的关系详解"></a>Spring 如何设计容器的，BeanFactory和ApplicationContext的关系详解</h5><p>Spring 作者 Rod Johnson 设计了两个接口用以表示容器。</p>
<ul>
<li>BeanFactory</li>
<li>ApplicationContext</li>
</ul>
<p>BeanFactory 简单粗暴，可以理解为就是个 HashMap，Key 是 BeanName，Value 是 Bean 实例。通常只提供注册（put），获取（get）这两个功能。我们可以称之为 “低级容器”。</p>
<p>ApplicationContext 可以称之为 <strong>“高级容器”</strong>。因为他比 BeanFactory 多了更多的功能。他继承了多个接口。因此具备了更多的功能。例如资源的获取，支持多种消息（例如 JSP tag 的支持），对 BeanFactory 多了工具级别的支持等待。所以你看他的名字，已经不是 BeanFactory 之类的工厂了，而是 “应用上下文”， 代表着整个大容器的所有功能。该接口定义了一个 refresh 方法，此方法是所有阅读 Spring 源码的人的最熟悉的方法，用于刷新整个容器，即重新加载/刷新所有的 bean。</p>
<p>当然，除了这两个大接口，还有其他的辅助接口，这里就不介绍他们了。</p>
<p>BeanFactory和ApplicationContext的关系</p>
<p>为了更直观的展示 “低级容器” 和 “高级容器” 的关系，这里通过常用的 ClassPathXmlApplicationContext 类来展示整个容器的层级 UML 关系。</p>
<p><img src="https://img-blog.csdnimg.cn/20191105111441363.png" alt></p>
<p>有点复杂？ 先不要慌，我来解释一下。</p>
<p>最上面的是 BeanFactory，下面的 3 个绿色的，都是功能扩展接口，这里就不展开讲。</p>
<p>看下面的隶属 ApplicationContext 粉红色的 “高级容器”，依赖着 “低级容器”，这里说的是依赖，不是继承哦。他依赖着 “低级容器” 的 getBean 功能。而高级容器有更多的功能：支持不同的信息源头，可以访问文件资源，支持应用事件（Observer 模式）。</p>
<p>通常用户看到的就是 “高级容器”。 但 BeanFactory 也非常够用啦！</p>
<p>左边灰色区域的是 “低级容器”， 只负载加载 Bean，获取 Bean。容器其他的高级功能是没有的。例如上图画的 refresh 刷新 Bean 工厂所有配置，生命周期事件回调等。</p>
<p>小结</p>
<p>说了这么多，不知道你有没有理解Spring IoC？ 这里小结一下：IoC 在 Spring 里，只需要低级容器就可以实现，2 个步骤：</p>
<ol>
<li>加载配置文件，解析成 BeanDefinition 放在 Map 里。</li>
<li>调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入。</li>
</ol>
<p>上面就是 Spring 低级容器（BeanFactory）的 IoC。</p>
<p>至于高级容器 ApplicationContext，他包含了低级容器的功能，当他执行 refresh 模板方法的时候，将刷新整个容器的 Bean。同时其作为高级容器，包含了太多的功能。一句话，他不仅仅是 IoC。他支持不同信息源头，支持 BeanFactory 工具类，支持层级容器，支持访问文件资源，支持事件发布通知，支持接口回调等等。</p>
<h5 id="ApplicationContext通常的实现是什么？"><a href="#ApplicationContext通常的实现是什么？" class="headerlink" title="ApplicationContext通常的实现是什么？"></a>ApplicationContext通常的实现是什么？</h5><p><strong>FileSystemXmlApplicationContext</strong> ：此容器从一个XML文件中加载beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。</p>
<p><strong>ClassPathXmlApplicationContext</strong>：此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。</p>
<p><strong>WebXmlApplicationContext</strong>：此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。</p>
<h5 id="什么是Spring的依赖注入？"><a href="#什么是Spring的依赖注入？" class="headerlink" title="什么是Spring的依赖注入？"></a>什么是Spring的依赖注入？</h5><p>控制反转IoC是一个很大的概念，可以用不同的方式来实现。其主要实现方式有两种：依赖注入和依赖查找</p>
<p>依赖注入：相对于IoC而言，依赖注入(DI)更加准确地描述了IoC的设计理念。所谓依赖注入（Dependency Injection），即组件之间的依赖关系由容器在应用系统运行期来决定，也就是由容器动态地将某种依赖关系的目标对象实例注入到应用系统中的各个关联的组件之中。组件不做定位查询，只提供普通的Java方法让容器去决定依赖关系。</p>
<h5 id="依赖注入的基本原则"><a href="#依赖注入的基本原则" class="headerlink" title="依赖注入的基本原则"></a>依赖注入的基本原则</h5><p>依赖注入的基本原则是：应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由IoC容器负责，“查找资源”的逻辑应该从应用组件的代码中抽取出来，交给IoC容器负责。容器全权负责组件的装配，它会把符合依赖关系的对象通过属性（JavaBean中的setter）或者是构造器传递给需要的对象。</p>
<h5 id="依赖注入有什么优势"><a href="#依赖注入有什么优势" class="headerlink" title="依赖注入有什么优势"></a>依赖注入有什么优势</h5><p>依赖注入之所以更流行是因为它是一种更可取的方式：让容器全权负责依赖查询，受管组件只需要暴露JavaBean的setter方法或者带参数的构造器或者接口，使容器可以在初始化时组装对象的依赖关系。其与依赖查找方式相比，主要优势为：</p>
<ul>
<li>查找定位操作与应用代码完全无关。</li>
<li>不依赖于容器的API，可以很容易地在任何容器以外使用应用对象。</li>
<li>不需要特殊的接口，绝大多数对象可以做到完全不必依赖容器。</li>
</ul>
<h5 id="有哪些不同类型的依赖注入实现方式？"><a href="#有哪些不同类型的依赖注入实现方式？" class="headerlink" title="有哪些不同类型的依赖注入实现方式？"></a>有哪些不同类型的依赖注入实现方式？</h5><p>依赖注入是时下最流行的IoC实现方式，依赖注入分为接口注入（Interface Injection），Setter方法注入（Setter Injection）和构造器注入（Constructor Injection）三种方式。其中接口注入由于在灵活性和易用性比较差，现在从Spring4开始已被废弃。</p>
<p><strong>构造器依赖注入</strong>：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</p>
<p><strong>Setter方法注入</strong>：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。</p>
<h5 id="构造器依赖注入和-Setter方法注入的区别"><a href="#构造器依赖注入和-Setter方法注入的区别" class="headerlink" title="构造器依赖注入和 Setter方法注入的区别"></a>构造器依赖注入和 Setter方法注入的区别</h5><table>
<thead>
<tr>
<th align="center"><strong>构造函数注入</strong></th>
<th align="center"><strong>setter</strong> <strong>注入</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">没有部分注入</td>
<td align="center">有部分注入</td>
</tr>
<tr>
<td align="center">不会覆盖 setter 属性</td>
<td align="center">会覆盖 setter 属性</td>
</tr>
<tr>
<td align="center">任意修改都会创建一个新实例</td>
<td align="center">任意修改不会创建一个新实例</td>
</tr>
<tr>
<td align="center">适用于设置很多属性</td>
<td align="center">适用于设置少量属性</td>
</tr>
</tbody></table>
<p>两种依赖方式都可以使用，构造器注入和Setter方法注入。最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖。</p>
<h4 id="Spring-Beans（19）"><a href="#Spring-Beans（19）" class="headerlink" title="Spring Beans（19）"></a>Spring Beans（19）</h4><h5 id="什么是Spring-beans？"><a href="#什么是Spring-beans？" class="headerlink" title="什么是Spring beans？"></a>什么是Spring beans？</h5><p>Spring beans 是那些形成Spring应用的主干的java对象。它们被Spring IOC容器初始化，装配，和管理。这些beans通过容器中配置的元数据创建。比如，以XML文件中 的形式定义。</p>
<h5 id="一个-Spring-Bean-定义-包含什么？"><a href="#一个-Spring-Bean-定义-包含什么？" class="headerlink" title="一个 Spring Bean 定义 包含什么？"></a>一个 Spring Bean 定义 包含什么？</h5><p>一个Spring Bean 的定义包含容器必知的所有配置元数据，包括如何创建一个bean，它的生命周期详情及它的依赖。<br>如何给Spring 容器提供配置元数据？Spring有几种配置方式</p>
<p>这里有三种重要的方法给Spring 容器提供配置元数据。</p>
<ul>
<li>XML配置文件。</li>
<li>基于注解的配置。</li>
<li>基于java的配置。</li>
</ul>
<h4 id="Spring配置文件包含了哪些信息"><a href="#Spring配置文件包含了哪些信息" class="headerlink" title="Spring配置文件包含了哪些信息"></a>Spring配置文件包含了哪些信息</h4><p>Spring配置文件是个XML 文件，这个文件包含了类信息，描述了如何配置它们，以及如何相互调用。</p>
<h5 id="Spring基于xml注入bean的几种方式"><a href="#Spring基于xml注入bean的几种方式" class="headerlink" title="Spring基于xml注入bean的几种方式"></a>Spring基于xml注入bean的几种方式</h5><ol>
<li>Set方法注入；</li>
<li>构造器注入：①通过index设置参数的位置；②通过type设置参数类型；</li>
<li>静态工厂注入；</li>
<li>实例工厂；</li>
</ol>
<h5 id="你怎样定义类的作用域？"><a href="#你怎样定义类的作用域？" class="headerlink" title="你怎样定义类的作用域？"></a>你怎样定义类的作用域？</h5><p>当定义一个 在Spring里，我们还能给这个bean声明一个作用域。它可以通过bean 定义中的scope属性来定义。如，当Spring要在需要的时候每次生产一个新的bean实例，bean的scope属性被指定为prototype。另一方面，一个bean每次使用的时候必须返回同一个实例，这个bean的scope 属性 必须设为 singleton。<br>解释Spring支持的几种bean的作用域</p>
<h5 id="Spring框架支持以下五种bean的作用域："><a href="#Spring框架支持以下五种bean的作用域：" class="headerlink" title="Spring框架支持以下五种bean的作用域："></a>Spring框架支持以下五种bean的作用域：</h5><ul>
<li><p>singleton : bean在每个Spring ioc 容器中只有一个实例。</p>
</li>
<li><p>prototype：一个bean的定义可以有多个实例。</p>
</li>
<li><p>request：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。</p>
</li>
<li><p>session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</p>
</li>
<li><p>global-session：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring </p>
<p>ApplicationContext情形下有效。</p>
</li>
</ul>
<p><strong>注意</strong>： 缺省的Spring bean 的作用域是Singleton。使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</p>
<h5 id="Spring框架中的单例bean是线程安全的吗？"><a href="#Spring框架中的单例bean是线程安全的吗？" class="headerlink" title="Spring框架中的单例bean是线程安全的吗？"></a><strong>Spring框架中的单例bean是线程安全的吗？</strong></h5><p>不是，Spring框架中的单例bean不是线程安全的。</p>
<p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。</p>
<p>实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。</p>
<ul>
<li>有状态就是有数据存储功能。</li>
<li>无状态就是不会保存数据。</li>
</ul>
<h5 id="Spring如何处理线程并发问题？"><a href="#Spring如何处理线程并发问题？" class="headerlink" title="Spring如何处理线程并发问题？"></a>Spring如何处理线程并发问题？</h5><p>在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域，因为Spring对一些Bean中非线程安全状态采用ThreadLocal进行处理，解决线程安全问题。</p>
<p>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。</p>
<p>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p>
<h5 id="解释Spring框架中bean的生命周期"><a href="#解释Spring框架中bean的生命周期" class="headerlink" title="解释Spring框架中bean的生命周期"></a>解释Spring框架中bean的生命周期</h5><p>在传统的Java应用中，bean的生命周期很简单。使用Java关键字new进行bean实例化，然后该bean就可以使用了。一旦该bean不再被使用，则由Java自动进行垃圾回收。相比之下，Spring容器中的bean的生命周期就显得相对复杂多了。正确理解Spring bean的生命周期非常重要，因为你或许要利用Spring提供的扩展点来自定义bean的创建过程。下图展示了bean装载到Spring应用上下文中的一个典型的生命周期过程。</p>
<p><img src="https://img-blog.csdnimg.cn/201911012343410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt></p>
<p>bean在Spring容器中从创建到销毁经历了若干阶段，每一阶段都可以针对Spring如何管理bean进行个性化定制。</p>
<p>正如你所见，在bean准备就绪之前，bean工厂执行了若干启动步骤。</p>
<p>我们对上图进行详细描述：</p>
<p>Spring对bean进行实例化；</p>
<p>Spring将值和bean的引用注入到bean对应的属性中；</p>
<p>如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBean-Name()方法；</p>
<p>如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入；</p>
<p>如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来；</p>
<p>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessBeforeInitialization()方法；</p>
<p>如果bean实现了InitializingBean接口，Spring将调用它们的after-PropertiesSet()方法。类似地，如果bean使用initmethod声明了初始化方法，该方法也会被调用；</p>
<p>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessAfterInitialization()方法；</p>
<p>此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；</p>
<p>如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用。</p>
<p>现在你已经了解了如何创建和加载一个Spring容器。但是一个空的容器并没有太大的价值，在你把东西放进去之前，它里面什么都没有。为了从Spring的DI(依赖注入)中受益，我们必须将应用对象装配进Spring容器中。</p>
<h5 id="哪些是重要的bean生命周期方法？-你能重载它们吗？"><a href="#哪些是重要的bean生命周期方法？-你能重载它们吗？" class="headerlink" title="哪些是重要的bean生命周期方法？ 你能重载它们吗？"></a>哪些是重要的bean生命周期方法？ 你能重载它们吗？</h5><p>有两个重要的bean 生命周期方法，第一个是setup ， 它是在容器加载bean的时候被调用。第二个方法是 teardown 它是在容器卸载类的时候被调用。</p>
<p>bean 标签有两个重要的属性（init-method和destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct和@PreDestroy）。</p>
<h5 id="什么是Spring的内部bean？什么是Spring-inner-beans？"><a href="#什么是Spring的内部bean？什么是Spring-inner-beans？" class="headerlink" title="什么是Spring的内部bean？什么是Spring inner beans？"></a>什么是Spring的内部bean？什么是Spring inner beans？</h5><p>在Spring框架中，当一个bean仅被用作另一个bean的属性时，它能被声明为一个内部bean。内部bean可以用setter注入“属性”和构造方法注入“构造参数”的方式来实现，内部bean通常是匿名的，它们的Scope一般是prototype。</p>
<h5 id="在-Spring中如何注入一个java集合？"><a href="#在-Spring中如何注入一个java集合？" class="headerlink" title="在 Spring中如何注入一个java集合？"></a>在 Spring中如何注入一个java集合？</h5><p>Spring提供以下几种集合的配置元素：</p>
<p>类型用于注入一列值，允许有相同的值。</p>
<p>类型用于注入一组值，不允许有相同的值。</p>
<p>类型用于注入一组键值对，键和值都可以为任意类型。</p>
<p>类型用于注入一组键值对，键和值都只能为String类型。</p>
<h5 id="什么是bean装配？"><a href="#什么是bean装配？" class="headerlink" title="什么是bean装配？"></a>什么是bean装配？</h5><p>装配，或bean 装配是指在Spring 容器中把bean组装到一起，前提是容器需要知道bean的依赖关系，如何通过依赖注入来把它们装配到一起。</p>
<h5 id="什么是bean的自动装配？"><a href="#什么是bean的自动装配？" class="headerlink" title="什么是bean的自动装配？"></a>什么是bean的自动装配？</h5><p>在Spring框架中，在配置文件中设定bean的依赖关系是一个很好的机制，Spring 容器能够自动装配相互合作的bean，这意味着容器不需要和配置，能通过Bean工厂自动处理bean之间的协作。这意味着 Spring可以通过向Bean Factory中注入的方式自动搞定bean之间的依赖关系。自动装配可以设置在每个bean上，也可以设定在特定的bean上。</p>
<h5 id="解释不同方式的自动装配，spring-自动装配-bean-有哪些方式？"><a href="#解释不同方式的自动装配，spring-自动装配-bean-有哪些方式？" class="headerlink" title="解释不同方式的自动装配，spring 自动装配 bean 有哪些方式？"></a>解释不同方式的自动装配，spring 自动装配 bean 有哪些方式？</h5><p>在spring中，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象，使用autowire来配置自动装载模式。</p>
<p>在Spring框架xml配置中共有5种自动装配：</p>
<ul>
<li>no：默认的方式是不进行自动装配的，通过手工设置ref属性来进行装配bean。</li>
<li>byName：通过bean的名称进行自动装配，如果一个bean的 property 与另一bean 的name 相同，就进行自动装配。</li>
<li>byType：通过参数的数据类型进行自动装配。</li>
<li>constructor：利用构造函数进行装配，并且构造函数的参数通过byType进行装配。</li>
<li>autodetect：自动探测，如果有构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。</li>
</ul>
<h5 id="使用-Autowired注解自动装配的过程是怎样的？"><a href="#使用-Autowired注解自动装配的过程是怎样的？" class="headerlink" title="使用@Autowired注解自动装配的过程是怎样的？"></a>使用@Autowired注解自动装配的过程是怎样的？</h5><p>使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，&lt;context:annotation-config /&gt;。</p>
<p>在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：</p>
<ul>
<li>如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；</li>
<li>如果查询的结果不止一个，那么@Autowired会根据名称来查找；</li>
<li>如果上述查找的结果为空，那么会抛出异常。解决方法时，使用required=false。</li>
</ul>
<h5 id="自动装配有哪些局限性？"><a href="#自动装配有哪些局限性？" class="headerlink" title="自动装配有哪些局限性？"></a>自动装配有哪些局限性？</h5><p>自动装配的局限性是：</p>
<p><strong>重写</strong>：你仍需用 和 配置来定义依赖，意味着总要重写自动装配。</p>
<p><strong>基本数据类型</strong>：你不能自动装配简单的属性，如基本数据类型，String字符串，和类。</p>
<p><strong>模糊特性</strong>：自动装配不如显式装配精确，如果有可能，建议使用显式装配。</p>
<h5 id="你可以在Spring中注入一个null-和一个空字符串吗？"><a href="#你可以在Spring中注入一个null-和一个空字符串吗？" class="headerlink" title="你可以在Spring中注入一个null 和一个空字符串吗？"></a>你可以在Spring中注入一个null 和一个空字符串吗？</h5><p>可以。</p>
<h4 id="Spring注解（8）"><a href="#Spring注解（8）" class="headerlink" title="Spring注解（8）"></a>Spring注解（8）</h4><h5 id="什么是基于Java的Spring注解配置-给一些注解的例子"><a href="#什么是基于Java的Spring注解配置-给一些注解的例子" class="headerlink" title="什么是基于Java的Spring注解配置? 给一些注解的例子"></a>什么是基于Java的Spring注解配置? 给一些注解的例子</h5><p>基于Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring配置而非通过XML文件。</p>
<p>以@Configuration 注解为例，它用来标记类可以当做一个bean的定义，被Spring IOC容器使用。</p>
<p>另一个例子是@Bean注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StudentBean <span class="title">myStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StudentBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="怎样开启注解装配？"><a href="#怎样开启注解装配？" class="headerlink" title="怎样开启注解装配？"></a>怎样开启注解装配？</h5><p>注解装配在默认情况下是不开启的，为了使用注解装配，我们必须在Spring配置文件中配置 <a href="context:annotation-config/">context:annotation-config/</a>元素。</p>
<h5 id="Component-Controller-Repository-Service-有何区别？"><a href="#Component-Controller-Repository-Service-有何区别？" class="headerlink" title="@Component, @Controller, @Repository, @Service 有何区别？"></a>@Component, @Controller, @Repository, @Service 有何区别？</h5><p>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</p>
<p>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</p>
<p>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。</p>
<p>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</p>
<h5 id="Required-注解有什么作用"><a href="#Required-注解有什么作用" class="headerlink" title="@Required 注解有什么作用"></a>@Required 注解有什么作用</h5><p>这个注解表明bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动装配，若@Required注解的bean属性未被设置，容器将抛出BeanInitializationException。示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Required</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> string <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Autowired-注解有什么作用"><a href="#Autowired-注解有什么作用" class="headerlink" title="@Autowired 注解有什么作用"></a>@Autowired 注解有什么作用</h5><p>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。@Autowired 注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它的用法和@Required一样，修饰setter方法、构造器、属性或者具有任意名称和/或多个参数的PN方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> string <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Autowired和-Resource之间的区别"><a href="#Autowired和-Resource之间的区别" class="headerlink" title="@Autowired和@Resource之间的区别"></a>@Autowired和@Resource之间的区别</h5><p>@Autowired可用于：构造函数、成员变量、Setter方法</p>
<p>@Autowired和@Resource之间的区别</p>
<ul>
<li>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。</li>
<li>@Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。</li>
</ul>
<h5 id="Qualifier-注解有什么作用"><a href="#Qualifier-注解有什么作用" class="headerlink" title="@Qualifier 注解有什么作用"></a>@Qualifier 注解有什么作用</h5><p>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。</p>
<h5 id="RequestMapping-注解有什么用？"><a href="#RequestMapping-注解有什么用？" class="headerlink" title="@RequestMapping 注解有什么用？"></a>@RequestMapping 注解有什么用？</h5><p>@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。此注释可应用于两个级别：</p>
<ul>
<li>类级别：映射请求的 URL</li>
<li>方法级别：映射 URL 以及 HTTP 请求方法</li>
</ul>
<h4 id="Spring数据访问（14）"><a href="#Spring数据访问（14）" class="headerlink" title="Spring数据访问（14）"></a>Spring数据访问（14）</h4><h5 id="解释对象-关系映射集成模块"><a href="#解释对象-关系映射集成模块" class="headerlink" title="解释对象/关系映射集成模块"></a>解释对象/关系映射集成模块</h5><p>Spring 通过提供ORM模块，支持我们在直接JDBC之上使用一个对象/关系映射映射(ORM)工具，Spring 支持集成主流的ORM框架，如Hiberate，JDO和 iBATIS，JPA，TopLink，JDO，OJB 。Spring的事务管理同样支持以上所有ORM框架及JDBC。</p>
<h5 id="在Spring框架中如何更有效地使用JDBC？"><a href="#在Spring框架中如何更有效地使用JDBC？" class="headerlink" title="在Spring框架中如何更有效地使用JDBC？"></a>在Spring框架中如何更有效地使用JDBC？</h5><p>使用Spring JDBC 框架，资源管理和错误处理的代价都会被减轻。所以开发者只需写statements 和 queries从数据存取数据，JDBC也可以在Spring框架提供的模板类的帮助下更有效地被使用，这个模板叫JdbcTemplate</p>
<h5 id="解释JDBC抽象和DAO模块"><a href="#解释JDBC抽象和DAO模块" class="headerlink" title="解释JDBC抽象和DAO模块"></a>解释JDBC抽象和DAO模块</h5><p>通过使用JDBC抽象和DAO模块，保证数据库代码的简洁，并能避免数据库资源错误关闭导致的问题，它在各种不同的数据库的错误信息之上，提供了一个统一的异常访问层。它还利用Spring的AOP 模块给Spring应用中的对象提供事务管理服务。</p>
<h5 id="spring-DAO-有什么用？"><a href="#spring-DAO-有什么用？" class="headerlink" title="spring DAO 有什么用？"></a>spring DAO 有什么用？</h5><p>Spring DAO（数据访问对象） 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。</p>
<h5 id="spring-JDBC-API-中存在哪些类？"><a href="#spring-JDBC-API-中存在哪些类？" class="headerlink" title="spring JDBC API 中存在哪些类？"></a>spring JDBC API 中存在哪些类？</h5><p>JdbcTemplate</p>
<p>SimpleJdbcTemplate</p>
<p>NamedParameterJdbcTemplate</p>
<p>SimpleJdbcInsert</p>
<p>SimpleJdbcCall</p>
<h5 id="JdbcTemplate是什么"><a href="#JdbcTemplate是什么" class="headerlink" title="JdbcTemplate是什么"></a>JdbcTemplate是什么</h5><p>JdbcTemplate 类提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</p>
<h5 id="使用Spring通过什么方式访问Hibernate？使用-Spring-访问-Hibernate-的方法有哪些？"><a href="#使用Spring通过什么方式访问Hibernate？使用-Spring-访问-Hibernate-的方法有哪些？" class="headerlink" title="使用Spring通过什么方式访问Hibernate？使用 Spring 访问 Hibernate 的方法有哪些？"></a>使用Spring通过什么方式访问Hibernate？使用 Spring 访问 Hibernate 的方法有哪些？</h5><p>在Spring中有两种方式访问Hibernate：</p>
<ul>
<li>使用 Hibernate 模板和回调进行控制反转</li>
<li>扩展 HibernateDAOSupport 并应用 AOP 拦截器节点</li>
</ul>
<h5 id="如何通过HibernateDaoSupport将Spring和Hibernate结合起来？"><a href="#如何通过HibernateDaoSupport将Spring和Hibernate结合起来？" class="headerlink" title="如何通过HibernateDaoSupport将Spring和Hibernate结合起来？"></a>如何通过HibernateDaoSupport将Spring和Hibernate结合起来？</h5><p>用Spring的 SessionFactory 调用 LocalSessionFactory。集成过程分三步：</p>
<ul>
<li>配置the Hibernate SessionFactory</li>
<li>继承HibernateDaoSupport实现一个DAO</li>
<li>在AOP支持的事务中装配</li>
</ul>
<h5 id="Spring支持的事务管理类型，-spring-事务实现方式有哪些？"><a href="#Spring支持的事务管理类型，-spring-事务实现方式有哪些？" class="headerlink" title="Spring支持的事务管理类型， spring 事务实现方式有哪些？"></a>Spring支持的事务管理类型， spring 事务实现方式有哪些？</h5><p>Spring支持两种类型的事务管理：</p>
<p><strong>编程式事务管理</strong>：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。</p>
<p><strong>声明式事务管理</strong>：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。</p>
<h5 id="Spring事务的实现方式和实现原理"><a href="#Spring事务的实现方式和实现原理" class="headerlink" title="Spring事务的实现方式和实现原理"></a>Spring事务的实现方式和实现原理</h5><p>Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。真正的数据库层的事务提交和回滚是通过binlog或者redo log实现的。</p>
<h5 id="说一下Spring的事务传播行为"><a href="#说一下Spring的事务传播行为" class="headerlink" title="说一下Spring的事务传播行为"></a>说一下Spring的事务传播行为</h5><p>spring事务的传播行为说的是，当多个事务同时存在的时候，spring如何处理这些事务的行为。</p>
<pre><code>① PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。

② PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。

③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。

④ PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。

⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。

⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。

⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。</code></pre><h5 id="说一下-spring-的事务隔离？"><a href="#说一下-spring-的事务隔离？" class="headerlink" title="说一下 spring 的事务隔离？"></a>说一下 spring 的事务隔离？</h5><p>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</p>
<ol>
<li>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</li>
<li>ISOLATION_READ_UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；</li>
<li>ISOLATION_READ_COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；</li>
<li>ISOLATION_REPEATABLE_READ：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；</li>
<li>ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</li>
</ol>
<p><strong>脏读</strong> ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p>
<p><strong>不可重复读</strong> ：是指在一个事务内，多次读同一数据。</p>
<p><strong>幻读</strong> ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p>
<h5 id="Spring框架的事务管理有哪些优点？"><a href="#Spring框架的事务管理有哪些优点？" class="headerlink" title="Spring框架的事务管理有哪些优点？"></a>Spring框架的事务管理有哪些优点？</h5><ul>
<li>为不同的事务API 如 JTA，JDBC，Hibernate，JPA 和JDO，提供一个不变的编程模式。</li>
<li>为编程式事务管理提供了一套简单的API而不是一些复杂的事务API</li>
<li>支持声明式事务管理。</li>
<li>和Spring各种数据访问抽象层很好得集成。</li>
</ul>
<h5 id="你更倾向用那种事务管理类型？"><a href="#你更倾向用那种事务管理类型？" class="headerlink" title="你更倾向用那种事务管理类型？"></a>你更倾向用那种事务管理类型？</h5><p>大多数Spring框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务管理，虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</p>
<h4 id="Spring面向切面编程-AOP-（13）"><a href="#Spring面向切面编程-AOP-（13）" class="headerlink" title="Spring面向切面编程(AOP)（13）"></a>Spring面向切面编程(AOP)（13）</h4><h5 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h5><p>OOP(Object-Oriented Programming)面向对象编程，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。</p>
<p>AOP(Aspect-Oriented Programming)，一般称为面向切面编程，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等。</p>
<h5 id="Spring-AOP-and-AspectJ-AOP-有什么区别？AOP-有哪些实现方式？"><a href="#Spring-AOP-and-AspectJ-AOP-有什么区别？AOP-有哪些实现方式？" class="headerlink" title="Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？"></a>Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？</h5><p>AOP实现的关键在于 代理模式，AOP代理主要分为静态代理和动态代理。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。</p>
<p>（1）AspectJ是静态代理的增强，所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的AOP对象。</p>
<p>（2）Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p>
<h5 id="JDK动态代理和CGLIB动态代理的区别"><a href="#JDK动态代理和CGLIB动态代理的区别" class="headerlink" title="JDK动态代理和CGLIB动态代理的区别"></a>JDK动态代理和CGLIB动态代理的区别</h5><p>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：</p>
<ul>
<li>JDK动态代理只提供接口的代理，不支持类的代理。核心InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的实例, 生成目标类的代理对象。</li>
<li>如果代理类没有实现 InvocationHandler 接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</li>
</ul>
<p>静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。</p>
<pre><code>InvocationHandler 的 invoke(Object proxy,Method method,Object[] args)：proxy是最终生成的代理实例; method 是被代理目标实例的某个具体方法; args 是被代理目标实例某个方法的具体入参, 在方法反射调用时使用。</code></pre><h5 id="如何理解-Spring-中的代理？"><a href="#如何理解-Spring-中的代理？" class="headerlink" title="如何理解 Spring 中的代理？"></a>如何理解 Spring 中的代理？</h5><p>将 Advice 应用于目标对象后创建的对象称为代理。在客户端对象的情况下，目标对象和代理对象是相同的。</p>
<p>Advice + Target Object = Proxy</p>
<h5 id="解释一下Spring-AOP里面的几个名词"><a href="#解释一下Spring-AOP里面的几个名词" class="headerlink" title="解释一下Spring AOP里面的几个名词"></a>解释一下Spring AOP里面的几个名词</h5><p>（1）切面（Aspect）：切面是通知和切点的结合。通知和切点共同定义了切面的全部内容。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @AspectJ 注解来实现。</p>
<p>（2）连接点（Join point）：指方法，在Spring AOP中，一个连接点 总是 代表一个方法的执行。 应用可能有数以千计的时机应用通知。这些时机被称为连接点。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</p>
<p>（3）通知（Advice）：在AOP术语中，切面的工作被称为通知。</p>
<p>（4）切入点（Pointcut）：切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。</p>
<p>（5）引入（Introduction）：引入允许我们向现有类添加新方法或属性。</p>
<p>（6）目标对象（Target Object）： 被一个或者多个切面（aspect）所通知（advise）的对象。它通常是一个代理对象。也有人把它叫做 被通知（adviced） 对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。</p>
<p>（7）织入（Weaving）：织入是把切面应用到目标对象并创建新的代理对象的过程。在目标对象的生命周期里有多少个点可以进行织入：</p>
<ul>
<li>编译期：切面在目标类编译时被织入。AspectJ的织入编译器是以这种方式织入切面的。</li>
<li>类加载期：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入就支持以这种方式织入切面。</li>
<li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面。</li>
</ul>
<h5 id="Spring在运行时通知对象"><a href="#Spring在运行时通知对象" class="headerlink" title="Spring在运行时通知对象"></a>Spring在运行时通知对象</h5><p>通过在代理类中包裹切面，Spring在运行期把切面织入到Spring管理的bean中。代理封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标bean。当代理拦截到方法调用时，在调用目标bean方法之前，会执行切面逻辑。</p>
<p>直到应用需要被代理的bean时，Spring才创建代理对象。如果使用的是ApplicationContext的话，在ApplicationContext从BeanFactory中加载所有bean的时候，Spring才会创建被代理的对象。因为Spring运行时才创建代理对象，所以我们不需要特殊的编译器来织入SpringAOP的切面。</p>
<h5 id="Spring只支持方法级别的连接点"><a href="#Spring只支持方法级别的连接点" class="headerlink" title="Spring只支持方法级别的连接点"></a>Spring只支持方法级别的连接点</h5><p>因为Spring基于动态代理，所以Spring只支持方法连接点。Spring缺少对字段连接点的支持，而且它不支持构造器连接点。方法之外的连接点拦截功能，我们可以利用Aspect来补充。</p>
<h5 id="在Spring-AOP-中，关注点和横切关注的区别是什么？在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处"><a href="#在Spring-AOP-中，关注点和横切关注的区别是什么？在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处" class="headerlink" title="在Spring AOP 中，关注点和横切关注的区别是什么？在 spring aop 中 concern 和 cross-cutting concern 的不同之处"></a>在Spring AOP 中，关注点和横切关注的区别是什么？在 spring aop 中 concern 和 cross-cutting concern 的不同之处</h5><p>关注点（concern）是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。</p>
<p>横切关注点（cross-cutting concern）是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。</p>
<h5 id="Spring通知有哪些类型？"><a href="#Spring通知有哪些类型？" class="headerlink" title="Spring通知有哪些类型？"></a>Spring通知有哪些类型？</h5><p>在AOP术语中，切面的工作被称为通知，实际上是程序执行时要通过SpringAOP框架触发的代码段。</p>
<p>Spring切面可以应用5种类型的通知：</p>
<ol>
<li><p>前置通知（Before）：在目标方法被调用之前调用通知功能；</p>
</li>
<li><p>后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</p>
</li>
<li><p>返回通知（After-returning ）：在目标方法成功执行之后调用通知；</p>
</li>
<li><p>异常通知（After-throwing）：在目标方法抛出异常后调用通知；</p>
</li>
<li><p>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</p>
<p> 同一个aspect，不同advice的执行顺序：<br> ①没有异常情况下的执行顺序：<br> around before advice<br> before advice<br> target method 执行<br> around after advice<br> after advice<br> afterReturning<br> ②有异常情况下的执行顺序：<br> around before advice<br> before advice<br> target method 执行<br> around after advice<br> after advice<br> afterThrowing:异常发生<br> java.lang.RuntimeException: 异常发生</p>
</li>
</ol>
<h5 id="什么是切面-Aspect？"><a href="#什么是切面-Aspect？" class="headerlink" title="什么是切面 Aspect？"></a>什么是切面 Aspect？</h5><p>aspect 由 pointcount 和 advice 组成，切面是通知和切点的结合。 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP 就是负责实施切面的框架, 它将切面所定义的横切逻辑编织到切面所指定的连接点中.<br>AOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:</p>
<ul>
<li>如何通过 pointcut 和 advice 定位到特定的 joinpoint 上</li>
<li>如何在 advice 中编写切面代码.</li>
</ul>
<p>可以简单地认为, 使用 @Aspect 注解的类就是切面.</p>
<p><img src="https://img-blog.csdnimg.cn/2020021212264438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt></p>
<h5 id="解释基于XML-Schema方式的切面实现"><a href="#解释基于XML-Schema方式的切面实现" class="headerlink" title="解释基于XML Schema方式的切面实现"></a>解释基于XML Schema方式的切面实现</h5><p>在这种情况下，切面由常规类以及基于XML的配置实现。</p>
<h5 id="解释基于注解的切面实现"><a href="#解释基于注解的切面实现" class="headerlink" title="解释基于注解的切面实现"></a>解释基于注解的切面实现</h5><p>在这种情况下(基于@AspectJ的实现)，涉及到的切面声明的风格与带有java5标注的普通java类一致。</p>
<h5 id="有几种不同类型的自动代理？"><a href="#有几种不同类型的自动代理？" class="headerlink" title="有几种不同类型的自动代理？"></a>有几种不同类型的自动代理？</h5><p>BeanNameAutoProxyCreator</p>
<p>DefaultAdvisorAutoProxyCreator</p>
<p>Metadata autoproxying</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat面试题</title>
    <url>/myblog/interview/Tomcat%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h5 id="Tomcat是什么？"><a href="#Tomcat是什么？" class="headerlink" title="Tomcat是什么？"></a>Tomcat是什么？</h5><a id="more"></a>
<p>Tomcat 服务器Apache软件基金会项目中的一个核心项目，是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。</p>
<h5 id="Tomcat的缺省端口是多少，怎么修改"><a href="#Tomcat的缺省端口是多少，怎么修改" class="headerlink" title="Tomcat的缺省端口是多少，怎么修改"></a>Tomcat的缺省端口是多少，怎么修改</h5><ol>
<li>找到Tomcat目录下的conf文件夹</li>
<li>进入conf文件夹里面找到server.xml文件</li>
<li>打开server.xml文件</li>
<li>在server.xml文件里面找到下列信息</li>
<li>把Connector标签的8080端口改成你想要的端口</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">"Catalina"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span> </span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span> </span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="tomcat-有哪几种Connector-运行模式-优化-？"><a href="#tomcat-有哪几种Connector-运行模式-优化-？" class="headerlink" title="tomcat 有哪几种Connector 运行模式(优化)？"></a>tomcat 有哪几种Connector 运行模式(优化)？</h5><!--more-->

<p>下面，我们先大致了解Tomcat Connector的三种运行模式。</p>
<ul>
<li><p><strong>BIO</strong>：同步并阻塞 一个线程处理一个请求。缺点：并发量高时，线程数较多，浪费资源。Tomcat7或以下，在Linux系统中默认使用这种方式。</p>
<p>配制项：protocol=”HTTP/1.1”</p>
</li>
<li><p>NIO：同步非阻塞IO</p>
</li>
<li><p>利用Java的异步IO处理，可以通过少量的线程处理大量的请求，可以复用同一个线程处理多个connection(多路复用)。</p>
</li>
<li><p>Tomcat8在Linux系统中默认使用这种方式。</p>
</li>
<li><p>Tomcat7必须修改Connector配置来启动。</p>
</li>
<li><p><strong>配制项</strong>：protocol=”org.apache.coyote.http11.Http11NioProtocol”</p>
</li>
<li><p><strong>备注</strong>：我们常用的Jetty，Mina，ZooKeeper等都是基于java nio实现.</p>
</li>
<li><p>APR：即Apache Portable Runtime，从操作系统层面解决io阻塞问题。<strong>AIO方式，</strong>异步非阻塞IO(Java NIO2又叫AIO) 主要与NIO的区别主要是操作系统的底层区别.可以做个比喻:比作快递，NIO就是网购后要自己到官网查下快递是否已经到了(可能是多次)，然后自己去取快递；AIO就是快递员送货上门了(不用关注快递进度)。</p>
</li>
<li><p><strong>配制项</strong>：protocol=”org.apache.coyote.http11.Http11AprProtocol”</p>
</li>
<li><p><strong>备注</strong>：需在本地服务器安装APR库。Tomcat7或Tomcat8在Win7或以上的系统中启动默认使用这种方式。Linux如果安装了apr和native，Tomcat直接启动就支持apr。</p>
</li>
</ul>
<h5 id="Tomcat有几种部署方式？"><a href="#Tomcat有几种部署方式？" class="headerlink" title="Tomcat有几种部署方式？"></a>Tomcat有几种部署方式？</h5><p><strong>在Tomcat中部署Web应用的方式主要有如下几种：</strong></p>
<ol>
<li><p>利用Tomcat的自动部署。</p>
<p>把web应用拷贝到webapps目录。Tomcat在启动时会加载目录下的应用，并将编译后的结果放入work目录下。</p>
</li>
<li><p>使用Manager App控制台部署。</p>
<p>在tomcat主页点击“Manager App” 进入应用管理控制台，可以指定一个web应用的路径或war文件。</p>
</li>
<li><p>修改conf/server.xml文件部署。</p>
<p>修改conf/server.xml文件，增加Context节点可以部署应用。</p>
</li>
<li><p>增加自定义的Web部署文件。</p>
</li>
</ol>
<p>​        在conf/Catalina/localhost/ 路径下增加 xyz.xml文件，内容是Context节点，可以部署应用。</p>
<h5 id="tomcat容器是如何创建servlet类实例？用到了什么原理？"><a href="#tomcat容器是如何创建servlet类实例？用到了什么原理？" class="headerlink" title="tomcat容器是如何创建servlet类实例？用到了什么原理？"></a>tomcat容器是如何创建servlet类实例？用到了什么原理？</h5><ol>
<li>当容器启动时，会读取在webapps目录下所有的web应用中的web.xml文件，然后对 xml文件进行解析，并读取servlet注册信息。然后，将每个应用中注册的servlet类都进行加载，并通过 反射的方式实例化。（有时候也是在第一次请求时实例化）</li>
<li>在servlet注册时加上1如果为正数，则在一开始就实例化，如果不写或为负数，则第一次请求实例化。</li>
</ol>
<h5 id="Tomcat工作模式"><a href="#Tomcat工作模式" class="headerlink" title="Tomcat工作模式"></a>Tomcat工作模式</h5><p>Tomcat作为servlet容器，有三种工作模式：</p>
<ul>
<li>1、独立的servlet容器，servlet容器是web服务器的一部分；</li>
<li>2、进程内的servlet容器，servlet容器是作为web服务器的插件和java容器的实现，web服务器插件在内部地址空间打开一个jvm使得java容器在内部得以运行。反应速度快但伸缩性不足；</li>
<li>3、进程外的servlet容器，servlet容器运行于web服务器之外的地址空间，并作为web服务器的插件和java容器实现的结合。反应时间不如进程内但伸缩性和稳定性比进程内优；</li>
</ul>
<p>进入Tomcat的请求可以根据Tomcat的工作模式分为如下两类：</p>
<ul>
<li>Tomcat作为应用程序服务器：请求来自于前端的web服务器，这可能是Apache, IIS, Nginx等；</li>
<li>Tomcat作为独立服务器：请求来自于web浏览器；</li>
</ul>
<p>面试时问到Tomcat相关问题的几率并不高，正式因为如此，很多人忽略了对Tomcat相关技能的掌握，下面这一篇文章整理了Tomcat相关的系统架构，介绍了Server、Service、Connector、Container之间的关系，各个模块的功能，可以说把这几个掌握住了，Tomcat相关的面试题你就不会有任何问题了！另外，在面试的时候你还要有意识无意识的往Tomcat这个地方引，就比如说常见的Spring MVC的执行流程，一个URL的完整调用链路，这些相关的题目你是可以往Tomcat处理请求的这个过程去说的！掌握了Tomcat这些技能，面试官一定会佩服你的！</p>
<p>学了本章之后你应该明白的是：</p>
<ul>
<li>Server、Service、Connector、Container四大组件之间的关系和联系，以及他们的主要功能点；</li>
<li>Tomcat执行的整体架构，请求是如何被一步步处理的；</li>
<li>Engine、Host、Context、Wrapper相关的概念关系；</li>
<li>Container是如何处理请求的；</li>
<li>Tomcat用到的相关设计模式；</li>
</ul>
<h5 id="Tomcat顶层架构"><a href="#Tomcat顶层架构" class="headerlink" title="Tomcat顶层架构"></a>Tomcat顶层架构</h5><p>俗话说，站在巨人的肩膀上看世界，一般学习的时候也是先总览一下整体，然后逐个部分个个击破，最后形成思路，了解具体细节，Tomcat的结构很复杂，但是 Tomcat 非常的模块化，找到了 Tomcat 最核心的模块，问题才可以游刃而解，了解了 Tomcat 的整体架构对以后深入了解 Tomcat 来说至关重要！</p>
<p>先上一张Tomcat的顶层结构图（图A），如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20191021215330153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt></p>
<p>Tomcat中最顶层的容器是Server，代表着整个服务器，从上图中可以看出，一个Server可以包含至少一个Service，即可以包含多个Service，用于具体提供服务。</p>
<p>Service主要包含两个部分：Connector和Container。从上图中可以看出 Tomcat 的心脏就是这两个组件，他们的作用如下：</p>
<ul>
<li>Connector用于处理连接相关的事情，并提供Socket与Request请求和Response响应相关的转化;</li>
<li>Container用于封装和管理Servlet，以及具体处理Request请求；</li>
</ul>
<p>一个Tomcat中只有一个Server，一个Server可以包含多个Service，一个Service只有一个Container，但是可以有多个Connectors，这是因为一个服务可以有多个连接，如同时提供Http和Https链接，也可以提供向相同协议不同端口的连接，示意图如下（Engine、Host、Context下面会说到）：</p>
<p><img src="https://img-blog.csdnimg.cn/20191021215344811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt></p>
<p>多个 Connector 和一个 Container 就形成了一个 Service，有了 Service 就可以对外提供服务了，但是 Service 还要一个生存的环境，必须要有人能够给她生命、掌握其生死大权，那就非 Server 莫属了！所以整个 Tomcat 的生命周期由 Server 控制。</p>
<p>另外，上述的包含关系或者说是父子关系，都可以在tomcat的conf目录下的server.xml配置文件中看出，下图是删除了注释内容之后的一个完整的server.xml配置文件（Tomcat版本为8.0）</p>
<p><img src="https://img-blog.csdnimg.cn/20191021215355649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt></p>
<p>详细的配置文件内容可以到Tomcat官网查看：Tomcat配置文件</p>
<p>上边的配置文件，还可以通过下边的一张结构图更清楚的理解：</p>
<p><img src="https://img-blog.csdnimg.cn/2019102121541531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt></p>
<p>Server标签设置的端口号为8005，shutdown=”SHUTDOWN” ，表示在8005端口监听“SHUTDOWN”命令，如果接收到了就会关闭Tomcat。一个Server有一个Service，当然还可以进行配置，一个Service有多个Connector，Service左边的内容都属于Container的，Service下边是Connector。</p>
<h5 id="Tomcat顶层架构小结"><a href="#Tomcat顶层架构小结" class="headerlink" title="Tomcat顶层架构小结"></a>Tomcat顶层架构小结</h5><ol>
<li>Tomcat中只有一个Server，一个Server可以有多个Service，一个Service可以有多个Connector和一个Container；</li>
<li>Server掌管着整个Tomcat的生死大权；</li>
<li>Service 是对外提供服务的；</li>
<li>Connector用于接受请求并将请求封装成Request和Response来具体处理；</li>
<li>Container用于封装和管理Servlet，以及具体处理request请求；</li>
</ol>
<p>知道了整个Tomcat顶层的分层架构和各个组件之间的关系以及作用，对于绝大多数的开发人员来说Server和Service对我们来说确实很远，而我们开发中绝大部分进行配置的内容是属于Connector和Container的，所以接下来介绍一下Connector和Container。</p>
<h5 id="Connector和Container的微妙关系"><a href="#Connector和Container的微妙关系" class="headerlink" title="Connector和Container的微妙关系"></a>Connector和Container的微妙关系</h5><p>由上述内容我们大致可以知道一个请求发送到Tomcat之后，首先经过Service然后会交给我们的Connector，Connector用于接收请求并将接收的请求封装为Request和Response来具体处理，Request和Response封装完之后再交由Container进行处理，Container处理完请求之后再返回给Connector，最后在由Connector通过Socket将处理的结果返回给客户端，这样整个请求的就处理完了！</p>
<p>Connector最底层使用的是Socket来进行连接的，Request和Response是按照HTTP协议来封装的，所以Connector同时需要实现TCP/IP协议和HTTP协议！</p>
<p>Tomcat既然需要处理请求，那么肯定需要先接收到这个请求，接收请求这个东西我们首先就需要看一下Connector！</p>
<p>Connector架构分析</p>
<p>Connector用于接受请求并将请求封装成Request和Response，然后交给Container进行处理，Container处理完之后在交给Connector返回给客户端。</p>
<p>因此，我们可以把Connector分为四个方面进行理解：</p>
<ol>
<li>Connector如何接受请求的？</li>
<li>如何将请求封装成Request和Response的？</li>
<li>封装完之后的Request和Response如何交给Container进行处理的？</li>
<li>Container处理完之后如何交给Connector并返回给客户端的？</li>
</ol>
<p>首先看一下Connector的结构图（图B），如下所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20191021215430677.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt></p>
<p>Connector就是使用ProtocolHandler来处理请求的，不同的ProtocolHandler代表不同的连接类型，比如：Http11Protocol使用的是普通Socket来连接的，Http11NioProtocol使用的是NioSocket来连接的。</p>
<p>其中ProtocolHandler由包含了三个部件：Endpoint、Processor、Adapter。</p>
<ol>
<li>Endpoint用来处理底层Socket的网络连接，Processor用于将Endpoint接收到的Socket封装成Request，Adapter用于将Request交给Container进行具体的处理。</li>
<li>Endpoint由于是处理底层的Socket网络连接，因此Endpoint是用来实现TCP/IP协议的，而Processor用来实现HTTP协议的，Adapter将请求适配到Servlet容器进行具体的处理。</li>
<li>Endpoint的抽象实现AbstractEndpoint里面定义的Acceptor和AsyncTimeout两个内部类和一个Handler接口。Acceptor用于监听请求，AsyncTimeout用于检查异步Request的超时，Handler用于处理接收到的Socket，在内部调用Processor进行处理。</li>
</ol>
<p>至此，我们应该很轻松的回答1，2，3的问题了，但是4还是不知道，那么我们就来看一下Container是如何进行处理的以及处理完之后是如何将处理完的结果返回给Connector的？</p>
<h5 id="Container架构分析"><a href="#Container架构分析" class="headerlink" title="Container架构分析"></a>Container架构分析</h5><p>Container用于封装和管理Servlet，以及具体处理Request请求，在Container内部包含了4个子容器，结构图如下（图C）：</p>
<p><img src="https://img-blog.csdnimg.cn/20191021215443306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt></p>
<p>4个子容器的作用分别是：</p>
<ol>
<li>Engine：引擎，用来管理多个站点，一个Service最多只能有一个Engine；</li>
<li>Host：代表一个站点，也可以叫虚拟主机，通过配置Host就可以添加站点；</li>
<li>Context：代表一个应用程序，对应着平时开发的一套程序，或者一个WEB-INF目录以及下面的web.xml文件；</li>
<li>Wrapper：每一Wrapper封装着一个Servlet；</li>
</ol>
<p>下面找一个Tomcat的文件目录对照一下，如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20191021215455991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt></p>
<p>Context和Host的区别是Context表示一个应用，我们的Tomcat中默认的配置下webapps下的每一个文件夹目录都是一个Context，其中ROOT目录中存放着主应用，其他目录存放着子应用，而整个webapps就是一个Host站点。</p>
<p>我们访问应用Context的时候，如果是ROOT下的则直接使用域名就可以访问，例如：<a href="http://www.baidu.com，如果是Host（webapps）下的其他应用，则可以使用www.baidu.com/docs进行访问，当然默认指定的根应用（ROOT）是可以进行设定的，只不过Host站点下默认的主应用是ROOT目录下的。" target="_blank" rel="noopener">www.baidu.com，如果是Host（webapps）下的其他应用，则可以使用www.baidu.com/docs进行访问，当然默认指定的根应用（ROOT）是可以进行设定的，只不过Host站点下默认的主应用是ROOT目录下的。</a></p>
<p>看到这里我们知道Container是什么，但是还是不知道Container是如何进行请求处理的以及处理完之后是如何将处理完的结果返回给Connector的？别急！下边就开始探讨一下Container是如何进行处理的！</p>
<h5 id="Container如何处理请求的"><a href="#Container如何处理请求的" class="headerlink" title="Container如何处理请求的"></a>Container如何处理请求的</h5><p>Container处理请求是使用Pipeline-Valve管道来处理的！（Valve是阀门之意）</p>
<p>Pipeline-Valve是责任链模式，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将处理后的结果返回，再让下一个处理者继续处理。</p>
<p><img src="https://img-blog.csdnimg.cn/20191021215507725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt></p>
<p>但是！Pipeline-Valve使用的责任链模式和普通的责任链模式有些不同！区别主要有以下两点：</p>
<ul>
<li>每个Pipeline都有特定的Valve，而且是在管道的最后一个执行，这个Valve叫做BaseValve，BaseValve是不可删除的；</li>
<li>在上层容器的管道的BaseValve中会调用下层容器的管道。</li>
</ul>
<p>我们知道Container包含四个子容器，而这四个子容器对应的BaseValve分别在：StandardEngineValve、StandardHostValve、StandardContextValve、StandardWrapperValve。</p>
<p>Pipeline的处理流程图如下（图D）：</p>
<p><img src="https://img-blog.csdnimg.cn/20191021215519408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt></p>
<ul>
<li>Connector在接收到请求后会首先调用最顶层容器的Pipeline来处理，这里的最顶层容器的Pipeline就是EnginePipeline（Engine的管道）；</li>
<li>在Engine的管道中依次会执行EngineValve1、EngineValve2等等，最后会执行StandardEngineValve，在StandardEngineValve中会调用Host管道，然后再依次执行Host的HostValve1、HostValve2等，最后在执行StandardHostValve，然后再依次调用Context的管道和Wrapper的管道，最后执行到StandardWrapperValve。</li>
<li>当执行到StandardWrapperValve的时候，会在StandardWrapperValve中创建FilterChain，并调用其doFilter方法来处理请求，这个FilterChain包含着我们配置的与请求相匹配的Filter和Servlet，其doFilter方法会依次调用所有的Filter的doFilter方法和Servlet的service方法，这样请求就得到了处理！</li>
<li>当所有的Pipeline-Valve都执行完之后，并且处理完了具体的请求，这个时候就可以将返回的结果交给Connector了，Connector在通过Socket的方式将结果返回给客户端。</li>
</ul>
<p><strong>总结</strong></p>
<p>至此，我们已经对Tomcat的整体架构有了大致的了解，从图A、B、C、D可以看出来每一个组件的基本要素和作用。我们在脑海里应该有一个大概的轮廓了！如果你面试的时候，让你简单的聊一下Tomcat，上面的内容你能脱口而出吗？当你能够脱口而出的时候，面试官一定会对你刮目相看的！</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>Welcome</title>
    <url>/myblog/uncategorized/Welcome/</url>
    <content><![CDATA[<img src="http://chfsun.gitee.io/cdn/bg_music.jpg">
<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>java端生成token</title>
    <url>/myblog/token/ava%E7%AB%AF%E7%94%9F%E6%88%90token/</url>
    <content><![CDATA[<h2 id="java后端生成token"><a href="#java后端生成token" class="headerlink" title="java后端生成token"></a>java后端生成token</h2><a id="more"></a>
<h4 id="一、创建一个Token-类"><a href="#一、创建一个Token-类" class="headerlink" title="一、创建一个Token 类"></a>一、创建一个Token 类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lxl.utils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * token编码工具类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ouyangjun</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Token</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 编码密码,可自定义</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ENCODED_PASSWORD = <span class="string">"ouyangjun"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 编码</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encoded</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> strToHex(encodedString(str, ENCODED_PASSWORD));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 转换</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">encodedString</span><span class="params">(String str, String password)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">char</span>[] pwd = password.toCharArray();</span><br><span class="line">		<span class="keyword">int</span> pwdLen = pwd.length;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">char</span>[] strArray = str.toCharArray();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strArray.length; i++) &#123;</span><br><span class="line">			strArray[i] = (<span class="keyword">char</span>) (strArray[i] ^ pwd[i % pwdLen] ^ pwdLen);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> String(strArray);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">strToHex</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> bytesToHexStr(s.getBytes());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">bytesToHexStr</span><span class="params">(<span class="keyword">byte</span>[] bytesArray)</span> </span>&#123;</span><br><span class="line">		StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		String hexStr;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">byte</span> bt : bytesArray) &#123;</span><br><span class="line">			hexStr = Integer.toHexString(bt &amp; <span class="number">0xFF</span>);</span><br><span class="line">			<span class="keyword">if</span> (hexStr.length() == <span class="number">1</span>) &#123;</span><br><span class="line">				builder.append(<span class="string">"0"</span>);</span><br><span class="line">				builder.append(hexStr);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				builder.append(hexStr);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> builder.toString();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 解码</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decoded</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">		String hexStr = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			hexStr = hexStrToStr(str);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (hexStr != <span class="keyword">null</span>) &#123;</span><br><span class="line">			hexStr = encodedString(hexStr, ENCODED_PASSWORD);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> hexStr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">hexStrToStr</span><span class="params">(String hexStr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> String(hexStrToBytes(hexStr));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] hexStrToBytes(String hexStr) &#123;</span><br><span class="line">		String hex;</span><br><span class="line">		<span class="keyword">int</span> val;</span><br><span class="line">		<span class="keyword">byte</span>[] btHexStr = <span class="keyword">new</span> <span class="keyword">byte</span>[hexStr.length() / <span class="number">2</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; btHexStr.length; i++) &#123;</span><br><span class="line">			hex = hexStr.substring(<span class="number">2</span> * i, <span class="number">2</span> * i + <span class="number">2</span>);</span><br><span class="line">			val = Integer.valueOf(hex, <span class="number">16</span>);</span><br><span class="line">			btHexStr[i] = (<span class="keyword">byte</span>) val;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> btHexStr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二、再创建一个TokenUtils类"><a href="#二、再创建一个TokenUtils类" class="headerlink" title="二、再创建一个TokenUtils类"></a>二、再创建一个TokenUtils类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lxl.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.lxl.utils.Token;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * token生成和校验</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ouyangjun</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, String&gt; MAP_TOKENS = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VALID_TIME = <span class="number">60</span> * <span class="number">60</span> * <span class="number">2</span>; <span class="comment">// token有效期(秒)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOKEN_ERROR = <span class="string">"F"</span>; <span class="comment">// 非法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOKEN_OVERDUE = <span class="string">"G"</span>; <span class="comment">// 过期</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOKEN_FAILURE = <span class="string">"S"</span>; <span class="comment">// 失效</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 生成token,该token长度不一致,如需一致,可自行MD5或者其它方式加密一下 </span></span><br><span class="line"><span class="comment">                 * 该方式的token只存在磁盘上,如果项目是分布式,最好用redis存储</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> str: 该字符串可自定义,在校验token时要保持一致</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getToken</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">		String token = Token.encoded(getCurrentTime() + <span class="string">","</span> + str);</span><br><span class="line">		MAP_TOKENS.put(str, token);</span><br><span class="line">		<span class="keyword">return</span> token;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 校验token的有效性</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">checkToken</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (token == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> TOKEN_ERROR;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			String[] tArr = Token.decoded(token).split(<span class="string">","</span>);</span><br><span class="line">			<span class="keyword">if</span> (tArr.length != <span class="number">2</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> TOKEN_ERROR;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// token生成时间戳</span></span><br><span class="line">			<span class="keyword">int</span> tokenTime = Integer.parseInt(tArr[<span class="number">0</span>]);</span><br><span class="line">			<span class="comment">// 当前时间戳</span></span><br><span class="line">			<span class="keyword">int</span> currentTime = getCurrentTime();</span><br><span class="line">			<span class="keyword">if</span> (currentTime - tokenTime &lt; VALID_TIME) &#123;</span><br><span class="line">				String tokenStr = tArr[<span class="number">1</span>];</span><br><span class="line">				String mToken = MAP_TOKENS.get(tokenStr);</span><br><span class="line">				<span class="keyword">if</span> (mToken == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">return</span> TOKEN_OVERDUE;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mToken.equals(token)) &#123;</span><br><span class="line">					<span class="keyword">return</span> TOKEN_FAILURE;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> tokenStr;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> TOKEN_OVERDUE;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> TOKEN_ERROR;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 获取当前时间戳（10位整数） */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCurrentTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">int</span>) (System.currentTimeMillis() / <span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 移除过期的token</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeInvalidToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> currentTime = getCurrentTime();</span><br><span class="line">		<span class="keyword">for</span> (Entry&lt;String, String&gt; entry : MAP_TOKENS.entrySet()) &#123;</span><br><span class="line">			String[] tArr = Token.decoded(entry.getValue()).split(<span class="string">","</span>);</span><br><span class="line">			<span class="keyword">int</span> tokenTime = Integer.parseInt(tArr[<span class="number">0</span>]);</span><br><span class="line">			<span class="keyword">if</span> (currentTime - tokenTime &gt; VALID_TIME) &#123;</span><br><span class="line">				MAP_TOKENS.remove(entry.getKey());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>三、测试类测试调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 测试</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String str = <span class="string">"username_and_password"</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 获取token</span></span><br><span class="line">		String token = TokenUtils.getToken(str);</span><br><span class="line">		System.out.println(<span class="string">"token Result: "</span> + token);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 校验token</span></span><br><span class="line">		String checkToken = TokenUtils.checkToken(token);</span><br><span class="line">		System.out.println(<span class="string">"checkToken Result: "</span> + checkToken);</span><br><span class="line">		<span class="keyword">if</span>(str.equals(checkToken)) &#123;</span><br><span class="line">			System.out.println(<span class="string">"==&gt;token verification succeeded!"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>token</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>token</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka入门及spring boot下简单整合</title>
    <url>/myblog/spring-boot/kafka%E5%85%A5%E9%97%A8%E5%8F%8Aspring-boot%E4%B8%8B%E7%AE%80%E5%8D%95%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<h2 id="win10下安装kafka"><a href="#win10下安装kafka" class="headerlink" title="win10下安装kafka"></a>win10下安装kafka</h2><p>注：kafka依赖于zookeeper，官网下载的kafka内置了zookeeper依赖。</p>
<h3>1. 下载Kafka</h3>
网址：http://kafka.apache.org/
<a id="more"></a>
<br>
<p>解压缩：<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNTEwODI5OC0zYzQ3M2MwNDc1MmFmZWZkLnBuZw?x-oss-process=image/format,png" alt><br>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNTEwODI5OC1jMWQ1Mzk2ZWNhMGM1N2RjLnBuZw?x-oss-process=image/format,png" alt></p>
<h3><a name="t1"></a><a name="t1"></a><a id="2__8"></a>2. 修改配置文件</h3>
<p>进入到config目录，修改service.properties：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNTEwODI5OC0zNWZhZjQ5YWVmNjUzODQyLnBuZw?x-oss-process=image/format,png" alt>
broker.id设置：https://cloud.tencent.com/developer/news/378568

<br>
更改为自行创建的文件夹
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNTEwODI5OC1hNGY2ZTNiMmU1ZGYyNzk2LnBuZw?x-oss-process=image/format,png" alt></p>
<h3><a name="t2"></a><a name="t2"></a><a id="3__15"></a>3. 进行单机实例测试简单使用</h3>
<h5><a name="t3"></a><a name="t3"></a><a id="1_kafkazookeeper_17"></a>(1) 启动kafka内置的zookeeper</h5>
<p>运行cmd命令：<br>
.\bin\windows\zookeeper-server-start.bat  .\config\zookeeper.properties</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNTEwODI5OC0yNmU3ODc0NzQ0NTllMWVmLnBuZw?x-oss-process=image/format,png" alt="启动kafka内置zookeeper"></p>
<p>不关闭当前窗口。</p>
<h5><a name="t4"></a><a name="t4"></a><a id="2_kafka_26"></a>(2) 启动kafka服务</h5>
<p>运行cmd命令：<br>
.\bin\windows\kafka-server-start.bat .\config\server.properties</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNTEwODI5OC0xM2FjYWRiMDdmZGRiYTAzLnBuZw?x-oss-process=image/format,png" alt="启动kafka服务"></p>
<p>不关闭当前窗口。</p>
<h5><a name="t5"></a><a name="t5"></a><a id="3_test1topickafka_35"></a>(3) 创建一个名为test1的topic测试主题kafka</h5>
<p>运行cmd命令：<br>
.\bin\windows\kafka-topics.bat --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test1</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNTEwODI5OC02ZTVlMmIxYzZjMTNiY2JjLnBuZw?x-oss-process=image/format,png" alt="创建kafka测试主题test1"></p>
<p>该窗口可关闭。</p>
<h5><a name="t6"></a><a name="t6"></a><a id="4__44"></a>(4) 创建消息生产者生产消息</h5>
<p>运行cmd命令：<br>
.\bin\windows\kafka-console-producer.bat --broker-list localhost:9092 --topic test1</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNTEwODI5OC1hMWI0MmQ2N2UwNTg5MmRiLnBuZw?x-oss-process=image/format,png" alt="创建消息生产者"></p>
<p>不关闭当前窗口。</p>
<h5><a name="t7"></a><a name="t7"></a><a id="5__53"></a>(5) 创建消息消费者接收消息</h5>
<p>运行cmd命令：<br>
.\bin\windows\kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic test1 --from-beginning</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNTEwODI5OC04NTM1MzZjNmYwNzRmZWY5LnBuZw?x-oss-process=image/format,png" alt="创建消息消费者"></p>
<p>不关闭当前窗口。</p>
<h5><a name="t8"></a><a name="t8"></a><a id="6__62"></a>(6) 测试消息发送和接收</h5>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNTEwODI5OC1kNmZkMjUyOTBiNzFkMmZlLnBuZw?x-oss-process=image/format,png" alt="测试"></p>
<p>测试成功。</p>
<br>
## 常用命令：

<h3>删除topic：</h3>

<p>彻底删除Kafka中的topic</p>
<p>1、删除kafka存储目录（server.properties文件log.dirs配置，默认为”/tmp/kafka-logs”）相关topic目录</p>
<p>2、Kafka 删除topic的命令是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/kafka-topics  --delete --zookeeper 【zookeeper server】  --topic 【topic name】</span><br></pre></td></tr></table></figure>

<p>   如果kafaka启动时加载的配置文件中server.properties没有配置delete.topic.enable=true，那么此时的删除并不是真正的删除，而是把topic标记为：marked for deletion</p>
<p>   你可以通过命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.\bin\windows\kafka-topics.bat --list --zookeeper localhost:2181</span><br></pre></td></tr></table></figure>

<p>   来查看所有topic</p>
<p>   此时你若想真正删除它，可以如下操作：</p>
<pre><code>（1）登录zookeeper客户端：命令：./bin/zookeeper-client

（2）找到topic所在的目录：ls /brokers/topics

（3）找到要删除的topic，执行命令：rmr /brokers/topics/【topic name】即可，此时topic被彻底删除。</code></pre><p>   另外被标记为marked for deletion的topic你可以在zookeeper客户端中通过命令获得：ls /admin/delete_topics/【topic name】，</p>
<p>   如果你删除了此处的topic，那么marked for deletion 标记消失</p>
<p>   zookeeper 的config中也有有关topic的信息： ls /config/topics/【topic name】暂时不知道有什么用</p>
<h3>总结：</h3>

<p>彻底删除topic：</p>
<p> 1、删除kafka存储目录（server.properties文件log.dirs配置，默认为”/tmp/kafka-logs”）相关topic目录</p>
<p> 2、如果配置了delete.topic.enable=true直接通过命令删除，如果命令删除不掉，直接通过zookeeper-client 删除掉broker下的topic即可。<br><br></p>
<h2 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h2><ul>
<li>kafka是伪集群，因为虚拟机有限，zookeeper也是集群</li>
</ul>
<ul>
<li>dubbo是微服务，微小的服务，如果并发量不是太高，上千万，上亿级别的或者想要返回结果的可以用dubbo</li>
</ul>
<ul>
<li>kafka是消息队列，如果想提高吞吐量，不要返回结果(返回结果可以放在redis里)就可以用它</li>
</ul>
<ul>
<li>不过上面的两种一般都有，当进行服务降级或者服务熔断时消息队列就大有用处</li>
</ul>
<p>Kafka是一个分布式的消息存储系统,提供了四大核心接口：</p>
<blockquote>
<p>1.Producer API允许了应用可以向Kafka中的topics发布消息；<br>2.Consumer API允许了应用可以订阅Kafka中的topics,并消费消息；<br>3.Streams API允许应用可以作为消息流的处理者，比如可以从topicA中消费消息，处理的结果发布到topicB中；<br>4.Connector API提供Kafka与现有的应用或系统适配功能，比如与数据库连接器可以捕获表结构的变化；</p>
</blockquote>
<br>

<blockquote>
<p>Topic —&gt; 每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic. Producer —&gt; 负责发布消息到Kafka<br>broker. Consumer —&gt; 消息消费者，向Kafka broker读取消息的客户端.<br><br></p>
</blockquote>
<p>更多请查看官网：<a href="http://kafka.apachecn.org/" target="_blank" rel="noopener">http://kafka.apachecn.org/</a></p>
<h2 id="spring-boot整合kafka"><a href="#spring-boot整合kafka" class="headerlink" title="spring boot整合kafka"></a>spring boot整合kafka</h2><p><em>PS:当前demo是基于注解实现</em></p>
<p>1、请保持zookeeper、kafka服务启动中</p>
<p>2、eclipse中新建项目<br><img src="https://img-blog.csdnimg.cn/20200425093407252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">3、pom文件如下：</p>
<pre><code> &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;
    &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre><p>4、配置文件application.yml如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  kafka:</span><br><span class="line">    bootstrap-servers: 127.0.0.1:9092 #指定kafka server的地址，集群配多个，中间，逗号隔开</span><br><span class="line">    producer:</span><br><span class="line">      key-serializer: org.apache.kafka.common.serialization.StringSerializer</span><br><span class="line">      value-serializer: org.apache.kafka.common.serialization.StringSerializer</span><br><span class="line">    consumer:</span><br><span class="line">      group-id: default_consumer_group #群组ID</span><br><span class="line">      enable-auto-commit: <span class="keyword">true</span></span><br><span class="line">      auto-commit-interval: <span class="number">1000</span></span><br><span class="line">      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer</span><br><span class="line">      value-deserializer: org.apache.kafka.common.serialization.StringDeserializer</span><br><span class="line">server:</span><br><span class="line">  port: <span class="number">8500</span></span><br></pre></td></tr></table></figure>

<p>5、项目结构<br><img src="https://img-blog.csdnimg.cn/20200425093823667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">6、生产者代码参考：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerController</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> KafkaTemplate&lt;String, Object&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping</span>(<span class="string">"message/send"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">		kafkaTemplate.send(<span class="string">"test1"</span>, msg); <span class="comment">// 使用kafka模板发送信息</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7、消费者代码参考：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监听服务器上的kafka是否有相关的消息发过来</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DELL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerDemo</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 定义此消费者接收topics = "test1"的消息，与controller中的topic对应上即可</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> record 变量代表消息本身，可以通过ConsumerRecord&lt;?,?&gt;类型的record变量来打印接收的消息的各种信息</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@KafkaListener</span>(topics = <span class="string">"test1"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(ConsumerRecord&lt;?, ?&gt; record)</span> </span>&#123;</span><br><span class="line">		System.out.printf(<span class="string">"topic is %s, offset is %d, value is %s \n"</span>, record.topic(), record.offset(), record.value());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>8、启动项目，页面访问生产者方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://localhost:8500/message/send?msg=<span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>9、查看控制台能看到消费者信息<br><img src="https://img-blog.csdnimg.cn/20200425094817918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">查看cmd窗口信息：<br><img src="https://img-blog.csdnimg.cn/20200425094916450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="Spring-Boot项目整合ELK、Kafka"><a href="#Spring-Boot项目整合ELK、Kafka" class="headerlink" title="Spring Boot项目整合ELK、Kafka"></a>Spring Boot项目整合ELK、Kafka</h2><p>使用Spring Boot整合log4j，配合ELK（Elasticsearch , Logstash, Kibana）整合Kafka完成日志收集，应用场景比较多的是分布式项目，这样可以直接收集各个节点的日志到一起，便于错误日志查看和分析业务。</p>
<p>整个流程如下：</p>
<p>使用log4j的appender发送数据到kafka到topic，topic再发送到logstash，然后经过elasticsearch分析处理后到kibana页面做查询展示。</p>
<p>环境准备：</p>
<p>1、安装ELK</p>
<p>2、安装kafka</p>
<p>3、Spring Boot项目搭建</p>
<p>简要步骤：</p>
<p>①、修改logj配置文件</p>
<p>②、加入日志打印代码</p>
<p>③、启动项目访问页面</p>
<p>④、使用kafka查看消费者打印</p>
<p>⑤、使用kibana建立日志索引</p>
<p>⑥、使用kibana查询日志、es语法查询</p>
<p>参考1：<a href="https://blog.csdn.net/w7239/article/details/104265601" target="_blank" rel="noopener">https://blog.csdn.net/w7239/article/details/104265601</a></p>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>boot kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用命令</title>
    <url>/myblog/tool/it%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><p>1、初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>2、添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>3、备注</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">'add'</span></span><br></pre></td></tr></table></figure>
<p>4、推送到仓库,</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PS:此处是推送到master分支下</p>
</blockquote>
<h2 id="创建分支并切换"><a href="#创建分支并切换" class="headerlink" title="创建分支并切换"></a>创建分支并切换</h2><p>1）新建分支</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">git branch <span class="title">xxx</span> <span class="params">(xxx填写你的分支名称)</span></span></span><br></pre></td></tr></table></figure>
<p>2）查看所有分支</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure>
<p>3）切换到某一分支</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">git checkout <span class="title">xxx</span> <span class="params">(xxx填写要切换的分支名称）</span></span></span><br></pre></td></tr></table></figure>
<p>4）添加修改代码到缓存（注意最后的”.”前面有个空格</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>
<p>5）添加提交代码的备注</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">"xxx"</span> （xxx为本次提交代码的备注）</span><br></pre></td></tr></table></figure>
<p>6）提交代码到指定分支</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git push origin xxx （xxx为要提交代码的分支名称）</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch-6.2.2 + kibana-6.2.2-windows-x86_64安装配置</title>
    <url>/myblog/tool/lasticsearch-6-2-2-kibana-6-2-2-windows-x86-64%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="一、使用版本"><a href="#一、使用版本" class="headerlink" title="一、使用版本"></a>一、使用版本</h2><p>es和kibana的版本都是6.2.2</p>
<pre><code>elasticsearch-6.2.2 + kibana-6.2.2-windows-x86_64</code></pre><a id="more"></a>
<h2 id="二、es配置"><a href="#二、es配置" class="headerlink" title="二、es配置"></a>二、es配置</h2><p>1、先安装es，下载下来解压， config目录下修改  elasticsearch.yml 配置文件</p>
<pre><code>#把以下配置的注释放开，并修改成自己想要的配置

cluster.name: es_cluster

node.name: node-1

path.data: F:\MYDATA\elasticsearch-6.2.2\\data

path.logs: F:\MYDATA\elasticsearch-6.2.2\\logs

network.host: 0.0.0.0

http.port: 9200</code></pre><p>2、保存修改，去bin目录下，运行  elasticsearch.bat 后，cmd窗口无异常，可进行下一步</p>
<p>3、浏览器访问 <a href="http://localhost:9200/" target="_blank" rel="noopener">http://localhost:9200/</a>   ，能看到以下信息则搭建正常</p>
<pre><code>    {

  &quot;name&quot; : &quot;node-1&quot;,
  &quot;cluster_name&quot; : &quot;es_cluster&quot;,
  &quot;cluster_uuid&quot; : &quot;fzx_I1tuSy2r9vzPZOVfVQ&quot;,
  &quot;version&quot; : {
    &quot;number&quot; : &quot;6.2.4&quot;,
    &quot;build_hash&quot; : &quot;ccec39f&quot;,
    &quot;build_date&quot; : &quot;2018-04-12T20:37:28.497551Z&quot;,
    &quot;build_snapshot&quot; : false,
    &quot;lucene_version&quot; : &quot;7.2.1&quot;,
    &quot;minimum_wire_compatibility_version&quot; : &quot;5.6.0&quot;,
    &quot;minimum_index_compatibility_version&quot; : &quot;5.0.0&quot;
  },
  &quot;tagline&quot; : &quot;You Know, for Search&quot;
}</code></pre><h2 id="三、kibana配置"><a href="#三、kibana配置" class="headerlink" title="三、kibana配置"></a>三、kibana配置</h2><p>1、安装kibana，解压包，进到config，修改kibana.yml文件</p>
<pre><code>server.port: 5601

server.host: &quot;localhost&quot;

elasticsearch.url: &quot;http://localhost:9200&quot;

kibana.index: &quot;.kibana&quot;</code></pre><p>2、进到bin目录，运行   kibana.bat 后，cmd窗口无异常，可进行下一步</p>
<p>3、进浏览器访问   <a href="http://localhost:5601" target="_blank" rel="noopener">http://localhost:5601</a>  能打开则配置正常</p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>cloud</tag>
        <tag>es</tag>
        <tag>kibana</tag>
      </tags>
  </entry>
  <entry>
    <title>spring boot 使用Nginx及其基本概念、安装、配置</title>
    <url>/myblog/spring-boot/spring-boot-%E4%BD%BF%E7%94%A8Nginx%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E3%80%81%E5%AE%89%E8%A3%85%E3%80%81%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<div class="item-wrap"><div class="article is-firefox" id="article" data-islow-browser="0"><div class="article-content"><p><span class="bjh-p">想必大家一定听说过 Nginx，若没听说过它，那么一定听过它的"同行"Apache 吧！</span></p><p><span class="bjh-p">

<h2 id="Nginx-的产生"><a href="#Nginx-的产生" class="headerlink" title="Nginx 的产生"></a>Nginx 的产生</h2><a id="more"></a>
<p></p></span></p><p><span class="bjh-p">Nginx 同 Apache 一样都是一种 Web 服务器。基于 REST 架构风格，以统一资源描述符（Uniform Resources Identifier）URI 或者统一资源定位符（Uniform Resources Locator）URL 作为沟通依据，通过 HTTP 协议提供各种网络服务。</span></p><p><span class="bjh-p">然而，这些服务器在设计之初受到当时环境的局限，例如当时的用户规模，网络带宽，产品特点等局限并且各自的定位和发展都不尽相同。这也使得各个 Web 服务器有着各自鲜明的特点。</span></p><p><span class="bjh-p">Apache 的发展时期很长，而且是毫无争议的世界第一大服务器。它有着很多优点：稳定、开源、跨平台等等。</span></p><p><span class="bjh-p">它出现的时间太长了，它兴起的年代，互联网产业远远比不上现在。所以它被设计为一个重量级的。</span></p><p><span class="bjh-p">它不支持高并发的服务器。在 Apache 上运行数以万计的并发访问，会导致服务器消耗大量内存。</span></p><p><span class="bjh-p">操作系统对其进行进程或线程间的切换也消耗了大量的 CPU 资源，导致 HTTP 请求的平均响应速度降低。</span></p><p><span class="bjh-p">这些都决定了 Apache 不可能成为高性能 Web 服务器，轻量级高并发服务器 Nginx 就应运而生了。</span></p><p><span class="bjh-p">俄罗斯的工程师 Igor Sysoev，他在为 Rambler Media 工作期间，使用 C 语言开发了 Nginx。</span></p><p><span class="bjh-p">Nginx 作为 Web 服务器一直为 Rambler Media 提供出色而又稳定的服务。然后呢，Igor Sysoev 将 Nginx 代码开源，并且赋予自由软件许可证。</span></p><p><span class="bjh-h3">由于以下这几点，所以，Nginx 火了：</span></p><p><span class="bjh-p">Nginx 使用基于事件驱动架构，使得其可以支持数以百万级别的 TCP 连接。高度的模块化和自由软件许可证使得第三方模块层出不穷（这是个开源的时代啊）。Nginx 是一个跨平台服务器，可以运行在 Linux、Windows、FreeBSD、Solaris、AIX、Mac OS 等操作系统上。这些优秀的设计带来的极大的稳定性。</span></p><p><span class="bjh-p">Nginx 的用武之地</span></p><p><span class="bjh-p">Nginx 是一款自由的、开源的、高性能的 HTTP 服务器和反向代理服务器；同时也是一个 IMAP、POP3、SMTP 代理服务器。</span></p><p><span class="bjh-p">Nginx 可以作为一个 HTTP 服务器进行网站的发布处理，另外 Nginx 可以作为反向代理进行负载均衡的实现。</span></p><p><span class="bjh-h3"></span></p>
<h2 id="关于代理"><a href="#关于代理" class="headerlink" title="关于代理"></a>关于代理</h2><p></p><p><span class="bjh-p">说到代理，首先我们要明确一个概念，所谓代理就是一个代表、一个渠道；此时就涉及到两个角色，一个是被代理角色，一个是目标角色。</span></p><p><span class="bjh-p">被代理角色通过这个代理访问目标角色完成一些任务的过程称为代理操作过程；如同生活中的专卖店，客人到 adidas 专卖店买了一双鞋，这个专卖店就是代理，被代理角色就是 adidas 厂家，目标角色就是用户。</span></p><p><span class="bjh-h3"></span></p>
<h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p></p><p><span class="bjh-p">说反向代理之前，我们先看看正向代理，正向代理也是大家最常接触到的代理模式，我们会从两个方面来说关于正向代理的处理模式，分别从软件方面和生活方面来解释一下什么叫正向代理。</span></p><p><span class="bjh-p">在如今的网络环境下，我们如果由于技术需要要去访问国外的某些网站，此时你会发现位于国外的某网站我们通过浏览器是没有办法访问的。</span></p><p><span class="bjh-p">此时大家可能都会用一个操作 FQ 进行访问，FQ 的方式主要是找到一个可以访问国外网站的代理服务器，我们将请求发送给代理服务器，代理服务器去访问国外的网站，然后将访问到的数据传递给我们！</span></p><p><span class="bjh-p">上述这样的代理模式称为正向代理，正向代理最大的特点是客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端；正向代理模式屏蔽或者隐藏了真实客户端信息。</span></p><p><span class="bjh-p">来看个示意图（我把客户端和正向代理框在一块，同属于一个环境，后面我有介绍）：<br><img src="https://img-blog.csdnimg.cn/20200419222449270.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的 IP 地址，还有代理程序的端口。</span></p><p><span class="bjh-p">如下图：<br><img src="https://img-blog.csdnimg.cn/20200419222749783.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>总结来说：正向代理，”它代理的是客户端”，是一个位于客户端和原始服务器（Origin Server）之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标（原始服务器）。</span></p><p><span class="bjh-p">然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。</span></p><p><span class="bjh-p">正向代理的用途：</span></p><p><span class="bjh-p">访问原来无法访问的资源，如 Google。可以做缓存，加速访问资源。对客户端访问授权，上网进行认证。代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息。</span></p><p><span class="bjh-h3">反向代理</span></p><p><span class="bjh-p">明白了什么是正向代理，我们继续看关于反向代理的处理方式，举例如我国的某宝网站，每天同时连接到网站的访问人数已经爆表，单个服务器远远不能满足人民日益增长的购买欲望了。</span></p><p><span class="bjh-p">此时就出现了一个大家耳熟能详的名词：分布式部署；也就是通过部署多台服务器来解决访问人数限制的问题。</span></p><p><span class="bjh-p">某宝网站中大部分功能也是直接使用 Nginx 进行反向代理实现的，并且通过封装 Nginx 和其他的组件之后起了个高大上的名字：Tengine。</span></p><p><span class="bjh-p">有兴趣的童鞋可以访问 Tengine 的官网查看具体的信息：<a href="http://tengine.taobao.org/" target="_blank" rel="noopener">http://tengine.taobao.org/</a></span></p><p><span class="bjh-p">那么反向代理具体是通过什么样的方式实现的分布式的集群操作呢，我们先看一个示意图（我把服务器和反向代理框在一块，同属于一个环境，后面我有介绍）：<br><img src="https://img-blog.csdnimg.cn/20200419222833373.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>通过上述的图解大家就可以看清楚了，多个客户端给服务器发送的请求，Nginx 服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理了。<span class="bjh-br"></span></span></p><p><span class="bjh-p">此时请求的来源也就是客户端是明确的，但是请求具体由哪台服务器处理的并不明确了，Nginx 扮演的就是一个反向代理角色。<span class="bjh-br"></span></span></p><p><span class="bjh-p">客户端是无感知代理的存在的，反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。因为客户端不需要任何配置就可以访问。<span class="bjh-br"></span></span></p><p><span class="bjh-p">反向代理，”它代理的是服务端”，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息<span class="bjh-br"></span></span></p><p><span class="bjh-p">反向代理的作用：</span></p><p><span class="bjh-p">保证内网的安全，通常将反向代理作为公网访问地址，Web 服务器是内网。负载均衡，通过反向代理服务器来优化网站的负载。</span></p><p><span class="bjh-h3">项目场景</span></p><p><span class="bjh-p">通常情况下，我们在实际项目操作时，正向代理和反向代理很有可能会存在同一个应用场景中，正向代理代理客户端的请求去访问目标服务器，目标服务器是一个反向单利服务器，反向代理了多台真实的业务处理服务器。</span></p><p><span class="bjh-p">具体的拓扑图如下：<br><img src="https://img-blog.csdnimg.cn/20200419222855313.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>截了一张图来说明正向代理和反向代理二者之间的区别，如下图：<br><img src="https://img-blog.csdnimg.cn/20200419223318916.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>图解：</span></p><p><span class="bjh-p">在正向代理中，Proxy 和 Client 同属于一个 LAN（图中方框内），隐藏了客户端信息。在反向代理中，Proxy 和 Server 同属于一个 LAN（图中方框内），隐藏了服务端信息。</span></p><p><span class="bjh-p">实际上，Proxy 在两种代理中做的事情都是替服务器代为收发请求和响应，不过从结构上看正好左右互换了一下，所以把后出现的那种代理方式称为反向代理了。</span></p><p><span class="bjh-h3">负载均衡</span></p><p><span class="bjh-p">我们已经明确了所谓代理服务器的概念，那么接下来，Nginx 扮演了反向代理服务器的角色，它是依据什么样的规则进行请求分发的呢？不用的项目应用场景，分发的规则是否可以控制呢？</span></p><p><span class="bjh-p">这里提到的客户端发送的、Nginx 反向代理服务器接收到的请求数量，就是我们说的负载量。请求数量按照一定的规则进行分发，到不同的服务器处理的规则，就是一种均衡规则。</span></p><p><span class="bjh-p">所以将服务器接收到的请求按照规则分发的过程，称为负载均衡。</span></p><p><span class="bjh-p">负载均衡在实际项目操作过程中，有硬件负载均衡和软件负载均衡两种，硬件负载均衡也称为硬负载，如 F5 负载均衡，相对造价昂贵成本较高。</span></p><p><span class="bjh-p">但是数据的稳定性安全性等等有非常好的保障，如中国移动中国联通这样的公司才会选择硬负载进行操作。</span></p><p><span class="bjh-p">更多的公司考虑到成本原因，会选择使用软件负载均衡，软件负载均衡是利用现有的技术结合主机硬件实现的一种消息队列分发机制.<br><img src="https://img-blog.csdnimg.cn/20200419223248211.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Nginx 支持的负载均衡调度算法方式如下：</span></p><p><span class="bjh-p">①weight 轮询（默认）：接收到的请求按照顺序逐一分配到不同的后端服务器，即使在使用过程中，某一台后端服务器宕机，Nginx 会自动将该服务器剔除出队列，请求受理情况不会受到任何影响。</span></p><p><span class="bjh-p">这种方式下，可以给不同的后端服务器设置一个权重值（weight），用于调整不同的服务器上请求的分配率。</span></p><p><span class="bjh-p">权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的。</span></p><p><span class="bjh-p">②ip_hash：每个请求按照发起客户端的 ip 的 hash 结果进行匹配，这样的算法下一个固定 ip 地址的客户端总会访问到同一个后端服务器，这也在一定程度上解决了集群部署环境下 Session 共享的问题。</span></p><p><span class="bjh-p">③fair：智能调整调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配。</span></p><p><span class="bjh-p">响应时间短处理效率高的服务器分配到请求的概率高，响应时间长处理效率低的服务器分配到的请求少，它是结合了前两者的优点的一种调度算法。</span></p><p><span class="bjh-p">但是需要注意的是 Nginx 默认不支持 fair 算法，如果要使用这种调度算法，请安装 upstream_fair 模块。</span></p><p><span class="bjh-p">④url_hash：按照访问的 URL 的 hash 结果分配请求，每个请求的 URL 会指向后端固定的某个服务器，可以在 Nginx 作为静态服务器的情况下提高缓存效率。</span></p><p><span class="bjh-p">同样要注意 Nginx 默认不支持这种调度算法，要使用的话需要安装 Nginx 的 hash 软件包。</span></p><p><span class="bjh-p">Web 服务器对比</span></p><p><span class="bjh-p">几种常用 Web 服务器对比如下图：<br><img src="https://img-blog.csdnimg.cn/20200419223117100.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></span></p>
<div>
<h3 style="background: #A8A8A8 !important; color: #ffffff;">&nbsp; 直接部署服务器的风险</h3>



</div>
<p><span style="font-size: 13px;">　　假设，我开发了一个网站，然后买了一台Web服务器和一台数据库服务器，直接部署到公共网络上。如下图，网站用户通过手机、平板、台式机等终端设备，连上网络，输入 118.178.109.187 这个地址，我的系统就读取数据库，然后直接返回一个网页。</span></p>
<p><span style="font-size: 13px;"><img style="display: block; margin-left: auto; margin-right: auto;" src="https://img2018.cnblogs.com/blog/295300/201812/295300-20181226113240184-1092615718.png" alt></span></p>
<p><span style="font-size: 13px;">　　像这种网站部署的方式在今天的网络部署上特别常见。这种部署方式虽然简单、方便，高效，但是也存在着巨大的安全隐患。为什么呢？那是因为我将所有服务器资源都直接暴露在了公共网络上。直接将服务器暴露在网上的风险特别高。据阿里统计，他们每天在全球范围内，会被黑客攻击大概16亿次。是不是很震惊？我的两台服务器在网上裸奔，没有防火墙，没有安全策略，也不知道其他黑客还掌握了哪些漏洞。因此一旦被各种黑客扫描到了，我的服务器就很容易沦为别人的肉鸡，任人宰割。</span></p>
<p><span style="font-size: 13px;">　　所以啊，一旦要直接暴露在网上的服务器都应该是具有强大的安全策略来方式被攻击。比如，防火墙策略要做好，漏洞要修补好，端口不要乱开放等等。而且即便是这样，地球上也没有任何人敢保证他的服务器不被入侵。因此，不被入侵是不可能的了！那么我们应该怎么办呢？我觉得应该增加黑客入侵的门槛，以及减少入侵成功之后的收益。这样费力又不讨好的事情，我相信很多黑客是不愿意做的。</span></p>
<p><span style="font-size: 13px;">　　</span><span style="font-size: 13px;">那说了那么多，怎么操作呢？我觉得要暴露在公网上的服务器，必须都应该是不存储任何数据的服务器，即便是服务器挂了。用户虽然不能访问了，但是至少数据不会丢失。 所以常用的策略就是，重要的东西尽量放内网。</span></p>
<p><span style="font-size: 13px;">　　如下图，手机、平板、台式机等终端设备通过公网访问反向代理服务器。反向代理服务器上有两张网卡，一张网卡是公共网卡，另一张网卡是局域网网卡。反向代理服务器通过将请求反向代理到192.168.1.1这台Web服务器，Web服务器连接局域网的数据库进行SQL查询操作，然后将数据返回给反向代理服务器，反向代理服务器再将数据通过公网传给终端设备。</span></p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="https://img2018.cnblogs.com/blog/295300/201812/295300-20181226115341930-1676037661.png" alt></p>
<p>&nbsp;</p>
<p><span style="font-size: 13px;">　　这种技术就相对安全一点了，因为只有反向代理服务器直接暴露在公网上了，即便是反向代理服务器被攻击了，只要局域网内的其他服务器不被攻击，也损失不了什么。</span></p>
<div>
<h3 style="background: #A8A8A8 !important; color: #ffffff;">&nbsp; 反向代理</h3>

</div>
<p><span style="font-size: 13px;">　　如何理解反向代理呢？就像刚刚那个图，</span><span style="font-size: 13px;">反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</span></p>
<p><span style="font-size: 13px;">　　我们从客户端的视野来看，实际上客户端并不知道真实的服务提供者是哪台服务器，它只知道它请求了反向代理服务器。因此反向代理这种方式又对外隐藏了真实服务器的地址，从一定程度上降低了安全隐患。</span></p>
<div>

<h4><a id="_windows10Nginx__6"></a><em>windows10系统下安装Nginx</em></h4>
<p><em><strong>打开nginx的官网：<a href="http://nginx.org/" target="_blank" rel="nofollow noopener">http://nginx.org/</a> ，下载最新的稳定版本。</strong></em><br>
<img src="https://img-blog.csdnimg.cn/20190620085649844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01yc19jaGVucw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20190620085706779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01yc19jaGVucw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><em><strong>按照版本需要点击进行下载即可,这里博主选择nginx-1.12.2下载windows版本</strong></em><br>
<img src="https://img-blog.csdnimg.cn/20190620085747161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01yc19jaGVucw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><em><strong>或者在首页点击download下载历史稳定版本</strong></em><br>
<img src="https://img-blog.csdnimg.cn/2019062008584711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01yc19jaGVucw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><em><strong>下载完成后，解压到你想要解压的文件路径中，我解压到了D盘中，并把文件名改为nginx；进入文件内，打开nginx.exe文件，会出现一个一闪而过的页面，然后打开任意一个浏览器，输入 localhost，出现下面的页面，则安装成功。</strong></em></p>
<p><img src="https://img-blog.csdnimg.cn/20190620090248902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01yc19jaGVucw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20190620090336569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01yc19jaGVucw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><em><strong>如果没有出现，则说明没有安装成功；通过cmd.exe来看nginx是否安装成功和错误所在。打开cmd后，输入D:（你的安装目录在哪输入哪个），再输入cd nginx，继续输入nginx，如果安装不成功就会反馈错误，我出现的错误是：[emery] blind() to 0.0.0.0:80 failed (10013: An attempt was made to access a socket in a way forbidden by its access permissions)</strong></em></p>
<p><em><strong>也就是80端口被其他程序占用。</strong></em></p>
<p><em><strong>解决方法是：以管理员身份运行regedit打开键值:HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\HTTP在右边找到Start这一项,将其改为0重启系统,System进程不会占用80端口。</strong></em></p>
<p><em><strong>重启后打开浏览器输入localhost，出现了下面页面：</strong></em></p>
<p><img src="https://img-blog.csdnimg.cn/20190620090336569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01yc19jaGVucw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
<em><strong>也可以在cmd命令窗口输入命令 

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tasklist /<span class="keyword">fi</span> “imagename eq nginx.exe”</span><br></pre></td></tr></table></figure>

<p>，出现如下结果说明启动成功</p></strong></em></p><p></p>
<p><img src="https://img-blog.csdnimg.cn/20190620090456727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01yc19jaGVucw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
<em><strong>nginx的配置文件是conf目录下的nginx.conf，默认配置的nginx监听的端口为80，如果80端口被占用可以修改为未被占用的端口即可</strong></em></p>
<p><img src="https://img-blog.csdnimg.cn/20190620090537123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01yc19jaGVucw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/2019062009062588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01yc19jaGVucw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
<em><strong>检查80端口是否被占用的命令是： netstat -ano | findstr 0.0.0.0:80 或 netstat -ano | findstr "80"</strong></em></p>
<p><em><strong>当我们修改了nginx的配置文件nginx.conf 时，不需要关闭nginx后重新启动nginx，只需要执行命令 nginx -s reload 即可让改动生效</strong></em></p>
<hr>

<h2 id="Nginx常用命令"><a href="#Nginx常用命令" class="headerlink" title="Nginx常用命令"></a>Nginx常用命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>Model</th>
</tr>
</thead>
<tbody>
<tr>
<td>start nginx</td>
<td>启动</td>
</tr>
<tr>
<td>nginx -s stop</td>
<td>迅速退出</td>
</tr>
<tr>
<td>nginx -s quit</td>
<td>优雅的退出</td>
</tr>
<tr>
<td>nginx -s reload</td>
<td>修改配置文件后重载</td>
</tr>
</tbody>
</table>


<h4><a id="_nginx__49"></a><em>关闭nginx</em></h4>
<p><strong>如果使用cmd命令窗口启动nginx，关闭cmd窗口是不能结束nginx进程的，可使用两种方法关闭nginx</strong></p>
<p>(1)输入nginx命令  nginx -s stop(快速停止nginx)  或  nginx -s quit(完整有序的停止nginx)</p>
(2)使用taskkill   

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">taskkill /f /t /im nginx.exe</span><br></pre></td></tr></table></figure>

<hr>
<h4><a id="_nginx__59"></a><em>使用nginx代理服务器做负载均衡</em></h4>

<p>我们可以修改nginx的配置文件nginx.conf 达到访问nginx代理服务器时跳转到指定服务器的目的，即通过proxy_pass 配置请求转发地址，即当我们依然输入http://localhost:80 时，请求会跳转到我们配置的服务器</p>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">   <span class="selector-tag">upstream</span> <span class="selector-tag">mytomcats</span> &#123;  </span><br><span class="line">      server localhost:8081;  </span><br><span class="line">&#125;  </span><br><span class="line">   <span class="selector-tag">server</span> &#123;</span><br><span class="line">       listen       80;</span><br><span class="line">       <span class="selector-tag">server_name</span>  <span class="selector-tag">localhost</span>;</span><br><span class="line">       <span class="selector-id">#charset</span> <span class="selector-tag">koi8-r</span>;</span><br><span class="line">       #access_log  logs/host.access.log  main;</span><br><span class="line">       # 以下为解决跨域的设置</span><br><span class="line">       <span class="selector-tag">add_header</span> <span class="selector-tag">Access-Control-Allow-Origin</span> *;</span><br><span class="line">	add_header Access-Control-Allow-Methods 'GET,POST';</span><br><span class="line">	add_header Access-Control-Allow-Headers 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization';</span><br><span class="line">	</span><br><span class="line">       location / &#123;</span><br><span class="line">		proxy_pass http://mytomcats;  </span><br><span class="line">       &#125;</span><br><span class="line">  ......</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>同理，我们可以配置多个目标服务器，当一台服务器出现故障时，nginx能将请求自动转向另一台服务器，例如配置如下：</strong></em><br>

</p><p><img src="https://img-blog.csdnimg.cn/20190620091802976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01yc19jaGVucw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p></p>
<p><em><strong>当服务器 localhost:8080 挂掉时，nginxnginx能将请求自动转向服务器 192.168.101.9:8080 。上面还加了一个weight属性，此属性表示各服务器被访问到的权重，weight越高被访问到的几率越高。</strong></em></p>
<hr>
<h4><a id="_Nginx__73"></a><em>Nginx配置静态资源</em></h4>
<p><em><strong>将静态资源（如jpg|png|css|js等）放在如下配置的f:/nginx-1.12.2/static目录下，然后在nginx配置文件中做如下配置(注意：静态资源配置只能放在 location / 中)，浏览器中访问 http://localhost/1.jpg 即可看到图片

<pre><code>location ~ \.(gif|jpg|png|js|css)$ {
    root F:/nginx-1.12.2/static;
    index index.html index.htm;
}</code></pre><hr>


<p>原文参考1：<a href="https://blog.csdn.net/Mrs_chens/article/details/92961608" target="_blank" rel="nofollow noopener">https://blog.csdn.net/Mrs_chens/article/details/92961608</a></p>
<p>原文参考2：<a href="https://baijiahao.baidu.com/s?id=1652608869911988442&wfr=spider&for=pc" target="_blank" rel="nofollow noopener">https://baijiahao.baidu.com/s?id=1652608869911988442&wfr=spider&for=pc</a></p></strong></em></p></div></div></div></div>]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>boot Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>spring boot下整合dubbo和zookeeper</title>
    <url>/myblog/spring-boot/spring-boot%E4%B8%8B%E6%95%B4%E5%90%88dubbo%E5%92%8Czookeeper/</url>
    <content><![CDATA[<p>本章主要说下dubbo和zookeeper的概念，以及在基于springboot框架搭建dubbo+zookeeper分布式服务架构。</p>
<a id="more"></a>
<p>什么是dubbo：</p>
<blockquote>
<p>dubbo框架：dubbo是阿里巴巴soa服务化治理方案的核心框架，是一个分布式服务的框架，致力于提高性能和透明化rpc远程服务调用方案，以及soa服务治理方案。</p>
</blockquote>
<p>确实懵，什么是soa呢，什么是rpc呢？？？</p>
<blockquote>
<p>soa：面向服务的架构，将应用程序的不同功能单元（也叫作服务）通过服务之间的定义良好的接口和契约联系起来。</p>
</blockquote>
<blockquote>
<p>rpc：远程过程调用协议，是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。</p>
</blockquote>
<p>在dubbo+zookeeper中有三个重要的角色：</p>
<pre><code>1. provider（服务提供者）：在我们项目中可以粗糙地理解成实现类

2. Consumer（服务消费者）：可以理解为调用服务（调用实现类）的类，类似于controller，当然如果集成rabbitmq也有可能是消息队列的类，也有可能是实现类调用实现类，所以实现类可以身兼数职，既可以是服务提供者也可以是服务调用者。

3. registry（zookeeper）：也就是我们的注册中心，zookeeper是Apache下的产品。</code></pre><p>没有用dubbo之前我们一般是controller调用service，service调用mapper（dao），但是现在加上了dubbo以后就是controller（当然不止controller，所有服务消费者都可以）通过向zookeeper订阅服务，service向zookeeper注册服务，通过zookeeper这个中介，把服务提供方的服务注入到服务消费者中。</p>
<h2 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h2><pre><code>1. 服务容器负责启动，加载，运行服务提供者。
2. 服务提供者在启动时，向注册中心注册自己提供的服务。
3. 服务消费者在启动时，向注册中心订阅自己所需的服务。
4. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。
5. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。
6. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</code></pre><p>理解不理解没关系来张图看下：<br><img src="https://img-blog.csdnimg.cn/20200421214035358.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">为什么需要dubbo？</p>
<blockquote>
<p>　单一应用架构</p>
<p>　　　　当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。</p>
</blockquote>
<p>　　　　
　</p>
<blockquote>
<p>垂直应用架构</p>
<p>　　　　当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。</p>
</blockquote>
<p>　　　　
　</p>
<blockquote>
<p>分布式服务架构</p>
<p>　　　　当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。</p>
</blockquote>
<p>　　　　</p>
<blockquote>
<p>   流动计算架构</p>
<p>　　　　当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。</p>
</blockquote>
<p>  上述部分描述了互联网架构的演变，关键要素及dubbo存在的意义，可谓简约而不简单 <a href="http://dubbo.apache.org" target="_blank" rel="noopener">官网地址</a><br>，在这里关于dubbo的介绍我就不再这里阐述了，官网有中文的说明而且很详细</p>
<h2 id="上demo："><a href="#上demo：" class="headerlink" title="上demo："></a>上demo：</h2><blockquote>
<p>运行环境：JDK8，Maven 3.0+<br>技术栈：SpringBoot 2.2.6.RELEASE、Dubbo 1.0.0、ZooKeeper3.5.7、mybatis2.1.2（推荐使用MP）、mysql<br>编辑器：eclipse 4.15.0（已安装好STS）<br>提供者项目</p>
</blockquote>
<p><strong>1、提供者：</strong><br><img src="https://img-blog.csdnimg.cn/20200421225324525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>pom文件需引入的内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">      &lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;2.1.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- 整合dubbo --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;io.dubbo.springboot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-dubbo&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 注意:dubbo强制内置log4J 如果没有则会报错 --&gt;</span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">	&lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>提供者的项目结构如下：<br><img src="https://img-blog.csdnimg.cn/2020042122571262.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">配置文件，此处使用的默认的application.properties类型的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring.dubbo.application.name=provider</span><br><span class="line">spring.dubbo.registry.address=zookeeper://127.0.0.1:2181</span><br><span class="line">spring.dubbo.protocol.name=dubbo</span><br><span class="line">spring.dubbo.protocol.port=20880</span><br><span class="line"><span class="comment">#dubbo 资源扫描文件 </span></span><br><span class="line">spring.dubbo.scan=cn.chfsun.server.service</span><br><span class="line"></span><br><span class="line">server.port=8084</span><br><span class="line"></span><br><span class="line"><span class="comment">#数据库相关配置</span></span><br><span class="line">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span><br><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/orcl?useUnicode=<span class="literal">true</span>&amp;useJDBCCompliantTimezoneShift=<span class="literal">true</span>&amp;useLegacyDatetimeCode=<span class="literal">false</span>&amp;serverTimezone=UTC</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root123</span><br><span class="line">spring.datasource.max-idle=10</span><br><span class="line">spring.datasource.max-wait=10000</span><br><span class="line">spring.datasource.min-idle=5</span><br><span class="line">spring.datasource.initial-size=5</span><br></pre></td></tr></table></figure>
<p>mapper层：<br><img src="https://img-blog.csdnimg.cn/20200421230012176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">业务逻辑实现层：<br><img src="https://img-blog.csdnimg.cn/20200421230132443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">PS：到此提供者已经写好了，然后，然后使用mvn命令打包为jar文件，再启动服务，看着控制台愉快的跑起来……</p>
<blockquote>
<p>等等！是不是报错了（如果没报错更好，但是可能吗，除非…）：打包报错，启动也报错……什么鬼！ 别慌，你的zookeeper服务启动了没？zookeeper是啥？这个还需要服务？</p>
</blockquote>
<h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><p>本文刚开始已经提到了：<em>….zookeeper这个中介，把服务提供方的服务注入到服务消费者中。</em></p>
<p>再来点：</p>
<blockquote>
<p>zookeeper是开放源码的分布式应用程序协调服务，可以作为dubbo等服务的注册中心，也可以在分布式系统中实现分布式锁。</p>
<p>ZooKeeper的基本运转流程：</p>
<p>1、选举Leader。（选举leader可以参考<br><a href="https://blog.csdn.net/gaoshan12345678910/article/details/67638657）" target="_blank" rel="noopener">https://blog.csdn.net/gaoshan12345678910/article/details/67638657）</a></p>
<p>2、同步数据。</p>
<p>3、选举Leader过程中算法有很多，但要达到的选举标准是一致的。</p>
<p>4、Leader要具有最高的执行ID，类似root权限。</p>
<p>5、集群中大多数的机器得到响应并接受选出的Leader。</p>
</blockquote>
<p><strong>zookeeper的四种状态：</strong></p>
<p>　　</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LOOKING：寻找Leader状态。当服务器处于该状态时，它会认为当前集群中没有Leader，因此需要进入Leader选举状态。</span><br><span class="line"></span><br><span class="line">　　FOLLOWING：跟随者状态。表明当前服务器角色是Follower。</span><br><span class="line"></span><br><span class="line">　　LEADING：领导者状态。表明当前服务器角色是Leader。</span><br><span class="line"></span><br><span class="line">　　OBSERVING：观察者状态。表明当前服务器角色是Observer。</span><br></pre></td></tr></table></figure>
<p>不是很理解没关系，先让它跑起来再说：</p>
<p>1、下载地址：<br>     <a href="https://archive.apache.org/dist/zookeeper/" target="_blank" rel="noopener">zookeeper</a>：<a href="https://archive.apache.org/dist/zookeeper/" target="_blank" rel="noopener">https://archive.apache.org/dist/zookeeper/</a><br><img src="https://img-blog.csdnimg.cn/202004212321389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">不是版本越高越好，稳定决定一切，我下载的是3.5.7的。点击进去，跳转到如下页面，选择标识的版本——-为啥？有坑啊！稍不注意就会…..</p>
<blockquote>
<p>注意： 从zookeeper-3.5.5开始，在下载zk时候 请下载apache-zookeeper-3.5.5 -bin .tar.gz<br>而不是apache-zookeeper-3.5.5.tar.gz：</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200421232415888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">不然启动时候会报</p>
<blockquote>
<p>找不到或无法加载主类 org.apache.zookeeper.server.quorum.QuorumPeerMain</p>
</blockquote>
<p>2、下载好了，解压缩到本地磁盘中，然后进入bin中，找到zkServer.cmd，双击打开就能运行，然后又…..<br><img src="https://img-blog.csdnimg.cn/20200421233104361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">如果不是这个错，那么你很悲催，还得解决其它的错误，最后还是会看到这个错误！！！<br>从错误中我们能大致知道是缺少初始化文件了。<br>解决方式很简单粗暴：</p>
<blockquote>
<p>1.将conf目录下的zoo-sample.cfg复制下，改名为zoo.cfg，或者粗暴的修改conf目录下的zoo-sample.cfg重命名为zoo.cfg；</p>
</blockquote>
<blockquote>
<p>2.修改配置文件，如果不存在路径data和log，请先新建。（最好使用文本编辑器来修改配置）<br><img src="https://img-blog.csdnimg.cn/20200421233652221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</blockquote>
<p>启动：<br>打开bin文件夹，cmd进去执行：<br><img src="https://img-blog.csdnimg.cn/20200421234013461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">保持doc窗口不要关闭，更不要鼠标点进去，否则你可以试下，看会怎么样。<br>回到eclipse中，启动提供者项目：<br><img src="https://img-blog.csdnimg.cn/20200421234411638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">能看到红色的部分就说明提供者起作用名副其实了，别急，既然是提供者，是需要给消费者用的，就需要打包成一个starter。停止项目，项目右键先build path更改下<br><img src="https://img-blog.csdnimg.cn/20200422000101341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>保存退出，然后继续项目右键–&gt;Run As—&gt;Maven clean/Maven install  或者使用mvn命令也可。<br><img src="https://img-blog.csdnimg.cn/20200422000241822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">红色部分即为打包后的jar，如果没看到刷新下就可以了。此时已经写入了你的本地maven仓库中。<br>再启动项目，作为服务提供者。</p>
<p>继续再来个消费者：</p>
<p><strong>2消费者项目</strong>：<br>创建方式同提供者项目，名字不一样就行，但是最好还是见名知意，符合规范。结构如下：<br><img src="https://img-blog.csdnimg.cn/20200421235051659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>前文提起过：调用者可以直接调取提供者提供的服务，自身也可以是一个服务提供者，给其他调用者提供服务，此处只是调用，因此架构上不需要什么复杂的。</p>
</blockquote>
<p>pom文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">     &lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;cn.chfsun&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;dubbo-serverorcl&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 整合dubbo --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;io.dubbo.springboot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-dubbo&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;!-- 注意:dubbo强制内置log4J 如果没有则会报错 --&gt;</span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>PS:pom文件中需要引入之前打包好的服务提供者jar<br>如果不清楚怎么引入可查看服务提供者打包后的配置文件：<br><img src="https://img-blog.csdnimg.cn/20200422001453434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#防止服务消费者和提供者端口冲突(一致)</span></span><br><span class="line">server.port=8085</span><br><span class="line"><span class="comment">## Dubbo 消费者  </span></span><br><span class="line">spring.dubbo.application.name=consumer</span><br><span class="line">spring.dubbo.registry.address=zookeeper://127.0.0.1:2181</span><br><span class="line"></span><br><span class="line">spring.dubbo.scan=cn.chfsun.client.controller</span><br><span class="line"></span><br><span class="line"><span class="comment">#数据库相关配置</span></span><br><span class="line">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span><br><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/orcl?useUnicode=<span class="literal">true</span>&amp;useJDBCCompliantTimezoneShift=<span class="literal">true</span>&amp;useLegacyDatetimeCode=<span class="literal">false</span>&amp;serverTimezone=UTC</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=123456</span><br></pre></td></tr></table></figure>
<p>控制层代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Reference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.chfsun.server.service.DeptServie;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptController</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Reference</span>(version = <span class="string">"1.0.0"</span>)</span><br><span class="line">	<span class="keyword">private</span> DeptServie deptServie;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@GetMapping</span>(value = <span class="string">"/list"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> deptServie.queryList();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：<em>@Reference(version = “1.0.0”)这个注解用的是dubbo提供的</em></p>
<p>然后启动消费者项目<br><img src="https://img-blog.csdnimg.cn/20200422002057226.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">能看到红色部分代表消费者搭建成功。</p>
<p>下面打开浏览器访问：<a href="http://localhost:7001/，在服务监控中切换到提供者标签，即可看到：" target="_blank" rel="noopener">http://localhost:7001/，在服务监控中切换到提供者标签，即可看到：</a><br><img src="https://img-blog.csdnimg.cn/2020042200230726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">切换到消费者标签即可看到：<br><img src="https://img-blog.csdnimg.cn/20200422002704402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">嗯？访问这个url看不到？你问怎么访问这个，搭建个服务监控就行了，走起！</p>
<h2 id="Dubbo环境搭建-ZooKeeper注册中心"><a href="#Dubbo环境搭建-ZooKeeper注册中心" class="headerlink" title="Dubbo环境搭建-ZooKeeper注册中心"></a>Dubbo环境搭建-ZooKeeper注册中心</h2><p>在上面搭建好ZooKeeper注册中心后，搭建管理控制台实现服务监控。<br>进入Dubbo官网，点击GIthub<br><a href="http://dubbo.apache.org/zh-cn/" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/</a><br><img src="https://img-blog.csdnimg.cn/20200422092112963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>进入到Github页面后，一直往下找到dubbo-admin/dubbo-monitor<br><img src="https://img-blog.csdnimg.cn/20200422092228489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在此页面会看到dubbo-admin-server,但是没有dubbo-admin,这是因为此时的分支是develop,将分支切换为master<br><img src="https://img-blog.csdnimg.cn/20200422092252226.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>此时页面地址为：<br><a href="https://github.com/apache/dubbo-admin/tree/master" target="_blank" rel="noopener">https://github.com/apache/dubbo-admin/tree/master</a><br>在此页面可以看见其官方说明<br><img src="https://img-blog.csdnimg.cn/20200422092332764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>下载后找到dubbo-admin-server/src/main/resources/application.properties<br>将要监控的Zookpeeper注册中心的地址修改，这里是本机。<br><img src="https://img-blog.csdnimg.cn/20200422092404174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>然后回到dubbo-admin目录下，在此处打开命令行窗口，使用maven进行打包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn clean package</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2020042209252121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>出现Build Success 则就打包成功</p>
<p>此时在目录下会生成target目录，在target目录下会有一个jar包</p>
<p>在运行jar包程序前将上面所讲的ZooKeeper的服务端与客户端运行<br>然后在target目录下打开命令行运行jar包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar dubbo-admin-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>


<p>此时打开浏览器输入：<br><a href="http://localhost:7001/" target="_blank" rel="noopener">http://localhost:7001/</a><br>默认是7001端口，会提示输入账户密码，默认都是root</p>
<p>点击登录，不出意外就能看到上面所展示的页面</p>
<h2 id="管理控制台的作用"><a href="#管理控制台的作用" class="headerlink" title="管理控制台的作用"></a>管理控制台的作用</h2><p>禁止提供者<br><img src="https://img-blog.csdnimg.cn/2020042217164162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">发送请求后：<br><img src="https://img-blog.csdnimg.cn/20200422171735261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">后端控制台：<br><img src="https://img-blog.csdnimg.cn/20200422171816786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>禁止消费者<br><img src="https://img-blog.csdnimg.cn/2020042216532885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">执行后再去访问页面返回：<br><img src="https://img-blog.csdnimg.cn/20200422165505431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">eclipse控制台：<br><img src="https://img-blog.csdnimg.cn/20200422165537522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">再允许访问后，即可正常访问。</p>
<h2 id="Dubbo与SpringCloud"><a href="#Dubbo与SpringCloud" class="headerlink" title="Dubbo与SpringCloud"></a>Dubbo与SpringCloud</h2><p>如果非要比较一下两者的孰优孰劣，要根据实际应用场景来阐述。其实，这两者都是当下微服务典型的技术解决方案，可谓一时瑜亮，只不过在国内dubbo比较流行一些，原因其实很简单:</p>
<p>　　1. dubbo官方文档详细且有中文，而且运行原理技术解决方案描述比较透彻</p>
<p>　　2.国内的架构师有许多来自于阿里，对dubbo的推广起到了不可磨灭的作用</p>
<p>　　3.由于dubbo出现的较早，当然也开源。对于当时可谓轰动一时，各大公司争先使用，即使到现在谁也不愿意将原先的项目大刀阔斧的用新技术重构，代价要考虑。</p>
<p>　　相反，在国外的社区，dubbo的使用广度恐怕就远不及SpringCloud了。原因其实也很明了：就公司而言，dubbo出自于阿里，属于商业公司。我觉得阿里的框架肯定优先满足于自己的业务与利益。而springcloud出自于Spring的产品族，而其公司本身就是为了简化企业的开发模式，为各大企业所服务。因此他们的本身出发点就不同，个人觉得这个才是必要因素。</p>
<p>　　但是有几点需要在这里了解一下：</p>
<p>　　1.  就完成的功能而言：dubbo其实是SpringCloud组件中的一部分，也就相当于netflix中的eureka+小半个Hystrix+ribbon+feign。但是SpringCloud集成的诸如：链路跟踪，分布式配置，网关路由等，目前dubbo里还没有找到，也有可能我没有发现。因此在dubbo里需要使用这些功能，我们还要借助于第三方的实现。</p>
<p>　　2.  dubbo是基于rpc实现远程调用，springcloud各个服务之间调用还是经过http，就性能而言是要弱于dubbo的，毕竟dubbo是经过阿里庞大的业务产品族和并发量考验的，不过这并不代表springcloud性能会很差</p>
<p>　　3. 常用的dubbo的技术使用方案还是基于spring，因此，我还是愿意把幕后英雄归功于spring</p>
<p>　　4. spring-cloud就相当于电脑的品牌机，拿来很方便的使用，因此它绝对是中小型公司(没有过多的精力和成本去搞基础研发)福音。而dubbo就好比是组装机，我们通过其已有的实现，完整的文档装配成我们自己想要的一套微服务方案。</p>
<p>总之，Dubbo 出生于阿里系，是阿里巴巴服务化治理的核心框架，并被广泛应用于中国各互联网公司；只需要通过 Spring 配置的方式即可完成服务化，对于应用无入侵，设计的目的还是服务于自身的业务为主。</p>
<p>虽然阿里内部原因 Dubbo 曾经一度暂停维护版本，但是框架本身的成熟度以及文档的完善程度，完全能满足各大互联网公司的业务需求。</p>
<p>如果我们使用配置中心、分布式跟踪这些内容都需要自己去集成，这样无形中增加了使用 Dubbo 的难度。</p>
<p>Spring Cloud 是大名鼎鼎的 Spring 家族的产品， 专注于企业级开源框架的研发。</p>
<p>Spring Cloud 自从发布到现在，仍然在不断的高速发展，几乎考虑了服务治理的方方面面，开发起来非常的便利和简单。</p>
<p>Dubbo 于 2017 年开始又重启维护，发布了更新后的 2.5.7 版本，而 Spring Cloud 更新的非常快，目前已经更新到 Finchley.M2。</p>
<p>因此，企业需要根据自身的研发水平和所处阶段选择合适的架构来解决业务问题，不管是 Dubbo 还是 Spring Cloud 都是实现微服务有效的工具。<br>微服务架构是互联网很热门的话题，是互联网技术发展的必然结果。它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。</p>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>boot dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云短信验证</title>
    <url>/myblog/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81/%E4%BA%91%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81/</url>
    <content><![CDATA[<h2 id="阿里云短信验证"><a href="#阿里云短信验证" class="headerlink" title="阿里云短信验证"></a>阿里云短信验证</h2><p>ps:这是一个根据前端发送的手机号 发送一个验证码 和注册功能！！！！</p>
<a id="more"></a>
<h4 id="一、先在项目里导入jar包"><a href="#一、先在项目里导入jar包" class="headerlink" title="一、先在项目里导入jar包"></a>一、先在项目里导入jar包</h4><p>1、pom形式</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">  &lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;com.aliyun&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;4.5.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;com.aliyun&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;aliyun-java-sdk-dysmsapi&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;1.1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2、jar包链接</p>
<blockquote>
<p>百度云：<a href="https://pan.baidu.com/s/1ld5CzBhIE0HHEkja2Xa90A" target="_blank" rel="noopener">https://pan.baidu.com/s/1ld5CzBhIE0HHEkja2Xa90A</a> 提取码：2etr</p>
</blockquote>
<h4 id="二、Controller-层"><a href="#二、Controller-层" class="headerlink" title="二、Controller 层"></a>二、Controller 层</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 产品名称:云通信短信API产品,开发者无需替换</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> String product = <span class="string">"Dysmsapi"</span>;</span><br><span class="line">	<span class="comment">// 产品域名,开发者无需替换</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> String domain = <span class="string">"dysmsapi.aliyuncs.com"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// TODO 此处需要替换成开发者自己的AK(在阿里云访问控制台寻找)</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> String accessKeyId = <span class="string">"？？？？？？"</span>; <span class="comment">// TODO 修改成自己的</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> String accessKeySecret = <span class="string">"？？？？？？"</span>; <span class="comment">// TODO 修改成自己的</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SendSmsResponse <span class="title">sendSms</span><span class="params">(String telephone, String code)</span> <span class="keyword">throws</span> ClientException </span>&#123;</span><br><span class="line">		<span class="comment">// 可自助调整超时时间</span></span><br><span class="line">		System.setProperty(<span class="string">"sun.net.client.defaultConnectTimeout"</span>, <span class="string">"30000"</span>);</span><br><span class="line">		System.setProperty(<span class="string">"sun.net.client.defaultReadTimeout"</span>, <span class="string">"30000"</span>);</span><br><span class="line">		<span class="comment">// 初始化acsClient,暂不支持region化</span></span><br><span class="line">		IClientProfile profile = DefaultProfile.getProfile(<span class="string">"cn-hangzhou"</span>, accessKeyId, accessKeySecret);</span><br><span class="line">		DefaultProfile.addEndpoint(<span class="string">"cn-hangzhou"</span>, <span class="string">"cn-hangzhou"</span>, product, domain);</span><br><span class="line">		IAcsClient acsClient = <span class="keyword">new</span> DefaultAcsClient(profile);</span><br><span class="line">		<span class="comment">// 组装请求对象-具体描述见控制台-文档部分内容</span></span><br><span class="line">		SendSmsRequest request = <span class="keyword">new</span> SendSmsRequest();</span><br><span class="line">		<span class="comment">// 必填:待发送手机号</span></span><br><span class="line">		request.setPhoneNumbers(telephone);</span><br><span class="line">		<span class="comment">// 必填:短信签名-可在短信控制台中找到</span></span><br><span class="line">		request.setSignName(<span class="string">"？？？？？"</span>); <span class="comment">// TODO 修改成自己的</span></span><br><span class="line">		<span class="comment">// 必填:短信模板-可在短信控制台中找到</span></span><br><span class="line">		request.setTemplateCode(<span class="string">"？？？？？"</span>); <span class="comment">// TODO 修改成自己的</span></span><br><span class="line">		<span class="comment">// 可选:模板中的变量替换JSON串,如模板内容为"亲爱的$&#123;name&#125;,您的验证码为$&#123;code&#125;"时,此处的值为</span></span><br><span class="line"><span class="comment">//		        request.setTemplateParam("&#123;\"name\":\"Tom\", \"code\":\"123\"&#125;");</span></span><br><span class="line">		request.setTemplateParam(<span class="string">"&#123;\"code\":\""</span> + code + <span class="string">"\"&#125;"</span>);</span><br><span class="line">		<span class="comment">// 选填-上行短信扩展码(无特殊需求用户请忽略此字段)</span></span><br><span class="line">		<span class="comment">// request.setSmsUpExtendCode("90997");</span></span><br><span class="line">		<span class="comment">// 可选:outId为提供给业务方扩展字段,最终在短信回执消息中将此值带回给调用者</span></span><br><span class="line">		request.setOutId(<span class="string">"yourOutId"</span>);</span><br><span class="line">		<span class="comment">// hint 此处可能会抛出异常，注意catch</span></span><br><span class="line">		SendSmsResponse sendSmsResponse = acsClient.getAcsResponse(request);</span><br><span class="line">		<span class="keyword">if</span> (sendSmsResponse.getCode() != <span class="keyword">null</span> &amp;&amp; sendSmsResponse.getCode().equals(<span class="string">"OK"</span>)) &#123;</span><br><span class="line">			System.out.println(<span class="string">"短信发送成功！"</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"短信发送失败！"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sendSmsResponse;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Map&lt;Object, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 接受手机号发短信</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> feedback</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> ClientException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@PostMapping</span>(<span class="string">"/inserts"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Result <span class="title">inserts</span><span class="params">(@RequestBody Member member, HttpServletRequest request)</span> <span class="keyword">throws</span> ClientException </span>&#123;</span><br><span class="line">		<span class="comment">// 随机一个4位数</span></span><br><span class="line">		<span class="keyword">int</span> a = (<span class="keyword">int</span>) (Math.random() * <span class="number">9000</span> + <span class="number">1000</span>);</span><br><span class="line">		String code = Integer.toString(a);</span><br><span class="line">		String codess = map.get(member.getTelePhone());</span><br><span class="line">		map.put(member.getTelePhone(), code);</span><br><span class="line">		SendSmsResponse response = sendSms(member.getTelePhone(), code);</span><br><span class="line">		<span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Result(code, <span class="number">200</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="string">"操作失败"</span>, -<span class="number">200</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@PostMapping</span>(<span class="string">"/zc"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Result <span class="title">insertss</span><span class="params">(@RequestBody Member member)</span> </span>&#123;</span><br><span class="line">		Date date = <span class="keyword">new</span> Date();</span><br><span class="line">		SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyMMddhhmmss"</span>);</span><br><span class="line">		String now = dateFormat.format(date).toString();</span><br><span class="line">		member.setId(<span class="string">"KWY"</span> + now + (<span class="keyword">int</span>) (Math.random() * <span class="number">9000</span> + <span class="number">1000</span>));</span><br><span class="line">		String codess = map.get(member.getTelePhone());</span><br><span class="line">		String n = member.getCode();</span><br><span class="line">		<span class="keyword">if</span> (codess.equals(n)) &#123;</span><br><span class="line"></span><br><span class="line">			restTemplate.postForObject(memberServiceUrl + <span class="string">"/Member/zc"</span>, member, Result<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Result(n, <span class="number">200</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="string">"操作失败"</span>, -<span class="number">200</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>阿里云短信验证</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>阿里云短信验证</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工具——windows下载安装curl工具调用http接口</title>
    <url>/myblog/tool/%E4%BB%B6%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94windows%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85curl%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8http%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>curl是利用URL语法在命令行方式下工作的开源文件传输工具，支持的通信协议有FTP、FTPS、HTTP、HTTPS、TFTP、SFTP、Gopher、SCP、Telnet、DICT、FILE、LDAP、LDAPS、IMAP、POP3、SMTP和RTSP，功能强大，用于文件下载和上传，项目需要，学习一下。</p>
<a id="more"></a>
<h2 id="二、下载"><a href="#二、下载" class="headerlink" title="二、下载"></a>二、下载</h2><p>地址：<a href="https://curl.haxx.se/windows/" target="_blank" rel="noopener">https://curl.haxx.se/windows/</a></p>
<blockquote>
<p>windows的好处就是双击傻瓜式安装，不需要智商。</p>
</blockquote>
<h2 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h2><p>解压后打开bin目录有curl工具可执行文件，cmd进去直接使用：<br><img src="https://img-blog.csdnimg.cn/20200517234730148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="四、语法"><a href="#四、语法" class="headerlink" title="四、语法"></a>四、语法</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl [option] [url]</span><br></pre></td></tr></table></figure>

<p>帮助：curl –help<br>1.http协议</p>
<p>【Option】可选参数             描述</p>
<p>-X  或者 –request      指定请求方式，如GET 、POST 、PUT 、DELETE 、HEAD 等七种方式<br>-i  或者 –include      显示服务器response 响应头部信息<br>-v  或者 –verbose      显示详细(冗长)信息<br>-H  或者 –header       指定http 请求头 ，如  -H  “Content-Type:application/json”<br>-d  或者 –data         指定请求体body参数 , 如有多个参数可以用&amp;隔开或者使用多个-d 选项。 如  -d “a=abc&amp;b=110&amp;c=true” （指定三个参数）或  -d a=abc -d b=110 -d c=true 亦可。<br>-F  或者 –form         指定multipart Form 请求体，如文件域参数，或者普通表单域参数。<br>-u  或者 –user         指定用户名：密码<br>-C  或者 –continue-at  offset  用于断点续传。<br>-c  或者 -cookie-jar    请求返回,回写cookie到指定文件中<br>-D  或者 –dump-header  请求返回,回写response header信息到指定文件中<br>-b  或者 –cookie       请求时携带上cookie，指定本地cookie所在文件<br>-x  或者 –proxy        指定 http代理服务器ip:port<br>-O                      请求Url并保存到本地<br>-o                      请求Url并保存到指定文件</p>
<pre><code>基本用法，get请求：curl {url}
显示HTTP响应的头部信息：curl -i {url}
查看HTTP请求/响应过程中的所有头部信息：curl -v {url}
无参POST请求：curl -X POST {url}
Form表单(application/x-www-form-urlencoded)POST请求：curl -X POST -d &quot;name=xxx&quot; {url}
JSON形式POST请求：curl -H &quot;Content-Type:application/json&quot; -X POST -d &apos;{&quot;name&quot;: &quot;xxx&quot;}&apos; {url}
文件流（multipart/form-data）POST请求：curl -X POST  -F &quot;Filedata=@{filePath}&quot; (文件参数)  -F &quot;FileName=text.txt&quot; （普通文本参数) {url}
请求cookie回写到本地：curl -c cookie.txt {url}
请求携带cookie：curl -b cookie.txt {url}
下载文件到本地：curl -O {url}
下载文件到本地并指定文件名：curl -o {fileName} {url}</code></pre><p>2.ftp协议</p>
<pre><code>显示FTP文件列表：
curl -u {userName}:{password} ftp://{url} &lt;or&gt;  curl ftp://{userName}:{password}@{url}
不显示进度条
curl -u {userName}:{password} -s ftp://{url}
下载单个文件
curl -u {userName}:{password} ftp://{ip}:{21}/{srcFilepath} -o {destFilepath}
上传单个文件
curl -u {userName}:{password} ftp://{ip}:{21}/{destFilepath} -T {srcFilepath}
删除ftp服务器文件（ftp 删除命令）：
curl -u {userName}:{password} ftp://{ip}:{21} -X &apos;DELE {filePath}&apos;
连续下载多个文件到本地（不支持递归下载，不指定文件名）：
curl -u {userName}:{password} ftp://{ip}:{21}/[1,2,3].txt -O  或者
curl -u {userName}:{password} ftp://{ip}:{21}/[1-3].txt -O</code></pre><p>3.响应时长</p>
<pre><code>curl -o /dev/null -w %{time_namelookup}::%{time_connect}::%{time_starttransfer}::%{time_total}::%{speed_download}&quot;\n&quot;  {url}</code></pre><p>参数说明：</p>
<pre><code>-o：把curl 返回的html、js 写到垃圾回收站[ /dev/null]
-s：去掉所有状态
-w：按照后面的格式写出rt
    time_namelookup：DNS 解析域名[www.taobao.com]的时间 
    time_commect：client和server端建立TCP 连接的时间
    time_starttransfer：从client发出请求；到web的server 响应第一个字节的时间
    time_total：client发出请求；到web的server发送会所有的相应数据的时间
    speed_download：下周速度  单位 byte/s</code></pre>]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>curl</tag>
      </tags>
  </entry>
  <entry>
    <title>关于限流的6种实现方案</title>
    <url>/myblog/tool/%E5%85%B3%E4%BA%8E%E9%99%90%E6%B5%81%E7%9A%846%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h3 id="为什么需要限流"><a href="#为什么需要限流" class="headerlink" title="为什么需要限流"></a>为什么需要限流</h3><a id="more"></a>
<p>关于这个命题，相信很多同学心中都有各种答案，最能想到的或许就是淘宝双十一活动了。这里我们假设一个系统只能为 10W 人提供服务，突然有一天因为这个热点事件，造成了系统短时间内的访问量迅速增加到了 50W，那么导致的直接结果是系统崩溃，任何人都不能用系统了，显然只有少人数能用远比所有人都不能用更符合我们的预期，因此这个时候我们要使用「限流」了。</p>
<h3 id="限流分类"><a href="#限流分类" class="headerlink" title="限流分类"></a>限流分类</h3><p>限流的实现方案有很多种，这里稍微理了一下，限流的分类如下所示：</p>
<ol>
<li><p>合法性验证限流：比如验证码、IP 黑名单等，这些手段可以有效的防止恶意攻击和爬虫采集；</p>
</li>
<li><p>容器限流：比如 Tomcat、Nginx 等限流手段，其中 Tomcat 可以设置最大线程数（maxThreads），当并发超过最大线程数会排队等待执行；而 Nginx 提供了两种限流手段：一是控制速率，二是控制并发连接数；</p>
</li>
<li><p>服务端限流：比如我们在服务器端通过限流算法实现限流，此项也是我们本文介绍的重点。</p>
</li>
</ol>
<p>合法性验证限流为最常规的业务代码，就是普通的验证码和 IP 黑名单系统，本文就不做过多的叙述了，我们重点来看下后两种限流的实现方案：容器限流和服务端限流。</p>
<h3 id="容器限流"><a href="#容器限流" class="headerlink" title="容器限流"></a>容器限流</h3><h5 id="Tomcat-限流"><a href="#Tomcat-限流" class="headerlink" title="Tomcat 限流"></a>Tomcat 限流</h5><p>Tomcat 8.5 版本的最大线程数在 conf/server.xml 配置中，如下所示：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;Connector port="8080" protocol="HTTP/1.1"</span><br><span class="line">          connectionTimeout="20000"</span><br><span class="line">          maxThreads="150"</span><br><span class="line">          redirectPort="8443" /&gt;</span><br></pre></td></tr></table></figure>

<p>其中 maxThreads 就是 Tomcat 的最大线程数，当请求的并发大于此值（maxThreads）时，请求就会排队执行，这样就完成了限流的目的。</p>
<blockquote>
<p>小贴士：maxThreads 的值可以适当的调大一些，此值默认为 150（Tomcat 版本 8.5.42），但这个值也不是越大越好，要看具体的硬件配置，需要注意的是每开启一个线程需要耗用 1MB 的 JVM 内存空间用于作为线程栈之用，并且线程越多 GC 的负担也越重。最后需要注意一下，操作系统对于进程中的线程数有一定的限制，Windows 每个进程中的线程数不允许超过 2000，Linux 每个进程中的线程数不允许超过 1000。</p>
</blockquote>
<h5 id="Nginx-限流"><a href="#Nginx-限流" class="headerlink" title="Nginx 限流"></a>Nginx 限流</h5><p>Nginx 提供了两种限流手段：一是控制速率，二是控制并发连接数。<br>控制速率</p>
<p>我们需要使用 limit_req_zone 用来限制单位时间内的请求数，即速率限制，示例配置如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">limit_req_zone $binary_remote_addr zone=mylimit:10m rate=2r/s;</span><br><span class="line"><span class="selector-tag">server</span> &#123; </span><br><span class="line">    location / &#123; </span><br><span class="line">        limit_req zone=mylimit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上配置表示，限制每个 IP 访问的速度为 2r/s，因为 Nginx 的限流统计是基于毫秒的，我们设置的速度是 2r/s，转换一下就是 500ms 内单个 IP 只允许通过 1 个请求，从 501ms 开始才允许通过第 2 个请求。</p>
<p>我们使用单 IP 在 10ms 内发并发送了 6 个请求的执行结果如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200528204228602.png#pic_center" alt="在这里插入图片描述">从以上结果可以看出他的执行符合我们的预期，只有 1 个执行成功了，其他的 5 个被拒绝了（第 2 个在 501ms 才会被正常执行）</p>
<h6 id="速率限制升级版"><a href="#速率限制升级版" class="headerlink" title="速率限制升级版"></a>速率限制升级版</h6><p>上面的速率控制虽然很精准但是应用于真实环境未免太苛刻了，真实情况下我们应该控制一个 IP 单位总时间内的总访问次数，而不是像上面那么精确但毫秒，我们可以使用 burst 关键字开启此设置，示例配置如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">limit_req_zone $binary_remote_addr zone=mylimit:10m rate=2r/s;</span><br><span class="line"><span class="selector-tag">server</span> &#123; </span><br><span class="line">    location / &#123; </span><br><span class="line">        limit_req zone=mylimit burst=4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>burst=4 表示每个 IP 最多允许4个突发请求，如果单个 IP 在 10ms 内发送 6 次请求的结果如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200528204503222.png#pic_center" alt="在这里插入图片描述">从以上结果可以看出，有 1 个请求被立即处理了，4 个请求被放到 burst 队列里排队执行了，另外 1 个请求被拒绝了。</p>
<h6 id="控制并发数"><a href="#控制并发数" class="headerlink" title="控制并发数"></a>控制并发数</h6><p>利用 limit_conn_zone 和 limit_conn 两个指令即可控制并发数，示例配置如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">limit_conn_zone $binary_remote_addr zone=perip:10m;</span><br><span class="line">limit_conn_zone $server_name zone=perserver:10m;</span><br><span class="line"><span class="selector-tag">server</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="selector-tag">limit_conn</span> <span class="selector-tag">perip</span> 10;</span><br><span class="line">    <span class="selector-tag">limit_conn</span> <span class="selector-tag">perserver</span> 100;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 limit_conn perip 10 表示限制单个 IP 同时最多能持有 10 个连接；limit_conn perserver 100 表示 server 同时能处理并发连接的总数为 100 个。</p>
<blockquote>
<p>小贴士：只有当 request header 被后端处理后，这个连接才进行计数。</p>
</blockquote>
<h5 id="服务端限流"><a href="#服务端限流" class="headerlink" title="服务端限流"></a>服务端限流</h5><p>服务端限流需要配合限流的算法来执行，而算法相当于执行限流的“大脑”，用于指导限制方案的实现。</p>
<p>有人看到「算法」两个字可能就晕了，觉得很深奥，其实并不是。算法就相当于操作某个事务的具体实现步骤汇总，其实并不难懂，不要被它的表象给吓到哦~</p>
<p>限流的常见算法有以下三种：</p>
<ol>
<li><p>时间窗口算法</p>
</li>
<li><p>漏桶算法</p>
</li>
<li><p>令牌算法</p>
</li>
</ol>
<p>接下来我们分别看来。<br>1.时间窗口算法</p>
<p>所谓的滑动时间算法指的是以当前时间为截止时间，往前取一定的时间，比如往前取 60s 的时间，在这 60s 之内运行最大的访问数为 100，此时算法的执行逻辑为，先清除 60s 之前的所有请求记录，再计算当前集合内请求数量是否大于设定的最大请求数 100，如果大于则执行限流拒绝策略，否则插入本次请求记录并返回可以正常执行的标识给客户端。</p>
<p>滑动时间窗口如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/2020052820515955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>其中每一小个表示 10s，被红色虚线包围的时间段则为需要判断的时间间隔，比如 60s 秒允许 100 次请求，那么红色虚线部分则为 60s。</p>
<p>我们可以借助 Redis 的有序集合 ZSet 来实现时间窗口算法限流，实现的过程是先使用 ZSet 的 key 存储限流的 ID，score 用来存储请求的时间，每次有请求访问来了之后，先清空之前时间窗口的访问量，统计现在时间窗口的个数和最大允许访问量对比，如果大于等于最大访问量则返回 false 执行限流操作，负责允许执行业务逻辑，并且在 ZSet 中添加一条有效的访问记录，具体实现代码如下。</p>
<p>我们借助 Jedis 包来操作 Redis，实现在 pom.xml 添加 Jedis 框架的引用，配置如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span><br><span class="line">&lt;<span class="selector-tag">dependency</span>&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>具体的 Java 实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLimit</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Redis 操作客户端</span></span><br><span class="line">    <span class="keyword">static</span> Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> res = isPeriodLimiting(<span class="string">"java"</span>, <span class="number">3</span>, <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                System.out.println(<span class="string">"正常执行请求："</span> + i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"被限流："</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 休眠 4s</span></span><br><span class="line">        Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">        <span class="comment">// 超过最大执行时间之后，再从发起请求</span></span><br><span class="line">        <span class="keyword">boolean</span> res = isPeriodLimiting(<span class="string">"java"</span>, <span class="number">3</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (res) &#123;</span><br><span class="line">            System.out.println(<span class="string">"休眠后，正常执行请求"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"休眠后，被限流"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 限流方法（滑动时间算法）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key      限流标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> period   限流时间范围（单位：秒）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxCount 最大运行访问次数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPeriodLimiting</span><span class="params">(String key, <span class="keyword">int</span> period, <span class="keyword">int</span> maxCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> nowTs = System.currentTimeMillis(); <span class="comment">// 当前时间戳</span></span><br><span class="line">        <span class="comment">// 删除非时间段内的请求数据（清除老访问数据，比如 period=60 时，标识清除 60s 以前的请求记录）</span></span><br><span class="line">        jedis.zremrangeByScore(key, <span class="number">0</span>, nowTs - period * <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">long</span> currCount = jedis.zcard(key); <span class="comment">// 当前请求次数</span></span><br><span class="line">        <span class="keyword">if</span> (currCount &gt;= maxCount) &#123;</span><br><span class="line">            <span class="comment">// 超过最大请求次数，执行限流</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未达到最大请求数，正常执行业务</span></span><br><span class="line">        jedis.zadd(key, nowTs, <span class="string">""</span> + nowTs); <span class="comment">// 请求记录 +1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上程序的执行结果为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">正常执行请求：0</span><br><span class="line"></span><br><span class="line">正常执行请求：1</span><br><span class="line"></span><br><span class="line">正常执行请求：2</span><br><span class="line"></span><br><span class="line">正常执行请求：3</span><br><span class="line"></span><br><span class="line">正常执行请求：4</span><br><span class="line"></span><br><span class="line">正常执行请求：5</span><br><span class="line"></span><br><span class="line">正常执行请求：6</span><br><span class="line"></span><br><span class="line">正常执行请求：7</span><br><span class="line"></span><br><span class="line">正常执行请求：8</span><br><span class="line"></span><br><span class="line">正常执行请求：9</span><br><span class="line"></span><br><span class="line">被限流：10</span><br><span class="line"></span><br><span class="line">被限流：11</span><br><span class="line"></span><br><span class="line">被限流：12</span><br><span class="line"></span><br><span class="line">被限流：13</span><br><span class="line"></span><br><span class="line">被限流：14</span><br><span class="line"></span><br><span class="line">休眠后，正常执行请求</span><br></pre></td></tr></table></figure>

<p>此实现方式存在的缺点有两个：</p>
<ol>
<li><p>使用 ZSet 存储有每次的访问记录，如果数据量比较大时会占用大量的空间，比如 60s 允许 100W 访问时；</p>
</li>
<li><p>此代码的执行非原子操作，先判断后增加，中间空隙可穿插其他业务逻辑的执行，最终导致结果不准确。</p>
</li>
</ol>
<h6 id="2-漏桶算法"><a href="#2-漏桶算法" class="headerlink" title="2.漏桶算法"></a>2.漏桶算法</h6><p>漏桶算法的灵感源于漏斗，如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20200528210453706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">滑动时间算法有一个问题就是在一定范围内，比如 60s 内只能有 10 个请求，当第一秒时就到达了 10 个请求，那么剩下的 59s 只能把所有的请求都给拒绝掉，而漏桶算法可以解决这个问题。</p>
<p>漏桶算法类似于生活中的漏斗，无论上面的水流倒入漏斗有多大，也就是无论请求有多少，它都是以均匀的速度慢慢流出的。当上面的水流速度大于下面的流出速度时，漏斗会慢慢变满，当漏斗满了之后就会丢弃新来的请求;当上面的水流速度小于下面流出的速度的话，漏斗永远不会被装满，并且可以一直流出。</p>
<p>漏桶算法的实现步骤是，先声明一个队列用来保存请求，这个队列相当于漏斗，当队列容量满了之后就放弃新来的请求，然后重新声明一个线程定期从任务队列中获取一个或多个任务进行执行，这样就实现了漏桶算法。</p>
<p>上面我们演示 Nginx 的控制速率其实使用的就是漏桶算法，当然我们也可以借助 Redis 很方便的实现漏桶算法。</p>
<p>我们可以使用 Redis 4.0 版本中提供的 Redis-Cell 模块，该模块使用的是漏斗算法，并且提供了原子的限流指令，而且依靠 Redis 这个天生的分布式程序就可以实现比较完美的限流了。</p>
<p>Redis-Cell 实现限流的方法也很简单，只需要使用一条指令 cl.throttle 即可，使用示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; cl.throttle mylimit 15 30 60</span><br><span class="line">1）（<span class="built_in">integer</span>）0 <span class="comment"># 0 表示获取成功，1 表示拒绝</span></span><br><span class="line">2）（<span class="built_in">integer</span>）15 <span class="comment"># 漏斗容量</span></span><br><span class="line">3）（<span class="built_in">integer</span>）14 <span class="comment"># 漏斗剩余容量</span></span><br><span class="line">4）（<span class="built_in">integer</span>）-1 <span class="comment"># 被拒绝之后，多长时间之后再试（单位：秒）-1 表示无需重试</span></span><br><span class="line">5）（<span class="built_in">integer</span>）2 <span class="comment"># 多久之后漏斗完全空出来</span></span><br></pre></td></tr></table></figure>
<p>其中 15 为漏斗的容量，30 / 60s 为漏斗的速率。</p>
<h6 id="3-令牌算法"><a href="#3-令牌算法" class="headerlink" title="3.令牌算法"></a>3.令牌算法</h6><p>在令牌桶算法中有一个程序以某种恒定的速度生成令牌，并存入令牌桶中，而每个请求需要先获取令牌才能执行，如果没有获取到令牌的请求可以选择等待或者放弃执行，如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20200528210631294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">我们可以使用 Google 开源的 guava 包，很方便的实现令牌桶算法，首先在 pom.xml 添加 guava 引用，配置如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.google.guava/guava --&gt;</span><br><span class="line">&lt;<span class="selector-tag">dependency</span>&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;28.2-jre&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>具体实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.util.concurrent.RateLimiter;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.time.Instant;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Guava 实现限流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimiterExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每秒产生 10 个令牌（每 100 ms 产生一个）</span></span><br><span class="line">        RateLimiter rt = RateLimiter.create(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 获取 1 个令牌</span></span><br><span class="line">                rt.acquire();</span><br><span class="line">                System.out.println(<span class="string">"正常执行方法，ts:"</span> + Instant.now());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">正常执行方法，ts:2020-05-15T14:46:37.175Z</span><br><span class="line"></span><br><span class="line">正常执行方法，ts:2020-05-15T14:46:37.237Z</span><br><span class="line"></span><br><span class="line">正常执行方法，ts:2020-05-15T14:46:37.339Z</span><br><span class="line"></span><br><span class="line">正常执行方法，ts:2020-05-15T14:46:37.442Z</span><br><span class="line"></span><br><span class="line">正常执行方法，ts:2020-05-15T14:46:37.542Z</span><br><span class="line"></span><br><span class="line">正常执行方法，ts:2020-05-15T14:46:37.640Z</span><br><span class="line"></span><br><span class="line">正常执行方法，ts:2020-05-15T14:46:37.741Z</span><br><span class="line"></span><br><span class="line">正常执行方法，ts:2020-05-15T14:46:37.840Z</span><br><span class="line"></span><br><span class="line">正常执行方法，ts:2020-05-15T14:46:37.942Z</span><br><span class="line"></span><br><span class="line">正常执行方法，ts:2020-05-15T14:46:38.042Z</span><br><span class="line"></span><br><span class="line">正常执行方法，ts:2020-05-15T14:46:38.142Z</span><br></pre></td></tr></table></figure>

<p>从以上结果可以看出令牌确实是每 100ms 产生一个，而 acquire() 方法为阻塞等待获取令牌，它可以传递一个 int 类型的参数，用于指定获取令牌的个数。它的替代方法还有 tryAcquire()，此方法在没有可用令牌时就会返回 false 这样就不会阻塞等待了。当然 tryAcquire() 方法也可以设置超时时间，未超过最大等待时间会阻塞等待获取令牌，如果超过了最大等待时间，还没有可用的令牌就会返回 false。</p>
<blockquote>
<p>注意：使用 guava 实现的令牌算法属于程序级别的单机限流方案，而上面使用 Redis-Cell 的是分布式的限流方案。</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文提供了 6 种具体的实现限流的手段，他们分别是：Tomcat 使用 maxThreads 来实现限流；Nginx 提供了两种限流方式，一是通过 limit_req_zone 和 burst 来实现速率限流，二是通过 limit_conn_zone 和 limit_conn 两个指令控制并发连接的总数。</p>
<p>最后我们讲了时间窗口算法借助 Redis 的有序集合可以实现，还有漏桶算法可以使用 Redis-Cell 来实现，以及令牌算法可以解决 Google 的 guava 包来实现。</p>
<p>需要注意的是借助 Redis 实现的限流方案可用于分布式系统，而 guava 实现的限流只能应用于单机环境。如果你嫌弃服务器端限流麻烦，甚至可以在不改代码的情况下直接使用容器限流（Nginx 或 Tomcat），但前提是能满足你的业务需求。</p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>限流</tag>
      </tags>
  </entry>
  <entry>
    <title>综合面试题</title>
    <url>/myblog/interview/%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>综合面试题</p>
<a id="more"></a>
<h4 id="1-反射的实现方式"><a href="#1-反射的实现方式" class="headerlink" title="1.反射的实现方式"></a>1.反射的实现方式</h4><p>第一种：通过Object类的getClass方法<br>Class cla = foo.getClass();</p>
<p>第二种：通过对象实例方法获取对象<br>Class cla = foo.class;</p>
<p>第三种：通过Class.forName方式<br>Class cla = Class.forName(“xx.xx.Foo”);</p>
<h4 id="2-spring的事务"><a href="#2-spring的事务" class="headerlink" title="2.spring的事务"></a>2.spring的事务</h4><p>原子性 （atomicity）:强调事务的不可分割.<br>一致性 （consistency）:事务的执行的前后数据的完整性保持一致.<br>隔离性 （isolation）:一个事务执行的过程中,不应该受到其他事务的干扰<br>持久性（durability） :事务一旦结束,数据就持久到数据库</p>
<p>脏读 :一个事务读到了另一个事务的未提交的数据<br>不可重复读 :一个事务读到了另一个事务已经提交的 update 的数据导致多次查询结果不一致.<br>虚 | 幻读 :一个事务读到了另一个事务已经提交的 insert 的数据导致多次查询结果不一致.</p>
<p>DEFAULT 这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别.<br>未提交读（read uncommited） :脏读，不可重复读，虚读都有可能发生<br>已提交读 （read commited）:避免脏读。但是不可重复读和虚读有可能发生<br>可重复读 （repeatable read） :避免脏读和不可重复读.但是虚读有可能发生.<br>串行化的 （serializable） :避免以上所有读问题.<br>Mysql 默认:可重复读<br>Oracle 默认:读已提交</p>
<p>概念<br>　　Repeatable Read（可重复读）：即：事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容。<br>实现原理（MVCC [ 多版本并发控制 ]）</p>
<p>　　InnoDB在每行记录后面保存两个隐藏的列，分别保存了这个行的创建时间和行的删除时间。这里存储的并不是实际的时间值,而是系统版本号，当数据被修改时，版本号加1<br>　　在读取事务开始时，系统会给当前读事务一个版本号，事务会读取版本号&lt;=当前版本号的数据<br>　　此时如果其他写事务修改了这条数据，那么这条数据的版本号就会加1，从而比当前读事务的版本号高，读事务自然而然的就读不到更新后的数据了<br>MySQL的可重复读，对事务B进行查询时，事务A提交的更新不会影响到事务B。<br>　　但是对事务B进行更新时，事务A提交的更新会影响到事务B。<br>read uncommited：是最低的事务隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。<br>read commited：保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据。<br>repeatable read：这种事务隔离级别可以防止脏读，不可重复读。但是可能会出现幻象读。它除了保证一个事务不能被另外一个事务读取未提交的数据之外还避免了以下情况产生（不可重复读）。<br>serializable：这是花费最高代价但最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读之外，还避免了幻象读（避免三种）。</p>
<h4 id="3-java堆和栈的区别"><a href="#3-java堆和栈的区别" class="headerlink" title="3.java堆和栈的区别"></a>3.java堆和栈的区别</h4><p>堆是在运行数据区划分出来的一块内存区域，用于存储在程序运行过程中创建的对象实例和数组，在虚拟机运行的所有线程创建的对象实例和数组都共享一个堆。堆中的存储空间是有限的，当堆中存储的对象实例超过堆的存储空间时，堆就无法再存储新的实例对象，在这种情况下就会造成堆的溢出，java程序也会抛出内存溢出异常。因此当堆中的实例对象不再需要时，应及时回收空间，回收的空间再分配给新的实例对象。</p>
<p>栈是一个数据结构，栈结构是一种特殊的线性表，限定仅在表的一端进行元素的插入和删除。当表中没有元素时，称为空栈。</p>
<h4 id="4-springboot-run方法执行流程"><a href="#4-springboot-run方法执行流程" class="headerlink" title="4.springboot.run方法执行流程"></a>4.springboot.run方法执行流程</h4><p>SpringApplication.run分析<br>分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行；<br>1.首先创建一个SpringApplication对象实例，然后调用这个创建好的SpringApplication的实例方法。</p>
<p>2.收集各种条件和回调接口，调用它们的started()方法。</p>
<p>3.创建并配置当前Spring Boot应用将要使用的Environment。</p>
<p>4.遍历调用所有SpringApplicationRunListener的environmentPrepared()的方法。</p>
<p>5.如果SpringApplication的showBanner属性被设置为true，则打印banner。</p>
<p>6.创建ApplicationContext，将之前准备好的Environment给ApplicationContext使用。</p>
<p>7.遍历调用所有SpringApplicationRunListener的contextPrepared()方法。</p>
<p>8.最核心的一步，将之前通过@EnableAutoConfiguration获取的所有配置以及其他形式的IoC容器配置加载到已经准备完毕的ApplicationContext</p>
<p>9.遍历调用所有SpringApplicationRunListener的contextLoaded()方法。</p>
<p>10.调用ApplicationContext的refresh()方法，完成IoC容器可用的最后一道工序。</p>
<p>11.执行 ApplicationRunner和CommandLineRunner通告finished()。</p>
<h4 id="5-jsp执行流程"><a href="#5-jsp执行流程" class="headerlink" title="5.jsp执行流程"></a>5.jsp执行流程</h4><p>因为第一请求服务端 会有翻译 和编译的过程，因此比较慢； 后续访问 可以直接访问class,因此速度较快。但是 如果 服务端修改了代码，则再次访问时  会重新的翻译、编译。</p>
<h4 id="6-jsp与servlet的关系"><a href="#6-jsp与servlet的关系" class="headerlink" title="6.jsp与servlet的关系"></a>6.jsp与servlet的关系</h4><p>JSP是Servlet技术的扩展，本质上就是Servlet的简易方式。JSP编译后是“类servlet”。<br>Servlet和JSP最主要的不同点在于：Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML里分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。<br>JSP侧重于视图，Servlet主要用于控制逻辑。</p>
<h4 id="7-servlet生命周期"><a href="#7-servlet生命周期" class="headerlink" title="7.servlet生命周期"></a>7.servlet生命周期</h4><p>1.加载和实例化<br>Servlet容器负责加载和实例化Servlet。当Servlet容器启动时，或者在容器检测到需要这个Servlet来响应第一个请求时，创建Servlet实例。<br>2.初始化<br>在Servlet实例化之后，容器将调用Servlet的init()方法初始化这个对象。<br>3.请求处理<br>Servlet容器调用Servlet的service()方法对请求进行处理。<br>4.服务终止<br>当容器检测到一个Servlet实例应该从服务中被移除的时候，容器就会调用实例的destroy()方法，以便让该实例可以释放它所使用的资源，保存数据到持久存<br>储设备中。当需要释放内存或者容器关闭时，容器就会调用Servlet实例的destroy()方法。在destroy()方法调用之后，容器会释放这个Servlet实例，该实例<br>随后会被Java的垃圾收集器所回收。如果再次需要这个Servlet处理请求，Servlet容器会创建一个新的Servlet实例。</p>
<p>在整个Servlet的生命周期过程中，创建Servlet实例、调用实例的init()和destroy()方法都只进行一次，当初始化完成后，Servlet容器会将该实例保存在内存中，通过调用它的service()方法，为接收到的请求服务。</p>
<h4 id="8-mybatis缓存"><a href="#8-mybatis缓存" class="headerlink" title="8.mybatis缓存"></a>8.mybatis缓存</h4><p>一级缓存：指的是MyBatis中SqlSession对象的缓存</p>
<p>当我们执行查询之后，查询的结果会同时存入到SqlSession为我们提供的一块区域中。<br>该区域的结构是一个Map。当我们再次查询同样的数据，MyBatis会先去SqlSession中查询是否有，有的话直接拿来用。<br>当SqlSession对象消失时( 关闭SqlSession，或者调用clearCache()方法 )，MyBatis的一级缓存也就消失了。</p>
<p>缓存的数据问题：如果将一个查询结果保存到缓存中，次数数据库对该数据进行更改，那么就会出现缓存数据和数据集数据不匹配的情况。</p>
<p>MyBatis的解决方案：当调用SqlSession的修改、添加、删除、commit()、close()等方法时，就会清空一级缓存。</p>
<p>二级缓存：指的是MyBatis中SqlSessionFactory对象的缓存，由同一个SqlSessionFactory对象创建的SqlSession共享其缓存。</p>
<p>二级缓存的使用步骤：</p>
<p>( 配置文件方式 )<br>1.让MyBatis框架支持二级缓存( 在SqlMapConfig.xml中配置 )( 默认开启 )</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">        &lt;setting name = <span class="string">"cacheEnabled"</span> value=<span class="string">"true"</span>&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>
<p>2.让当前的映射文件支持二级缓存( 在自定义的.xml中配置 )<br><cache><br>3.让当前的操作支持二级缓存( 在select标签中配置 )</cache></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">"selectAll"</span> resultType=<span class="string">"user"</span> useCache=<span class="string">"true"</span>&gt;</span><br><span class="line">        select * from user where id=#&#123;uid&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<p>( 注解方式 )<br>1.让MyBatis框架支持二级缓存( 在SqlMapConfig.xml中配置 )( 默认开启 )</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">        &lt;setting name = <span class="string">"cacheEnabled"</span> value=<span class="string">"true"</span>&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>
<p>2.在@select等curd标签所在的类上添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CacheNamespace</span>(blocking = <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure>
<p>注 : 二级缓存中存放的是数据，不是对象。当你使用时，会将这些数据放入一个新对象中返回。</p>
<h4 id="9-sql优化方案"><a href="#9-sql优化方案" class="headerlink" title="9.sql优化方案"></a>9.sql优化方案</h4><p>   常用的SQL语句优化手段</p>
<blockquote>
<pre><code>1. 尽量去除表连接操作 
2. 尽量减少操作到的列的数目 
3. 精简数据类型和约束条件，以改进表结构 
4. 合理的构建索引 
5. 在SQL中有意、合理的利用索引 
6. 去除重复索引 
7. 删除不用的索引 
8. 尽量减少sql语句要扫描的语句数量 
9. 确保on或者using子句上的列上有索引 
10. 确保group by和order by中的表达式只涉及表中的一个列 
11. 尽量明确写出要查询的列，少用select * 
12. 尽量不要在where里面使用不等于符号，或者是进行null值判断，这会导致全表扫描 
13. 尽量不要在where里面对字段进行函数式操作 
14. 用exist代替in</code></pre></blockquote>
<p>SQL优化实际是个综合性的工作 硬件服务器、MySQL配置、表结构、索引、临时表、SQL语句</p>
<h4 id="10-springboot核心注解和功能"><a href="#10-springboot核心注解和功能" class="headerlink" title="10.springboot核心注解和功能"></a>10.springboot核心注解和功能</h4><p>1、@SpringBootApplication<br>这是 Spring Boot 最最最核心的注解，用在 Spring Boot 主类上，标识这是一个 Spring Boot 应用，用来开启 Spring Boot 的各项能力。<br>其实这个注解就是@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan这三个注解的组合，也可以用这三个注解来代替 @SpringBootApplication 注解。<br>2、@EnableAutoConfiguration<br>允许 Spring Boot 自动配置注解，开启这个注解之后，Spring Boot 就能根据当前类路径下的包或者类来配置 Spring Bean。<br>如：当前类路径下有 Mybatis 这个 JAR 包，MybatisAutoConfiguration 注解就能根据相关参数来配置 Mybatis 的各个 Spring Bean。<br>3、@Configuration<br>这是 Spring 3.0 添加的一个注解，用来代替 applicationContext.xml 配置文件，所有这个配置文件里面能做到的事情都可以通过这个注解所在类来进行注册。<br>4、@SpringBootConfiguration<br>这个注解就是 @Configuration 注解的变体，只是用来修饰是 Spring Boot 配置而已，或者可利于 Spring Boot 后续的扩展。<br>5、@ComponentScan<br>这是 Spring 3.1 添加的一个注解，用来代替配置文件中的 component-scan 配置，开启组件扫描，即自动扫描包路径下的 @Component 注解进行注册 bean 实例到 context 中。<br>6、@Conditional<br>这是 Spring 4.0 添加的新注解，用来标识一个 Spring Bean 或者 Configuration 配置文件，当满足指定的条件才开启配置。<br>7、@ConditionalOnBean<br>组合 @Conditional 注解，当容器中有指定的 Bean 才开启配置。<br>8、@ConditionalOnMissingBean<br>组合 @Conditional 注解，和 @ConditionalOnBean 注解相反，当容器中没有指定的 Bean 才开启配置。<br>9、@ConditionalOnClass<br>组合 @Conditional 注解，当容器中有指定的 Class 才开启配置。<br>10、@ConditionalOnMissingClass<br>组合 @Conditional 注解，和 @ConditionalOnMissingClass 注解相反，当容器中没有指定的 Class 才开启配置。<br>11、@ConditionalOnWebApplication<br>组合 @Conditional 注解，当前项目类型是 WEB 项目才开启配置。<br>当前项目有以下 3 种类型。<br>enum Type { /** * Any web application will match. <em>/ ANY, /*</em> * Only servlet-based web application will match. <em>/ SERVLET, /*</em> * Only reactive-based web application will match. */ REACTIVE}<br>12、@ConditionalOnNotWebApplication<br>组合 @Conditional 注解，和 @ConditionalOnWebApplication 注解相反，当前项目类型不是 WEB 项目才开启配置。<br>13、@ConditionalOnProperty<br>组合 @Conditional 注解，当指定的属性有指定的值时才开启配置。<br>14、@ConditionalOnExpression<br>组合 @Conditional 注解，当 SpEL 表达式为 true 时才开启配置。<br>15、@ConditionalOnJava<br>组合 @Conditional 注解，当运行的 Java JVM 在指定的版本范围时才开启配置。<br>16、@ConditionalOnResource<br>组合 @Conditional 注解，当类路径下有指定的资源才开启配置。<br>17、@ConditionalOnJndi<br>组合 @Conditional 注解，当指定的 JNDI 存在时才开启配置。<br>18、@ConditionalOnCloudPlatform<br>组合 @Conditional 注解，当指定的云平台激活时才开启配置。<br>19、@ConditionalOnSingleCandidate<br>组合 @Conditional 注解，当指定的 class 在容器中只有一个 Bean，或者同时有多个但为首选时才开启配置。<br>20、@ConfigurationProperties<br>用来加载额外的配置（如 .properties 文件），可用在 @Configuration 注解类，或者@Bean 注解方法上面。<br>21、@EnableConfigurationProperties<br>一般要配合 @ConfigurationProperties 注解使用，用来开启对@ConfigurationProperties 注解配置 Bean 的支持。<br>22、@AutoConfigureAfter<br>用在自动配置类上面，表示该自动配置类需要在另外指定的自动配置类配置完之后。<br>如 Mybatis 的自动配置类，需要在数据源自动配置类之后。<br>@AutoConfigureAfter(DataSourceAutoConfiguration.class)public class MybatisAutoConfiguration {<br>23、@AutoConfigureBefore<br>这个和 @AutoConfigureAfter 注解使用相反，表示该自动配置类需要在另外指定的自动配置类配置之前。<br>24、@Imp面试题ort<br>这是 Spring 3.0 添加的新注解，用来导入一个或者多个 @Configuration 注解修饰的类，这在 Spring Boot 里面应用很多。<br>25、@ImportResource<br>这是 Spring 3.0 添加的新注解，用来导入一个或者多个 Spring 配置文件，这对 Spring Boot 兼容老项目非常有用，因为有些配置无法通过 Java Config 的形式来配置就只能用这个注解来导入。</p>
<h4 id="11-springmvc的核心注解和功能"><a href="#11-springmvc的核心注解和功能" class="headerlink" title="11.springmvc的核心注解和功能"></a>11.springmvc的核心注解和功能</h4><p>1.@Controller注解<br>使用该注解时不需要实现Controller接口。只需要将该注解标注在类上面就表示他是一个控制器了，<br>然后通过spring的扫描机制找到该类就行，&lt;context:component-scan base-package=”包名”&gt;<br>与实现接口相比较，使用注解可以同时处理多个请求，而使用接口一次只能处理一个请求。</p>
<p>2.@RequestMapping注解<br>RequestMapping用于映射一个请求或者一个方法。可以标注在类上，也可以标注在方法上。</p>
<p>3.组合注解<br>@GetMapping:匹配get方式的请求<br>@PostMapping：匹配post方式的请求<br>@PutMapping:匹配put方式的请求<br>@DeleteMapping:匹配Delete方式的请求<br>@PatchMapping：匹配Patch方式的请求</p>
<p>4.@RequestBody注解<br>用于将请求体中的数据绑定到方法的形参中。该注解用在方法的形参上面。<br>也就是将json格式数据映射绑定到形参上。</p>
<p>5.@ResponseBody注解<br>用于直接返回return对象。该注解用在方法上。也就是直接返回json格式数据。</p>
<p>6.@PathVariable注解<br>用于获取url路径中的参数。用在方法的形参上面，也就是形参名和url路径上的参数名对应起来。</p>
<h4 id="12-spring-aop-应用场景和实现思路"><a href="#12-spring-aop-应用场景和实现思路" class="headerlink" title="12.spring aop 应用场景和实现思路"></a>12.spring aop 应用场景和实现思路</h4><p>作用：在不修改源代码的情况下，可以实现功能的增强。</p>
<p>AOP 思想： 基于代理思想，对原来目标对象，创建代理对象，在不修改原对象代码情况下，通过代理对象，调用增强功能的代码，从而对原有业务方法进行增强。</p>
<p>AOP应用场景<br>场景一： 记录日志<br>场景二： 监控方法运行时间 （监控性能）<br>场景三： 权限控制<br>场景四： 缓存优化 （第一次调用查询数据库，将查询结果放入内存对象， 第二次调用， 直接从内存对象返回，不需要查询数据库 ）<br>场景五： 事务管理 （调用方法前开启事务， 调用方法后提交关闭事务 ）</p>
<p>AOP的实现原理<br>那Spring中AOP是怎么实现的呢？Spring中AOP的有两种实现方式：<br>1、JDK动态代理<br>2、Cglib动态代理</p>
<h4 id="13-MySql三大范式"><a href="#13-MySql三大范式" class="headerlink" title="13.MySql三大范式"></a>13.MySql三大范式</h4><p>第一范式</p>
<p>第一范式（1NF）要求数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值。<br>若某一列有多个值，可以将该列单独拆分成一个实体，新实体和原实体间是一对多的关系。<br>在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。</p>
<p>第二范式</p>
<p>满足第二范式（2NF）必须先满足第一范式（1NF）。<br>第二范式要求实体中没一行的所有非主属性都必须完全依赖于主键；即：非主属性必须完全依赖于主键。<br>完全依赖：主键可能由多个属性构成，完全依赖要求不允许存在非主属性依赖于主键中的某一部分属性。<br>若存在哪个非主属性依赖于主键中的一部分属性，那么要将发生部分依赖的这一组属性单独新建一个实体，并且在旧实体中用外键与新实体关联，并且新实体与旧实体间是一对多的关系。</p>
<p>第三范式<br>满足第三范式必须先满足第二范式。<br>第三范式要求：实体中的属性不能是其他实体中的非主属性。因为这样会出现冗余。即：属性不依赖于其他非主属性。<br>如果一个实体中出现其他实体的非主属性，可以将这两个实体用外键关联，而不是将另一张表的非主属性直接写在当前表中。</p>
<h4 id="14-shiro核心组件"><a href="#14-shiro核心组件" class="headerlink" title="14.shiro核心组件"></a>14.shiro核心组件</h4><p>Apache Shiro是一个强大且易用的Java安全框架,执行身份验证、授权、密码和会话管理。使用Shiro的易于理解的API,您可以快速、轻松地获得任何应用程序,从最小的移动应用程序到最大的网络和企业应用程序。</p>
<p>Shiro的核心组件：</p>
<p>Subject：</p>
<p>表示主体，代表了当前用户的安全操作。外部用户与Subject进行交互，Subject记录了当前操作用户。在Shiro中，Subject这一概念并不仅仅指人，也可以是第三方进程、后台帐户（Daemon Account）或其他类似事物。它仅仅意味着“当前跟软件交互的东西”，负责收集用户名和密码等交给SecurityManager。Subject在Shiro中时一个接口，接口中定义了很多认证授权相关的方法，外部程序通过Subject进行认证授权，而Subject通过SecurityManager安全管理器进行认证授权。</p>
<p>SecurityManager：</p>
<p>表示安全管理器，对全部的Subject进行安全管理，它是Shiro框架的核心，典型的Facade模式，Shiro通过SecurityManager来管理内部组件实例，并通过它来提供安全管理的各种服务。通过SecurityManager可以完成Subject的认证、授权等，实质上SecurityManager是通过Authentication进行验证，通过Authorizer进行授权，通过SessionManager进行会话管理。</p>
<p>SecurityManager是一个接口，继承了Authenticator，Authorizer，SessionManger这三个接口。</p>
<p>Realms：</p>
<p>Realm即“领域”，相当于DataSource数据源，充当了Shiro与应用安全数据间的“桥梁”或者“连接器”，SecurityManager进行安全验证时需要通过Realm获取用户权限数据。也就是说，当对用户执行认证（登录）和授权（访问控制）验证时，Shiro会从应用配置的Realm中查找用户及其权限信息。Realm实质上是一个安全相关的DAO：它封装了数据源的连接细节，并在需要时将相关数据提供给Shiro。当配置Shiro时，你必须至少指定一个Realm，用于认证和（或）授权。配置多个Realm是可以的，但是至少需要一个。</p>
<p>Shiro内置了可以连接大量安全数据源（又名目录）的Realm，如LDAP、关系数据库（JDBC）、类似INI的文本配置资源以及属性文件等。如果缺省的Realm不能满足需求，你还可以插入代表自定义数据源的自己的Realm实现。</p>
<h4 id="15-mysql索引"><a href="#15-mysql索引" class="headerlink" title="15.mysql索引"></a>15.mysql索引</h4><p>索引是什么#<br>    索引( index )是帮助MySQL高效获取数据的数据结构。<br>    你可以简单理解为“排好序的快速查找数据结构”。<br>    会影响到where后面的查找和order by后面的排序。</p>
<p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用( 指向 )数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p>
<p>为了加快数据的查找，可以维护一个二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录。</p>
<p>一般来说索引本身也很大，不可能全部存储在内存中，因此往往以索引文件的形式存储到磁盘上。</p>
<p>索引如果没有特别指明，都是指B树(多路搜索树，并不一定是二叉树)结构组织的索引。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引。</p>
<p>索引的基本信息</p>
<p>   索引的分类：</p>
<p>   普通索引：仅加速查询<br>   唯一索引：加速查询 + 列值唯一（可以有null）<br>   主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个<br>   组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并<br>   全文索引：对文本的内容进行分词，进行搜索</p>
<p>   Orace数据库还支持  位图索引( bitmap )。</p>
<pre><code>MySQL支持以下几种类型的索引。
（1）B-Tree索引
（2）哈希索引
（3）空间数据索引（R-Tree）
（4）全文索引
（5）其他索引类别</code></pre><p>索引的优劣势</p>
<p>优势：<br>    1.提高数据检索的效率，降低数据库的IO成本。<br>    2.对数据进行排序，降低排序成本，降低了CPU的消耗。</p>
<p>劣势：<br>    1.索引实际上也是一张表( 保存了主键与索引字段 )，会占用空间。<br>    2.会降低更新的速度，每次操作会调整更新所带来的索引的键值变化。<br>    3.想要建立优秀的索引，会花时间。</p>
<h4 id="16-java-hashmap、ArrayList的底层原理"><a href="#16-java-hashmap、ArrayList的底层原理" class="headerlink" title="16.java hashmap、ArrayList的底层原理"></a>16.java hashmap、ArrayList的底层原理</h4><p>hashmap：</p>
<p>概述： HashMap基于Map接口实现，元素以键值对的方式存储，并且允许使用null 建和null值，因为key不允许重复，因此只能有一个键为null,另外HashMap不能保证放入元素的顺序，它是无序的，和放入的顺序并不能相同。HashMap是线程不安全的。</p>
<p>Note：HashMap的扩容操作是一项很耗时的任务，所以如果能估算Map的容量，最好给它一个默认初始值，避免进行多次扩容。HashMap的线程是不安全的，多线程环境中推荐是ConcurrentHashMap。</p>
<h4 id="17-常被问到的HashMap和Hashtable的区别"><a href="#17-常被问到的HashMap和Hashtable的区别" class="headerlink" title="17.常被问到的HashMap和Hashtable的区别"></a>17.常被问到的HashMap和Hashtable的区别</h4><p>1、线程安全</p>
<p>两者最主要的区别在于Hashtable是线程安全，而HashMap则非线程安全。</p>
<p>Hashtable的实现方法里面都添加了synchronized关键字来确保线程同步，因此相对而言HashMap性能会高一些，我们平时使用时若无特殊需求建议使用HashMap，在多线程环境下若使用HashMap需要使用Collections.synchronizedMap()方法来获取一个线程安全的集合。</p>
<p>Note：</p>
<p>Collections.synchronizedMap()实现原理是Collections定义了一个SynchronizedMap的内部类，这个类实现了Map接口，在调用方法时使用synchronized来保证线程同步,当然了实际上操作的还是我们传入的HashMap实例，简单的说就是Collections.synchronizedMap()方法帮我们在操作HashMap时自动添加了synchronized来实现线程同步，类似的其它Collections.synchronizedXX方法也是类似原理。</p>
<p>2、针对null的不同<br>HashMap可以使用null作为key，而Hashtable则不允许null作为key</p>
<p>3、继承结构<br>HashMap是对Map接口的实现，HashTable实现了Map接口和Dictionary抽象类。</p>
<p>4、初始容量与扩容</p>
<p>HashMap源码中的加载因子<br>static final float DEFAULT_LOAD_FACTOR = 0.75f;</p>
<p>当时想到的是应该是“哈希冲突”和“空间利用率”矛盾的一个折衷。<br>跟数据结构要么查询快要么插入快一个道理，hashmap就是一个插入慢、查询快的数据结构。<br>提高空间利用率和 减少查询成本的折中，主要是泊松分布，0.75的话碰撞最小，</p>
<p>加载因子是表示Hash表中元素的填满的程度。</p>
<p>加载因子越大,填满的元素越多,空间利用率越高，但冲突的机会加大了。<br>反之,加载因子越小,填满的元素越少,冲突的机会减小,但空间浪费多了。<br>冲突的机会越大,则查找的成本越高。反之,查找的成本越小。<br>因此,必须在 “冲突的机会”与”空间利用率”之间寻找一种平衡与折衷。<br>哈希冲突主要与两个因素有关：</p>
<ol>
<li>加载因子，加载因子是指哈希表中已存入的数据元素个数与哈希地址空间的大小的比值，a=n/m ; a越小，冲突的可能性就越小，相反则冲突可能性较大；但是a越小空间利用率也就越小，a越大，空间利用率越高。</li>
<li>与所用的哈希函数有关，如果哈希函数得当，就可以使哈希地址尽可能的均匀分布在哈希地址空间上，从而减少冲突的产生。</li>
</ol>
<p>HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75。</p>
<p>HashMap扩容时是当前容量翻倍即:capacity<em>2，Hashtable扩容时是容量翻倍+1即:capacity</em>2+1。</p>
<p>5、两者计算hash的方法不同</p>
<p>Hashtable计算hash是直接使用key的hashcode对table数组的长度直接进行取模</p>
<p>HashMap计算hash对key的hashcode进行了二次hash，以获得更好的散列值，然后对table数组长度取摸。</p>
<h4 id="18-、HashMap的数据存储结构"><a href="#18-、HashMap的数据存储结构" class="headerlink" title="18.、HashMap的数据存储结构"></a>18.、HashMap的数据存储结构</h4><p>1、HashMap由数组和链表来实现对数据的存储</p>
<p>HashMap采用Entry数组来存储key-value对，每一个键值对组成了一个Entry实体，Entry类实际上是一个单向的链表结构，它具有Next指针，可以连接下一个Entry实体，以此来解决Hash冲突的问题。</p>
<p>数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为O(1)；数组的特点是：寻址容易，插入和删除困难；链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达O（N）。链表的特点是：寻址困难，插入和删除容易。<br>数据结构由数组+链表组成，一个长度为16的数组中，每个元素存储的是一个链表的头结点。那么这些元素是按照什么样的规则存储到数组中呢。<br>一般情况是通过hash(key.hashCode())%len获得，也就是元素的key的哈希值对数组长度取模得到。比如上述哈希表中，12%16=12,28%16=12,108%16=12,140%16=12。所以12、28、108以及140都存储在数组下标为12的位置。</p>
<p>HashMap里面实现一个静态内部类Entry，其重要的属性有 hash，key，value，next。</p>
<p>HashMap里面用到链式数据结构的一个概念。上面我们提到过Entry类里面有一个next属性，作用是指向下一个Entry。打个比方， 第一个键值对A进来，通过计算其key的hash得到的index=0，记做:Entry[0] = A。一会后又进来一个键值对B，通过计算其index也等于0，现在怎么办？HashMap会这样做:B.next = A,Entry[0] = B,如果又进来C,index也等于0,那么C.next = B,Entry[0] = C；这样我们发现index=0的地方其实存取了A,B,C三个键值对,他们通过next这个属性链接在一起。所以疑问不用担心。也就是说数组中存储的是最后插入的元素。到这里为止，HashMap的大致实现，我们应该已经清楚了。</p>
<h4 id="19-如何解决哈希冲突："><a href="#19-如何解决哈希冲突：" class="headerlink" title="19.如何解决哈希冲突："></a>19.如何解决哈希冲突：</h4><p>一、 开放定址法<br>1）线性探查法(Linear Probing)：di=1,2,3,…,m-1<br>　 简单地说就是以当前冲突位置为起点，步长为１循环查找，直到找到一个空的位置就把元素插进去，循环完了都找不到说明容器满了。就像你去一条街上的店里吃饭，问了第一家被告知满座，然后挨着一家家去问是否有位置一样。<br>2）线性补偿探测法：di=Ｑ　下一个位置满足 Hi=(H(key) + Ｑ) mod m i=1,2,…k(k&lt;=m-1) ，要求 Q 与 m 是互质的，以便能探测到哈希表中的所有单元。<br>继续用上面的例子，现在你不是挨着一家家去问了，拿出计算器算了一下，然后隔Ｑ家问一次有没有位置。<br>3）伪随机探测再散列：di=伪随机数序列。还是那个例子，这是完全根据心情去选一家店来问了</p>
<p>缺点：</p>
<blockquote>
<p>这种方法建立起来的hash表当冲突多的时候数据容易堆聚在一起，这时候对查找不友好；<br>    删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点<br>    当空间满了，还要建立一个溢出表来存多出来的元素。</p>
</blockquote>
<p>二、再哈希法<br>同义词产生地址冲突时计算另一个哈希函数地址，直到不发生冲突为止。这种方法不易产生聚集，但是增加了计算时间。<br>缺点：增加了计算时间。</p>
<p>三、建立一个公共溢出区<br>所有关键字和基本表中关键字为同义词的记录，不管他们由哈希函数得到的哈希地址是什么，一旦发生冲突，都填入溢出表。简单地说就是搞个新表存冲突的元素。</p>
<p>四、链地址法（拉链法）<br>将所有关键字为同义词的记录存储在同一线性链表中，也就是把冲突位置的元素构造成链表。<br>拉链法的优点:</p>
<blockquote>
<p>拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；<br>由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；<br>在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。</p>
</blockquote>
<p>拉链法的缺点：</p>
<blockquote>
<p>指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度</p>
</blockquote>
<h4 id="20-HashMap-JDK-1-8的-改变"><a href="#20-HashMap-JDK-1-8的-改变" class="headerlink" title="20.HashMap JDK 1.8的 改变"></a>20.HashMap JDK 1.8的 改变</h4><p>HashMap采用数组+链表+红黑树实现。<br>在Jdk1.8中HashMap的实现方式做了一些改变，但是基本思想还是没有变得，只是在一些地方做了优化，下面来看一下这些改变的地方,数据结构的存储由数组+链表的方式，变化为数组+链表+红黑树的存储方式，当链表长度超过阈值( 8 )时，将链表转换为红黑树。在性能上进一步得到提升。</p>
<p>ArrayList：</p>
<p>ArrayList是基于数组实现的，是一个动态数组，其容量能自动增长，类似于C语言中的动态申请内存，动态增长内存。<br>ArrayList不是线程安全的，只能用在单线程环境下，多线程环境下可以考虑用Collections.synchronizedList(List l)函数返回一个线程安全的ArrayList类，也可以使用concurrent并发包下的CopyOnWriteArrayList类。<br>ArrayList实现了Serializable接口，因此它支持序列化，能够通过序列化传输，实现了RandomAccess接口，支持快速随机访问，实际上就是通过下标序号进行快速访问，实现了Cloneable接口，能被克隆。</p>
<p>每个ArrayList实例都有一个容量，该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向ArrayList中不断添加元素，其容量也自动增长。自动增长会带来数据向新数组的重新拷贝，因此，如果可预知数据量的多少，可在构造ArrayList时指定其容量。在添加大量元素前，应用程序也可以使用ensureCapacity操作来增加ArrayList实例的容量，这可以减少递增式再分配的数量。<br>注意，此实现不是同步的。如果多个线程同时访问一个ArrayList实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。</p>
<p>ArrayList定义只定义类两个私有属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>
<p>很容易理解，elementData存储ArrayList内的元素，size表示它包含的元素的数量。</p>
<p> ArrayList提供了三种方式的构造器，可以构造一个默认初始容量为10的空列表、构造一个指定初始容量的空列表以及构造一个包含指定collection的元素的列表，这些元素按照该collection的迭代器返回它们的顺序排列的。</p>
<p>每当向数组中添加元素时，都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容，以满足添加数据的需求。数组扩容通过一个公开的方法ensureCapacity(int minCapacity)来实现。在实际添加大量元素前，我也可以使用ensureCapacity来手动增加ArrayList实例的容量，以减少递增式再分配的数量。</p>
<p>总结:<br>关于ArrayList的源码，给出几点比较重要的总结：</p>
<blockquote>
<p>1、注意其三个不同的构造方法。无参构造方法构造的ArrayList的容量默认为10，带有Collection参数的构造方法，将Collection转化为数组赋给ArrayList的实现数组elementData。<br>2、注意扩充容量的方法ensureCapacity。ArrayList在每次增加元素（可能是1个，也可能是一组）时，都要调用该方法来确保足够的容量。当容量不足以容纳当前的元素个数时，就设置新的容量为旧的容量的1.5倍加1，如果设置后的新容量还不够，则直接新容量设置为传入的参数（也就是所需的容量），而后用Arrays.copyof()方法将元素拷贝到新的数组（详见下面的第3点）。从中可以看出，当容量不够时，每次增加元素，都要将原来的元素拷贝到一个新的数组中，非常之耗时，也因此建议在事先能确定元素数量的情况下，才使用ArrayList，否则建议使用LinkedList。<br>3、ArrayList的实现中大量地调用了Arrays.copyof()和System.arraycopy()方法。<br>4、ArrayList基于数组实现，可以通过下标索引直接查找到指定位置的元素，因此查找效率高，但每次插入或删除元素，就要大量地移动元素，插入删除元素的效率低。<br>5、在查找给定元素索引值等的方法中，源码都将该元素的值分为null和不为null两种情况处理，ArrayList中允许元素为null。</p>
</blockquote>
<h4 id="21-java中常用的工具类"><a href="#21-java中常用的工具类" class="headerlink" title="21.java中常用的工具类"></a>21.java中常用的工具类</h4><blockquote>
<p><a href="https://www.cnblogs.com/nizuimeiabc1/p/9651094.html" target="_blank" rel="noopener">https://www.cnblogs.com/nizuimeiabc1/p/9651094.html</a></p>
</blockquote>
<h4 id="22-Nginx基本概念"><a href="#22-Nginx基本概念" class="headerlink" title="22.Nginx基本概念"></a>22.Nginx基本概念</h4><p>概念：</p>
<p>Nginx (“engine x”)是一个高性能的HTTP和反向代理服务器,特点是占有内存少，并发能<br>力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx<br>网站用户有:百度、京东、新浪、网易、腾讯、淘宝等。</p>
<p>能做什么：</p>
<p>Nginx作为Web服务器</p>
<p>Nginx可以作为静态页面的web服务器，同时还支持CGI协议的动态语言，比如perl、php<br>等。但是不支持java. Java程序只能通过与tomcat配合完成。Nginx专为性能优化而开发，<br>性能是其最重要的考量,实现上非常注重效率，能经受高负载的考验，有报告表明能支持高<br>达50, 000个并发连接数。</p>
<h4 id="23-springboot如何实现热部署"><a href="#23-springboot如何实现热部署" class="headerlink" title="23.springboot如何实现热部署"></a>23.springboot如何实现热部署</h4><p>1.引入依赖</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.4.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>2.安装插件</p>
<ol start="3">
<li>在你更改了项目内容之后，需要使用Ctrl+F9快捷键来进行项目的部署，（其实这个就是build project的快捷键）。</li>
</ol>
<h4 id="24-jdk1-8新特性"><a href="#24-jdk1-8新特性" class="headerlink" title="24.jdk1.8新特性"></a>24.jdk1.8新特性</h4><p>1.Lambda表达式</p>
<p>2.函数式接口：简单来说就是只定义了一个抽象方法的接口（Object类的public方法除外），就是函数式接口，并且还提供了注解：@FunctionalInterface</p>
<p>3.方法引用和构造器调用</p>
<p>三种表现形式：</p>
<ol>
<li>对象：：实例方法名</li>
<li>类：：静态方法名</li>
<li>类：：实例方法名 （lambda参数列表中第一个参数是实例方法的调用 者，第二个参数是实例方法的参数时可用）</li>
</ol>
<p>4.Stream API</p>
<p>Stream操作的三个步骤<br>创建stream<br>中间操作（过滤、map）<br>终止操作</p>
<p>5.接口中的默认方法和静态方法</p>
<p>在接口中可以使用default和static关键字来修饰接口中定义的普通方法</p>
<p>6.新时间日期API</p>
<p>新的日期API LocalDate | LocalTime | LocalDateTime</p>
<p>21.redis的数据类型</p>
<p>String、Hash、List、Set、SortedSet</p>
<h4 id="25-线程常见问题-东西太多-仅作了解"><a href="#25-线程常见问题-东西太多-仅作了解" class="headerlink" title="25.线程常见问题( 东西太多,仅作了解 )"></a>25.线程常见问题( 东西太多,仅作了解 )</h4><p>并发编程三要素是什么：</p>
<p>原子性：原子，即一个不可再被分割的颗粒。原子性指的是一个或多个操作要么全部执行成功要么全部执行失败。<br>可见性：一个线程对共享变量的修改,另一个线程能够立刻看到。（synchronized,volatile）<br>有序性：程序执行的顺序按照代码的先后顺序执行。（处理器可能会对指令进行重排序）</p>
<p>并行和并发有什么区别：</p>
<p>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。<br>并行：单位时间内，多个处理器或多核处理器同时处理多个任务，是真正意义上的“同时进行”。<br>串行：有n个任务，由一个线程按顺序执行。由于任务、方法都在一个线程执行所以不存在线程不安全情况，也就不存在临界区的问题。</p>
<p>什么是线程死锁 | 如何解决：</p>
<p>死锁是指两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程（线程）称为死锁进程（线程）。</p>
<p>形成死锁的必要条件：</p>
<p>互斥条件：线程(进程)对于所分配到的资源具有排它性，即一个资源只能被一个线程(进程)占用，直到被该线程(进程)释放<br>请求与保持条件：一个线程(进程)因请求被占用资源而发生阻塞时，对已获得的资源保持不放。<br>不剥夺条件：线程(进程)已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。<br>循环等待条件：当发生死锁时，所等待的线程(进程)必定会形成一个环路（类似于死循环），造成永久阻塞</p>
<p>解决方式：<br>我们只要破坏产生死锁的四个条件中的其中一个就可以了。<br>1.破坏互斥条件<br>这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。<br>2.破坏请求与保持条件<br>一次性申请所有的资源。<br>3.破坏不剥夺条件<br>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。<br>4.破坏循环等待条件<br>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p>
<p>创建线程的四种方式：</p>
<p>1.继承 Thread 类<br>2.实现 Runnable 接口<br>3.实现 Callable 接口<br>4.使用 Executors 工具类创建线程池</p>
<p>线程的生命周期：</p>
<blockquote>
<ol>
<li>新建(new)：新创建了一个线程对象。</li>
<li>可运行(runnable)：线程对象创建后，当调用线程对象的 start()方法，该线程处于就绪状态，等待被线程调度选中，获取cpu的使用权。</li>
<li>运行(running)：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。</li>
<li>阻塞(block)：处于运行状态中的线程由于某种原因，暂时放弃对 CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被 CPU 调用以进入到运行状态。</li>
<li>死亡(dead)：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。</li>
</ol>
</blockquote>
<p>什么是线程池：</p>
<p>在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在 Java 中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。</p>
<p>线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。</p>
<p>常用的线程池种类：</p>
<blockquote>
<p>（1）newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。<br>（2）newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。<br>（3） newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60 秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。<br>（4）newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p>
</blockquote>
<h4 id="26-springmvc请求流程"><a href="#26-springmvc请求流程" class="headerlink" title="26.springmvc请求流程"></a>26.springmvc请求流程</h4><p>springMVC请求流程：</p>
<blockquote>
<p>1、用户发送请求至前端控制器DispatcherServlet。<br>2、DispatcherServlet收到请求调用HandlerMapping处理器映射器。<br>3、处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。<br>4、 DispatcherServlet调用HandlerAdapter处理器适配器。<br>5、HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。<br>6、Controller执行完成返回ModelAndView。<br>7、HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。<br>8、DispatcherServlet将ModelAndView传给ViewReslover视图解析器。<br>9、ViewReslover解析后返回具体View.<br>10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。<br>11、DispatcherServlet响应用户。</p>
</blockquote>
<h4 id="27-spring中的常用设计模式"><a href="#27-spring中的常用设计模式" class="headerlink" title="27.spring中的常用设计模式"></a>27.spring中的常用设计模式</h4><p>工厂模式、单例模式、懒汉 | 饿汉模式、适配器、代理、观察者</p>
<h4 id="28-缓存淘汰策略和场景"><a href="#28-缓存淘汰策略和场景" class="headerlink" title="28.缓存淘汰策略和场景"></a>28.缓存淘汰策略和场景</h4><p>当 Redis 内存超出物理内存限制时，内存的数据会开始和磁盘产生频繁的交换 。会让 Redis 的性能急剧下降，对于访问量比较频繁的 Redis 来说，这样存取效率基本上等于不可用。<br>在生产环境中我们是不允许 Redis 出现交换行为的，为了限制最大使用内存，Redis 提供了配置参数 maxmemory 来限制内存超出期望大小。<br>当实际内存超出 maxmemory 时，Redis 提供了几种可选策略 (maxmemory-policy) 来让用户自己决定该如何腾出新的空间以继续提供读写服务。<br>noeviction 不会继续处理写请求 (del,read请求可以继续进行)。这样可以保证不会丢失数据，但是会让线上的写相关的业务不能持续进行。这是默认的淘汰策略。<br>volatile-lru 尝试淘汰设置了过期时间的 key，最少使用的 key 优先被淘汰。没有设置过期时间的 key 不会被淘汰，这样可以保证需要持久化的数据不会突然丢失。<br>volatile-ttl 跟上面一样，除了淘汰的策略不是 LRU，而是 key 的剩余寿命 ttl 的值，ttl 越小越优先被淘汰。<br>volatile-random 跟上面一样，不过淘汰的 key 是过期 key 集合中随机的 key。<br>allkeys-lru 区别于 volatile-lru，这个策略要淘汰的 key 对象是全体的 key 集合，而不只是过期的 key 集合。这意味着没有设置过期时间的 key 也会被淘汰。<br>allkeys-random 跟上面一样，不过淘汰的策略是随机的 key。<br>volatile-xxx 策略只会针对带过期时间的 key 进行淘汰，allkeys-xxx 策略会对所有的 key 进行淘汰。如果你只是拿 Redis 做缓存，那应该使用 allkeys-xxx，客户端写缓存时不必携带过期时间。如果你还想同时使用 Redis 的持久化功能，那就使用 volatile-xxx 策略，这样可以保留没有设置过期时间的 key，它们是永久的 key 不会被 LRU 算法淘汰。</p>
<h4 id="29-springmvc如何实现全局异常"><a href="#29-springmvc如何实现全局异常" class="headerlink" title="29.springmvc如何实现全局异常"></a>29.springmvc如何实现全局异常</h4><blockquote>
<p>（1）使用Spring MVC提供的简单异常处理器SimpleMappingExceptionResolver；<br>（2）实现Spring的异常处理接口HandlerExceptionResolver 自定义自己的异常处理器；<br>（3）使用@ExceptionHandler注解实现异常处理； </p>
</blockquote>
<h4 id="30-springmvc实现拦截器"><a href="#30-springmvc实现拦截器" class="headerlink" title="30.springmvc实现拦截器"></a>30.springmvc实现拦截器</h4><p>   第一种方式是要定义的Interceptor类要实现了Spring的HandlerInterceptor 接口<br>   第二种方式是继承实现了HandlerInterceptor接口的类，比如Spring已经提供的实现了HandlerInterceptor接口的抽象类HandlerInterceptorAdapter</p>
<h4 id="31-mysql的主从复制-读写分离"><a href="#31-mysql的主从复制-读写分离" class="headerlink" title="31.mysql的主从复制( 读写分离 )"></a>31.mysql的主从复制( 读写分离 )</h4><p>MySQL复制过程分成三步:</p>
<blockquote>
<p>1 master将改变记录到二进制日志(binary log) 。这些记录过程叫做二进制日志事件，binary log events;<br>2 slave将master的binary log events拷贝到它的中继日志(relay log) ;<br>3 slave重做中继日志中的事件，将改变应用到自己的数据库中。MySQL复制是异步的且串行化的</p>
</blockquote>
<p>复制的基本原则：</p>
<p>1.每个slave只有一个master<br>2.每个slave只能有一个唯一的服务器ID<br>3.每个master可以有多个slave</p>
<p>如果使用“读写分离”，就需要注意这些问题：</p>
<p>1.数据库连接池要进行区分，哪些是读连接池，哪个是写连接池，研发的难度会增加；<br>2.为了保证高可用，读连接池要能够实现故障自动转移；<br>3.主从的一致性问题需要考虑。</p>
<h4 id="32-数据库锁的机制"><a href="#32-数据库锁的机制" class="headerlink" title="32.数据库锁的机制"></a>32.数据库锁的机制</h4><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。<br>在数据库中，除传统的计算资源(如CPU、RAM、I/O等)的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发<br>访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的-一个重要因素。从这个角度来说<br>锁对数据库而言显得尤其重要，也更加复杂。</p>
<p>打个比方，我们到淘宝上买一件商品，商品只有一件库存，这个时候如果还有另一个人买，<br>那么如何解决是你买到还是另一个人买到的问题?</p>
<p>这里肯定要用到事务，我们先从库存表中取出物品数量，然后插入订单，付款后插入付款表信息，<br>然后更新商品数量。在这个过程中，使用锁可以对有限的资源进行保护，解决隔离和并发的矛盾。</p>
<p>锁的分类：</p>
<p>加锁SQL：lock table表名字read(write)，表名字2 read(write)，其它;<br>释放锁SQL：unlock tables;</p>
<p>一：从对数据操作的类型分为( 读\写 锁 )</p>
<p>1.读锁(共享锁)：针对同一份数据，多个读操作可以同时进行而不会互相影响。</p>
<p>2.写锁( 排他锁 )：当前写操作没有完成前，它会阻断其他写锁和读锁。</p>
<p>二：从对数据操作的粒度分( 表\行 锁 )</p>
<p>表锁 ：偏向MyISAM存储引擎，开销小，加锁快;无死锁;锁定粒度大，发生锁冲突的概率最高,并发度最低( 效率低 )。</p>
<p>行锁：偏向InnoDB存储引擎，开销大，加锁慢;会出现死锁:锁定粒度最小，发生锁冲突的概率最低,并发度也最高( 支持事务 )。</p>
<p>间隙锁：</p>
<p>什么是间隙锁</p>
<p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁;<br>对于键值在条件范围内但并不存在的记录，叫做“间隙(GAP)”,<br>InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁(Next-Key锁) 。</p>
<p>危害：</p>
<p>因为Query执行过程中通过过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值并不存在。<br>间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无<br>法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害</p>
<p>死锁：<br>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。当事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时也可能会产生死锁。锁的行为和顺序和存储引擎相关。以同样的顺序执行语句，有些存储引擎会产生死锁有些不会——死锁有双重原因：真正的数据冲突；存储引擎的实现方式。<br>死锁恢复：死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁，InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。所以事务型应用程序在设计时必须考虑如何处理死锁，多数情况下只需要重新执行因死锁回滚的事务即可。</p>
<p>乐观锁、悲观锁：</p>
<blockquote>
<p>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 乐观锁不能解决脏读的问题。</p>
</blockquote>
<p>乐观锁, 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。</p>
<blockquote>
<p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。</p>
</blockquote>
<p>悲观锁，顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p>
<h4 id="33-实现动态代理的方法"><a href="#33-实现动态代理的方法" class="headerlink" title="33.实现动态代理的方法"></a>33.实现动态代理的方法</h4><p>代理模式</p>
<p>代理(Proxy)是一种设计模式,提供了对目标对象另外的访问方式;即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能.<br>这里使用到编程中的一个思想:不要随意去修改别人已经写好的代码或者方法,如果需改修改,可以通过代理的方式来扩展该方法</p>
<p>举个例子来说明代理的作用:假设我们想邀请一位明星,那么并不是直接连接明星,而是联系明星的经纪人,来达到同样的目的.明星就是一个目标对象,他只要负责活动中的节目,而其他琐碎的事情就交给他的代理人(经纪人)来解决.这就是代理思想在现实中的一个例子</p>
<p>动态代理有以下特点:</p>
<p>1.代理对象,不需要实现接口<br>2.代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)<br>3.动态代理也叫做:JDK代理,接口代理</p>
<p>JDK中生成代理对象的API<br>代理类所在包:java.lang.reflect.Proxy<br>JDK实现代理只需要使用newProxyInstance方法,但是该方法需要接收三个参数。</p>
<p>ClassLoader loader,:指定当前目标对象使用类加载器,获取加载器的方法是固定的<br>Class&lt;?&gt;[] interfaces,:目标对象实现的接口的类型,使用泛型方式确认类型<br>InvocationHandler h:事件处理,执行目标对象的方法时,会触发事件处理器的方法,会把当前执行目标对象的方法作为参数传入</p>
<h4 id="34-springboot的十个核心模块"><a href="#34-springboot的十个核心模块" class="headerlink" title="34.springboot的十个核心模块"></a>34.springboot的十个核心模块</h4><p>Spring Boot 的核心模块</p>
<blockquote>
<p>1、spring-boot  这是Spring Boot 的主模块，也是支持其他模块的核心模块。<br>2、spring-boot-autoconfigure    提供的 @EnableAutoConfiguration 注解就能启用 Spring 功能的自动配置<br>3、spring-boot-starters    启动器<br>4、spring-boot-cli    这是 Spring Boot 的命令行工具，用于编译和运行 Groovy 源程序，可以十分简单的编写并运行一个应用程序。它也能监控你的文件，一旦有变动就会自动重新编译和重新启动应用程序。<br>5、spring-boot-actuator     这是 Spring Boot 提供的执行端点，你可以更好的监控及和你的应用程序交互<br>6、spring-boot-actuator-autoconfigure    这个原理同上，为 Spring Boot 执行端点提供自动配置。<br>7、spring-boot-test  Spring Boot测试模块，为应用测试提供了许多非常有用的核心功能。<br>8、spring-boot-test-autoconfigure    这个原理同上，为Spring Boot 测试模块提供自动配置。<br>9、spring-boot-loader    这个模块可以用来构建一个单独可执行的 jar 包，使用 java -jar 就能直接运行。<br>10、spring-boot-devtools    开发者工具模块。</p>
</blockquote>
<h4 id="35-spring的核心模块"><a href="#35-spring的核心模块" class="headerlink" title="35.spring的核心模块"></a>35.spring的核心模块</h4><p>核心容器( core、beans、context等 )、AOP、Web、数据访问( JPA、tx、orm等 )、text( 单元测试 )</p>
<h4 id="36-Redis常见问题"><a href="#36-Redis常见问题" class="headerlink" title="36.Redis常见问题"></a>36.Redis常见问题</h4><p>缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题<br>一、缓存雪崩我们可以简单的理解为：由于原有缓存失效，新缓存未到期间<br>(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。<br>解决办法：<br>大多数系统设计者考虑用加锁（ 最多的解决方案）或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就时讲缓存失效时间分散开。</p>
<p>二、缓存穿透<br>缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。<br>解决办法;<br>最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。<br>另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。<br>5TB的硬盘上放满了数据，请写一个算法将这些数据进行排重。如果这些数据是一些32bit大小的数据该如何解决？如果是64bit的呢？</p>
<p>对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。<br>Bitmap： 典型的就是哈希表<br>缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了。</p>
<p>布隆过滤器（推荐）<br>就是引入了k(k&gt;1)k(k&gt;1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。<br>它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。<br>Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。<br>Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是Bloom-Filter的基本思想。<br>Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。<br>受提醒补充：缓存穿透与缓存击穿的区别<br>缓存击穿：指一个key非常热点，大并发集中对这个key进行访问，当这个key在失效的瞬间，仍然持续的大并发访问就穿破缓存，转而直接请求数据库。<br>解决方案;在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。</p>
<p>三、缓存预热<br>缓存预热这个应该是一个比较常见的概念，相信很多小伙伴都应该可以很容易的理解，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！<br>解决思路：</p>
<blockquote>
<p>1、直接写个缓存刷新页面，上线时手工操作下；<br>2、数据量不大，可以在项目启动的时候自动进行加载；<br>3、定时刷新缓存；</p>
</blockquote>
<p>四、缓存更新<br>除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p>
<blockquote>
<p>（1）定时去清理过期的缓存；<br>（2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。<br>两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。<br>五、缓存降级<br>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。<br>降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。<br>以参考日志级别设置预案：<br>（1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；<br>（2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；<br>（3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；<br>（4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</p>
</blockquote>
<p>服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。</p>
<h4 id="37-其他问题"><a href="#37-其他问题" class="headerlink" title="37.其他问题"></a>37.其他问题</h4><p>1.项目中哪些地方用到了多线程</p>
<p>2.项目中的难点</p>
<p>3.遇到的BUG</p>
<p>4.你负责的模块</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>综合面试题02</title>
    <url>/myblog/interview/%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%982/</url>
    <content><![CDATA[<p>综合面试题02</p>
<a id="more"></a>
<h4 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h4><p>1、 Java语言有哪些特点</p>
<p>2、面向对象和面向过程的区别</p>
<p>3 、八种基本数据类型的大小，以及他们的封装类</p>
<p>4、标识符的命名规则。</p>
<p>5、instanceof 关键字的作用</p>
<p>6、Java自动装箱与拆箱</p>
<p>7、 重载和重写的区别</p>
<p>8、 equals与==的区别</p>
<p>9、 Hashcode的作用</p>
<p>10、String、String StringBuffer 和 StringBuilder 的区别是什么?</p>
<p>11、ArrayList和linkedList的区别</p>
<p>12、 HashMap和HashTable的区别</p>
<p>13、 Collection包结构，与Collections的区别</p>
<p>14、 Java的四种引用，强弱软虚</p>
<p>15、 泛型常用特点</p>
<p>16、Java创建对象有几种方式？</p>
<p>17、有没有可能两个不相等的对象有相同的hashcode</p>
<p>18、深拷贝和浅拷贝的区别是什么?</p>
<p>19、final有哪些用法?</p>
<p>20、static都有哪些用法?</p>
<p>21、3*0.1==0.3返回值是什么</p>
<p>22、a=a+b与a+=b有什么区别吗?</p>
<p>23、try catch finally，try里有return，finally还执行么？</p>
<p>24、 Excption与Error包结构</p>
<p>25、OOM你遇到过哪些情况，SOF你遇到过哪些情况</p>
<p>26、 简述线程、程序、进程的基本概念。以及他们之间关系是什么?</p>
<p>27、线程有哪些基本状态?</p>
<p>28、Java 序列化中如果有些字段不想进行序列化，怎么办？</p>
<p>29、Java 中 IO 流</p>
<p>30、 Java IO与 NIO的区别</p>
<p>31、java反射的作用于原理</p>
<p>32、说说List,Set,Map三者的区别？<br>2020最新版Java面试宝典详尽讲解</p>
<h4 id="JVM篇"><a href="#JVM篇" class="headerlink" title="JVM篇"></a>JVM篇</h4><p>1、知识点汇总</p>
<p>2、知识点详解：</p>
<p>3、类加载与卸载</p>
<p>4、简述一下JVM的内存模型 - 线程私有区 - 线程共享区</p>
<p>5、堆和栈的区别</p>
<p>6、 什么时候会触发FullGC</p>
<p>7、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？</p>
<p>8、Java内存结构</p>
<p>9、对象分配规则</p>
<p>10、描述一下JVM加载class文件的原理机制？</p>
<p>11、Java对象创建过程</p>
<p>12、类的生命周期</p>
<p>13、简述Java的对象结构</p>
<p>14、如何判断对象可以被回收？</p>
<p>15、JVM的永久代中会发生垃圾回收么？</p>
<p>16、垃圾收集算法</p>
<p>17、调优命令有哪些？</p>
<p>18、调优工具</p>
<p>19、Minor GC与Full GC分别在什么时候发生？</p>
<p>20、你知道哪些JVM性能调优<br>2020最新版Java面试宝典详尽讲解</p>
<h4 id="多线程-amp-并发篇"><a href="#多线程-amp-并发篇" class="headerlink" title="多线程&amp;并发篇"></a>多线程&amp;并发篇</h4><p>1、Java中实现多线程有几种方法</p>
<p>2、如何停止一个正在运行的线程</p>
<p>3、notify()和notifyAll()有什么区别？</p>
<p>4、sleep()和wait() 有什么区别？</p>
<p>5、volatile 是什么?可以保证有序性吗?</p>
<p>6、Thread 类中的start() 和 run() 方法有什么区别？</p>
<p>7、为什么wait, notify 和 notifyAll这些方法不在thread类里面？</p>
<p>8、为什么wait和notify方法要在同步块中调用？</p>
<p>9、Java中interrupted 和 isInterruptedd方法的区别？</p>
<p>10、Java中synchronized 和 ReentrantLock 有什么不同？</p>
<p>11、有三个线程T1,T2,T3,如何保证顺序执行？</p>
<p>12、SynchronizedMap和ConcurrentHashMap有什么区别？</p>
<p>13、什么是线程安全</p>
<p>14、Thread类中的yield方法有什么作用？</p>
<p>15、Java线程池中submit() 和 execute()方法有什么区别？</p>
<p>16、说一说自己对于 synchronized 关键字的了解</p>
<p>17、说说自己是怎么使用 synchronized 关键字，在项目中用到了吗synchronized关键字最主要的三种使用方式：</p>
<p>18、什么是线程安全？Vector是一个线程安全类吗？</p>
<p>19、 volatile关键字的作用？</p>
<p>20、常用的线程池有哪些？</p>
<p>21、简述一下你对线程池的理解</p>
<p>22、Java程序是如何执行的<br>2020最新版Java面试宝典详尽讲解</p>
<h4 id="Spring篇"><a href="#Spring篇" class="headerlink" title="Spring篇"></a>Spring篇</h4><p>1、 Spring的IOC和AOP机制？</p>
<p>2、 Spring中Autowired和Resource关键字的区别？</p>
<p>3、依赖注入的方式有几种，各是什么?</p>
<p>4、讲一下什么是Spring</p>
<p>5、Spring MVC流程</p>
<p>6、SpringMVC怎么样设定重定向和转发的？</p>
<p>7、 SpringMVC常用的注解有哪些？</p>
<p>8、 Spring的AOP理解：</p>
<p>9、Spring的IOC理解</p>
<p>10、解释一下spring bean的生命周期</p>
<p>11、 解释Spring支持的几种bean的作用域。</p>
<p>12、 Spring基于xml注入bean的几种方式：</p>
<p>13、Spring框架中都用到了哪些设计模式？</p>
<h4 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h4><h4 id="MyBatis篇"><a href="#MyBatis篇" class="headerlink" title="MyBatis篇"></a>MyBatis篇</h4><p>1、什么是MyBatis</p>
<p>2、MyBatis的优点和缺点</p>
<p>3、#{}和${}的区别是什么？</p>
<p>4、当实体类中的属性名和表中的字段名不一样 ，怎么办 ？</p>
<p>5、Mybatis是如何进行分页的？分页插件的原理是什么？</p>
<p>6、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</p>
<p>7、 如何执行批量插入？</p>
<p>8、Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？</p>
<p>9、MyBatis实现一对一有几种方式?具体怎么操作的？</p>
<p>10、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</p>
<p>11、Mybatis的一级、二级缓存。</p>
<h4 id="SpringBoot篇"><a href="#SpringBoot篇" class="headerlink" title="SpringBoot篇"></a>SpringBoot篇</h4><p>1、什么是SpringBoot？为什么要用SpringBoot</p>
<p>2、Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</p>
<p>3、运行Spring Boot有哪几种方式？</p>
<p>4、如何理解 Spring Boot 中的 Starters？</p>
<p>5、 如何在Spring Boot启动的时候运行一些特定的代码？</p>
<p>6、 Spring Boot 需要独立的容器运行吗？</p>
<p>7、 Spring Boot中的监视器是什么？</p>
<p>8、 如何使用Spring Boot实现异常处理？</p>
<p>9、 你如何理解 Spring Boot 中的 Starters？</p>
<p>10、 springboot常用的starter有哪些</p>
<p>11、 SpringBoot 实现热部署有哪几种方式？</p>
<p>12、 如何理解 Spring Boot 配置加载顺序？</p>
<p>13、 Spring Boot 的核心配置文件有哪几个？它们的区别是什么？</p>
<p>14、如何集成 Spring Boot 和 ActiveMQ？</p>
<p>15、如何重新加载Spring Boot上的更改，而无需重新启动服务器？</p>
<p>16、 Spring Boot、Spring MVC 和 Spring 有什么区别？</p>
<p>17、 能否举一个例子来解释更多 Staters 的内容？</p>
<p>18、 Spring Boot 还提供了其它的哪些 Starter Project Options？</p>
<h4 id="MySQL篇"><a href="#MySQL篇" class="headerlink" title="MySQL篇"></a>MySQL篇</h4><p>1、数据库的三范式是什么</p>
<p>2、数据库引擎有哪些</p>
<p>3、InnoDB与MyISAM的区别</p>
<p>4、数据库的事务</p>
<p>5、索引问题</p>
<p>6、SQL优化</p>
<p>7、简单说一说drop、delete与truncate的区别</p>
<p>8、什么是视图</p>
<p>9、 什么是内联接、左外联接、右外联接？</p>
<p>10、并发事务带来哪些问题?</p>
<p>11、事务隔离级别有哪些?MySQL的默认隔离级别是?</p>
<p>12、大表如何优化？</p>
<ol>
<li><p>限定数据的范围</p>
</li>
<li><p>读/写分离</p>
</li>
<li><p>垂直分区</p>
</li>
<li><p>水平分区</p>
</li>
</ol>
<p>13、分库分表之后,id 主键如何处理？</p>
<p>14、mysql有关权限的表都有哪几个</p>
<p>15、mysql有哪些数据类型</p>
<p>16、创建索引的三种方式，删除索引</p>
<p>Redis篇</p>
<p>1、Redis持久化机制</p>
<p>2、缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题</p>
<p>3、热点数据和冷数据是什么</p>
<p>4、Memcache与Redis的区别都有哪些？</p>
<p>5、单线程的redis为什么这么快</p>
<p>6、redis的数据类型，以及每种数据类型的使用场景</p>
<p>7、redis的过期策略以及内存淘汰机制</p>
<p>8、Redis 为什么是单线程的</p>
<p>9、Redis 常见性能问题和解决方案？</p>
<p>10、为什么Redis的操作是原子性的，怎么保证原子性的？</p>
<p>11、Redis事务</p>
<p>SpringCloud篇</p>
<p>1、什么是SpringCloud</p>
<p>2、什么是微服务</p>
<p>3、SpringCloud有什么优势</p>
<p>4、 什么是服务熔断？什么是服务降级？</p>
<p>5、 Eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？</p>
<p>6、SpringBoot和SpringCloud的区别？</p>
<p>7、负载平衡的意义什么？</p>
<p>8、什么是Hystrix？它如何实现容错？</p>
<p>9、什么是Hystrix断路器？我们需要它吗？</p>
<p>10、说说 RPC 的实现原理</p>
<p>Nginx篇</p>
<p>1、简述一下什么是Nginx，它有什么优势和功能？</p>
<p>2、Nginx是如何处理一个HTTP请求的呢？</p>
<p>3、列举一些Nginx的特性</p>
<p>4、请列举Nginx和Apache 之间的不同点</p>
<p>5、在Nginx中，如何使用未定义的服务器名称来阻止处理请求？</p>
<p>6、请解释Nginx服务器上的Master和Worker进程分别是什么?</p>
<p>7、请解释代理中的正向代理和反向代理</p>
<p>8、解释Nginx用途</p>
<p>MQ篇</p>
<p>1、为什么使用MQ</p>
<p>2、MQ优缺点</p>
<p>3、Kafka、ActiveMQ、RabbitMQ、RocketMQ 都有什么区别？</p>
<p>4、如何保证高可用的？</p>
<p>5、如何保证消息的可靠传输？如果消息丢了怎么办</p>
<p>6、如何保证消息的顺序性</p>
<p>7、 如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？</p>
<p>8、设计MQ的思路</p>
<p>数据结构与算法篇</p>
<p>1、常用的数据结构 - 1. 数组 - 2. 栈 - 3. 队列 - 4. 链表 - 5. 图 - 6. 树 - 7. 前缀树 - 8. 哈希表</p>
<p>2、 数据里有{1,2,3,4,5,6,7,8,9}，请随机打乱顺序，生成一个新的数组（请以代码实现）</p>
<p>3、 写出代码判断一个整数是不是2的阶次方（请代码实现，谢绝调用API方法）</p>
<p>4、 假设今日是2015年3月1日，星期日，请算出13个月零6天后是星期几，距离现在多少天（请用代码实现，谢绝调用API方法）</p>
<p>5、 有两个篮子，分别为A 和 B，篮子A里装有鸡蛋，篮子B里装有苹果，请用面向对象的思想实现两个篮子里的物品交换（请用代码实现）</p>
<p>6、更多算法练习</p>
<p>Linux篇</p>
<p>1、 绝对路径用什么符号表示？当前目录、上层目录用什么表示？主目录用什么表示? 切换目录用什么命令？</p>
<p>2、 怎么查看当前进程？怎么执行退出？怎么查看当前路径？</p>
<p>3、查看文件有哪些命令</p>
<p>4、列举几个常用的Linux命令</p>
<p>5、你平时是怎么查看日志的？</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员、架构师、技术经理、技术总监和CTO各自职责</title>
    <url>/myblog/talkabout/%E5%91%98%E3%80%81%E6%9E%B6%E6%9E%84%E5%B8%88%E3%80%81%E6%8A%80%E6%9C%AF%E7%BB%8F%E7%90%86%E3%80%81%E6%8A%80%E6%9C%AF%E6%80%BB%E7%9B%91%E5%92%8CCTO%E5%90%84%E8%87%AA%E8%81%8C%E8%B4%A3/</url>
    <content><![CDATA[<h3 id="程序员"><a href="#程序员" class="headerlink" title="程序员"></a>程序员</h3><p>　　程序员，英文名coder/programmer，大家常自嘲叫码农的阶段。这个角色职责是把需求或产品实现为用户可用的软件产品。</p>
<a id="more"></a>
<p>　　此职位为执行级别。另外因为经验较少，一般需要求助别人，或与别人一起完（ban）成（zhuan）一个任务。</p>
<p>　　此阶段大概要经历3年，程序员的职责如下：</p>
<p>　　1、负责公司运营系统的设计与开发工作</p>
<p>　　2、运营数据处理和分析</p>
<h3 id="高级程序员"><a href="#高级程序员" class="headerlink" title="高级程序员"></a>高级程序员</h3><p>　　高级程序员学名工程师。到了这个level，英文名可改叫做engineer或developer。此时你的功力开始增强，这与你平时的积累努力是分不开的，祝贺你～</p>
<p>　　此时的你不仅可以完成任务，开始注重代码的质量，能够写出工业级的代码。</p>
<p>　　你的经验可胜任模块级的系统设计，承担完成较为复杂的技术，能有效的自我管理，有帮助别人快速解决问题（trouble shooting）的能力。</p>
<p>　　此阶段你需要经历到7、8年左右的体验，中间要经历一段深刻自我历练的过程。</p>
<p>　　有时给人致命一击其实是心里的小蟊贼。一般人在5年前后遇到一个门槛，碰到天花板+彷徨期，或者你打心眼里不在喜欢编程，可尝试转为其它角色，如产品经理，售前售后支持等岗位，也不失为好选择。</p>
<p>　　当我们熬过这段儿，就会“山随平野尽，江入大荒流“，渐入佳境矣。</p>
<p>　　高级程序员定义软件功能、做开发计划推进和管理。可以带几个个帮手把产品规划的功能实现，你是团队中的”大手“，遇到难题也是你亲自攻艰克难。</p>
<p>　　所以，一个高级程序员，他的职责很清晰：</p>
<p>　　1、负责产品核心复杂功能的方案设计、编码实现</p>
<p>　　2、负责疑难BUG分析诊断、攻关解决</p>
<h3 id="架构师"><a href="#架构师" class="headerlink" title="架构师"></a>架构师</h3><p>　　到了架构师级别，想必你已经学会降龙十八掌，可登堂入世，成为一位准（lao）专（you）家（tiao）。</p>
<p>　　我们大喊声：“单打独斗，老衲谁也不惧！“，遂开始领导一众技术高手，指点武功，来设计和完成一个系统，大多是分布式，高并发的系统架构平台。</p>
<p>　　架构师的任务是为公司产品的业务问题提供高质量技术解决方案。可能每条产品线都设置了架构师，也可能多条生产品线的的后端是由一个架构师设计的平台提供。</p>
<p>　　通过上面架构师的部分成果，总结其职责如下：</p>
<p>　　1、需求分析：“知彼”有时比“知已”还重要。管理市场，产品等的需求，确立关键需求。坚持技术上的优秀与需求的愿景统一，提升技术负债意识，提供技术选项，风险预判，工期等解决方案。</p>
<p>　　2、架构设计：在产品功能中抽取中非功能的需求，由关键需求变成概念型架构。列出功能树，分层治之，如用户界面层、系统交互层，数据管理层。达成高扩展，高可用，高性能，高安全，易运维，易部署，易接入等能力。</p>
<p>　　3、功能设计与实现：对架构设计的底层代码级别实现。如公共核心类，接口实现，应用发现规则、接口变更等。</p>
<h3 id="技术经理"><a href="#技术经理" class="headerlink" title="技术经理"></a>技术经理</h3><p>　　人生就是不断上升的过程，你已经到达经理的层次了。如今的你，需要不断提高领导力，需要定期召开团队会议讨论问题。</p>
<p>　　首先我们要更加自信，在工作中显示自己的功力，给讲话增添力量。如：“本次项目虽然有很大的困难，我们也需苦战到底。当然示先垂范，身先士卒，方能成功！”</p>
<p>　　技术经理有时候也可能叫系统分析员，一些小公司可能会整个公司或者部门有一个技术经理。技术经理承担的角色主要是系统分析、架构搭建、系统构建、代 码走查等工作，如果说项目经理是总统，那么技术经理就是总理。当然不是所有公司都是这样的，有些公司项目经理是不管技术团队的，只做需求、进度和同客户沟 通，那么这个时候的项目经理就好像工厂里的跟单人员了，这种情况在外包公司比较多。对于技术经理来说，着重于技术方面，你需要知道某种功能用哪些技术合 适，需要知道某项功能需要多长的开发时间等。同时，技术经理也应该承担提高团队整体技术水平的工作。</p>
<p>　　你需要和大家站在一起，因为人们也都有解决问题的能力，更需要有以下的能力与责任：</p>
<p>　　1、任务管理：开发工作量评估、定立开发流程、分配和追踪开发任务</p>
<p>　　2、质量管理：代码review、开发风险判断/报告/协调解决</p>
<p>　　3、效率提升：代码底层研发和培训、最佳代码实践规范总结与推广、自动化生产工具、自动化部署工具</p>
<p>　　4、技术能力提升：招聘面试、试题主拟、新人指导、项目复盘与改进</p>
<h3 id="技术总监"><a href="#技术总监" class="headerlink" title="技术总监"></a>技术总监</h3><p>　　如果一个研发团队超过20人，有多条产品线或业务量很大，这时已经有多个技术经理在负责每个业务，这时需要一位技术总监。</p>
<p>　　技术总监的职责：</p>
<p>　　1、组建平台研发部，与架构师共建软件公共平台，方便各条产品业务线研发。</p>
<p>　　2、通过技术平台、通过高一层的职权，管理和协调公司各个部门与本部门各条线。现在每个产品线都应该有合格的技术经理和高级程序员。</p>
<h3 id="CTO"><a href="#CTO" class="headerlink" title="CTO"></a>CTO</h3><p>　　首席技术官，英文名Chief Technology Officer。是与CEO、COO、CFO同级的领导者，是技术和业务融合的领袖。</p>
<p>　　国内与国外对CTO的定义有些许不同。</p>
<p>　　美国对CTO的职责是设计公司三年内的产品和服务的技术发展方向，较少参与技术团队的日常管理和项目管理事务。基本是前瞻性的策略思维，比如Google的谢尔盖.布林一直保持对技术方向的敏锐，比如无人驾驶汽车，人工智能等走向。</p>
<p>　　在国内，CTO大部分则偏重于研发管理，相当于技术总监的Plus版。它相当于美国互联网公司常设的工程师副总裁+CTO的工作并集。但总体事情比美国的CTO层次低，大部分CTO的是领导技术团队开发各类产品，解决技术问题，管理不同的项目，排期交付。还有一部分的职能类似于架构师或总工程师，作为技术侧的权威，为下一步的发展方向 做研究探讨，为CEO提供建设型决定参考。</p>
<p>　　CTO的职责如下列表：</p>
<p>　　1、技术愿景：识别新技术、利用新技术、整合新技术、驱动新技术。驱动商业战略、驱动产品战略</p>
<p>　　2、技术架构：建立主营业务中的技术架构与实施模式，建立技术体系标准</p>
<p>　　3、流程制度：建立高质量，高效率的技术团队。健全的项目管理体系；完善的员工能力发展体系</p>
<p>　　4、知识培训：建立以研发内容为主的知识库管理体系、技术分享与技术文化的体系</p>
<p>　　5、业务支撑：与其它部门的沟通协作，如HR、市场、BD、财务、客服等提供技术管理接口；在产品技术层面能够领先于业内同行</p>
<p>　　6、影响力：在公司内部与行业中具备一定影响力与口碑</p>
<p>　　7、视野&amp;格局&amp;执行力：看待问题全面，具有强大的学习力，具备技术前瞻力，敏锐的市场嗅觉，战略落地的能力</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>　　CTO做的事情，是商业、产品、技术、管理、团队相平衡的综合统管，公司的技术研发方向与重点商业化的结果负责，激励员工，营造工程师文化。</p>
<p>　　而技术总监主要是协调团队内部各个资源，引入工具，和方法提升工作效率。</p>
<p>　　技术经理角色相对具体，绩效考核，产品落地，执行优胜劣汰的规则。</p>
]]></content>
      <categories>
        <category>talkabout</category>
      </categories>
      <tags>
        <tag>talkabout</tag>
      </tags>
  </entry>
  <entry>
    <title>大型网站一般架构技术</title>
    <url>/myblog/talkabout/%E5%9E%8B%E7%BD%91%E7%AB%99%E4%B8%80%E8%88%AC%E6%9E%B6%E6%9E%84%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h3 id="一、-前端架构"><a href="#一、-前端架构" class="headerlink" title="一、  前端架构"></a>一、  前端架构</h3><p>前端指用户请求到达网站应用服务器之前经历的环节，通常不包含网站业务逻辑，不处理动态内容。</p>
<a id="more"></a>
<p>（1）    浏览器优化技术；</p>
<p>（2）    CDN；</p>
<p>（3）    动静分离，静态资源独立部署；</p>
<p>（4）    图片服务；</p>
<p>（5）    反向代理；</p>
<p>（6）    DNS：域名服务，将域名解析成IP地址，利用DNS可以实现DNS负载均衡，配置CDN也需要修改DNS，使域名解析后指向CDN服务器。</p>
<h3 id="二、-应用层架构"><a href="#二、-应用层架构" class="headerlink" title="二、  应用层架构"></a>二、  应用层架构</h3><p>应用层是处理网站主要业务逻辑的地方</p>
<p>（1）    开发框架；</p>
<p>（2）    页面渲染；</p>
<p>（3）    负载均衡；</p>
<p>（4）    Session管理；</p>
<p>（5）    动态页面静态化；</p>
<p>（6）    业务拆分；</p>
<p>（7）    虚拟化服务器；</p>
<h3 id="三、-服务层架构"><a href="#三、-服务层架构" class="headerlink" title="三、  服务层架构"></a>三、  服务层架构</h3><p>提供基础服务，供应用层调用，完成网站业务。</p>
<p>（1）    分布式消息：利用消息队列机制，实现业务与业务、业务和服务之间的异步消息发送及低耦合的业务关系；</p>
<p>（2）    分布式服务；提供高性能、低耦合、易复用、易管理的分布式服务，在网站实现面向服务架构（SOA）；</p>
<p>（3）    分布式缓存：通过可伸缩的服务器集群提供大规模热点数据的缓存服务，是网站性能优化的重要手段；</p>
<p>（4）    分布式配置；</p>
<h3 id="四、-存储层架构"><a href="#四、-存储层架构" class="headerlink" title="四、  存储层架构"></a>四、  存储层架构</h3><p>提供数据、文件的持久化存储访问与管理服务。</p>
<p>（1）    分布式文件；</p>
<p>（2）    关系数据库；</p>
<p>（3）    NoSQL数据库；</p>
<p>（4）    数据同步；</p>
<h3 id="五、-后台架构"><a href="#五、-后台架构" class="headerlink" title="五、  后台架构"></a>五、  后台架构</h3><p>网站应用中，除了要处理用户的实时访问请求外，还有一些后台非实时数据分析要处理。</p>
<p>（1）    搜索引擎：即使是网站内部的搜索引擎，也需要进行数据增量更新及全量更新、构建索引等。这些操作通过后台系统定时执行；</p>
<p>（2）    数据仓库：根据离线数据，提供数据分析与数据挖掘服务；</p>
<p>（3）    推荐系统：社交网站及购物网站通过挖掘任何人之间的关系，任何商品之间的关系，发觉潜在的人际关系和购物兴趣，为用户提供个性化推荐服务；</p>
<h3 id="六、-数据采集与监控"><a href="#六、-数据采集与监控" class="headerlink" title="六、  数据采集与监控"></a>六、  数据采集与监控</h3><p>监控网站访问情况与系统运行情况，为网站运营决策和运维管理提供支持保障。</p>
<p>（1）    浏览器数据采集：通过在网站页面中嵌入JS脚本采集用户浏览器环境与操作记录，分析用户行为；</p>
<p>（2）    服务器业务数据采集：服务器业务数据包括两种，一种是采集在服务端记录的用户请求操作日志；一种是采集应用程序运行期业务数据，比如待处理消息数目等；</p>
<p>（3）    服务器性能数据采集；</p>
<p>（4）    系统监控；</p>
<p>（5）    系统报警；</p>
<h3 id="七、-安全架构"><a href="#七、-安全架构" class="headerlink" title="七、  安全架构"></a>七、  安全架构</h3><p>保护网站免遭攻击及敏感信息泄露。</p>
<p>（1）    Web攻击；</p>
<p>（2）    数据保护；</p>
<h3 id="八、-数据中心机房架构"><a href="#八、-数据中心机房架构" class="headerlink" title="八、  数据中心机房架构"></a>八、  数据中心机房架构</h3><p>大型网站需要的服务器规模数以万计，机房物理架构也需要关注。</p>
<p>（1）    机房架构</p>
<p>（2）    机柜架构</p>
<p>（3）    服务器架构</p>
]]></content>
      <categories>
        <category>talkabout</category>
      </categories>
      <tags>
        <tag>talkabout</tag>
      </tags>
  </entry>
  <entry>
    <title>我的外包经验：印度、中国和菲律宾（译文）</title>
    <url>/myblog/talkabout/%E6%9D%82%E8%B0%88/</url>
    <content><![CDATA[<h1 id="page-title" class="asset-name entry-title">我的外包经验：印度、中国和菲律宾（译文）</h1>
作者： 阮一峰

<p>日期：2020年2月27日</p>
<p>外包在软件业很常见，各种规模的公司都在用，每年要吸纳大量就业。</p><p></p>
<p>但是，外包的曝光量很少，大家似乎都不太关心，很少有人谈论。这导致许多人不了解外包到底是怎么回事。</p>
<a id="more"></a>
<p>本周，我读到 Troy Hunt 在2016年的<a href="https://www.troyhunt.com/offshoring-roulette-lessons-from-outsourcing-to-india-china-and-the-philippines/" target="_blank">一篇旧文</a>，介绍他的外包经验。我觉得，读起来很新鲜，有启发。下面就是节选的译文，插图是我配的。</p><p></p>
<h2>我的外包经验：印度、中国和菲律宾</h2>

<p>作者：Troy Hunt</p>

<p>原文网址：<a href="https://www.troyhunt.com/offshoring-roulette-lessons-from-outsourcing-to-india-china-and-the-philippines/" target="_blank">troyhunt.com</a></p>

<p>1、</p>

<p><img src="https://www.wangbase.com/blogimg/asset/202002/bg2020022506.jpg" alt title></p>

<p>我有很多与亚洲外包供应商合作的经历。这篇文章我想来谈谈，多年来将软件项目外包到印度，中国和菲律宾的经验。</p>

<p>我以前的工作是辉瑞公司的软件架构师，一共干了14年，曾经负责过亚太地区的软件架构。</p>

<p>2、</p>

<p><img src="https://www.wangbase.com/blogimg/asset/202002/bg2020022507.jpg" alt title></p>

<p>辉瑞公司的软件开发策略很简单，就是将所有事情外包。</p>

<p>这是行业的标准做法，我因此跟亚太地区数十个软件供应商合作过，参与了各种各样的项目，范围很广，从简单的产品宣传网站到大型临床研究系统，从移动应用 App 到 POS 机的终端程序。</p>

<p>我对印度、中国和菲律宾的软件外包行业，接触得比较多，感触尤其深，我想讨论对它们的观察。</p>

<p>3、</p>

<p><img src="https://www.wangbase.com/blogimg/asset/202002/bg2020022508.jpg" alt title></p>

<p>辉瑞公司为什么要外包？</p>

<p>原因很简单，因为程序员很贵。你必须花很多钱，雇佣很多人来构建软件产品，无论他们是否在工作，你都需要支付薪水。而且你雇来的程序员不一定懂每个项目所需的特定技能，这意味着你还要雇佣更多的人。</p>

<p>外包就相当于"云程序员"，你可以只在需要的时候去用它，只为所消费的东西付费，因此减轻了自己公司的负担。</p>

<p>4、</p>

<p><img src="https://www.wangbase.com/blogimg/asset/202002/bg2020022509.jpg" alt title></p>

<p>外包一般都选择亚洲，因为其他地方的工资太高。澳大利亚很贵，美国很贵，英国很贵，上图是世界银行的人均收入数据，这三个地区与印度、中国、菲律宾。</p>

<p>以我的经验，前三个国家的外包公司小时工资，比后三个国家贵4到5倍。</p>

<p>5、</p>

<p><img src="https://www.wangbase.com/blogimg/asset/202002/bg2020022510.jpg" alt title></p>

<p>先来看印度。这个国家已经成为离岸外包的代名词，在许多 IT 经理的心中，外包就等于印度。原因有很多。</p>

<ul>
<li>印度当过英国的殖民地，印度人的英语水平很好。</li>
<li>印度拥有超过13亿人口，这意味着它有源源不断的工程师。</li>
<li>印度的外包行业很成熟，外包巨头 Tech Mahindra、Infosys、Wipro 有规范的外包流程，在这个领域进行了大量投资。</li>
</ul>

<p>6、</p>

<p><img src="https://www.wangbase.com/blogimg/asset/202002/bg2020022511.jpg" alt title></p>

<p>印度许多程序员都是通过单项技术的强化培训而大量生产的，往往只懂培训教的非常特定的技术栈。我常常发现，他们只懂软件组件的一个独立部分，而这就是他们要做的全部事情。</p>

<p>这对项目带来的后果就是，最终会导致很多人参与其中。我查看工作量估算，向外包负责人提问："为什么需要这么多人？"。里面会有初级程序员、高级程序员，专门从事 API 开发的人员，负责网站的人员，负责数据库的人员等等。有些项目由于庞大的规模，需要这样做，但即使是很小的项目，也是这个样子。</p>

<p>7、</p>

<p><img src="https://www.wangbase.com/blogimg/asset/202002/bg2020022515.jpg" alt title></p>

<p>印度的另一个问题是流失率，程序员总是在离开。传统的公司忠诚度在印度并不盛行，大多数人在一家外包公司不会超过一两年。程序员总是去其他地方寻求更好的机会，这无可厚非，但是这种流失率意味着项目会产生更多的摩擦。这些并不会出现在你的外包合同中。</p>

<p>我还发现，印度程序员对需求文档要求很高，他们始终要求真正详细的文档。其他地方的程序员也要求需求文档，但在印度这个要求更强烈，细节对印度人来说很重要。很多时候，我们假设软件应该包括的功能，事后发现这些功能被认为是"超出范围"。这可能在全世界任何地方的任何项目中发生，但在印度极为盛行。</p>

<p>最合适外包到印度的项目，我认为最好是一个独立的工作单元，范围有着明确的界定，文档齐全，并且完全遵循印度公司现有的模式。你要知道，那里的程序员接受的是非常具体的事情的训练，并以工厂流水线的心态在开发，你按照他们的模式，那就会走上"快乐之路"。</p>

<p>8、</p>

<p><img src="https://www.wangbase.com/blogimg/asset/202002/bg2020022516.jpg" alt title></p>

<p>接着来谈谈中国。</p>

<p>中国正在快速城市化，越来越多的人口接受高等教育。他们是一个非常精通技术的国家，在这方面不断壮大，从新兴的硬件提供商变成现在占主导地位的厂商，比如华为和联想，也有像阿里巴巴这样的非常强的服务类公司。这些公司如今已经进入了世界舞台。如果您热衷于技术而不关心中国的动态，那么可能会错过未来几十年世界上最重要的技术创新和增长来源。</p>

<p>9、</p>

<p><img src="https://www.wangbase.com/blogimg/asset/202002/bg2020022517.jpg" alt title></p>

<p>对于外国人来说，中国人并不容易合作，主要原因是外语水平。中国的内部市场很大，几乎所有项目都有自己的中文服务，因此中国人接触英语的机会很有限，如果要跟他们清晰的沟通可能是一件很棘手的事情。</p>

<p>这意味着，你几乎总是与实际从事开发的程序员，至少隔了一层。通常会有一个具有一定英语技能的客户经理，你与他联系，他再把你的意思翻译给技术人员。这样的后果就是，当你真正需要进行详细讨论时，没法跟程序员直接沟通。中国程序员会在内部自己商量，你不知道他们在想些什么，并且很多东西在翻译过程中丢失了。</p>

<p>这对代码质量有深刻影响。从功能上讲，代码本身可能还不错，但这是很少或几乎没有英语技能的人编写的代码。高质量软件的要求之一，就是代码本身就是自我记录的文档，这一点很难实现。他们的代码可能无法清晰地描述软件的功能，不仅对作者也对将来维护的人，都很难阅读。</p>

<p>要是你愿意一直跟同一个软件供应商合作，那可能不会成为问题，但如果你收回代码或交给其他人维护，就会遇到严重问题。我的切身体会是，很难评审中国程序员编写的代码。另外，语言障碍对用户界面也有影响，那些编写代码的人由于不太了解英语，编写的​​标签和标题可能会使英语用户不适应，这意味着要进行许多意想不到的（且预算未定）的修订。</p>

<p>10、</p>

<p><img src="https://www.wangbase.com/blogimg/asset/202002/bg2020022518.jpg" alt title></p>

<p>我有一个习惯，一直要求供应商提供工作分解表。如果我要外包一个具有20个功能的应用程序，那么我想知道每个功能要花多少钱。然后，我可以评估，讨论一下每个功能的重要性，是否要通过放弃价值较低的功能来降低成本。</p>

<p>但是在中国，供应商无法提供这种表格，因为他们不是以这种方式核算成本。他们给我的细分，只是有多少个大三和​​大四的学生、项目经理、测试人员参与，他们每个人的花费是多少。在我看来，这根本没用，但我也没办法。</p>

<p>中国的另一个现象，就是工时非常高，他们会投入大量的时间。我很清楚地记得一个案例，中国供应商的报价与澳大利亚的本地供应商相同，而工时却大了一个数量级。</p>

<p>11、</p>

<p><img src="https://www.wangbase.com/blogimg/asset/202002/bg2020022606.jpg" alt title></p>

<p>中国现在变得越来越昂贵，根据我得到的消息，北京程序员的薪水是两位数的涨幅，有报告称，他们的年薪约为25,000美元，而孟买的年薪约为7,000美元。这是一个非常重要的差异。</p>

<p>中国的优势之一（尤其跟印度相比）就是对需求文档的要求不高。中国有一种真正的"可以做"的态度，不管你提什么要求，他们都愿意拿起任何东西去尝试。不过，虽然他们对任何事情都会说"是"，但是实际上的意思很可能是"否"或别的，这里会存在风险。但是总的来说，我发现他们的适应性非常强，这是一大优势。</p>

<p>我更倾向于外包给中国，因为那里更加灵活，限制也更少。不过由于语言障碍，与新的供应商合作期间，涉及的摩擦也更大。</p>

<p>12、</p>

<p><img src="https://www.wangbase.com/blogimg/asset/202002/bg2020022605.jpg" alt title></p>

<p>再来谈谈菲律宾。</p>

<p>我在马尼拉度过了很多时间，可以很自信地说，菲律宾人是你在任何地方所能遇到的最友好的一群人。由于菲律宾当过美国的殖民地，所以当地人的英语水平很出色，英语是菲律宾排名第二的官方语言。你在马尼拉的任何地方，都能毫无问题地被理解，并与当地人进行交流。</p>

<p>近年来，我注意到的一件事是，呼叫中心转移到菲律宾的趋势很明显。以前你打客服电话，是印度人接听，现在每次我打给电信公司，都会与菲律宾人交谈。我认为，这是他们强大的英语能力，友善的性格和新兴的科技行业共同作用的结果。另外，菲律宾的薪水比中国低得多，更接近印度。</p>

<p>13、</p>

<p><img src="https://www.wangbase.com/blogimg/asset/202002/bg2020022607.jpg" alt title></p>

<p>菲律宾是一个贫困的国家，到处都可以看到这一点，特别是在前往机场的路上穿过摇摇欲坠的房屋时。</p>

<p>这对技术领域也产生了影响，我在外包中看到的最明显的一点，就是菲律宾程序员对 PHP 的强烈亲和力。这样说并不是要贬低 PHP，而是 LAMP 技术栈的低成本造成的。辉瑞公司所使用的 Microsoft 技术栈在菲律宾很难找到市场。你随便去一家供应商，他们的默认态度总是"是的，我们将用 PHP 和 MySQL做到你们的需求。 "尽管我们后来确实找到了可以使用 Microsoft 技术栈的供应商，但我始终觉得它们并不受到重视，这让我对他们的技术能力有些担心。</p>

<p>14、</p>

<p><img src="https://www.wangbase.com/blogimg/asset/202002/bg2020022608.jpg" alt title></p>

<p>在成本上，菲律宾肯定比中国低，而且经常比印度低。根据现在的趋势，这种情况大概会保持很长一段时间。</p>

<p>在许多方面，菲律宾是世界上最好的。除了成本，他们还有这个价格的国家中最好的英语技能，友善的性格，以及我在中国观察到的相同的"可以做"的态度。</p>

<p>15、</p>

<p><img src="https://www.wangbase.com/blogimg/asset/202002/bg2020022609.jpg" alt title></p>

<p>最后，谈谈我的外包经验。</p>

<p>首先，外包是一种不稳定的商品，因为程序员是不稳定的，尤其是在印度。我们当时与一家孟买的开发商合作，花了很多时间和金钱培训一个叫做 Avni 的程序员，让她掌握所需的特定技术。这个项目进展顺利，但是有一天，Avni 离开了。我怀疑她要去生孩子了，根据我的经验，这种情况通常会在发生几个月后才通知你。开发商跟我们说不要担心，会给你找另一个 Avni，跟上一个一样！</p>

<p>开发人员不是可以替代的商品。你不能简单地用一个人去替代另一个人，然后期望他们同样地工作。我经常看到外包供应商信誓旦旦地断言，他们能够像更换厨房灯泡那样简单地更换程序员。这是一种危险的不称职的信念，表明对软件开发的实际情况有根本的误解。</p>

<p>16、</p>

<p><img src="https://www.wangbase.com/blogimg/asset/202002/bg2020022610.jpg" alt title></p>

<p>第二点，外包软件的质量，不一定能够在项目交付时看出来。通常要花上数月甚至数年的时间，才能意识到你所承担的"技术债务"的成本。供应商开发完软件，将其移交给客户之后，如果客户以后要添加功能，发现代码难以辨认，将花多少钱才能解决？在软件产品生命周期中，长期的成本通常被忽略，因为人们争先恐后地希望立即节省短期成本。</p>

<p>我从未见过，外包供应商为项目编写任何单元测试！他们没有自动化测试流程，总是用人工测试确保一切正常。开发人员甚至从未听说过自动化测试这种概念，因为编写额外的代码将花费更多的金钱，一切在他们看来理所当然。所以，外包项目的长期可维护性和成本是可怕的。</p>

<p>17、</p>

<p><img src="https://www.wangbase.com/blogimg/asset/202002/bg2020022611.jpg" alt title></p>

<p>第三点，如果想让外包成功，最好采用混合模式。不是"将所有事情外包"，而是"让我们的人与他们的人一起工作，各自做自己最擅长的事情"。</p>

<p>我花了大量时间，到世界各地的外包公司，培训他们的开发人员，跟他们的团队待在一起，交谈要开发的项目。我遇到了各种坏的故事，但也有一些非常积极的经历。</p>

<p>避免依赖外包组织中的个人，比如上文的 Avni，外包行业的人员流动性比一般情况大得多。相反地，应将重点放在让更多人一起参与，如果其中一个离开，你就不会损失太多的项目知识。</p>

<p>还可以多应用一些开发工具，比如代码质量检查工具、构建服务、版本管理等等，让工作过程变得更加可预测。</p>

<p>18、</p>

<p><img src="https://www.wangbase.com/blogimg/asset/202002/bg2020022612.jpg" alt title></p>

<p>第四点，也是最重要的一点，不要把小时费率视为外包成功的指标，不要根据报价的高低选择供应商。</p>

<p>外包给哪个供应商，通常是由公司内部对软件开发了解最少的人决定的。低报价吸引了他们，只考虑了短期成本和交付条件，没有将长期成本（诸如可维护性，可用性以及安全性之类的因素）考虑在内。因为公司的预算和业务目标总是聚焦在短期，难怪那些掌握资金却不了解技术的人做出了不明智的外包决策。</p>

<p>廉价的离岸外包是软件行业的麦当劳。因为需求量很大，外包公司就把软件开发做成了批量生产的产品。但如果你一直吃麦当劳，就不是很好。你最好将外包视为均衡饮食的一部分，做出明智的决定，不要因标价低而盲目选择，不考虑要支付的实际成本。</p>

<p>（完）</p>


<h3>文档信息</h3>
<ul>
<li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">创意共享3.0许可证</a>）</li>
<li>发表日期： <abbr class="published" title="2020-02-27T09:15:27+08:00">2020年2月27日</abbr></li>

</ul>
                                

                            

  <div style="display: inline-block ! important;width: 100%;">

  </div>

<p>留言（35条）</p>
<p>我现在教三年级的儿子学C语言编程，要求他无论是变量命名，还是写注释，全部使用英语，不会的就谷歌翻译，从小严格要求。</p>
        
<span class="vcard author"><a title="https://mp.weixin.qq.com/s/5c7aaokFZ3umLdnypNzQ9A" href="https://mp.weixin.qq.com/s/5c7aaokFZ3umLdnypNzQ9A" target="_blank" rel="nofollow">布莱恩特</a></span>

<p> 说：<br>                </p>
<p></p>
            
        
        <div class="comment-content" id="comment-quote-416445">
            <p>之前在外包工作过，之前在杭州待过一段时间，在qq群上看到一条招聘信息，说深圳坂田有一个岗位非常匹配，问我要不要试试，确实是·非常匹配·，不知道你们听没听说过xamarin？这玩意根本没人做，并非恶意去黑微软的移动快平台框架，招聘网站确实几乎没有啊。</p>

<p><br>
后来才知道我被‘三包’了，客户公司外包项目给大外包公司，大外包再外包一个人头，我太太太难，结果是非常悲剧的，我tm以为能长期做，至少也能做个一年半载，结果把我的小摩托车从杭州物流到深圳，花了860，后来骑了不到2个月，就被深圳交警没收。毕竟三无车辆，没收也是理所当然。</p>

<p>外包合同签了一年，一般都是一年，便于灵活操作。要人再招人，做完再释放，以此循环，毕竟外包公司是中间商赚差价。</p>

<p>后来，没出任何意外，项目按原计划3个月完成，我也不出意外的·被动离职了。</p>

<p>辞职之后，回到老家湖北，已经失业3个月了。</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
<abbr class="published" title="February 27, 2020 10:08 PM">2020年2月27日 22:08</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416445" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用布莱恩特的这条留言" onclick="return CommentQuote('comment-quote-416445','布莱恩特');">引用</a>
</p>
</div>
</div>
    

weston

<p> 说：<br>                </p>
<p></p>
            
        
        <div class="comment-content" id="comment-quote-416447">
            <p>实际上去东南亚的中国人并不是做外包，大部分是去做菠菜的，工资也比国内高一些，但是风险更是高了好几倍。菠菜现在已经演变成，大陆提供技术人员，香港提供资金，台湾提供运维和客服，面向的却是大陆市场，每年造成大量的金钱外流。</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
                   <abbr class="published" title="February 28, 2020  1:13 AM">2020年2月28日 01:13</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416447" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用weston的这条留言" onclick="return CommentQuote('comment-quote-416447','weston');">引用</a>
</p>
</div>
</div>
    

<div id="comment-416449" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
<span class="byline">

<p><span class="vcard author">ww</span></p>
<p> 说：<br>                </p></span></p>
<p>我现在教三年级的儿子学C语言编程，要求他无论是变量命名，还是写注释，全部使用英语，不会的就谷歌翻译，从小严格要求。</p>



<p>母语不是英语这种操作根本没用，因为一些英语专业词汇不是靠Google翻译就能表达的清的。</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
                   <abbr class="published" title="February 28, 2020  9:00 AM">2020年2月28日 09:00</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416449" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用ww的这条留言" onclick="return CommentQuote('comment-quote-416449','ww');">引用</a>
</p>
</div>
</div>
    </div>
</div>
<div id="comment-416455" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
                <span class="byline">
 <span class="vcard author">哼哼哈嘿</span>

<p> 说：<br>                </p></span></p>
<p></p>
            </div>
        </div>
        <div class="comment-content" id="comment-quote-416455">
            <blockquote>
<pre>引用江云的发言：</pre>

<p>印度人的英语真的好难听懂</p>

</blockquote>

<p>但是英美系国家的人反而可以和印度人几乎无障碍的沟通，且信息传达效率高。而东亚国家的英语口音似乎没那么重，但实际沟通起来却令人费解得多。个人认为，英语在中国的普及可能还需要一两代人才能实现，学习英语的确对理解世界大有裨益。</p>
</div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
<abbr class="published" title="February 28, 2020 11:10 AM">2020年2月28日 11:10</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416455" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用哼哼哈嘿的这条留言" onclick="return CommentQuote('comment-quote-416455','哼哼哈嘿');">引用</a>
</p>
</div>
</div>
    </div>
</div>
<div id="comment-416478" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
<span class="byline">
 <span class="vcard author">胡森</span>

<p> 说：<br></p></span></p>
<p></p>
</div>
        </div>
        <div class="comment-content" id="comment-quote-416478">
            <p>涨知识</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
                   <abbr class="published" title="February 28, 2020  3:47 PM">2020年2月28日 15:47</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416478" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用胡森的这条留言" onclick="return CommentQuote('comment-quote-416478','胡森');">引用</a>
</p>
</div>
</div>
    </div>
</div>
<div id="comment-416482" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
<span class="byline">
<span class="vcard author">hei</span>

<p> 说：<br></p></span></p>
<p></p>
 </div>
</div>
<div class="comment-content" id="comment-quote-416482">
            <p>涨知识了</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
<abbr class="published" title="February 28, 2020  4:57 PM">2020年2月28日 16:57</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416482" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用hei的这条留言" onclick="return CommentQuote('comment-quote-416482','hei');">引用</a>
</p>
</div>
</div>
    </div>
</div>
<div id="comment-416486" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
                <span class="byline">
 <span class="vcard author">无畏</span>

<p> 说：<br></p></span></p>
<p></p>
</div>
        </div>
        <div class="comment-content" id="comment-quote-416486">
            <p>能干成事儿的都是有本事的，绝大部分还是像咱们这种在国内发展平平出去也还是个渣渣</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
                   <abbr class="published" title="February 28, 2020  6:26 PM">2020年2月28日 18:26</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416486" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用无畏的这条留言" onclick="return CommentQuote('comment-quote-416486','无畏');">引用</a>
</p>
</div>
</div>
    </div>
</div>
<div id="comment-416495" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
                <span class="byline">
<span class="vcard author"><a title="https://blog.ifuture.pro/" href="https://blog.ifuture.pro/" target="_blank" rel="nofollow">ifuture</a></span>

<p> 说：<br></p></span></p>
<p></p>
            </div>
        </div>
        <div class="comment-content" id="comment-quote-416495">
            <p>其实最应该思考，我们应该怎么改变</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
                   <abbr class="published" title="February 29, 2020 10:55 AM">2020年2月29日 10:55</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416495" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用ifuture的这条留言" onclick="return CommentQuote('comment-quote-416495','ifuture');">引用</a>
</p>
</div>
</div>
    </div>
</div>
<div id="comment-416508" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
                <span class="byline">
<span class="vcard author">lliw</span>

<p> 说：<br>                </p></span></p>
<p></p>
            </div>
        </div>
        <div class="comment-content" id="comment-quote-416508">
            <blockquote>
<pre>引用bluesen的发言：</pre>

<p>我现在教三年级的儿子学C语言编程，要求他无论是变量命名，还是写注释，全部使用英语，不会的就谷歌翻译，从小严格要求。</p>

</blockquote>

<p>你是亲爹吗？</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
                   <abbr class="published" title="February 29, 2020  3:26 PM">2020年2月29日 15:26</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416508" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用lliw的这条留言" onclick="return CommentQuote('comment-quote-416508','lliw');">引用</a>
</p>
</div>
</div>
    </div>
</div>
<div id="comment-416513" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
                <span class="byline">
  <span class="vcard author"><a title="http://attilax" href="http://attilax" target="_blank" rel="nofollow">attilax</a></span>

<p> 说：<br>                </p></span></p>
<p></p>
            </div>
        </div>
        <div class="comment-content" id="comment-quote-416513">
            <blockquote>
<pre>引用lwl的发言：</pre>

<p></p>

<p>那岂不是比国内赚的钱还少？</p>

</blockquote>

<p>你不懂，哈哈，比上海更高赚的。。</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
                   <abbr class="published" title="February 29, 2020  9:01 PM">2020年2月29日 21:01</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416513" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用attilax的这条留言" onclick="return CommentQuote('comment-quote-416513','attilax');">引用</a>
</p>
</div>
</div>
    </div>
</div>
 <div id="comment-416514" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
                <span class="byline">
 <span class="vcard author">两仪院水月</span>

<p> 说：<br> </p></span></p>
<p></p>
            </div>
        </div>
        <div class="comment-content" id="comment-quote-416514">
            <p>正在外包 目前已经开始自动化，且自己就是项目组里的开发</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
                   <abbr class="published" title="February 29, 2020  9:08 PM">2020年2月29日 21:08</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416514" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用两仪院水月的这条留言" onclick="return CommentQuote('comment-quote-416514','两仪院水月');">引用</a>
</p>
</div>
</div>
    </div>
</div>
 <div id="comment-416525" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
                <span class="byline">
 <span class="vcard author"><a title="http://www.wekair.com" href="http://www.wekair.com" target="_blank" rel="nofollow">Kevin</a></span>

<p> 说：<br>                </p></span></p>
<p></p>
            </div>
        </div>
        <div class="comment-content" id="comment-quote-416525">
            <p>深刻地体会到，在不是英语系的国家要把英语学好确实很难。</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
                   <abbr class="published" title="March  2, 2020  9:27 AM">2020年3月 2日 09:27</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416525" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用Kevin的这条留言" onclick="return CommentQuote('comment-quote-416525','Kevin');">引用</a>
</p>
</div>
</div>
    </div>
</div>
<div id="comment-416526" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
                <span class="byline">
 <span class="vcard author"><a title="http://attilax" href="http://attilax" target="_blank" rel="nofollow">attilax</a></span>

<p> 说：<br>                </p></span></p>
<p></p>
            </div>
        </div>
        <div class="comment-content" id="comment-quote-416526">
            <blockquote>
<pre>引用哼哼哈嘿的发言：</pre>

<p></p>

<p>但是英美系国家的人反而可以和印度人几乎无障碍的沟通，且信息传达效率高。而东亚国家的英语口音似乎没那么重，但实际沟通起来却令人费解得多。个人认为，英语在中国的普及可能还需要一两代人才能实现，学习英语的确对理解世界大有裨益。</p>

</blockquote>

<p>没办法，谁让印度人和欧美都是一个种族呢。。。东南亚种族不同，做事方法不同差异大，<br>
</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
                   <abbr class="published" title="March  2, 2020 11:46 AM">2020年3月 2日 11:46</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416526" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用attilax的这条留言" onclick="return CommentQuote('comment-quote-416526','attilax');">引用</a>
</p>
</div>
</div>
    </div>
</div>
<div id="comment-416527" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
                <span class="byline">
 <span class="vcard author"><a title="http://andyron.com" href="http://andyron.com" target="_blank" rel="nofollow">AndyRon</a></span>

<p> 说：<br>                </p></span></p>
<p></p>
            </div>
        </div>
        <div class="comment-content" id="comment-quote-416527">
            <p>"技术债务"  哇，第一次听说</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
                   <abbr class="published" title="March  2, 2020  2:03 PM">2020年3月 2日 14:03</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416527" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用AndyRon的这条留言" onclick="return CommentQuote('comment-quote-416527','AndyRon');">引用</a>
</p>
</div>
</div>
    </div>
</div>
<div id="comment-416543" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
                <span class="byline">
 <span class="vcard author"><a title="http://没有" href="http://没有" target="_blank" rel="nofollow">岑小白</a></span>

<p> 说：<br>                </p></span></p>
<p></p>
            </div>
        </div>
        <div class="comment-content" id="comment-quote-416543">
            <p>“中国的优势之一（尤其跟印度相比）就是对需求文档的要求不高。中国有一种真正的"可以做"的态度，不管你提什么要求，他们都愿意拿起任何东西去尝试。不过，虽然他们对任何事情都会说"是"，但是实际上的意思很可能是"否"或别的，这里会存在风险。但是总的来说，我发现他们的适应性非常强，这是一大优势。”</p>

<p>----</p>

<p>翻译过来就是，操起键盘就能干，能不能成另说。</p>

<p>其实外包在远程工作中特别常见，但是说实话，专干互联网外包项目的公司就悬了，因为互联网项目能做三个月就已经是大项目！</p>

<p>这类项目不仅开发周期短，命也断。无论是短期线上活动还是官网、 APP， 甚至线下物联网项目做个能滚会说的“小机器人”，都是小跑快打，新手一直泡在这样的项目中自然难有技术积累。</p>

<p>再者，因为项目大多是一锤子买卖，少有长期运维或者版本升级迭代一说，所以公司单位时间承接的项目总量起伏特别大，员工会在闲死和忙死中反复切换！人员流动自然大了。</p>

<p>总之，互联网外包项目只适合经验丰富的小团队，不适合新手、菜鸟踩坑，这种项目就是赚快钱。三五个人把技术栈撸齐了，收入还是非常可观的，时间上也相对灵活可控，方便照顾家庭。</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
                   <abbr class="published" title="March  3, 2020 12:12 AM">2020年3月 3日 00:12</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416543" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用岑小白的这条留言" onclick="return CommentQuote('comment-quote-416543','岑小白');">引用</a>
</p>
</div>
</div>
    </div>
</div>
<div id="comment-416548" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
                <span class="byline">
<span class="vcard author">流浪码农</span>

<p> 说：<br>                </p></span></p>
<p></p>
            </div>
        </div>
        <div class="comment-content" id="comment-quote-416548">
            <p>这篇老外的文章写得蛮中肯，站在外国人的观点看中国，确实英语这方面要抓紧，我觉得中国是缺少英语环境，不是缺少能力，我跟外国人交流不用注重语法也能沟通</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
                   <abbr class="published" title="March  3, 2020 12:47 PM">2020年3月 3日 12:47</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416548" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用流浪码农的这条留言" onclick="return CommentQuote('comment-quote-416548','流浪码农');">引用</a>
</p>
</div>
</div>
    </div>
</div>
<div id="comment-416549" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
                <span class="byline">
<span class="vcard author">adc</span>

<p> 说：<br>                </p></span></p>
<p></p>
            </div>
        </div>
        <div class="comment-content" id="comment-quote-416549">
            <p>云程序员。。</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
                   <abbr class="published" title="March  3, 2020  1:48 PM">2020年3月 3日 13:48</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416549" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用adc的这条留言" onclick="return CommentQuote('comment-quote-416549','adc');">引用</a>
</p>
</div>
</div>
    </div>
</div>
<div id="comment-416556" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
                <span class="byline">
<span class="vcard author">Thinker</span>

<p> 说：<br>                </p></span></p>
<p></p>
            </div>
        </div>
        <div class="comment-content" id="comment-quote-416556">
            <blockquote>
<pre>引用daly的发言：</pre>

<p>正在外包工作，表示从未有过单元测试与自动化测试</p>

</blockquote>

<p>确实要做这些要多很多工作量</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
<abbr class="published" title="March  3, 2020  5:18 PM">2020年3月 3日 17:18</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416556" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用Thinker的这条留言" onclick="return CommentQuote('comment-quote-416556','Thinker');">引用</a>
</p>
</div>
</div>
    </div>
</div>
<div id="comment-416692" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
                <span class="byline">
 <span class="vcard author"><a title="http://www.91guangju.com" href="http://www.91guangju.com" target="_blank" rel="nofollow">我要吃肉</a></span>

<p> 说：<br>                </p></span></p>
<p></p>
            </div>
        </div>
        <div class="comment-content" id="comment-quote-416692">
            <p>确实英语环境不一样啊</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
                   <abbr class="published" title="March  8, 2020  6:53 PM">2020年3月 8日 18:53</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416692" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用我要吃肉的这条留言" onclick="return CommentQuote('comment-quote-416692','我要吃肉');">引用</a>
</p>
</div>
</div>
    </div>
</div>
<div id="comment-416693" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
                <span class="byline">
<span class="vcard author"><a title="http://www.91guangju.com" href="http://www.91guangju.com" target="_blank" rel="nofollow">guangju</a></span>

<p> 说：<br>                </p></span></p>
<p></p>
            </div>
        </div>
        <div class="comment-content" id="comment-quote-416693">
            <p>看来以后要加强英语水平了，毕竟有的新技术是英文原版，方便学习和交流啊</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
                   <abbr class="published" title="March  8, 2020  6:55 PM">2020年3月 8日 18:55</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416693" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用guangju的这条留言" onclick="return CommentQuote('comment-quote-416693','guangju');">引用</a>
</p>
</div>
</div>
    </div>
</div>
<div id="comment-416803" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
                <span class="byline">
 <span class="vcard author">Feng</span>

<p> 说：<br>                </p></span></p>
<p></p>
            </div>
        </div>
        <div class="comment-content" id="comment-quote-416803">
            <blockquote>
<pre>引用bluesen的发言：</pre>

<p>我现在教三年级的儿子学C语言编程，要求他无论是变量命名，还是写注释，全部使用英语，不会的就谷歌翻译，从小严格要求。</p>

</blockquote>

<p>大神，膜拜啊！三年级就被你推坑里去了！！</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
                   <abbr class="published" title="March 11, 2020  3:11 PM">2020年3月11日 15:11</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416803" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用Feng的这条留言" onclick="return CommentQuote('comment-quote-416803','Feng');">引用</a>
</p>
</div>
</div>
    </div>
</div>
<div id="comment-416860" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
                <span class="byline">
<span class="vcard author"><a title="http://www.leoseo.cn" href="http://www.leoseo.cn" target="_blank" rel="nofollow">吕民康</a></span>

<p> 说：<br>                </p></span></p>
<p></p>
            </div>
        </div>
        <div class="comment-content" id="comment-quote-416860">
            <blockquote>
<pre>引用bluesen的发言：</pre>

<p>我现在教三年级的儿子学C语言编程，要求他无论是变量命名，还是写注释，全部使用英语，不会的就谷歌翻译，从小严格要求。</p>

</blockquote>

<p>这个。。。你也要看他是不是适合，是不是喜欢编程这个东西吧。这个世界这么大， 孩子的未来是有无限可能性的，他可以靠其他的技能一样生活得很好。</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
                   <abbr class="published" title="March 13, 2020  9:37 PM">2020年3月13日 21:37</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416860" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用吕民康的这条留言" onclick="return CommentQuote('comment-quote-416860','吕民康');">引用</a>
</p>
</div>
</div>
    </div>
</div>
<div id="comment-416905" class="comment">
    <div id="comment-last" class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
                <span class="byline">
 <span class="vcard author">Q</span>

<p> 说：<br>                </p></span></p>
<p></p>
            </div>
        </div>
        <div class="comment-content" id="comment-quote-416905">
            <p>印度约两亿人（约占总人口1/7）说流利英语，这一点比菲律宾好，菲律宾人口才一亿多</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
                   <abbr class="published" title="March 18, 2020 12:14 PM">2020年3月18日 12:14</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416905" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用Q的这条留言" onclick="return CommentQuote('comment-quote-416905','Q');">引用</a>
</p>
</div>
</div>
    </div>
</div>
 </div>

]]></content>
      <categories>
        <category>talkabout</category>
      </categories>
      <tags>
        <tag>talkabout</tag>
      </tags>
  </entry>
  <entry>
    <title>一个简单的拦截器</title>
    <url>/myblog/interceptor/%E7%AE%80%E5%8D%95%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    <content><![CDATA[<h4 id="一个简单的拦截器"><a href="#一个简单的拦截器" class="headerlink" title="一个简单的拦截器"></a>一个简单的拦截器</h4><a id="more"></a>
<h4 id="一、创建一个LoginInterceptor-继承"><a href="#一、创建一个LoginInterceptor-继承" class="headerlink" title="一、创建一个LoginInterceptor 继承"></a>一、创建一个LoginInterceptor 继承</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HandlerInterceptorpackage cn.lxl.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.lxl.utils.RedisUtils;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(LoginInterceptor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">      </span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> RedisUtils redisUtils;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		LOGGER.info(<span class="string">"############进入用户token验证拦截器"</span>);</span><br><span class="line">		String uri = request.getRequestURI().toString();</span><br><span class="line">		LOGGER.info(uri);</span><br><span class="line">		<span class="comment">// 根据名称获取请求头的值</span></span><br><span class="line">		String token = request.getHeader(<span class="string">"Authorization"</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> == token) &#123;</span><br><span class="line">			LOGGER.error(<span class="string">"##########当前用户未登录"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 根据key获取缓存中的val</span></span><br><span class="line">		<span class="keyword">boolean</span> hasKey = redisUtils.exists(token);</span><br><span class="line">		<span class="keyword">if</span> (hasKey == <span class="keyword">false</span>) &#123;</span><br><span class="line">			LOGGER.error(<span class="string">"##########当前用户token在redis中不存在,token:&#123;&#125;"</span> + token);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 根据key获取过期时间</span></span><br><span class="line">		Long expire = redisUtils.getExpire(token);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (expire &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			LOGGER.error(<span class="string">"##########当前用户token已失效,token:&#123;&#125;"</span> + token);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 为当前登录用户重置登录活性</span></span><br><span class="line">		<span class="comment">// 向redis里存入数据和设置缓存时间</span></span><br><span class="line">		redisUtils.set(token, token, <span class="number">1L</span>, TimeUnit.DAYS);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在业务处理器处理请求完成之后，生成视图之前执行</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">			ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在DispatcherServlet完全处理完请求之后被调用，可用于清理资源</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                           , Object handler, Exception ex)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二、在这个类里写判断条件，然后创建一个WebConfigurer 继承 jar包里的WebMvcConfigurer类 引用LoginInterceptor类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lxl.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.lxl.controller.LoginInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfigurer</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> LoginInterceptor loginInterceptor;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这个方法是用来配置静态资源的，比如html，js，css，等等</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 解决跨域请求问题</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">		registry.addMapping(<span class="string">"/**"</span>).allowedOrigins(<span class="string">"*"</span>).allowCredentials(<span class="keyword">true</span>)</span><br><span class="line">				.allowedMethods(<span class="string">"GET"</span>, <span class="string">"POST"</span>, <span class="string">"DELETE"</span>, <span class="string">"PUT"</span>).maxAge(<span class="number">3600</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这个方法用来注册拦截器，我们自己写好的拦截器需要通过这里添加注册才能生效</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// addPathPatterns("/**") 表示拦截所有的请求，</span></span><br><span class="line">		<span class="comment">// excludePathPatterns("/login", "/register") 表示除了登陆与注册之外，因为登陆注册不需要登陆也可以访问</span></span><br><span class="line">		registry.addInterceptor(loginInterceptor).addPathPatterns(<span class="string">"/**"</span>)</span><br><span class="line">				.excludePathPatterns(<span class="string">"/FeedbackService/login/&#123;card&#125;"</span>);</span><br><span class="line">		<span class="comment">/* super.addInterceptors(registry); */</span> <span class="comment">// 较新Spring Boot的版本中这里可以直接去掉，否则会报错</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 众多的拦截器组成了一个拦截器链</span></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 主要方法说明： addPathPatterns 用于添加拦截规则 excludePathPatterns 用户排除拦截</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">// registry.addInterceptor(new FirstInterceptor()).addPathPatterns("/*");</span></span><br><span class="line">		<span class="comment">// 拦截器SecondInterceptor不拦截hello</span></span><br><span class="line">		<span class="comment">// registry.addInterceptor(new</span></span><br><span class="line">		<span class="comment">// LoginInterceptor()).addPathPatterns("/*").excludePathPatterns("/hello");</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面写需要拦截的方法 和 放行的方法 路径</p>
]]></content>
      <categories>
        <category>interceptor</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>interceptor</tag>
      </tags>
  </entry>
  <entry>
    <title>脑裂</title>
    <url>/myblog/spring-cloud/%E8%84%91%E8%A3%82/</url>
    <content><![CDATA[<h3 id="什么是裂脑？"><a href="#什么是裂脑？" class="headerlink" title="什么是裂脑？"></a>什么是裂脑？</h3><a id="more"></a>
<p>当两台高可用服务器在指定的时间内，无法互相检测到对方心跳而各自启动故障转移功能，取得了资源以及服务的所有权，而此时的两台高可用服务器对都还活着并作正常运行，这样就会导致同一个服务在两端同时启动而发生冲突的严重问题，最严重的就是两台主机同时占用一个VIP的地址（类似双端导入概念），当用户写入数据的时候可能会分别写入到两端，这样可能会导致服务器两端的数据不一致或造成数据的丢失，这种情况就称为裂脑，也有的人称之为分区集群或者大脑垂直分隔</p>
<h3 id="脑裂导致的问题"><a href="#脑裂导致的问题" class="headerlink" title="脑裂导致的问题"></a>脑裂导致的问题</h3><ol>
<li><p>引起数据的不完整性：集群中节点（在脑裂期间）同时访问同一共享资源，而且没有机制去协调控制的话，那么就存在数据的不完整性的可能。</p>
</li>
<li><p>服务异常：对外提供的服务出现异常。</p>
</li>
<li><p>发生脑裂，导致互相竞争同一个IP资源，就如同我们局域网内常见的IP地址冲突一样，两个机器就会有一个或者两个不正常，影响用户正常访问服务器。如果是应用在数据库或者是存储服务这种极重要的高可用上，那就导致用户发布的数据间断的写在两台服务器上的恶果，最终数据恢复及困难或者是难已恢复</p>
</li>
</ol>
<h3 id="导致裂脑发生的原因："><a href="#导致裂脑发生的原因：" class="headerlink" title="导致裂脑发生的原因："></a>导致裂脑发生的原因：</h3><p>优先考虑心跳线路上的问题，在可能是心跳服务，软件层面的问题</p>
<p>1）高可用服务器对之间心跳线路故障，导致无法正常的通信。原因比如：</p>
<ol>
<li><p>——心跳线本身就坏了（包括断了，老化）；</p>
</li>
<li><p>-——网卡以及相关驱动坏了,IP配置及冲突问题；</p>
</li>
<li><p>——心跳线间连接的设备故障（交换机的故障或者是网卡的故障）；</p>
</li>
<li><p>——仲裁的服务器出现问题。</p>
</li>
</ol>
<p>2）高可用服务器对上开启了防火墙阻挡了心跳消息的传输；</p>
<p>3）高可用服务器对上的心跳网卡地址等信息配置的不正确，导致发送心跳失败；</p>
<p>4）其他服务配置不当等原因，如心跳的方式不同，心跳广播冲突，软件出现了BUG等。</p>
<h3 id="防止脑裂发生的方法："><a href="#防止脑裂发生的方法：" class="headerlink" title="防止脑裂发生的方法："></a>防止脑裂发生的方法：</h3><p>实际的生产环境中，我们可以从以下几个方面来防止裂脑的发生：</p>
<p>1）同时使用串行电缆和以太网电缆连接，同时用两条心跳线路，这样一条线路坏了，另一个线路还是好的，依然能传送消息（推荐的）</p>
<p>2）检测到裂脑的时候强行的关闭一个心跳节点（需要特殊的节点支持，如stonith，fence），相当于程序上备节点发现心跳线故障，发送关机命令到主节点。</p>
<p>3）多节点集群中，可以通过增加仲裁的机制，确定谁该获得资源，这里面有几个参考的思路：</p>
<ol>
<li><p>——增加一个仲裁机制。例如设置参考的IP，当心跳完全断开的时候，2个节点各自都ping一下参考的IP，不同则表明断点就出现在本段，这样就主动放弃竞争，让能够ping通参考IP的一端去接管服务。</p>
</li>
<li><p>——通过第三方软件仲裁谁该获得资源，这个在阿里有类似的软件应用</p>
</li>
</ol>
<p>4）做好对裂脑的监控报警（如邮件以及手机短信等），在问题发生的时候能够人为的介入到仲裁，降低损失。当然，在实施高可用方案的时候，要根据业务的实际需求确定是否能够容忍这样的损失。对于一般的网站业务，这个损失是可控的（公司使用）</p>
<p>5）启用磁盘锁。正在服务一方锁住共享磁盘，脑裂发生的时候，让对方完全抢不走共享的磁盘资源。但使用锁磁盘也会有一个不小的问题，如果占用共享盘的乙方不主动解锁，另一方就永远得不到共享磁盘。现实中介入服务节点突然死机或者崩溃，另一方就永远不可能执行解锁命令。后备节点也就截关不了共享的资源和应用服务。于是有人在HA中涉及了“智能”锁，正在服务的一方只在发现心跳线全部断开时才启用磁盘锁，平时就不上锁了</p>
<p>6）报警报在服务器接管之前，给人员处理留足够的时间就是1分钟内报警了，但是服务器不接管，而是5分钟之后接管，接管的时间较长。数据不会丢失，但就是会导致用户无法写数据。报警后，不直接自动服务器接管，而是由人员接管。</p>
<h4 id="redis脑裂"><a href="#redis脑裂" class="headerlink" title="redis脑裂"></a>redis脑裂</h4><p>redis的集群脑裂是指因为网络原因，导致redis master节点和redis slave节点和sentinel集群处于不用的网络分区，此时因为sentinel集群无法感知到master的存在所以将slave节点提升为master节点 此时存在两个不同的master节点就像一个大脑分裂成了两个。</p>
<p>集群脑裂问题中，如果客户端还在基于原来的master节点继续写入数据那么新的master节点将无法同步这些数据当网络问题解决后sentinel集群将原先的master节点降为slave节点，此时再从新的master中同步数据将造成大量的数据丢失。</p>
<h4 id="处理方案"><a href="#处理方案" class="headerlink" title="处理方案"></a>处理方案</h4><p>redis的配置文件中存在两个参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">min-slaves-to-write 3</span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一个参数表示连接到master的最少slave数量<br>第二个参数表示slave连接到master的最大延迟时间</p>
</blockquote>
<p>如果连接到master的slave数量小于第一个参数且ping的延迟时间小于等于第二个参数那么master就会拒绝写请求配置了这两个参数后, 如果发生了集群脑裂原先的master节点接收到客户端的写入请求会拒绝就可以减少数据同步之后的数据丢失。</p>
<blockquote>
<p>redis中的异步复制情况下的数据丢失问题也能使用这两个参数</p>
</blockquote>
<h2 id="ZooKeeper脑裂"><a href="#ZooKeeper脑裂" class="headerlink" title="ZooKeeper脑裂"></a>ZooKeeper脑裂</h2><p>在搭建hadoop的HA集群环境后，由于两个namenode的状态不一，当active的namenode由于网络等原因出现假死状态，standby接收不到active的心跳，因此判断active的namenode宕机，但实际上active并没有死亡。</p>
<p>此时standby的namenode就会切换成active的状态，保证服务能够正常使用。若原来的namenode复活，此时在整个集群中就出现2个active状态的namenode，该状态成为脑裂。脑裂现象可能导致这2个namenode争抢资源，从节点不知道该连接哪一台namenode，导致节点的数据不统一，这在企业生产中是不可以容忍的。</p>
<h5 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h5><ol>
<li><p>添加心跳线。</p>
<p>原来两个namenode之间只有一条心跳线路，此时若断开，则接收不到心跳报告，判断对方已经死亡。此时若有2条心跳线路，一条断开，另一条仍然能够接收心跳报告，能保证集群服务正常运行。2条心跳线路同时断开的可能性比1条心跳线路断开的小得多。再有，心跳线路之间也可以HA（高可用），这两条心跳线路之间也可以互相检测，若一条断开，则另一条马上起作用。正常情况下，则不起作用，节约资源。</p>
</li>
<li><p>启用磁盘锁。</p>
<p>由于两个active会争抢资源，导致从节点不知道该连接哪一台namenode，可以使用磁盘锁的形式，保证集群中只能有一台namenode获取磁盘锁，对外提供服务，避免数据错乱的情况发生。但是，也会存在一个问题，若该namenode节点宕机，则不能主动释放锁，那么其他的namenode就永远获取不了共享资源。因此，在HA上使用”智能锁”就成为了必要措施。”智能锁”是指active的namenode检测到了心跳线全部断开时才启动磁盘锁，正常情况下不上锁。保证了假死状态下，仍然只有一台namenode的节点提供服务。</p>
</li>
<li><p>设置仲裁机制</p>
<p>脑裂导致的后果最主要的原因就是从节点不知道该连接哪一台namenode，此时如果有一方来决定谁留下，谁放弃就最好了。因此出现了仲裁机制，比如提供一个参考的IP地址，当出现脑裂现象时，双方接收不到对方的心跳机制，但是能同时ping参考IP，如果有一方ping不通，那么表示该节点网络已经出现问题，则该节点需要自行退出争抢资源的行列，或者更好的方法是直接强制重启，这样能更好的释放曾经占有的共享资源，将服务的提供功能让给功能更全面的namenode节点。</p>
</li>
</ol>
<p>以上的3种方式可以同时使用，这样更能减少集群中脑裂情况的发生。但是还是不能保证完全不出现，如果仲裁机制中2台机器同时宕机，那么此时集群中没有namenode可以使用。此时需要运维人员人工的抢修，或者提供一台新的机器作为namenode，这个时间是不可避免的。</p>
<h4 id="数据库脑裂"><a href="#数据库脑裂" class="headerlink" title="数据库脑裂"></a>数据库脑裂</h4><p>….算了，感觉自己要脑裂了……</p>
<p>希望未来能有更好的解决办法，能彻底杜绝这类情况的发生吧~</p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>脑裂</tag>
      </tags>
  </entry>
  <entry>
    <title>如何设计一个高并发系统</title>
    <url>/myblog/spring-cloud/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h4 id="1、面试题"><a href="#1、面试题" class="headerlink" title="1、面试题"></a>1、面试题</h4><p>如何设计一个高并发系统？</p>
<a id="more"></a>
<h4 id="2、面试官心里分析"><a href="#2、面试官心里分析" class="headerlink" title="2、面试官心里分析"></a>2、面试官心里分析</h4><p>说实话，如果面试官问你这个题目，那么你必须要使出全身吃奶劲了。为啥？因为你没看到现在很多公司招聘的jd里都是说啥，有高并发就经验者优先。</p>
<p>所以如果你确实有真才实学，在互联网公司里干过高并发系统，那你确实拿offer基本如探囊取物，没啥问题。但是如果你要是真是干过高并发系统，面试官绝对绝对不会问这个问题，否则他就不太明智了。</p>
<p>假设你在某知名电商公司干过高并发系统，用户上亿，一天流量几十亿，高峰期并发量上万，甚至是十万。那么人家一定会仔细盘问你的系统架构，你们系统啥架构？怎么部署的？部署了多少台机器？缓存咋用的？MQ咋用的？数据库咋用的？就是深挖你到底是如何抗下高并发的。</p>
<p>因为真正干过高并发的人一定知道，脱离了业务的系统架构都是在纸上谈兵，真正在复杂业务场景而且还高并发的时候，那系统架构一定不是那么简单的，用个redis，用mq就能搞定？当然不是，真实的系统架构搭配上业务之后，会比这种简单的所谓“高并发架构”要复杂很多倍。</p>
<p>如果有面试官问你个问题说，如何设计一个高并发系统？那么不好意思，一定是因为你实际上没干过高并发系统。面试官看你简历就没啥出彩的，感觉就不咋地，所以就会问问你，如何设计一个高并发系统？其实说白了本质就是看看你有没有自己研究过，有没有一定的知识积累。</p>
<p>最好的当然是招聘个真正干过高并发的哥儿们咯，但是这种哥儿们人数稀缺，不好招。所以可能次一点的就是招一个自己研究过的哥儿们，总比招一个啥也不会的哥儿们好吧！</p>
<p>所以这个时候你必须得做一把个人秀了，秀出你所有关于高并发的知识！</p>
<h4 id="3、面试题剖析"><a href="#3、面试题剖析" class="headerlink" title="3、面试题剖析"></a>3、面试题剖析</h4><p>其实所谓的高并发，如果你要理解这个问题呢，其实就得从高并发的根源出发，为啥会有高并发？为啥高并发就很牛逼？</p>
<p>我说的浅显一点，很简单，就是因为刚开始系统都是连接数据库的，但是要知道数据库支撑到每秒并发两三千的时候，基本就快完了。所以才有说，很多公司，刚开始干的时候，技术比较low，结果业务发展太快，有的时候系统扛不住压力就挂了。（你们访问量大约多少？访问量不是很高，为什么还需要使用到这些高并发技术呢？）</p>
<p>当然会挂了，凭什么不挂？你数据库如果瞬间承载每秒5000,8000，甚至上万的并发，一定会宕机，因为比如mysql就压根儿扛不住这么高的并发量。</p>
<p>所以为啥高并发牛逼？就是因为现在用互联网的人越来越多，很多app、网站、系统承载的都是高并发请求，可能高峰期每秒并发量几千，很正常的。如果是什么双十一了之类的，每秒并发几万几十万都有可能。</p>
<p>高并发系统的架构组成.png</p>
<p>那么如此之高的并发量，加上原本就如此之复杂的业务，咋玩儿？真正厉害的，一定是在复杂业务系统里玩儿过高并发架构的人，但是你没有，那么我给你说一下你该怎么回答这个问题：</p>
<p>（1）系统拆分，将一个系统拆分为多个子系统，用分布式来实现。然后每个系统连一个数据库，这样本来就一个库，现在多个数据库，不也可以抗高并发么。</p>
<p>（2）缓存，必须得用缓存。大部分的高并发场景，都是读多写少，那你完全可以在数据库和缓存里都写一份，然后读的时候大量走缓存不就得了。毕竟人家redis轻轻松松单机几万的并发啊。没问题的。所以你可以考虑考虑你的项目里，那些承载主要请求的读场景，怎么用缓存来抗高并发。</p>
<p>（3）MQ，必须得用MQ。可能你还是会出现高并发写的场景，比如说一个业务操作里要频繁搞数据库几十次，增删改增删改，疯了。那高并发绝对搞挂你的系统，你要是用redis来承载写那肯定不行，人家是缓存，数据随时就被LRU了，数据格式还无比简单，没有事务支持。所以该用mysql还得用mysql啊。那你咋办？用MQ吧，大量的写请求灌入MQ里，排队慢慢玩儿，后边系统消费后慢慢写，控制在mysql承载范围之内。所以你得考虑考虑你的项目里，那些承载复杂写业务逻辑的场景里，如何用MQ来异步写，提升并发性。MQ单机抗几万并发也是ok的，这个之前还特意说过。</p>
<p>（4）分库分表，可能到了最后数据库层面还是免不了抗高并发的要求，好吧，那么就将一个数据库拆分为多个库，多个库来抗更高的并发；然后将一个表拆分为多个表，每个表的数据量保持少一点，提高sql跑的性能。</p>
<p>（5）读写分离，这个就是说大部分时候数据库可能也是读多写少，没必要所有请求都集中在一个库上吧，可以搞个主从架构，主库写入，从库读取，搞一个读写分离。读流量太多的时候，还可以加更多的从库。</p>
<p>（6）合理使用数据库Elasticsearch。es是分布式的，可以随便扩容，分布式天然就可以支撑高并发，因为动不动就可以扩容加机器来抗更高的并发。那么一些比较简单的查询、统计类的操作，可以考虑用es来承载，还有一些全文搜索类的操作，也可以考虑用es来承载。对非索引字段的查询</p>
<p> (7) 使用Undertow来替代Tomcat来作为http服务。Undertow在高并发业务场景中，性能要优于Tomcat，并且Undertow在新版本中默认使用持久连接，这将会进一步提高它的并发吞吐能力。</p>
<p>上面的7点，基本就是高并发系统肯定要干的一些事儿，大家可以仔细结合之前讲过的知识考虑一下，到时候你可以系统的把这块阐述一下，然后每个部分要注意哪些问题，之前都讲过了，你都可以阐述阐述，表明你对这块是有点积累的。</p>
<p>说句实话，毕竟真正你厉害的一点，不是在于弄明白一些技术，或者大概知道一个高并发系统应该长什么样？其实实际上在真正的复杂的业务系统里，做高并发要远远比我这个图复杂几十倍到上百倍。你需要考虑，哪些需要分库分表，哪些不需要分库分表，单库单表跟分库分表如何join，哪些数据要放到缓存里去啊，放哪些数据再可以抗掉高并发的请求，你需要完成对一个复杂业务系统的分析之后，然后逐步逐步的加入高并发的系统架构的改造，这个过程是务必复杂的，一旦做过一次，一旦做好了，你在这个市场上就会非常的吃香。</p>
<p>其实大部分公司，真正看重的，不是说你掌握高并发相关的一些基本的架构知识，架构中的一些技术，RocketMQ、Kafka、Redis、Elasticsearch，高并发这一块，次一等的人才。对一个有几十万行代码的复杂的分布式系统，一步一步架构、设计以及实践过高并发架构的人，这个经验是难能可贵的。</p>
<p>参考链接：<a href="https://blog.csdn.net/A_BlacksMoon/article/details/86386705" target="_blank" rel="noopener">https://blog.csdn.net/A_BlacksMoon/article/details/86386705</a></p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>cloud</tag>
        <tag>高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据库面试题</title>
    <url>/myblog/interview/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h4 id="数据库基础知识"><a href="#数据库基础知识" class="headerlink" title="数据库基础知识"></a>数据库基础知识</h4><a id="more"></a>
<h5 id="为什么要使用数据库"><a href="#为什么要使用数据库" class="headerlink" title="为什么要使用数据库"></a>为什么要使用数据库</h5><p><strong>数据保存在内存</strong></p>
<p>优点： 存取速度快</p>
<p>缺点： 数据不能永久保存</p>
<p><strong>数据保存在文件</strong></p>
<p>优点： 数据永久保存</p>
<p>缺点：1）速度比内存操作慢，频繁的IO操作。2）查询数据不方便</p>
<p><strong>数据保存在数据库</strong></p>
<p>1）数据永久保存</p>
<p>2）使用SQL语句，查询方便效率高。</p>
<p>3）管理数据方便</p>
<h5 id="什么是SQL？"><a href="#什么是SQL？" class="headerlink" title="什么是SQL？"></a>什么是SQL？</h5><!--more-->

<p>结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询语言。</p>
<p>作用：用于存取数据、查询、更新和管理关系数据库系统。</p>
<h4 id="什么是MySQL"><a href="#什么是MySQL" class="headerlink" title="什么是MySQL?"></a>什么是MySQL?</h4><p>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。</p>
<h5 id="数据库三大范式是什么"><a href="#数据库三大范式是什么" class="headerlink" title="数据库三大范式是什么"></a>数据库三大范式是什么</h5><p>第一范式：每个列都不可以再拆分。</p>
<p>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</p>
<p>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</p>
<p>在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。</p>
<h5 id="mysql有关权限的表都有哪几个"><a href="#mysql有关权限的表都有哪几个" class="headerlink" title="mysql有关权限的表都有哪几个"></a>mysql有关权限的表都有哪几个</h5><p>MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下面分别介绍一下这些表的结构和内容：</p>
<ul>
<li>user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</li>
<li>db权限表：记录各个帐号在各个数据库上的操作权限。</li>
<li>table_priv权限表：记录数据表级的操作权限。</li>
<li>columns_priv权限表：记录数据列级的操作权限。</li>
<li>host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。</li>
</ul>
<h5 id="MySQL的binlog有有几种录入格式？分别有什么区别？"><a href="#MySQL的binlog有有几种录入格式？分别有什么区别？" class="headerlink" title="MySQL的binlog有有几种录入格式？分别有什么区别？"></a>MySQL的binlog有有几种录入格式？分别有什么区别？</h5><p>有三种格式，statement，row和mixed。</p>
<ul>
<li>statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。</li>
<li>row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。</li>
<li>mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。</li>
</ul>
<p>此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。</p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><h5 id="mysql有哪些数据类型"><a href="#mysql有哪些数据类型" class="headerlink" title="mysql有哪些数据类型"></a>mysql有哪些数据类型</h5><table>
<thead>
<tr>
<th><strong>分类</strong></th>
<th><strong>类型名称</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>整数类型</strong></td>
<td>tinyInt</td>
<td>很小的整数(8位二进制)</td>
</tr>
<tr>
<td></td>
<td>smallint</td>
<td>小的整数(16位二进制)</td>
</tr>
<tr>
<td></td>
<td>mediumint</td>
<td>中等大小的整数(24位二进制)</td>
</tr>
<tr>
<td></td>
<td>int(integer)</td>
<td>普通大小的整数(32位二进制)</td>
</tr>
<tr>
<td><strong>小数类型</strong></td>
<td>float</td>
<td>单精度浮点数</td>
</tr>
<tr>
<td></td>
<td>double</td>
<td>双精度浮点数</td>
</tr>
<tr>
<td></td>
<td>decimal(m,d)</td>
<td>压缩严格的定点数</td>
</tr>
<tr>
<td><strong>日期类型</strong></td>
<td>year</td>
<td>YYYY 1901~2155</td>
</tr>
<tr>
<td></td>
<td>time</td>
<td>HH:MM:SS -838:59:59~838:59:59</td>
</tr>
<tr>
<td></td>
<td>date</td>
<td>YYYY-MM-DD 1000-01-01~9999-12-3</td>
</tr>
<tr>
<td></td>
<td>datetime</td>
<td>YYYY-MM-DD  HH:MM:SS 1000-01-01 00:00:00~ 9999-12-31 23:59:59</td>
</tr>
<tr>
<td></td>
<td>timestamp</td>
<td>YYYY-MM-DD HH:MM:SS   19700101 00:00:01 UTC~2038-01-19 03:14:07UTC</td>
</tr>
<tr>
<td><strong>文本、二进制类型</strong></td>
<td>CHAR(M)</td>
<td>M为0~255之间的整数</td>
</tr>
<tr>
<td></td>
<td>VARCHAR(M)</td>
<td>M为0~65535之间的整数</td>
</tr>
<tr>
<td></td>
<td>TINYBLOB</td>
<td>允许长度0~255字节</td>
</tr>
<tr>
<td></td>
<td>BLOB</td>
<td>允许长度0~65535字节</td>
</tr>
<tr>
<td></td>
<td>MEDIUMBLOB</td>
<td>允许长度0~167772150字节</td>
</tr>
<tr>
<td></td>
<td>LONGBLOB</td>
<td>允许长度0~4294967295字节</td>
</tr>
<tr>
<td></td>
<td>TINYTEXT</td>
<td>允许长度0~255字节</td>
</tr>
<tr>
<td></td>
<td>TEXT</td>
<td>允许长度0~65535字节</td>
</tr>
<tr>
<td></td>
<td>MEDIUMTEXT</td>
<td>允许长度0~167772150字节</td>
</tr>
<tr>
<td></td>
<td>LONGTEXT</td>
<td>允许长度0~4294967295字节</td>
</tr>
<tr>
<td></td>
<td>VARBINARY(M)</td>
<td>允许长度0~M个字节的变长字节字符串</td>
</tr>
<tr>
<td></td>
<td>BINARY(M)</td>
<td>允许长度0~M个字节的定长字节字符串</td>
</tr>
</tbody></table>
<p>1、整数类型，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。<br>长度：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNED ZEROFILL属性配合使用才有意义。<br>例子，假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数据库实际存储数据为00012。</p>
<p>2、实数类型，包括FLOAT、DOUBLE、DECIMAL。<br>DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。<br>而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。<br>计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。</p>
<p>3、字符串类型，包括VARCHAR、CHAR、TEXT、BLOB<br>VARCHAR用于存储可变长字符串，它比定长类型更节省空间。<br>VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2字节表示。<br>VARCHAR存储的内容超出设置的长度时，内容会被截断。<br>CHAR是定长的，根据定义的字符串长度分配足够的空间。<br>CHAR会根据需要使用空格进行填充方便比较。<br>CHAR适合存储很短的字符串，或者所有值都接近同一个长度。<br>CHAR存储的内容超出设置的长度时，内容同样会被截断。</p>
<p>使用策略：<br>对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。<br>对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。<br>使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。<br>尽量避免使用TEXT/BLOB类型，查询时会使用临时表，导致严重的性能开销。</p>
<p>4、枚举类型（ENUM），把不重复的数据存储为一个预定义的集合。<br>有时可以使用ENUM代替常用的字符串类型。<br>ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。<br>ENUM在内部存储时，其实存的是整数。<br>尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。<br>排序是按照内部存储的整数</p>
<p>5、日期和时间类型，尽量使用timestamp，空间效率高于datetime，<br>用整数保存时间戳通常不方便处理。<br>如果需要存储微妙，可以使用bigint存储。<br>看到这里，这道真题是不是就比较容易回答了。</p>
<h4 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h4><h5 id="MySQL存储引擎MyISAM与InnoDB区别"><a href="#MySQL存储引擎MyISAM与InnoDB区别" class="headerlink" title="MySQL存储引擎MyISAM与InnoDB区别"></a>MySQL存储引擎MyISAM与InnoDB区别</h5><p>存储引擎Storage engine：MySQL中的数据、索引以及其他对象是如何存储的，是一套文件系统的实现。</p>
<p>常用的存储引擎有以下：</p>
<ul>
<li>Innodb引擎：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。</li>
<li>MyIASM引擎(原本Mysql的默认引擎)：不提供事务的支持，也不支持行级锁和外键。</li>
<li>MEMORY引擎：所有的数据都在内存中，数据的处理速度快，但是安全性不高。</li>
</ul>
<h5 id="MyISAM与InnoDB区别"><a href="#MyISAM与InnoDB区别" class="headerlink" title="MyISAM与InnoDB区别"></a>MyISAM与InnoDB区别</h5><table>
<thead>
<tr>
<th></th>
<th>MyISAM</th>
<th>Innodb</th>
</tr>
</thead>
<tbody><tr>
<td>存储结构</td>
<td>每张表被存放在三个文件：frm-表格定义、MYD(MYData)-数据文件、MYI(MYIndex)-索引文件</td>
<td>所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB</td>
</tr>
<tr>
<td>存储空间</td>
<td>MyISAM可被压缩，存储空间较小</td>
<td>InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引</td>
</tr>
<tr>
<td>可移植性、备份及恢复</td>
<td>由于MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作</td>
<td>免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了</td>
</tr>
<tr>
<td>文件格式</td>
<td>数据和索引是分别存储的，数据<code>.MYD</code>，索引<code>.MYI</code></td>
<td>数据和索引是集中存储的，<code>.ibd</code></td>
</tr>
<tr>
<td>记录存储顺序</td>
<td>按记录插入顺序保存</td>
<td>按主键大小有序插入</td>
</tr>
<tr>
<td>外键</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>事务</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>锁支持（锁是避免资源争用的一个机制，MySQL锁对用户几乎是透明的）</td>
<td>表级锁定</td>
<td>行级锁定、表级锁定，锁定力度小并发能力高</td>
</tr>
<tr>
<td>SELECT</td>
<td>MyISAM更优</td>
<td></td>
</tr>
<tr>
<td>INSERT、UPDATE、DELETE</td>
<td></td>
<td>InnoDB更优</td>
</tr>
<tr>
<td>select count(*)</td>
<td>myisam更快，因为myisam内部维护了一个计数器，可以直接调取。</td>
<td></td>
</tr>
<tr>
<td>索引的实现方式</td>
<td>B+树索引，myisam 是堆表</td>
<td>B+树索引，Innodb 是索引组织表</td>
</tr>
<tr>
<td>哈希索引</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>全文索引</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<h5 id="MyISAM索引与InnoDB索引的区别？"><a href="#MyISAM索引与InnoDB索引的区别？" class="headerlink" title="MyISAM索引与InnoDB索引的区别？"></a>MyISAM索引与InnoDB索引的区别？</h5><ul>
<li>InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。</li>
<li>InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。</li>
<li>MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。</li>
<li>InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</li>
</ul>
<h4 id="InnoDB引擎的4大特性"><a href="#InnoDB引擎的4大特性" class="headerlink" title="InnoDB引擎的4大特性"></a>InnoDB引擎的4大特性</h4><ul>
<li>插入缓冲（insert buffer)</li>
<li>二次写(double write)</li>
<li>自适应哈希索引(ahi)</li>
<li>预读(read ahead)</li>
</ul>
<p>存储引擎选择</p>
<p>如果没有特别的需求，使用默认的Innodb即可。</p>
<p>MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。</p>
<p>Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如OA自动化办公系统。</p>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><h5 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h5><p>索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。</p>
<p>索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</p>
<p>更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。</p>
<h5 id="索引有哪些优缺点？"><a href="#索引有哪些优缺点？" class="headerlink" title="索引有哪些优缺点？"></a>索引有哪些优缺点？</h5><p>索引的优点</p>
<ul>
<li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li>
</ul>
<p>索引的缺点</p>
<ul>
<li>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；</li>
<li>空间方面：索引需要占物理空间。</li>
</ul>
<h5 id="索引使用场景（重点）"><a href="#索引使用场景（重点）" class="headerlink" title="索引使用场景（重点）"></a>索引使用场景（重点）</h5><p>where</p>
<p><img src="http://zhao.zcycomputer.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8yLzE5LzE2OTA0NTk2ZTFiNTU4YjI.png" alt></p>
<p>上图中，根据id查询记录，因为id字段仅建立了主键索引，因此此SQL执行可选的索引只有主键索引，如果有多个，最终会选一个较优的作为检索的依据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 增加一个没有建立索引的字段</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> innodb1 <span class="keyword">add</span> sex <span class="built_in">char</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">-- 按sex检索时可选的索引为null</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">from</span> innodb1 <span class="keyword">where</span> sex=<span class="string">'男'</span>;</span><br></pre></td></tr></table></figure>

<p><img src="http://zhao.zcycomputer.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8yLzE5LzE2OTA0NTk2Zjk1YTdmOTk.png" alt></p>
<pre><code>可以尝试在一个字段未建立索引时，根据该字段查询的效率，然后对该字段建立索引（alter table 表名 add index(字段名)），同样的SQL执行的效率，你会发现查询效率会有明显的提升（数据量越大越明显）。</code></pre><p>order by</p>
<p>当我们使用order by将查询结果按照某个字段排序时，如果该字段没有建立索引，那么执行计划会将查询出的所有数据使用外部排序（将数据从硬盘分批读取到内存使用内部排序，最后合并排序结果），这个操作是很影响性能的，因为需要将查询涉及到的所有数据从磁盘中读到内存（如果单条数据过大或者数据量过多都会降低效率），更无论读到内存之后的排序了。</p>
<p>但是如果我们对该字段建立索引alter table 表名 add index(字段名)，那么由于索引本身是有序的，因此直接按照索引的顺序和映射关系逐条取出数据即可。而且如果分页的，那么只用取出索引表某个范围内的索引对应的数据，而不用像上述那取出所有数据进行排序再返回某个范围内的数据。（从磁盘取数据是最影响性能的）</p>
<p>join</p>
<pre><code>对join语句匹配关系（on）涉及的字段建立索引能够提高效率</code></pre><p>索引覆盖</p>
<p>如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖。因此我们需要尽可能的在select后<strong>只写必要的查询字段</strong>，以增加索引覆盖的几率。</p>
<p>这里值得注意的是不要想着为每个字段建立索引，因为优先使用索引的优势就在于其体积小。</p>
<h5 id="索引有哪几种类型？"><a href="#索引有哪几种类型？" class="headerlink" title="索引有哪几种类型？"></a>索引有哪几种类型？</h5><p>主键索引: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。</p>
<p>唯一索引: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</p>
<ul>
<li>可以通过 <code>ALTER TABLE table_name ADD UNIQUE (column);</code> 创建唯一索引</li>
<li>可以通过 <code>ALTER TABLE table_name ADD UNIQUE (column1,column2);</code> 创建唯一组合索引</li>
</ul>
<p>普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值。</p>
<ul>
<li>可以通过ALTER TABLE table_name ADD INDEX index_name (column);创建普通索引</li>
<li>可以通过ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);创建组合索引</li>
</ul>
<p><strong>全文索引</strong>： 是目前搜索引擎使用的一种关键技术。</p>
<ul>
<li>可以通过ALTER TABLE table_name ADD FULLTEXT (column);创建全文索引</li>
</ul>
<h5 id="索引的数据结构（b树，hash）"><a href="#索引的数据结构（b树，hash）" class="headerlink" title="索引的数据结构（b树，hash）"></a>索引的数据结构（b树，hash）</h5><p>索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有Hash索引，B+树索引等，而我们经常使用的InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</p>
<p>1）B树索引</p>
<p>mysql通过存储引擎取数据，基本上90%的人用的就是InnoDB了，按照实现方式分，InnoDB的索引类型目前只有两种：BTREE（B树）索引和HASH索引。B树索引是Mysql数据库中使用最频繁的索引类型，基本所有存储引擎都支持BTree索引。通常我们说的索引不出意外指的就是（B树）索引（实际是用B+树实现的，因为在查看表索引时，mysql一律打印BTREE，所以简称为B树索引）</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC85LzI0LzE2NjBjMGYxNGRhY2Y2ZjU?x-oss-process=image/format,png" alt></p>
<p>查询方式：</p>
<p>主键索引区:PI(关联保存的时数据的地址)按主键查询,</p>
<p>普通索引区:si(关联的id的地址,然后再到达上面的地址)。所以按主键查询,速度最快</p>
<p>B+tree性质：</p>
<p>1.）n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。</p>
<p>2.）所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p>
<p>3.）所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</p>
<p>4.）B+ 树中，数据对象的插入和删除仅在叶节点上进行。</p>
<p>5.）B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</p>
<p>2）哈希索引</p>
<p>简要说下，类似于数据结构中简单实现的HASH表（散列表）一样，当我们在mysql中用哈希索引时，主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。当然这只是简略模拟图。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC85LzI0LzE2NjBjMGYxNThhNzZmOTQ?x-oss-process=image/format,png" alt></p>
<h5 id="索引的基本原理"><a href="#索引的基本原理" class="headerlink" title="索引的基本原理"></a>索引的基本原理</h5><p>索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。</p>
<p>索引的原理很简单，就是把无序的数据变成有序的查询</p>
<ol>
<li>把创建了索引的列的内容进行排序</li>
<li>对排序结果生成倒排表</li>
<li>在倒排表内容上拼上数据地址链</li>
<li>在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</li>
</ol>
<h5 id="索引算法有哪些？"><a href="#索引算法有哪些？" class="headerlink" title="索引算法有哪些？"></a>索引算法有哪些？</h5><p>索引算法有 BTree算法和Hash算法</p>
<p><strong>BTree算法</strong></p>
<p>BTree是最常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在=,&gt;,&gt;=,&lt;,&lt;=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量， 例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 只要它的查询条件是一个不以通配符开头的常量</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'jack%'</span>; </span><br><span class="line"><span class="comment">-- 如果一通配符开头，或者没有使用常量，则不会使用索引，例如： </span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%jack'</span>;</span><br></pre></td></tr></table></figure>

<p><strong>Hash算法</strong></p>
<p>Hash Hash索引只能用于对等比较，例如=,&lt;=&gt;（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。</p>
<h4 id="索引设计的原则？"><a href="#索引设计的原则？" class="headerlink" title="索引设计的原则？"></a>索引设计的原则？</h4><ol>
<li>适合索引的列是出现在where子句中的列，或者连接子句中指定的列</li>
<li>基数较小的类，索引效果较差，没有必要在此列建立索引</li>
<li>使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间</li>
<li>不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</li>
</ol>
<h5 id="创建索引的原则（重中之重）"><a href="#创建索引的原则（重中之重）" class="headerlink" title="创建索引的原则（重中之重）"></a>创建索引的原则（重中之重）</h5><p>索引虽好，但也不是无限制的使用，最好符合一下几个原则</p>
<p>1） 最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p>
<p>2）较频繁作为查询条件的字段才去创建索引</p>
<p>3）更新频繁字段不适合创建索引</p>
<p>4）若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)</p>
<p>5）尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p>
<p>6）定义有外键的数据列一定要建立索引。</p>
<p>7）对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</p>
<p>8）对于定义为text、image和bit的数据类型的列不要建立索引。</p>
<h5 id="创建索引的三种方式，删除索引"><a href="#创建索引的三种方式，删除索引" class="headerlink" title="创建索引的三种方式，删除索引"></a>创建索引的三种方式，删除索引</h5><p>第一种方式：在执行CREATE TABLE时创建索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_index2 (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">INT</span> auto_increment PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">	first_name <span class="built_in">VARCHAR</span> (<span class="number">16</span>),</span><br><span class="line">	last_name <span class="built_in">VARCHAR</span> (<span class="number">16</span>),</span><br><span class="line">	id_card <span class="built_in">VARCHAR</span> (<span class="number">18</span>),</span><br><span class="line">	information <span class="built_in">text</span>,</span><br><span class="line">	<span class="keyword">KEY</span> <span class="keyword">name</span> (first_name, last_name),</span><br><span class="line">	FULLTEXT <span class="keyword">KEY</span> (information),</span><br><span class="line">	<span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> (id_card)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>第二种方式：使用ALTER TABLE命令去增加索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name (column_list);</span><br></pre></td></tr></table></figure>

<p>ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。</p>
<p>其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。</p>
<p>索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。</p>
<p>第三种方式：使用CREATE INDEX命令创建</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> table_name (column_list);</span><br></pre></td></tr></table></figure>

<p>CREATE INDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARY KEY索引）</p>
<p>删除索引</p>
<p>根据索引名删除普通索引、唯一索引、全文索引：alter table 表名 drop KEY 索引名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">drop</span> <span class="keyword">KEY</span> <span class="keyword">name</span>;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">drop</span> <span class="keyword">KEY</span> id_card;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">drop</span> <span class="keyword">KEY</span> information;</span><br></pre></td></tr></table></figure>

<p>删除主键索引：alter table 表名 drop primary key（因为主键只有一个）。这里值得注意的是，如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8yLzE5LzE2OTA0NTk2YjIxZTIwOWM?x-oss-process=image/format,png" alt></p>
<p>需要取消自增长再行删除：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index</span><br><span class="line"><span class="comment">-- 重新定义字段</span></span><br><span class="line"><span class="keyword">MODIFY</span> <span class="keyword">id</span> <span class="built_in">int</span>,</span><br><span class="line"><span class="keyword">drop</span> PRIMARY <span class="keyword">KEY</span></span><br></pre></td></tr></table></figure>

<p>但通常不会删除主键，因为设计主键一定与业务逻辑无关。</p>
<h5 id="创建索引时需要注意什么？"><a href="#创建索引时需要注意什么？" class="headerlink" title="创建索引时需要注意什么？"></a>创建索引时需要注意什么？</h5><ul>
<li>非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</li>
<li>取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</li>
<li>索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</li>
</ul>
<h5 id="使用索引查询一定能提高查询的性能吗？为什么"><a href="#使用索引查询一定能提高查询的性能吗？为什么" class="headerlink" title="使用索引查询一定能提高查询的性能吗？为什么"></a>使用索引查询一定能提高查询的性能吗？为什么</h5><p>通常，通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。</p>
<ul>
<li>索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:</li>
<li>基于一个范围的检索，一般查询返回结果集小于表中记录数的30%</li>
<li>基于非唯一性索引的检索</li>
</ul>
<h5 id="百万级别或以上的数据如何删除"><a href="#百万级别或以上的数据如何删除" class="headerlink" title="百万级别或以上的数据如何删除"></a>百万级别或以上的数据如何删除</h5><p>关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。</p>
<ol>
<li>所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</li>
<li>然后删除其中无用数据（此过程需要不到两分钟）</li>
<li>删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</li>
<li>与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</li>
</ol>
<h5 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h5><p>语法：index(field(10))，使用字段值的前10个字符建立索引，默认是使用字段的全部内容建立索引。</p>
<p>前提：前缀的标识度高。比如密码就适合建立前缀索引，因为密码几乎各不相同。</p>
<p>实操的难度：在于前缀截取的长度。</p>
<p>我们可以利用select count(*)/count(distinct left(password,prefixLen));，通过从调整prefixLen的值（从1自增）查看不同前缀长度的一个平均匹配度，接近1时就可以了（表示一个密码的前prefixLen个字符几乎能确定唯一一条记录）<br>什么是最左前缀原则？什么是最左匹配原则</p>
<ul>
<li>顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。</li>
<li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li>
<li>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li>
</ul>
<p>B树和B+树的区别</p>
<ul>
<li><p>在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。</p>
</li>
<li><p>B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC85LzIxLzE2NWZiNjgyZTc1OWNmMTI?x-oss-process=image/format,png" alt></p>
</li>
</ul>
<h5 id="使用B树的好处"><a href="#使用B树的好处" class="headerlink" title="使用B树的好处"></a>使用B树的好处</h5><p>B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。</p>
<h5 id="使用B-树的好处"><a href="#使用B-树的好处" class="headerlink" title="使用B+树的好处"></a>使用B+树的好处</h5><p>由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。 B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间</p>
<h5 id="Hash索引和B-树所有有什么区别或者说优劣呢"><a href="#Hash索引和B-树所有有什么区别或者说优劣呢" class="headerlink" title="Hash索引和B+树所有有什么区别或者说优劣呢?"></a>Hash索引和B+树所有有什么区别或者说优劣呢?</h5><p>首先要知道Hash索引和B+树索引的底层实现原理：</p>
<p>hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据。B+树底层实现是多路平衡查找树。对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。</p>
<p>那么可以看出他们有以下的不同：</p>
<ul>
<li>hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。</li>
</ul>
<p>因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。</p>
<ul>
<li>hash索引不支持使用索引进行排序，原理同上。</li>
<li>hash索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为hash函数的不可预测。AAAA和AAAAB的索引没有相关性。</li>
<li>hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。</li>
<li>hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。</li>
</ul>
<p>因此，在大多数情况下，直接选择B+树索引可以获得稳定且较好的查询速度。而不需要使用hash索引。</p>
<h5 id="数据库为什么使用B-树而不是B树"><a href="#数据库为什么使用B-树而不是B树" class="headerlink" title="数据库为什么使用B+树而不是B树"></a>数据库为什么使用B+树而不是B树</h5><ul>
<li>B树只适合随机检索，而B+树同时支持随机检索和顺序检索；</li>
<li>B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素；</li>
<li>B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。</li>
<li>B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。</li>
<li>增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。</li>
</ul>
<h5 id="B-树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，"><a href="#B-树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，" class="headerlink" title="B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，"></a>B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，</h5><p>在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。 在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。</p>
<p>当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。</p>
<h5 id="什么是聚簇索引？何时使用聚簇索引与非聚簇索引"><a href="#什么是聚簇索引？何时使用聚簇索引与非聚簇索引" class="headerlink" title="什么是聚簇索引？何时使用聚簇索引与非聚簇索引"></a>什么是聚簇索引？何时使用聚簇索引与非聚簇索引</h5><ul>
<li>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</li>
<li>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因</li>
</ul>
<p>澄清一个概念：innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值</p>
<p>何时使用聚簇索引与非聚簇索引</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMDE1NDQ5OS1kNTNhNWNlOWNlY2YyMmYzLnBuZw?x-oss-process=image/format,png" alt></p>
<h5 id="非聚簇索引一定会回表查询吗？"><a href="#非聚簇索引一定会回表查询吗？" class="headerlink" title="非聚簇索引一定会回表查询吗？"></a>非聚簇索引一定会回表查询吗？</h5><p>不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。</p>
<p>举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行select age from employee where age &lt; 20的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。</p>
<h5 id="联合索引是什么？为什么需要注意联合索引中的顺序？"><a href="#联合索引是什么？为什么需要注意联合索引中的顺序？" class="headerlink" title="联合索引是什么？为什么需要注意联合索引中的顺序？"></a>联合索引是什么？为什么需要注意联合索引中的顺序？</h5><p>MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。</p>
<p>具体原因为:</p>
<p>MySQL使用索引时需要索引有序，假设现在建立了”name，age，school”的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。</p>
<p>当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。</p>
<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><h5 id="什么是数据库事务？"><a href="#什么是数据库事务？" class="headerlink" title="什么是数据库事务？"></a>什么是数据库事务？</h5><p>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>
<p>事务最经典也经常被拿出来说例子就是转账了。</p>
<p>假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p>
<h5 id="事物的四大特性-ACID-介绍一下"><a href="#事物的四大特性-ACID-介绍一下" class="headerlink" title="事物的四大特性(ACID)介绍一下?"></a>事物的四大特性(ACID)介绍一下?</h5><p>关系性数据库需要遵循ACID规则，具体内容如下：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC81LzIwLzE2MzdiMDhiOTg2MTk0NTU?x-oss-process=image/format,png" alt></p>
<p>事务的特性</p>
<ol>
<li>原子性： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li>一致性： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>
<li>隔离性： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li>持久性： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ol>
<h5 id="什么是脏读？幻读？不可重复读？"><a href="#什么是脏读？幻读？不可重复读？" class="headerlink" title="什么是脏读？幻读？不可重复读？"></a>什么是脏读？幻读？不可重复读？</h5><ul>
<li>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</li>
<li>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</li>
<li>幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</li>
</ul>
<h5 id="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"><a href="#什么是事务的隔离级别？MySQL的默认隔离级别是什么？" class="headerlink" title="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"></a>什么是事务的隔离级别？MySQL的默认隔离级别是什么？</h5><p>为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻影读</th>
</tr>
</thead>
<tbody><tr>
<td>READ-UNCOMMITTED</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>READ-COMMITTED</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE-READ</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<p>SQL 标准定义了四个隔离级别：</p>
<ul>
<li><strong>READ-UNCOMMITTED(读取未提交)</strong>： 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读。</strong></li>
<li><strong>READ-COMMITTED(读取已提交)</strong>： 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生。</strong></li>
<li><strong>REPEATABLE-READ(可重复读)</strong>： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li>
<li><strong>SERIALIZABLE(可串行化)</strong>： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li>
</ul>
<p>这里需要注意的是：Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别</p>
<p>事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。</p>
<p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED(读取提交内容):，但是你要知道的是InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ（可重读）</strong>并不会有任何性能损失。</p>
<p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到<strong>SERIALIZABLE(可串行化)</strong>隔离级别。</p>
<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><h5 id="对MySQL的锁了解吗"><a href="#对MySQL的锁了解吗" class="headerlink" title="对MySQL的锁了解吗"></a>对MySQL的锁了解吗</h5><p>当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来保证访问的次序，锁机制就是这样的一个机制。</p>
<p>就像酒店的房间，如果大家随意进出，就会出现多人抢夺同一个房间的情况，而在房间上装上锁，申请到钥匙的人才可以入住并且将房间锁起来，其他人只有等他使用完毕才可以再次使用。</p>
<h5 id="隔离级别与锁的关系"><a href="#隔离级别与锁的关系" class="headerlink" title="隔离级别与锁的关系"></a>隔离级别与锁的关系</h5><p>在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突</p>
<p>在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；</p>
<p>在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</p>
<p>SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。</p>
<h5 id="按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法"><a href="#按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法" class="headerlink" title="按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法"></a>按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法</h5><p>在关系型数据库中，可以按照锁的粒度把数据库锁分为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。</p>
<p>MyISAM和InnoDB存储引擎使用的锁：</p>
<ul>
<li>MyISAM采用表级锁(table-level locking)。</li>
<li>InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁</li>
</ul>
<p>行级锁，表级锁和页级锁对比</p>
<p><strong>行级锁</strong> 行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。</p>
<p>特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>
<p><strong>表级锁</strong> 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。</p>
<p>特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</p>
<p><strong>页级锁</strong> 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。</p>
<p>特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p>
<h5 id="从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了"><a href="#从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了" class="headerlink" title="从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了"></a>从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了</h5><p><strong>从锁的类别上来讲</strong>，有共享锁和排他锁。</p>
<p>共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。</p>
<p>排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。</p>
<p>用上面的例子来说就是用户的行为有两种，一种是来看房，多个用户一起看房是可以接受的。 一种是真正的入住一晚，在这期间，无论是想入住的还是想看房的都不可以。</p>
<p>锁的粒度取决于具体的存储引擎，InnoDB实现了行级锁，页级锁，表级锁。</p>
<p>他们的加锁开销从大到小，并发能力也是从大到小。</p>
<h5 id="MySQL中InnoDB引擎的行锁是怎么实现的？"><a href="#MySQL中InnoDB引擎的行锁是怎么实现的？" class="headerlink" title="MySQL中InnoDB引擎的行锁是怎么实现的？"></a>MySQL中InnoDB引擎的行锁是怎么实现的？</h5><p>答：InnoDB是基于索引来完成行锁</p>
<p>例: select * from tab_with_index where id = 1 for update;</p>
<p>for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将完成表锁，并发将无从谈起<br>InnoDB存储引擎的锁的算法有三种</p>
<ul>
<li>Record lock：单个行记录上的锁</li>
<li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li>
<li>Next-key lock：record+gap 锁定一个范围，包含记录本身</li>
</ul>
<p>相关知识点：</p>
<ol>
<li>innodb对于行的查询使用next-key lock</li>
<li>Next-locking keying为了解决Phantom Problem幻读问题</li>
<li>当查询的索引含有唯一属性时，将next-key lock降级为record key</li>
<li>Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</li>
<li>有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1</li>
</ol>
<h5 id="什么是死锁？怎么解决？"><a href="#什么是死锁？怎么解决？" class="headerlink" title="什么是死锁？怎么解决？"></a>什么是死锁？怎么解决？</h5><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</p>
<p>常见的解决死锁的方法</p>
<p>1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</p>
<p>2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</p>
<p>3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</p>
<p>如果业务处理不好可以用分布式事务锁或者使用乐观锁</p>
<h5 id="数据库的乐观锁和悲观锁是什么？怎么实现的？"><a href="#数据库的乐观锁和悲观锁是什么？怎么实现的？" class="headerlink" title="数据库的乐观锁和悲观锁是什么？怎么实现的？"></a>数据库的乐观锁和悲观锁是什么？怎么实现的？</h5><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p>
<p><strong>悲观锁</strong>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制</p>
<p><strong>乐观锁</strong>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。</p>
<p><strong>两种锁的使用场景</strong></p>
<p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐<strong>观锁适用于写比较少的情况下（多读场景）</strong>，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。</p>
<p>但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以<strong>一般多写的场景下用悲观锁就比较合</strong>适。</p>
<h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><h5 id="为什么要使用视图？什么是视图？"><a href="#为什么要使用视图？什么是视图？" class="headerlink" title="为什么要使用视图？什么是视图？"></a>为什么要使用视图？什么是视图？</h5><p>为了提高复杂SQL语句的复用性和表操作的安全性，MySQL数据库管理系统提供了视图特性。所谓视图，本质上是一种虚拟表，在物理上是不存在的，其内容与真实的表相似，包含一系列带有名称的列和行数据。但是，视图并不在数据库中以储存的数据值形式存在。行和列数据来自定义视图的查询所引用基本表，并且在具体引用视图时动态生成。</p>
<p>视图使开发者只关心感兴趣的某些特定数据和所负责的特定任务，只能看到视图中所定义的数据，而不是视图所引用表中的数据，从而提高了数据库中数据的安全性。</p>
<h5 id="视图有哪些特点？"><a href="#视图有哪些特点？" class="headerlink" title="视图有哪些特点？"></a>视图有哪些特点？</h5><p>视图的特点如下:</p>
<ul>
<li>视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。</li>
<li>视图是由基本表(实表)产生的表(虚表)。</li>
<li>视图的建立和删除不影响基本表。</li>
<li>对视图内容的更新(添加，删除和修改)直接影响基本表。</li>
<li>当视图来自多个基本表时，不允许添加和删除数据。</li>
</ul>
<p>视图的操作包括创建视图，查看视图，删除视图和修改视图。</p>
<h5 id="视图的使用场景有哪些？"><a href="#视图的使用场景有哪些？" class="headerlink" title="视图的使用场景有哪些？"></a>视图的使用场景有哪些？</h5><p>视图根本用途：简化sql查询，提高开发效率。如果说还有另外一个用途那就是兼容老的表结构。</p>
<p>下面是视图的常见使用场景：</p>
<ul>
<li>重用SQL语句；</li>
<li>简化复杂的SQL操作。在编写查询后，可以方便的重用它而不必知道它的基本查询细节；</li>
<li>使用表的组成部分而不是整个表；</li>
<li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限；</li>
<li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li>
</ul>
<h5 id="视图的优点"><a href="#视图的优点" class="headerlink" title="视图的优点"></a>视图的优点</h5><ol>
<li>查询简单化。视图能简化用户的操作</li>
<li>数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护</li>
<li>逻辑数据独立性。视图对重构数据库提供了一定程度的逻辑独立性</li>
</ol>
<h5 id="视图的缺点"><a href="#视图的缺点" class="headerlink" title="视图的缺点"></a>视图的缺点</h5><ol>
<li>性能。数据库必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也把它变成一个复杂的结合体，需要花费一定的时间。</li>
<li>修改限制。当用户试图修改视图的某些行时，数据库必须把它转化为对基本表的某些行的修改。事实上，当从视图中插入或者删除时，情况也是这样。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的</li>
<li>这些视图有如下特征：1.有UNIQUE等集合操作符的视图。2.有GROUP BY子句的视图。3.有诸如AVG\SUM\MAX等聚合函数的视图。 4.使用DISTINCT关键字的视图。5.连接表的视图（其中有些例外）</li>
</ol>
<h5 id="什么是游标？"><a href="#什么是游标？" class="headerlink" title="什么是游标？"></a>什么是游标？</h5><p>游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果，每个游标区都有一个名字。用户可以通过游标逐一获取记录并赋给主变量，交由主语言进一步处理。</p>
<h5 id="存储过程与函数"><a href="#存储过程与函数" class="headerlink" title="存储过程与函数"></a>存储过程与函数</h5><h5 id="什么是存储过程？有哪些优缺点？"><a href="#什么是存储过程？有哪些优缺点？" class="headerlink" title="什么是存储过程？有哪些优缺点？"></a>什么是存储过程？有哪些优缺点？</h5><p>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。</p>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>1）存储过程是预编译过的，执行效率高。</p>
<p>2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</p>
<p>3）安全性高，执行存储过程需要有一定权限的用户。</p>
<p>4）存储过程可以重复使用，减少数据库开发人员的工作量。</p>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>1）调试麻烦，但是用 PL/SQL Developer 调试很方便！弥补这个缺点。</p>
<p>2）移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。</p>
<p>3）重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。</p>
<p>4）如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。</p>
<h4 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h4><h5 id="什么是触发器？触发器的使用场景有哪些？"><a href="#什么是触发器？触发器的使用场景有哪些？" class="headerlink" title="什么是触发器？触发器的使用场景有哪些？"></a>什么是触发器？触发器的使用场景有哪些？</h5><p>触发器是用户定义在关系表上的一类由事件驱动的特殊的存储过程。触发器是指一段代码，当触发某个事件时，自动执行这些代码。</p>
<p>使用场景</p>
<ul>
<li>可以通过数据库中的相关表实现级联更改。</li>
<li>实时监控某张表中的某个字段的更改而需要做出相应的处理。</li>
<li>例如可以生成某些业务的编号。</li>
<li>注意不要滥用，否则会造成数据库及应用程序的维护困难。</li>
<li>大家需要牢记以上基础知识点，重点是理解数据类型CHAR和VARCHAR的差异，表存储引擎InnoDB和MyISAM的区别。</li>
</ul>
<h5 id="MySQL中都有哪些触发器？"><a href="#MySQL中都有哪些触发器？" class="headerlink" title="MySQL中都有哪些触发器？"></a>MySQL中都有哪些触发器？</h5><p>在MySQL数据库中有如下六种触发器：</p>
<ul>
<li>Before Insert</li>
<li>After Insert</li>
<li>Before Update</li>
<li>After Update</li>
<li>Before Delete</li>
<li>After Delete</li>
</ul>
<h4 id="常用SQL语句"><a href="#常用SQL语句" class="headerlink" title="常用SQL语句"></a>常用SQL语句</h4><h5 id="SQL语句主要分为哪几类"><a href="#SQL语句主要分为哪几类" class="headerlink" title="SQL语句主要分为哪几类"></a>SQL语句主要分为哪几类</h5><p>数据定义语言DDL（Data Ddefinition Language）CREATE，DROP，ALTER</p>
<p>主要为以上操作 即对逻辑结构等有操作的，其中包括表结构，视图和索引。</p>
<p>数据查询语言DQL（Data Query Language）SELECT</p>
<p>这个较为好理解 即查询操作，以select关键字。各种简单查询，连接查询等 都属于DQL。</p>
<p>数据操纵语言DML（Data Manipulation Language）INSERT，UPDATE，DELETE</p>
<p>主要为以上操作 即对数据进行操作的，对应上面所说的查询操作 DQL与DML共同构建了多数初级程序员常用的增删改查操作。而查询是较为特殊的一种 被划分到DQL中。</p>
<p>数据控制功能DCL（Data Control Language）GRANT，REVOKE，COMMIT，ROLLBACK</p>
<p>主要为以上操作 即对数据库安全性完整性等有操作的，可以简单的理解为权限控制等。</p>
<h5 id="超键、候选键、主键、外键分别是什么？"><a href="#超键、候选键、主键、外键分别是什么？" class="headerlink" title="超键、候选键、主键、外键分别是什么？"></a>超键、候选键、主键、外键分别是什么？</h5><ul>
<li>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</li>
<li>候选键：是最小超键，即没有冗余元素的超键。</li>
<li>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</li>
<li>外键：在一个表中存在的另一个表的主键称此表的外键。</li>
</ul>
<p>SQL 约束有哪几种？</p>
<pre><code>SQL 约束有哪几种？</code></pre><ul>
<li>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</li>
<li>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</li>
<li>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</li>
<li>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li>
<li>CHECK: 用于控制字段的值范围。</li>
</ul>
<h5 id="六种关联查询"><a href="#六种关联查询" class="headerlink" title="六种关联查询"></a>六种关联查询</h5><ul>
<li>交叉连接（CROSS JOIN）</li>
<li>内连接（INNER JOIN）</li>
<li>外连接（LEFT JOIN/RIGHT JOIN）</li>
<li>联合查询（UNION与UNION ALL）</li>
<li>全连接（FULL JOIN）</li>
<li>交叉连接（CROSS JOIN）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A,B(,C)或者<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> B (<span class="keyword">CROSS</span> <span class="keyword">JOIN</span> C)<span class="comment">#没有任何关联条件，结果是笛卡尔积，结果集会很大，没有意义，很少使用内连接（INNER JOIN）SELECT * FROM A,B WHERE A.id=B.id或者SELECT * FROM A INNER JOIN B ON A.id=B.id多表中同时符合某种条件的数据记录的集合，INNER JOIN可以缩写为JOIN</span></span><br></pre></td></tr></table></figure>

<p>内连接分为三类</p>
<ul>
<li>等值连接：ON A.id=B.id</li>
<li>不等值连接：ON A.id &gt; B.id</li>
<li>自连接：SELECT * FROM A T1 INNER JOIN A T2 ON T1.id=T2.pid</li>
</ul>
<p>外连接（LEFT JOIN/RIGHT JOIN）</p>
<ul>
<li>左外连接：LEFT OUTER JOIN, 以左表为主，先查询出左表，按照ON后的关联条件匹配右表，没有匹配到的用NULL填充，可以简写成LEFT JOIN</li>
<li>右外连接：RIGHT OUTER JOIN, 以右表为主，先查询出右表，按照ON后的关联条件匹配左表，没有匹配到的用NULL填充，可以简写成RIGHT JOIN</li>
</ul>
<p>联合查询（UNION与UNION ALL）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A <span class="keyword">UNION</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> B <span class="keyword">UNION</span> ...</span><br></pre></td></tr></table></figure>

<ul>
<li>就是把多个结果集集中在一起，UNION前的结果为基准，需要注意的是联合查询的列数要相等，相同的记录行会合并</li>
<li>如果使用UNION ALL，不会合并重复的记录行</li>
<li>效率 UNION 高于 UNION ALL</li>
</ul>
<p>全连接（FULL JOIN）</p>
<ul>
<li>MySQL不支持全连接</li>
<li>可以使用LEFT JOIN 和UNION和RIGHT JOIN联合使用</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> B <span class="keyword">ON</span> A.id=B.id UNIONSELECT * <span class="keyword">FROM</span> A <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> B <span class="keyword">ON</span> A.id=B.id</span><br></pre></td></tr></table></figure>

<p>表连接面试题</p>
<p>有2张表，1张R、1张S，R表有ABC三列，S表有CD两列，表中各有三条记录。</p>
<p>R表</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
</tr>
</tbody></table>
<p>S表</p>
<table>
<thead>
<tr>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>c4</td>
<td>d3</td>
</tr>
</tbody></table>
<ol>
<li>交叉连接(笛卡尔积):</li>
</ol>
<p>select r.<em>,s.</em> from r,s</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c4</td>
<td>d3</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c4</td>
<td>d3</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td>c4</td>
<td>d3</td>
</tr>
</tbody></table>
<ol start="2">
<li><p>内连接结果：</p>
<p>select r.<em>,s.</em> from r inner join s on r.c=s.c</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
</tbody></table>
<ol start="3">
<li>左连接结果：</li>
</ol>
<p>​       select r.<em>,s.</em> from r left join s on r.c=s.c</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ol start="4">
<li>右连接结果：</li>
</ol>
<p>​          select r.<em>,s.</em> from r right join s on r.c=s.c</p>
<p>​            </p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>c4</td>
<td>d3</td>
</tr>
</tbody></table>
<ol start="5">
<li>全表连接的结果（MySql不支持，Oracle支持）：</li>
</ol>
<p>​       select r.<em>,s.</em> from r full join s on r.c=s.c</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>3</td>
<td>b3</td>
<td>c3</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>c4</td>
<td>d3</td>
</tr>
</tbody></table>
<p>什么是子查询</p>
<ol>
<li>条件：一条SQL语句的查询结果做为另一条查询语句的条件或查询结果</li>
<li>嵌套：多条SQL语句嵌套使用，内部的SQL查询语句称为子查询。</li>
</ol>
<p>子查询的三种情况</p>
<ol>
<li>子查询是单行单列的情况：结果集是一个值，父查询使用：=、 &lt;、 &gt; 等运算符</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询工资最高的员工是谁？ </span></span><br><span class="line"><span class="keyword">select</span>  * <span class="keyword">from</span> employee <span class="keyword">where</span> salary=(<span class="keyword">select</span> <span class="keyword">max</span>(salary) <span class="keyword">from</span> employee);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>子查询是多行单列的情况：结果集类似于一个数组，父查询使用：in 运算符</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询工资最高的员工是谁？ </span></span><br><span class="line"><span class="keyword">select</span>  * <span class="keyword">from</span> employee <span class="keyword">where</span> salary=(<span class="keyword">select</span> <span class="keyword">max</span>(salary) <span class="keyword">from</span> employee);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>子查询是多行多列的情况：结果集类似于一张虚拟表，不能用于where条件，用于select子句中做为子表</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1) 查询出2011年以后入职的员工信息</span></span><br><span class="line"><span class="comment">-- 2) 查询所有的部门信息，与上面的虚拟表中的信息比对，找出所有部门ID相等的员工。</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> dept d,  (<span class="keyword">select</span> * <span class="keyword">from</span> employee <span class="keyword">where</span> join_date &gt; <span class="string">'2011-1-1'</span>) e <span class="keyword">where</span> e.dept_id =  d.id;    </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用表连接：</span></span><br><span class="line"><span class="keyword">select</span> d.*, e.* <span class="keyword">from</span>  dept d <span class="keyword">inner</span> <span class="keyword">join</span> employee e <span class="keyword">on</span> d.id = e.dept_id <span class="keyword">where</span> e.join_date &gt;  <span class="string">'2011-1-1'</span></span><br></pre></td></tr></table></figure>

<h5 id="mysql中-in-和-exists-区别"><a href="#mysql中-in-和-exists-区别" class="headerlink" title="mysql中 in 和 exists 区别"></a>mysql中 in 和 exists 区别</h5><p>mysql中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。一直大家都认为exists比in语句的效率要高，这种说法其实是不准确的。这个是要区分环境的。</p>
<ol>
<li>如果查询的两个表大小相当，那么用in和exists差别不大。</li>
<li>如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。</li>
<li>not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。</li>
</ol>
<h5 id="varchar与char的区别"><a href="#varchar与char的区别" class="headerlink" title="varchar与char的区别"></a>varchar与char的区别</h5><p><strong>char的特点</strong></p>
<ul>
<li>char表示定长字符串，长度是固定的；</li>
<li>如果插入数据的长度小于char的固定长度时，则用空格填充；</li>
<li>因为长度固定，所以存取速度要比varchar快很多，甚至能快50%，但正因为其长度固定，所以会占据多余的空间，是空间换时间的做法；</li>
<li>对于char来说，最多能存放的字符个数为255，和编码无关</li>
</ul>
<p><strong>varchar的特点</strong></p>
<ul>
<li>varchar表示可变长字符串，长度是可变的；</li>
<li>插入的数据是多长，就按照多长来存储；</li>
<li>varchar在存取方面与char相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法；</li>
<li>对于varchar来说，最多能存放的字符个数为65532</li>
</ul>
<p>总之，结合性能角度（char更快）和节省磁盘空间角度（varchar更小），具体情况还需具体来设计数据库才是妥当的做法。</p>
<h5 id="varchar-50-中50的涵义"><a href="#varchar-50-中50的涵义" class="headerlink" title="varchar(50)中50的涵义"></a>varchar(50)中50的涵义</h5><p>最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)。在早期 MySQL 版本中， 50 代表字节数，现在代表字符数。</p>
<h5 id="int-20-中20的涵义"><a href="#int-20-中20的涵义" class="headerlink" title="int(20)中20的涵义"></a>int(20)中20的涵义</h5><p>是指显示字符的长度。20表示最大显示宽度为20，但仍占4字节存储，存储范围不变；</p>
<p>不影响内部存储，只是影响带 zerofill 定义的 int 时，前面补多少个 0，易于报表展示</p>
<h5 id="mysql为什么这么设计"><a href="#mysql为什么这么设计" class="headerlink" title="mysql为什么这么设计"></a>mysql为什么这么设计</h5><p>对大多数应用没有意义，只是规定一些工具用来显示字符的个数；int(1)和int(20)存储和计算均一样；</p>
<h5 id="mysql中int-10-和char-10-以及varchar-10-的区别"><a href="#mysql中int-10-和char-10-以及varchar-10-的区别" class="headerlink" title="mysql中int(10)和char(10)以及varchar(10)的区别"></a>mysql中int(10)和char(10)以及varchar(10)的区别</h5><ul>
<li>int(10)的10表示显示的数据的长度，不是存储数据的大小；chart(10)和varchar(10)的10表示存储数据的大小，即表示存储多少个字符。int(10) 10位的数据长度 9999999999，占32个字节，int型4位</li>
<li>char(10) 10位固定字符串，不足补空格 最多10个字符</li>
<li>varchar(10) 10位可变字符串，不足补空格 最多10个字符char(10)表示存储定长的10个字符，不足10个就用空格补齐，占用更多的存储空间varchar(10)表示存储10个变长的字符，存储多少个就是多少个，空格也按一个字符存储，这一点是和char(10)的空格不同的，char(10)的空格表示占位不算一个字符</li>
</ul>
<p>FLOAT和DOUBLE的区别是什么？</p>
<ul>
<li>FLOAT类型数据可以存储至多8位十进制数，并在内存中占4字节。</li>
<li>DOUBLE类型数据可以存储至多18位十进制数，并在内存中占8字节。</li>
</ul>
<h5 id="drop、delete与truncate的区别"><a href="#drop、delete与truncate的区别" class="headerlink" title="drop、delete与truncate的区别"></a>drop、delete与truncate的区别</h5><p>三者都表示删除，但是三者有一些差别：<br>    Delete     Truncate     Drop</p>
<table>
<thead>
<tr>
<th></th>
<th>Delete</th>
<th>Truncate</th>
<th>Drop</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>属于DML</td>
<td>属于DDL</td>
<td>属于DDL</td>
</tr>
<tr>
<td>回滚</td>
<td>可回滚</td>
<td>不可回滚</td>
<td>不可回滚</td>
</tr>
<tr>
<td>删除内容</td>
<td>表结构还在，删除表的全部或者一部分数据行</td>
<td>表结构还在，删除表中的所有数据</td>
<td>从数据库中删除表，所有的数据行，索引和权限也会被删除</td>
</tr>
<tr>
<td>删除速度</td>
<td>删除速度慢，需要逐行删除</td>
<td>删除速度快</td>
<td>删除速度最快</td>
</tr>
</tbody></table>
<p>因此，在不再需要一张表的时候，用drop；在想删除部分数据行时候，用delete；在保留表而删除所有数据的时候用truncate。</p>
<h5 id="UNION与UNION-ALL的区别？"><a href="#UNION与UNION-ALL的区别？" class="headerlink" title="UNION与UNION ALL的区别？"></a>UNION与UNION ALL的区别？</h5><ul>
<li>如果使用UNION ALL，不会合并重复的记录行</li>
<li>效率 UNION 高于 UNION ALL</li>
</ul>
<h4 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h4><h5 id="如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到-或者说怎么才可以知道这条语句运行很慢的原因？"><a href="#如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到-或者说怎么才可以知道这条语句运行很慢的原因？" class="headerlink" title="如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？"></a>如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？</h5><p>对于低性能的SQL语句的定位，最重要也是最有效的方法就是使用执行计划，MySQL提供了explain命令来查看语句的执行计划。 我们知道，不管是哪种数据库，或者是哪种数据库引擎，在对一条SQL语句进行执行的过程中都会做很多相关的优化，<strong>对于查询语句，最重要的优化方式就是使用索引。 而执行计划，就是显示数据库引擎对于SQL语句的执行的详细情况，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200310171131582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt></p>
<p>执行计划包含的信息 id 有一组数字组成。表示一个查询中各个子查询的执行顺序;</p>
<ul>
<li>id相同执行顺序由上至下。</li>
<li>id不同，id值越大优先级越高，越先被执行。</li>
<li>id为null时表示一个结果集，不需要使用它查询，常出现在包含union等查询语句中。</li>
</ul>
<p><strong>select_type</strong> 每个子查询的查询类型，一些常见的查询类型。</p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>不包含任何子查询或union等查询</td>
</tr>
<tr>
<td>2</td>
<td>PRIMARY</td>
<td>包含子查询最外层查询就显示为 PRIMARY</td>
</tr>
<tr>
<td>3</td>
<td>SUBQUERY</td>
<td>在select或 where字句中包含的查询</td>
</tr>
<tr>
<td>4</td>
<td>DERIVED</td>
<td>from字句中包含的查询</td>
</tr>
<tr>
<td>5</td>
<td>UNION</td>
<td>出现在union后的查询语句中</td>
</tr>
<tr>
<td>6</td>
<td>UNION RESULT</td>
<td>从UNION中获取结果集，例如上文的第三个例子</td>
</tr>
</tbody></table>
<p><strong>table</strong> 查询的数据表，当从衍生表中查数据时会显示 x 表示对应的执行计划id partitions 表分区、表创建的时候可以指定通过那个列进行表分区。 举个例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tmp (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)</span><br><span class="line">) <span class="keyword">engine</span> = <span class="keyword">innodb</span></span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">key</span> (<span class="keyword">id</span>) <span class="keyword">partitions</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p><strong>type</strong>(非常重要，可以看到有没有走索引) 访问类型</p>
<ul>
<li>ALL 扫描全表数据</li>
<li>index 遍历索引</li>
<li>range 索引范围查找</li>
<li>index_subquery 在子查询中使用 ref</li>
<li>unique_subquery 在子查询中使用 eq_ref</li>
<li>ref_or_null 对Null进行索引的优化的 ref</li>
<li>fulltext 使用全文索引</li>
<li>ref 使用非唯一索引查找数据</li>
<li>eq_ref 在join查询中使用PRIMARY KEYorUNIQUE NOT NULL索引关联。</li>
</ul>
<p><strong>possible_keys</strong> 可能使用的索引，注意不一定会使用。查询涉及到的字段上若存在索引，则该索引将被列出来。当该列为 NULL时就要考虑当前的SQL是否需要优化了。</p>
<p><strong>key</strong> 显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL。</p>
<p><strong>TIPS</strong>:查询中若使用了覆盖索引(覆盖索引：索引的数据覆盖了需要查询的所有数据)，则该索引仅出现在key列表中</p>
<p><strong>key_length</strong> 索引长度</p>
<p><strong>ref</strong> 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p>
<p><strong>rows</strong> 返回估算的结果集数目，并不是一个准确的值。</p>
<p><strong>extra</strong> 的信息非常丰富，常见的有：</p>
<ol>
<li><p>Using index 使用覆盖索引</p>
</li>
<li><p>Using where 使用了用where子句来过滤结果集</p>
</li>
<li><p>Using filesort 使用文件排序，使用非索引列进行排序时出现，非常消耗性能，尽量优化。</p>
</li>
<li><p>Using temporary 使用了临时表 sql优化的目标可以参考阿里开发手册</p>
<p> 【推荐】SQL性能优化的目标：至少要达到 range 级别，要求是ref级别，如果可以是consts最好。<br> 说明：<br> 1） consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。<br> 2） ref 指的是使用普通的索引（normal index）。<br> 3） range 对索引进行范围检索。<br> 反例：explain表的结果，type=index，索引物理文件全扫描，速度非常慢，这个index级别比较range还低，与全表扫描是小巫见大巫。</p>
</li>
</ol>
<h5 id="SQL的生命周期？"><a href="#SQL的生命周期？" class="headerlink" title="SQL的生命周期？"></a>SQL的生命周期？</h5><ol>
<li><p>应用服务器与数据库服务器建立一个连接</p>
</li>
<li><p>数据库进程拿到请求sql</p>
</li>
<li><p>解析并生成执行计划，执行</p>
</li>
<li><p>读取数据到内存并进行逻辑处理</p>
</li>
<li><p>通过步骤一的连接，发送结果到客户端</p>
</li>
<li><p>关掉连接，释放资源大表数据查询，怎么优化</p>
<p><img src="https://img-blog.csdnimg.cn/20200310170936478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt></p>
</li>
</ol>
<h3 id="大表数据查询，怎么优化"><a href="#大表数据查询，怎么优化" class="headerlink" title="大表数据查询，怎么优化"></a>大表数据查询，怎么优化</h3><ol>
<li><p>优化shema、sql语句+索引；</p>
</li>
<li><p>第二加缓存，memcached, redis；</p>
</li>
<li><p>主从复制，读写分离；</p>
</li>
<li><p>垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；</p>
</li>
<li><p>水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding </p>
<p>key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；</p>
</li>
</ol>
<h5 id="超大分页怎么处理？"><a href="#超大分页怎么处理？" class="headerlink" title="超大分页怎么处理？"></a>超大分页怎么处理？</h5><p>超大的分页一般从两个方向上来解决.</p>
<ul>
<li>数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于select * from table where age &gt; 20 limit 1000000,10这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为select * from table where id in (select id from table where age &gt; 20 limit 1000000,10).这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以select * from table where id &gt; 1000000 limit 10,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据.</li>
<li>从需求的角度减少这种请求…主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.</li>
</ul>
<p>解决超大分页,其实主要是靠缓存,可预测性的提前查到内容,缓存至redis等k-V数据库中,直接返回即可.</p>
<p>在阿里巴巴《Java开发手册》中,对超大分页的解决办法是类似于上面提到的第一种.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">【推荐】利用延迟关联或者子查询优化超多分页场景。 </span><br><span class="line"></span><br><span class="line">说明：MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。 </span><br><span class="line"></span><br><span class="line">正例：先快速定位需要获取的id段，然后再关联： </span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> a.* <span class="keyword">FROM</span> 表<span class="number">1</span> a, (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">where</span> 条件 <span class="keyword">LIMIT</span> <span class="number">100000</span>,<span class="number">20</span> ) b <span class="keyword">where</span> a.id=b.id</span><br></pre></td></tr></table></figure>

<h5 id="mysql-分页"><a href="#mysql-分页" class="headerlink" title="mysql 分页"></a>mysql 分页</h5><p>LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是 0(而不是 1)</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15</span><br></pre></td></tr></table></figure>

<p>为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last.</span><br></pre></td></tr></table></figure>

<p>如果只给定一个参数，它表示返回最大的记录行数目：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM table LIMIT 5; //检索前 5 个记录行</span><br></pre></td></tr></table></figure>

<p>换句话说，LIMIT n 等价于 LIMIT 0,n。<br>慢查询日志</p>
<pre><code>用于记录执行时间超过某个临界值的SQL日志，用于快速定位慢查询，为我们的优化做参考。</code></pre><p>开启慢查询日志</p>
<p>配置项：slow_query_log</p>
<p>可以使用show variables like ‘slov_query_log’查看是否开启，如果状态值为OFF，可以使用set GLOBAL slow_query_log = on来开启，它会在datadir下产生一个xxx-slow.log的文件。</p>
<p>设置临界时间</p>
<p>配置项：long_query_time</p>
<p>查看：show VARIABLES like ‘long_query_time’，单位秒</p>
<p>设置：set long_query_time=0.5</p>
<p>实操时应该从长时间设置到短的时间，即将最慢的SQL优化掉</p>
<p>查看日志，一旦SQL超过了我们设置的临界时间就会被记录到xxx-slow.log中</p>
<h5 id="关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？"><a href="#关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？" class="headerlink" title="关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？"></a>关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？</h5><p>在业务系统中，除了使用主键进行的查询，其他的我都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。</p>
<p>慢查询的优化首先要搞明白慢的原因是什么？ 是查询条件没有命中索引？是load了不需要的数据列？还是数据量太大？</p>
<p>所以优化也是针对这三个方向来的，</p>
<ul>
<li>首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。</li>
<li>分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。</li>
<li>如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。</li>
</ul>
<h5 id="为什么要尽量设定一个主键？"><a href="#为什么要尽量设定一个主键？" class="headerlink" title="为什么要尽量设定一个主键？"></a>为什么要尽量设定一个主键？</h5><p>主键是数据库确保数据行在整张表唯一性的保障，即使业务上本张表没有主键，也建议添加一个自增长的ID列作为主键。设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。</p>
<h5 id="主键使用自增ID还是UUID？"><a href="#主键使用自增ID还是UUID？" class="headerlink" title="主键使用自增ID还是UUID？"></a>主键使用自增ID还是UUID？</h5><p>推荐使用自增ID，不要使用UUID。</p>
<p>因为在InnoDB存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降。</p>
<p>总之，在数据量大一些的情况下，用自增主键性能会好一些。</p>
<p>关于主键是聚簇索引，如果没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个隐式的主键。</p>
<h5 id="字段为什么要求定义为not-null？"><a href="#字段为什么要求定义为not-null？" class="headerlink" title="字段为什么要求定义为not null？"></a>字段为什么要求定义为not null？</h5><p>null值会占用更多的字节，且会在程序中造成很多与预期不符的情况。</p>
<h5 id="如果要存储用户的密码散列，应该使用什么字段进行存储？"><a href="#如果要存储用户的密码散列，应该使用什么字段进行存储？" class="headerlink" title="如果要存储用户的密码散列，应该使用什么字段进行存储？"></a>如果要存储用户的密码散列，应该使用什么字段进行存储？</h5><p>密码散列，盐，用户身份证号等固定长度的字符串应该使用char而不是varchar来存储，这样可以节省空间且提高检索效率。</p>
<h5 id="优化查询过程中的数据访问"><a href="#优化查询过程中的数据访问" class="headerlink" title="优化查询过程中的数据访问"></a>优化查询过程中的数据访问</h5><ul>
<li>访问数据太多导致查询性能下降</li>
<li>确定应用程序是否在检索大量超过需要的数据，可能是太多行或列</li>
<li>确认MySQL服务器是否在分析大量不必要的数据行</li>
<li>避免犯如下SQL语句错误</li>
<li>查询不需要的数据。解决办法：使用limit解决</li>
<li>多表关联返回全部列。解决办法：指定列名</li>
<li>总是返回全部列。解决办法：避免使用SELECT *</li>
<li>重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存</li>
<li>是否在扫描额外的记录。解决办法：</li>
<li>使用explain进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优化：</li>
<li>使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。</li>
<li>改变数据库和表的结构，修改数据表范式</li>
<li>重写SQL语句，让优化器可以以更优的方式执行查询。</li>
</ul>
<h5 id="优化长难的查询语句"><a href="#优化长难的查询语句" class="headerlink" title="优化长难的查询语句"></a>优化长难的查询语句</h5><ul>
<li>一个复杂查询还是多个简单查询</li>
<li>MySQL内部每秒能扫描内存中上百万行数据，相比之下，响应数据给客户端就要慢得多</li>
<li>使用尽可能小的查询是好的，但是有时将一个大的查询分解为多个小的查询是很有必要的。</li>
<li>切分查询</li>
<li>将一个大的查询分为多个小的相同的查询</li>
<li>一次性删除1000万的数据要比一次删除1万，暂停一会的方案更加损耗服务器开销。</li>
<li>分解关联查询，让缓存的效率更高。</li>
<li>执行单个查询可以减少锁的竞争。</li>
<li>在应用层做关联更容易对数据库进行拆分。</li>
<li>查询效率会有大幅提升。</li>
<li>较少冗余记录的查询。</li>
</ul>
<h5 id="优化特定类型的查询语句"><a href="#优化特定类型的查询语句" class="headerlink" title="优化特定类型的查询语句"></a>优化特定类型的查询语句</h5><ul>
<li>count(*)会忽略所有的列，直接统计所有列数，不要使用count(列名)</li>
<li><em>MyISAM中，没有任何where条件的count(</em>)非常快。</li>
<li>当有where条件时，MyISAM的count统计不一定比其它引擎快。</li>
<li>可以使用explain查询近似值，用近似值替代count(*)</li>
<li>增加汇总表</li>
<li>使用缓存</li>
</ul>
<h5 id="优化关联查询"><a href="#优化关联查询" class="headerlink" title="优化关联查询"></a>优化关联查询</h5><ul>
<li>确定ON或者USING子句中是否有索引。</li>
<li>确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引。</li>
</ul>
<h5 id="优化子查询"><a href="#优化子查询" class="headerlink" title="优化子查询"></a>优化子查询</h5><ul>
<li>用关联查询替代</li>
<li>优化GROUP BY和DISTINCT</li>
<li>这两种查询据可以使用索引来优化，是最有效的优化方法</li>
<li>关联查询中，使用标识列分组的效率更高</li>
<li>如果不需要ORDER BY，进行GROUP BY时加ORDER BY NULL，MySQL不会再进行文件排序。</li>
<li>WITH ROLLUP超级聚合，可以挪到应用程序处理</li>
</ul>
<h5 id="优化LIMIT分页"><a href="#优化LIMIT分页" class="headerlink" title="优化LIMIT分页"></a>优化LIMIT分页</h5><ul>
<li>LIMIT偏移量大的时候，查询效率较低</li>
<li>可以记录上次查询的最大ID，下次查询时直接根据该ID来查询</li>
</ul>
<h5 id="优化UNION查询"><a href="#优化UNION查询" class="headerlink" title="优化UNION查询"></a>优化UNION查询</h5><ul>
<li>UNION ALL的效率高于UNION</li>
</ul>
<h5 id="优化WHERE子句"><a href="#优化WHERE子句" class="headerlink" title="优化WHERE子句"></a>优化WHERE子句</h5><p>解题方法</p>
<p>对于此类考题，先说明如何定位低效SQL语句，然后根据SQL语句可能低效的原因做排查，先从索引着手，如果索引没有问题，考虑以上几个方面，数据访问的问题，长难查询句的问题还是一些特定类型优化的问题，逐一回答。</p>
<p>SQL语句优化的一些方法？</p>
<ul>
<li>1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li>
<li>2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">is</span> <span class="literal">null</span></span><br><span class="line"><span class="comment">-- 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=</span><br></pre></td></tr></table></figure>

<ul>
<li>3.应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。</li>
<li>4.应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">10</span> <span class="keyword">or</span> <span class="keyword">num</span>=<span class="number">20</span></span><br><span class="line"><span class="comment">-- 可以这样查询：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">10</span> <span class="keyword">union</span> <span class="keyword">all</span> <span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">20</span></span><br></pre></td></tr></table></figure>

<ul>
<li>5.in 和 not in 也要慎用，否则会导致全表扫描，如：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) </span><br><span class="line"><span class="comment">-- 对于连续的数值，能用 between 就不要用 in 了：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>6.下面的查询也将导致全表扫描：select id from t where name like ‘%李%’若要提高效率，可以考虑全文检索。</li>
<li>7.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=@<span class="keyword">num</span></span><br><span class="line"><span class="comment">-- 可以改为强制查询使用索引：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">with</span>(<span class="keyword">index</span>(索引名)) <span class="keyword">where</span> <span class="keyword">num</span>=@<span class="keyword">num</span></span><br></pre></td></tr></table></figure>

<ul>
<li>8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>/<span class="number">2</span>=<span class="number">100</span></span><br><span class="line"><span class="comment">-- 应改为:</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">100</span>*<span class="number">2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">substring</span>(<span class="keyword">name</span>,<span class="number">1</span>,<span class="number">3</span>)=’abc’</span><br><span class="line"><span class="comment">-- name以abc开头的id应改为:</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> ‘abc%’</span><br></pre></td></tr></table></figure>

<ul>
<li>10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</li>
</ul>
<h4 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h4><h5 id="为什么要优化"><a href="#为什么要优化" class="headerlink" title="为什么要优化"></a>为什么要优化</h5><ul>
<li>系统的吞吐量瓶颈往往出现在数据库的访问速度上</li>
<li>随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢</li>
<li>数据是存放在磁盘上的，读写速度无法和内存相比</li>
</ul>
<p>优化原则：减少系统瓶颈，减少资源占用，增加系统的反应速度。</p>
<h5 id="数据库结构优化"><a href="#数据库结构优化" class="headerlink" title="数据库结构优化"></a>数据库结构优化</h5><p>一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。</p>
<p>需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</p>
<p><strong>将字段很多的表分解成多个表</strong></p>
<p>对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。</p>
<p>因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</p>
<p><strong>增加中间表</strong></p>
<p>对于需要经常联合查询的表，可以建立中间表以提高查询效率。</p>
<p>通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。</p>
<p><strong>增加冗余字段</strong></p>
<p>设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。</p>
<p>表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。</p>
<p><strong>注意</strong>：</p>
<p><strong>冗余字段的值在一个表中修改了，就要想办法在其他表中更新，否则就会导致数据不一致的问题。</strong></p>
<h5 id="MySQL数据库cpu飙升到500-的话他怎么处理？"><a href="#MySQL数据库cpu飙升到500-的话他怎么处理？" class="headerlink" title="MySQL数据库cpu飙升到500%的话他怎么处理？"></a>MySQL数据库cpu飙升到500%的话他怎么处理？</h5><p>当 cpu 飙升到 500%时，先用操作系统命令 top 命令观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。</p>
<p>如果是 mysqld 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。</p>
<p>一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。</p>
<p>也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等</p>
<h5 id="大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？"><a href="#大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？" class="headerlink" title="大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？"></a>大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？</h5><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p>
<ol>
<li>限定数据的范围： 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。；</li>
<li>读/写分离： 经典的数据库拆分方案，主库负责写，从库负责读；</li>
<li>缓存： 使用MySQL的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；</li>
</ol>
<p>还有就是通过分库分表的方式进行优化，主要有垂直分表和水平分表</p>
<ol>
<li><p><strong>垂直分区：</strong></p>
<p><strong>根据数据库里面数据表的相关性进行拆分</strong>。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p>
<p><strong>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表</strong>。 如下图所示，这样来说大家应该就更容易理解了。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC82LzE2LzE2NDA4NDM1NGJhMmUwZmQ?x-oss-process=image/format,png" alt></p>
</li>
</ol>
<p><strong>垂直拆分的优点</strong>： 可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</p>
<p><strong>垂直拆分的缺点</strong>： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</p>
<h5 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h5><p>把主键和一些列放在一个表，然后把主键和另外的列放在另一个表中</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy90dVNhS2M2U2ZQcjh0NFBaVVFJVUszVHl0aWF3T0VRa2dFZnBCTm4xZkNtdEVhMkRaNTlISFNSaWN2SEIzeU43Yk5LY1hkc3NWZGFNb25TOEFKanY5cFdBLzY0MA?x-oss-process=image/format,png" alt></p>
<p><strong>适用场景</strong><br>    1、如果一个表中某些列常用，另外一些列不常用<br>    2、可以使数据行变小，一个数据页能存储更多数据，查询时减少I/O次数<br><strong>缺点</strong><br>       1.  有些分表的策略基于应用层的逻辑算法，一旦逻辑算法改变，整个分表逻辑都会改变，扩展性较 差<br>            2.  对于应用层来说，逻辑算法增加开发成本<br>                     3.  管理冗余列，查询所有数据需要join操作</p>
<p><strong>水平分区</strong>：</p>
<p><strong>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</strong></p>
<p>水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC82LzE2LzE2NDA4NGI3ZTllNDIzZTM?x-oss-process=image/format,png" alt></p>
<p>水品拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 <strong>水平拆分最好分库 。</strong></p>
<p>水平拆分能够 <strong>支持非常大的数据量存储，应用端改造也少</strong>，但 <strong>分片事务难以解决</strong> ，跨界点Join性能较差，逻辑复杂。</p>
<p>《Java工程师修炼之道》的作者推荐 尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度 ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。<br><strong>水平分表</strong>：</p>
<p>表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询次数</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy90dVNhS2M2U2ZQcjh0NFBaVVFJVUszVHl0aWF3T0VRa2dkQVpyU1Y3M2liMWZkRENYS2M3QUd6Wmhid3FjS0ZVWkpGWThwMFZkVXRPM3JNYzZ2eDFBdzVBLzY0MA?x-oss-process=image/format,png" alt></p>
<p><strong>适用场景</strong><br>    1、表中的数据本身就有独立性，例如表中分表记录各个地区的数据或者不同时期的数据，特别是有些数据常用，有些不常用。<br>    2、需要把数据存放在多个介质上。<br><strong>水平切分的缺点</strong><br>    1、给应用增加复杂度，通常查询时需要多个表名，查询所有数据都需UNION操作<br>    2、在许多数据库应用中，这种复杂度会超过它带来的优点，查询时会增加读一个索引层的磁盘次数</p>
<p><strong>下面补充一下数据库分片的两种常见方案：</strong><br>    <strong>客户端代理</strong>： 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。 当当网的 Sharding-JDBC 、阿里的TDDL是两种比较常用的实现。<br>    <strong>中间件代理</strong>： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。 我们现在谈的 Mycat 、360的Atlas、网易的DDB等等都是这种架构的实现。</p>
<p><strong>分库分表后面临的问题</strong></p>
<ul>
<li><strong>事务支持</strong> 分库分表后，就成了分布式事务了。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价； 如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。</li>
<li><strong>跨库join</strong> 只要是进行切分，跨节点Join的问题是不可避免的。但是良好的设计和切分却可以减少此类情况的发生。解决这一问题的普遍做法是分两次查询实现。在第一次查询的结果集中找出关联数据的id,根据这些id发起第二次请求得到关联数据。 分库分表方案产品</li>
<li><strong>跨节点的count,order by,group by以及聚合函数问题</strong> 这些是一类问题，因为它们都需要基于全部数据集合进行计算。多数的代理都不会自动处理合并工作。解决方案：与解决跨节点join问题的类似，分别在各个节点上得到结果后在应用程序端进行合并。和join不同的是每个结点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。</li>
<li><strong>数据迁移，容量规划，扩容等问题</strong> 来自淘宝综合业务平台团队，它利用对2的倍数取余具有向前兼容的特性（如对4取余得1的数对2取余也是1）来分配数据，避免了行级别的数据迁移，但是依然需要进行表级别的迁移，同时对扩容规模和分表数量都有限制。总得来说，这些方案都不是十分的理想，多多少少都存在一些缺点，这也从一个侧面反映出了Sharding扩容的难度。</li>
<li><strong>ID</strong>问题</li>
<li>一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的ID无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得ID,以便进行SQL路由. 一些常见的主键生成策略</li>
</ul>
<p><strong>UUID</strong> 使用UUID作主键是最简单的方案，但是缺点也是非常明显的。由于UUID非常的长，除占用大量存储空间外，最主要的问题是在索引上，在建立索引和基于索引进行查询时都存在性能问题。 <strong>Twitter的分布式自增ID算法Snowflake 在</strong>分布式系统中，需要生成全局UID的场合还是比较多的，twitter的snowflake解决了这种需求，实现也还是很简单的，除去配置信息，核心代码就是毫秒级时间41位 机器ID 10位 毫秒内序列12位。</p>
<ul>
<li>跨分片的排序分页</li>
</ul>
<p>般来讲，分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会变得比较复杂了。为了最终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，并将不同分片返回的结果集进行汇总和再次排序，最后再返回给用户。如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20200310170753848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt></p>
<h4 id="MySQL的复制原理以及流程"><a href="#MySQL的复制原理以及流程" class="headerlink" title="MySQL的复制原理以及流程"></a>MySQL的复制原理以及流程</h4><p>主从复制：将主数据库中的DDL和DML操作通过二进制日志（BINLOG）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。</p>
<h5 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h5><ol>
<li>主数据库出现问题，可以切换到从数据库。</li>
<li>可以进行数据库层面的读写分离。</li>
<li>可以在从数据库上进行日常备份。</li>
</ol>
<h5 id="MySQL主从复制解决的问题"><a href="#MySQL主从复制解决的问题" class="headerlink" title="MySQL主从复制解决的问题"></a>MySQL主从复制解决的问题</h5><ul>
<li>数据分布：随意开始或停止复制，并在不同地理位置分布数据备份</li>
<li>负载均衡：降低单个服务器的压力</li>
<li>高可用和故障切换：帮助应用程序避免单点失败</li>
<li>升级测试：可以用更高版本的MySQL作为从库</li>
</ul>
<h5 id="MySQL主从复制工作原理"><a href="#MySQL主从复制工作原理" class="headerlink" title="MySQL主从复制工作原理"></a>MySQL主从复制工作原理</h5><p><strong>基本原理流程，3个线程以及之间的关联</strong></p>
<p><strong>主</strong>：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；</p>
<p><strong>从</strong>：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进自己的relay log中；</p>
<p><strong>从</strong>：sql执行线程——执行relay log中的语句；</p>
<p><strong>复制过程</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC85LzIxLzE2NWZiNjgzMjIyMDViMmU?x-oss-process=image/format,png" alt></p>
<p>Binary log：主数据库的二进制日志</p>
<p>Relay log：从服务器的中继日志</p>
<p>第一步：master在每个事务更新数据完成之前，将该操作记录串行地写入到binlog文件中。</p>
<p>第二步：salve开启一个I/O Thread，该线程在master打开一个普通连接，主要工作是binlog dump process。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的事件。I/O线程最终的目的是将这些事件写入到中继日志中。</p>
<p>第三步：SQL Thread会读取中继日志，并顺序执行该日志中的SQL事件，从而与主数据库中的数据保持一致。</p>
<h5 id="读写分离有哪些解决方案？"><a href="#读写分离有哪些解决方案？" class="headerlink" title="读写分离有哪些解决方案？"></a>读写分离有哪些解决方案？</h5><p>读写分离是依赖于主从复制，而主从复制又是为读写分离服务的。因为主从复制要求slave不能写只能读（如果对slave执行写操作，那么show slave status将会呈现Slave_SQL_Running=NO，此时你需要按照前面提到的手动同步一下slave）。</p>
<p><strong>方案一</strong></p>
<p>使用mysql-proxy代理</p>
<p>优点：直接实现读写分离和负载均衡，不用修改代码，master和slave用一样的帐号，mysql官方不建议实际生产中使用</p>
<p>缺点：降低性能， 不支持事务</p>
<p><strong>方案二</strong></p>
<p>使用AbstractRoutingDataSource+aop+annotation在dao层决定数据源。<br>如果采用了mybatis， 可以将读写分离放在ORM层，比如mybatis可以通过mybatis plugin拦截sql语句，所有的insert/update/delete都访问master库，所有的select 都访问salve库，这样对于dao层都是透明。 plugin实现时可以通过注解或者分析语句是读写方法来选定主从库。不过这样依然有一个问题， 也就是不支持事务， 所以我们还需要重写一下DataSourceTransactionManager， 将read-only的事务扔进读库， 其余的有读有写的扔进写库。</p>
<p><strong>方案三</strong></p>
<p>使用AbstractRoutingDataSource+aop+annotation在service层决定数据源，可以支持事务.</p>
<p>缺点：类内部方法通过this.xx()方式相互调用时，aop不会进行拦截，需进行特殊处理。</p>
<h5 id="备份计划，mysqldump以及xtranbackup的实现原理"><a href="#备份计划，mysqldump以及xtranbackup的实现原理" class="headerlink" title="备份计划，mysqldump以及xtranbackup的实现原理"></a>备份计划，mysqldump以及xtranbackup的实现原理</h5><p><strong>(1)备份计划</strong></p>
<p>视库的大小来定，一般来说 100G 内的库，可以考虑使用 mysqldump 来做，因为 mysqldump更加轻巧灵活，备份时间选在业务低峰期，可以每天进行都进行全量备份(mysqldump 备份出来的文件比较小，压缩之后更小)。</p>
<p>100G 以上的库，可以考虑用 xtranbackup 来做，备份速度明显要比 mysqldump 要快。一般是选择一周一个全备，其余每天进行增量备份，备份时间为业务低峰期。</p>
<p>(<strong>2)备份恢复时间</strong></p>
<p>物理备份恢复快，逻辑备份恢复慢</p>
<p>这里跟机器，尤其是硬盘的速率有关系，以下列举几个仅供参考</p>
<p>20G的2分钟（mysqldump）</p>
<p>80G的30分钟(mysqldump)</p>
<p>111G的30分钟（mysqldump)</p>
<p>288G的3小时（xtra)</p>
<p>3T的4小时（xtra)</p>
<p>逻辑导入时间一般是备份时间的5倍以上</p>
<p><strong>(3)备份恢复失败如何处理</strong></p>
<p>首先在恢复之前就应该做足准备工作，避免恢复的时候出错。比如说备份之后的有效性检查、权限检查、空间检查等。如果万一报错，再根据报错的提示来进行相应的调整。</p>
<p>(4)mysqldump和xtrabackup实现原理</p>
<p>mysqldump</p>
<p>mysqldump 属于逻辑备份。加入–single-transaction 选项可以进行一致性备份。后台进程会先设置 session 的事务隔离级别为 RR(SET SESSION TRANSACTION ISOLATION LEVELREPEATABLE READ)，之后显式开启一个事务(START TRANSACTION /*!40100 WITH CONSISTENTSNAPSHOT */)，这样就保证了该事务里读到的数据都是事务事务时候的快照。之后再把表的数据读取出来。如果加上–master-data=1 的话，在刚开始的时候还会加一个数据库的读锁(FLUSH TABLES WITH READ LOCK),等开启事务后，再记录下数据库此时 binlog 的位置(showmaster status)，马上解锁，再读取表的数据。等所有的数据都已经导完，就可以结束事务</p>
<p>Xtrabackup:</p>
<p>xtrabackup 属于物理备份，直接拷贝表空间文件，同时不断扫描产生的 redo 日志并保存下来。最后完成 innodb 的备份后，会做一个 flush engine logs 的操作(老版本在有 bug，在5.6 上不做此操作会丢数据)，确保所有的 redo log 都已经落盘(涉及到事务的两阶段提交</p>
<p>概念，因为 xtrabackup 并不拷贝 binlog，所以必须保证所有的 redo log 都落盘，否则可能会丢最后一组提交事务的数据)。这个时间点就是 innodb 完成备份的时间点，数据文件虽然不是一致性的，但是有这段时间的 redo 就可以让数据文件达到一致性(恢复的时候做的事</p>
<p>情)。然后还需要 flush tables with read lock，把 myisam 等其他引擎的表给备份出来，备份完后解锁。这样就做到了完美的热备。</p>
<h5 id="数据表损坏的修复方式有哪些？"><a href="#数据表损坏的修复方式有哪些？" class="headerlink" title="数据表损坏的修复方式有哪些？"></a>数据表损坏的修复方式有哪些？</h5><p>使用 myisamchk 来修复，具体步骤：</p>
<ul>
<li>1）修复前将mysql服务停止。</li>
<li>2）打开命令行方式，然后进入到mysql的/bin目录。</li>
<li>3）执行myisamchk –recover 数据库所在路径/*.MYI</li>
</ul>
<p>使用repair table 或者 OPTIMIZE table命令来修复，REPAIR TABLE table_name 修复表 OPTIMIZE TABLE table_name 优化表 REPAIR TABLE 用于修复被破坏的表。 OPTIMIZE TABLE 用于回收闲置的数据库空间，当表上的数据行被删除时，所占据的磁盘空间并没有立即被回收，使用了OPTIMIZE TABLE命令后这些空间将被回收，并且对磁盘上的数据行进行重排（注意：是磁盘上，而非数据库）</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot2.0集成Shiro</title>
    <url>/myblog/spring-boot/SpringBoot2-0%E9%9B%86%E6%88%90Shiro/index/</url>
    <content><![CDATA[<p>Shiro 整合到 SpringBoot<br>中，并且避开一些小坑，由浅入深，从最基本的配置开始，一步一步加入新的功能。这样理解起来也稍微简单点</p><p></p>
<a id="more"></a>
<h1><a name="t0"></a><a name="t0"></a><a id="_2"></a>项目版本：</h1>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">springboot2.x</span><br><span class="line">shiro：<span class="number">1.3</span><span class="number">.2</span></span><br></pre></td></tr></table></figure>

<h1><a name="t1"></a><a name="t1"></a><a id="Maven_6"></a>
Maven配置：
</h1>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h1><a name="t2"></a><a name="t2"></a><a id="_16"></a>写在前面的话：</h1>

<blockquote>
<p>springboot中集成shiro相对简单，只需要两个类：一个是shiroConfig类，一个是CustonRealm类。</p>
</blockquote>
<h2><a name="t3"></a><a name="t3"></a><a id="ShiroConfig_19"></a>ShiroConfig类：</h2>
<p>顾名思义就是对shiro的一些配置，相对于之前的xml配置。包括：过滤的文件和权限，密码加密的算法，其用注解等相关功能。</p>
<h2><a name="t4"></a><a name="t4"></a><a id="CustomRealm_23"></a>CustomRealm类：</h2>
<p>自定义的CustomRealm继承<code>AuthorizingRealm</code>。并且重写父类中的<code>doGetAuthorizationInfo</code>（权限相关）、<code>doGetAuthenticationInfo</code>（身份认证）这两个方法。</p>
<h1><a name="t5"></a><a name="t5"></a><a id="_26"></a>最基本的配置：</h1>
<h2><a name="t6"></a><a name="t6"></a><a id="shiroConfig_28"></a>shiroConfig配置：</h2>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cj.shirodemo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.credential.HashedCredentialsMatcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.mgt.DefaultSecurityManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.mgt.SecurityManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.spring.LifecycleBeanPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.spring.web.ShiroFilterFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.web.mgt.DefaultWebSecurityManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.DependsOn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> caojing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-01-27-13:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"shiroFilter"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShiroFilterFactoryBean <span class="title">shiroFilter</span><span class="params">(SecurityManager securityManager)</span> </span>&#123;</span><br><span class="line">        ShiroFilterFactoryBean shiroFilterFactoryBean = <span class="keyword">new</span> ShiroFilterFactoryBean();</span><br><span class="line">        shiroFilterFactoryBean.setSecurityManager(securityManager);</span><br><span class="line">        shiroFilterFactoryBean.setLoginUrl(<span class="string">"/login"</span>);</span><br><span class="line">        shiroFilterFactoryBean.setUnauthorizedUrl(<span class="string">"/notRole"</span>);</span><br><span class="line">        Map&amp;lt;String, String&amp;gt; filterChainDefinitionMap = <span class="keyword">new</span> LinkedHashMap&amp;lt;&amp;gt;();</span><br><span class="line">        <span class="comment">// &amp;lt;!-- authc:所有url都必须认证通过才可以访问; anon:所有url都都可以匿名访问--&amp;gt;</span></span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">"/webjars/**"</span>, <span class="string">"anon"</span>);</span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">"/login"</span>, <span class="string">"anon"</span>);</span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">"/"</span>, <span class="string">"anon"</span>);</span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">"/front/**"</span>, <span class="string">"anon"</span>);</span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">"/api/**"</span>, <span class="string">"anon"</span>);</span><br><span class="line"></span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">"/admin/**"</span>, <span class="string">"authc"</span>);</span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">"/user/**"</span>, <span class="string">"authc"</span>);</span><br><span class="line">        <span class="comment">//主要这行代码必须放在所有权限设置的最后，不然会导致所有 url 都被拦截 剩余的都需要认证</span></span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">"/**"</span>, <span class="string">"authc"</span>);</span><br><span class="line">        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);</span><br><span class="line">        <span class="keyword">return</span> shiroFilterFactoryBean;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SecurityManager <span class="title">securityManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultWebSecurityManager defaultSecurityManager = <span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line">        defaultSecurityManager.setRealm(customRealm());</span><br><span class="line">        <span class="keyword">return</span> defaultSecurityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CustomRealm <span class="title">customRealm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CustomRealm customRealm = <span class="keyword">new</span> CustomRealm();</span><br><span class="line">        <span class="keyword">return</span> customRealm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<div class="hljs-button {2}" data-title="复制"></div>
<p>shiroConfig 也不复杂，基本就三个方法。再说这三个方法之前，我想给大家说一下shiro的三个核心概念：</p>

<blockquote>
<ol> <li>Subject：
代表当前正在执行操作的用户，但Subject代表的可以是人，也可以是任何第三方系统帐号。当然每个subject实例都会被绑定到SercurityManger上。</li>
<li>SecurityManger:SecurityManager是Shiro核心，主要协调Shiro内部的各种安全组件，这个我们不需要太关注，只需要知道可以设置自定的Realm。</li>
<li>Realm:用户数据和Shiro数据交互的桥梁。比如需要用户身份认证、权限认证。都是需要通过Realm来读取数据。</li>
</ol>
</blockquote>
<p><strong>shiroFilter方法：</strong><br>
这个方法看名字就知道了：

<blockquote>
<p>shiro的过滤器，可以设置登录页面（<code>setLoginUrl</code>）、权限不足跳转页面（<code>setUnauthorizedUrl</code>）、具体某些页面的权限控制或者身份认证。<br><br><strong>注意：这里是需要设置SecurityManager（<code>setSecurityManager</code>）。</strong><br></p>
</blockquote>
</p><p>默认的过滤器还有：</p>
<blockquote>
<p>anno、authc、authcBasic、logout、noSessionCreation、perms、port、rest、roles、ssl、user过滤器。</p>
</blockquote>
<br>
具体的大家可以查看<code>package org.apache.shiro.web.filter.mgt.DefaultFilter</code>。这个类，常用的也就authc、anno。<br>
<strong>securityManager 方法：</strong><br>
查看源码可以知道 securityManager是一个接口类，我们可以看下它的实现类：<br>
<img src="https://img-blog.csdnimg.cn/20190128141511109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JpY2hlbmc0NzY5,size_16,color_FFFFFF,t_70" alt="实现类"><br>
具体怎么实现的，感兴趣的同学可以看下。由于项目是一个web项目，所以我们使用的是<code>DefaultWebSecurityManager</code> ，然后设置自己的Realm。<br>
<strong>CustomRealm 方法：</strong><br>
将 customRealm的实例化交给spring去管理，当然这里也可以利用注解的方式去注入。<p></p>
<h2><a name="t7"></a><a name="t7"></a><a id="customRealm_112"></a>customRealm配置：</h2>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cj.shirodemo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.SecurityUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authz.AuthorizationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authz.SimpleAuthorizationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.realm.AuthorizingRealm;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.subject.PrincipalCollection;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.util.ByteSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> caojing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-01-27-13:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> </span>&#123;</span><br><span class="line">        String username = (String) SecurityUtils.getSubject().getPrincipal();</span><br><span class="line">        SimpleAuthorizationInfo info = <span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line">        Set&amp;lt;String&amp;gt; stringSet = <span class="keyword">new</span> HashSet&amp;lt;&amp;gt;();</span><br><span class="line">        stringSet.add(<span class="string">"user:show"</span>);</span><br><span class="line">        stringSet.add(<span class="string">"user:admin"</span>);</span><br><span class="line">        info.setStringPermissions(stringSet);</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里可以注入userService,为了方便演示，我就写死了帐号了密码</span></span><br><span class="line"><span class="comment">     * private UserService userService;</span></span><br><span class="line"><span class="comment">     * &amp;lt;p&amp;gt;</span></span><br><span class="line"><span class="comment">     * 获取即将需要认证的信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"-------身份认证方法--------"</span>);</span><br><span class="line">        String userName = (String) authenticationToken.getPrincipal();</span><br><span class="line">        String userPwd = <span class="keyword">new</span> String((<span class="keyword">char</span>[]) authenticationToken.getCredentials());</span><br><span class="line">        <span class="comment">//根据用户名从数据库获取密码</span></span><br><span class="line">        String password = <span class="string">"123"</span>;</span><br><span class="line">        <span class="keyword">if</span> (userName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AccountException(<span class="string">"用户名不正确"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!userPwd.equals(password )) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AccountException(<span class="string">"密码不正确"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(userName, password,getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>说明：</strong><br>
自定义的Realm类继承AuthorizingRealm类，并且重载<code>doGetAuthorizationInfo</code>和<code>doGetAuthenticationInfo</code>两个方法。<br>
<code>doGetAuthorizationInfo</code>： 权限认证，即登录过后，每个身份不一定，对应的所能看的页面也不一样。<br>
<code>doGetAuthenticationInfo</code>：身份认证。即登录通过账号和密码验证登陆人的身份信息。</p>
<h2><a name="t8"></a><a name="t8"></a><a id="controller_177"></a>controller类：</h2>
<p>新建一个HomeIndexController类，加入如下代码：</p>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/login"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">defaultLogin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"首页"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/login"</span>, method = RequestMethod.POST)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(@RequestParam(<span class="string">"username"</span>)</span> String username, @<span class="title">RequestParam</span><span class="params">(<span class="string">"password"</span>)</span> String password) </span>&#123;</span><br><span class="line">        <span class="comment">// 从SecurityUtils里边创建一个 subject</span></span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="comment">// 在认证提交前准备 token（令牌）</span></span><br><span class="line">        UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(username, password);</span><br><span class="line">        <span class="comment">// 执行认证登陆</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            subject.login(token);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownAccountException uae) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"未知账户"</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IncorrectCredentialsException ice) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"密码不正确"</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (LockedAccountException lae) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"账户已锁定"</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExcessiveAttemptsException eae) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"用户名或密码错误次数过多"</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AuthenticationException ae) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"用户名或密码不正确！"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (subject.isAuthenticated()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"登录成功"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            token.clear();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"登录失败"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2><a name="t9"></a><a name="t9"></a><a id="_218"></a>测试：</h2>
<p>我们可以使用postman进行测试：<br>
<img src="https://img-blog.csdnimg.cn/20190128143509871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JpY2hlbmc0NzY5,size_16,color_FFFFFF,t_70" alt="登录成功"><br>
ok 身份认证是没问题了，我们再来考虑如何加入权限。</p>
<h1><a name="t10"></a><a name="t10"></a><a id="_223"></a>利用注解配置权限：</h1>
<p>其实，我们完全可以不用注解的形式去配置权限，因为在之前已经加过了：DefaultFilter类中有<code>perms</code>（类似于perms[user:add]）这种形式的。但是试想一下，这种控制的粒度可能会很细，具体到某一个类中的方法，那么如果是配置文件配，是不是每个方法都要加一个perms？但是注解就不一样了，直接写在方法上面，简单快捷。<br>
很简单，主需要在config类中加入如下代码，就能开启注解：</p>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LifecycleBeanPostProcessor <span class="title">lifecycleBeanPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LifecycleBeanPostProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * *</span></span><br><span class="line"><span class="comment">     * 开启Shiro的注解(如<span class="doctag">@RequiresRoles</span>,<span class="doctag">@RequiresPermissions</span>),需借助SpringAOP扫描使用Shiro注解的类,并在必要时进行安全逻辑验证</span></span><br><span class="line"><span class="comment">     * *</span></span><br><span class="line"><span class="comment">     * 配置以下两个bean(DefaultAdvisorAutoProxyCreator(可选)和AuthorizationAttributeSourceAdvisor)即可实现此功能</span></span><br><span class="line"><span class="comment">     * * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@DependsOn</span>(&#123;<span class="string">"lifecycleBeanPostProcessor"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultAdvisorAutoProxyCreator <span class="title">advisorAutoProxyCreator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator = <span class="keyword">new</span> DefaultAdvisorAutoProxyCreator();</span><br><span class="line">        advisorAutoProxyCreator.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> advisorAutoProxyCreator;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthorizationAttributeSourceAdvisor <span class="title">authorizationAttributeSourceAdvisor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = <span class="keyword">new</span> AuthorizationAttributeSourceAdvisor();</span><br><span class="line">        authorizationAttributeSourceAdvisor.setSecurityManager(securityManager());</span><br><span class="line">        <span class="keyword">return</span> authorizationAttributeSourceAdvisor;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>新建一个UserController类。如下：</p>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequiresPermissions</span>(<span class="string">"user:list"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/show"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">showUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"这是学生信息"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重复刚才的登录步骤，登录成功后，postman 输入localhost:8080/user/show<br>
<img src="https://img-blog.csdnimg.cn/20190128144923792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JpY2hlbmc0NzY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
确实是没有权限。方法上是   <code>@RequiresPermissions("user:list")</code>，而customRealm中是 <code>user:show</code>、<code>user:admin</code>。我们可以调整下方法上的权限改为<code>user:show</code>。调试一下，发现成功了。<br>
这里有一个问题：当没有权限时，系统会报错，而没有跳转到对应的没有权限的页面，也就是<code>setUnauthorizedUrl</code>这个方法没起作用，这个问题，下一篇会给出解决方案-。-</p>
<h1><a name="t11"></a><a name="t11"></a><a id="_274"></a>密码采用加密方式进行验证：</h1>
<p>其实上面的功能已经基本满足我们的需求了，但是唯一一点美中不足的是，密码都是采用的明文方式进行比对的。那么shiro是否提供给我们一种密码加密的方式呢？答案是肯定。<br>
shiroConfig中加入加密配置：</p>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name = <span class="string">"credentialsMatcher"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> HashedCredentialsMatcher <span class="title">hashedCredentialsMatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      HashedCredentialsMatcher hashedCredentialsMatcher = <span class="keyword">new</span> HashedCredentialsMatcher();</span><br><span class="line">      <span class="comment">// 散列算法:这里使用MD5算法;</span></span><br><span class="line">      hashedCredentialsMatcher.setHashAlgorithmName(<span class="string">"md5"</span>);</span><br><span class="line">      <span class="comment">// 散列的次数，比如散列两次，相当于 md5(md5(""));</span></span><br><span class="line">      hashedCredentialsMatcher.setHashIterations(<span class="number">2</span>);</span><br><span class="line">      <span class="comment">// storedCredentialsHexEncoded默认是true，此时用的是密码加密用的是Hex编码；false时用Base64编码</span></span><br><span class="line">      hashedCredentialsMatcher.setStoredCredentialsHexEncoded(<span class="keyword">true</span>);</span><br><span class="line">      <span class="keyword">return</span> hashedCredentialsMatcher;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>customRealm初始化的时候耶需要做一些改变：</p>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CustomRealm <span class="title">customRealm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CustomRealm customRealm = <span class="keyword">new</span> CustomRealm();</span><br><span class="line">        <span class="comment">// 告诉realm,使用credentialsMatcher加密算法类来验证密文</span></span><br><span class="line">        customRealm.setCredentialsMatcher(hashedCredentialsMatcher());</span><br><span class="line">        customRealm.setCachingEnabled(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> customRealm;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>流程是这样的，用户注册的时候，程序将明文通过加密方式加密，存到数据库的是密文，登录时将密文取出来，再通过shiro将用户输入的密码进行加密对比，一样则成功，不一样则失败。<br>
我们可以看到这里的加密采用的是<code>MD5</code>，而且是加密两次（<code>MD5(MD5)</code>）。<br>
shiro提供了SimpleHash类帮助我们快速加密：</p>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">MD5Pwd</span><span class="params">(String username, String pwd)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加密算法MD5</span></span><br><span class="line">        <span class="comment">// salt盐 username + salt</span></span><br><span class="line">        <span class="comment">// 迭代次数</span></span><br><span class="line">        String md5Pwd = <span class="keyword">new</span> SimpleHash(<span class="string">"MD5"</span>, pwd,</span><br><span class="line">                ByteSource.Util.bytes(username + <span class="string">"salt"</span>), <span class="number">2</span>).toHex();</span><br><span class="line">        <span class="keyword">return</span> md5Pwd;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>也就是说注册的时候调用一下上面的方法得到密文之后，再存入数据库。<br>
在CustomRealm进行身份认证的时候我们也需要作出改变：</p>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"-------身份认证方法--------"</span>);</span><br><span class="line">String userName = (String) authenticationToken.getPrincipal();</span><br><span class="line">String userPwd = <span class="keyword">new</span> String((<span class="keyword">char</span>[]) authenticationToken.getCredentials());</span><br><span class="line"><span class="comment">//根据用户名从数据库获取密码</span></span><br><span class="line">String password = <span class="string">"2415b95d3203ac901e287b76fcef640b"</span>;</span><br><span class="line"><span class="keyword">if</span> (userName == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AccountException(<span class="string">"用户名不正确"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!userPwd.equals(userPwd)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AccountException(<span class="string">"密码不正确"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交给AuthenticatingRealm使用CredentialsMatcher进行密码匹配</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(userName, password,</span><br><span class="line">        ByteSource.Util.bytes(userName + <span class="string">"salt"</span>), getName());</span><br></pre></td></tr></table></figure>

<h2 id="这里唯一需要注意的是："><a href="#这里唯一需要注意的是：" class="headerlink" title="这里唯一需要注意的是："></a><strong><p>这里唯一需要注意的是：</p></strong></h2><blockquote>
<p>你注册的加密方式和设置的加密方式还有Realm中身份认证的方式都是要一模一样的。<br> 本文中的加密<br>：MD5两次、salt=username+salt加密。</p><p></p>
</blockquote>
<h1><a name="t12"></a><a name="t12"></a><a id="_337"></a>总结：</h1>

<p>spirngboot整合shiro其实不难，重点是对shiro的核心概念需要有点了解，不然只知道怎么配，而不知道为什么这么配，就很尴尬了。<br>
> **</p>




]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>boot Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot项目整合ELK、kafka</title>
    <url>/myblog/spring-boot/SpringBoot%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88ELK%E3%80%81kafka/</url>
    <content><![CDATA[<div class="htmledit_views" id="content_views">
                                            <p>本篇文章主要介绍使用Spring Boot整合log4j，配合ELK（Elasticsearch , Logstash, Kibana）整合Kafka完成日志收集，应用场景比较多的是分布式项目，这样可以直接收集各个节点的日志到一起，便于错误日志查看和分析业务。</p>
<a id="more"></a>
<p><span style="color:#f33b45;">整个流程如下：</span></p>

<p><span style="color:#f33b45;">使用log4j的appender发送数据到kafka到topic，topic再发送到logstash，然后经过elasticsearch分析处理后到kibana页面做查询展示。</span></p>

<p><span style="color:#f33b45;">环境准备：</span></p>

<p>1、安装ELK</p>

<p>2、安装kafka</p>

<p>3、Spring Boot项目demo</p>

<h2><a name="t0"></a><a name="t0"></a>简要步骤：</h2>

<p>①、修改logj配置文件</p>

<p>②、加入日志打印代码</p>

<p>③、启动项目访问页面</p>

<p>④、使用kafka查看消费者打印</p>

<p>⑤、使用kibana建立日志索引</p>

<p>⑥、使用kibana查询日志、es语法查询</p>

<p>&nbsp;</p>

<h2><a name="t1"></a><a name="t1"></a>详细步骤：</h2>

<h3><a name="t2"></a><a name="t2"></a><a name="t2"></a>一、修改logj配置文件</h3>

<p><span style="color:#f33b45;">注：本项目demo是基于之前到Spring Boot入门教程的一个整合JPA 和 Thymeleaf示例。</span></p>

<p>Spring Boot2.0系列教程之 JPA 和 Thymeleaf 实践（五）：<a href="https://blog.csdn.net/zjh_746140129/article/details/81254965" target="_blank" rel="noopener">Spring Boot2.0系列教程之 JPA 和 Thymeleaf 实践（五）</a></p>

<p><span style="color:#f33b45;">配置文件logback-spring.xml</span></p>

<p><span style="color:#f33b45;"><img alt class="has" src="https://img-blog.csdnimg.cn/20190302173422381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pqaF83NDYxNDAxMjk=,size_16,color_FFFFFF,t_70"></span></p>

<pre class="has" name="code"><code class="hljs xml"><ol class="hljs-ln hundred" style="width:1046px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="php"><span class="hljs-meta">&lt;?</span>xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span><span class="hljs-meta">?&gt;</span></span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span> <span class="hljs-attr">debug</span>=<span class="hljs-string">"false"</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;<span class="hljs-name">springProperty</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">"context"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"LOG_HOME"</span> <span class="hljs-attr">source</span>=<span class="hljs-string">"logback.file.path"</span> <span class="hljs-attr">defaultValue</span>=<span class="hljs-string">"E:\a_hadoop\All_logs"</span>/&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;<span class="hljs-name">springProperty</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">"context"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"LOG_LEVEL"</span> <span class="hljs-attr">source</span>=<span class="hljs-string">"logback.level"</span> <span class="hljs-attr">defaultValue</span>=<span class="hljs-string">"info"</span>/&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;<span class="hljs-name">springProperty</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">"context"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"SERVER_NAME"</span> <span class="hljs-attr">source</span>=<span class="hljs-string">"spring.application.name"</span> <span class="hljs-attr">defaultValue</span>=<span class="hljs-string">"boot_demo"</span>/&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-comment">&lt;!--&lt;property name="LOG_HOME" value="D:/application/logs/enett" /&gt;--&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-comment">&lt;!--&lt;property name="LOG_HOME" value="/Users/ailk/test/ysl" /&gt;--&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"SEF_Level"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"INFO"</span> /&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-comment">&lt;!--文件输出的格式设置 --&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"FILE"</span></span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">           <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-comment">&lt;!-- 文件输出的日志 的格式 --&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">         <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="18"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            ${SERVER_NAME} ${NODE_FLAG} %level %date{yyyy-MM-dd HH:mm:ss.SSS} %logger[%line] %msg%n</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="19"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">         <span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="20"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="21"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="22"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="23"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-comment">&lt;!-- 配置日志所生成的目录以及生成文件名的规则 在logs/mylog-2016-10-31.0.log --&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="24"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="25"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">         <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>${LOG_HOME}/${SERVER_NAME}/info/info-%d{yyyy-MM-dd}.%i.log<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="26"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">         <span class="hljs-tag">&lt;<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span></span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="27"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">               <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>&gt;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="28"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-comment">&lt;!-- 最大64MB 超过最大值，会重新建一个文件--&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="29"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>10 MB<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="30"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">         <span class="hljs-tag">&lt;/<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="31"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="32"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="33"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="34"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="35"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="36"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="37"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="38"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="39"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="40"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="41"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="42"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-comment">&lt;!--控制台输出的格式设置 --&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="43"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"STDOUT"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="44"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-comment">&lt;!-- 控制台输出的日志 的格式 --&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="45"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="46"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">         <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="47"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            ${SERVER_NAME} ${NODE_FLAG} %level %date{yyyy-MM-dd HH:mm:ss.SSS} %logger[%line] %msg%n</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="48"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">         <span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="49"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="50"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-comment">&lt;!-- 只是DEBUG级别以上的日志才显示 --&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="51"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="52"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">         <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>DEBUG<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="53"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="54"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="55"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="56"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="57"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="58"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="59"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="60"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="61"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    操作日志</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="62"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"DruidLog"</span></span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="63"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">           <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="64"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-comment">&lt;!-- 文件输出的日志 的格式 --&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="65"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="66"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">         <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="67"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            ${SERVER_NAME} ${NODE_FLAG} %level %date{yyyy-MM-dd HH:mm:ss.SSS} %logger[%line] %msg%n</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="68"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">         <span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="69"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="70"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="71"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="72"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-comment">&lt;!-- 配置日志所生成的目录以及生成文件名的规则 在logs/mylog-2016-10-31.0.log --&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="73"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="74"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">         <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>${LOG_HOME}/${SERVER_NAME}/Druid/DruidLog-%d{yyyy-MM-dd}.%i.log<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="75"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">         <span class="hljs-tag">&lt;<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span></span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="76"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">               <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>&gt;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="77"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-comment">&lt;!-- 最大64MB 超过最大值，会重新建一个文件--&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="78"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>10 MB<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="79"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">         <span class="hljs-tag">&lt;/<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="80"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="81"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="82"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="83"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="84"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="85"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="86"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="87"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"kafkaAppender"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.github.danielwegener.logback.kafka.KafkaAppender"</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="88"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="89"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="90"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">         <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>${SERVER_NAME} ${NODE_FLAG} %level %date{yyyy-MM-dd HH:mm:ss.SSS} %logger[%line] %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="91"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">         <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>utf8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="92"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="93"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-tag">&lt;<span class="hljs-name">topic</span>&gt;</span>boot_demo<span class="hljs-tag">&lt;/<span class="hljs-name">topic</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="94"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-tag">&lt;<span class="hljs-name">keyingStrategy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.github.danielwegener.logback.kafka.keying.NoKeyKeyingStrategy"</span>/&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="95"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-tag">&lt;<span class="hljs-name">deliveryStrategy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.github.danielwegener.logback.kafka.delivery.AsynchronousDeliveryStrategy"</span>/&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="96"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      　　　　 <span class="hljs-comment">&lt;!--注意此处应该是spring boot中的kafka配置属性--&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="97"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-tag">&lt;<span class="hljs-name">producerConfig</span>&gt;</span>bootstrap.servers=192.168.234.156:9092<span class="hljs-tag">&lt;/<span class="hljs-name">producerConfig</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="98"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      　　　　 <span class="hljs-tag">&lt;<span class="hljs-name">producerConfig</span>&gt;</span>retries=1<span class="hljs-tag">&lt;/<span class="hljs-name">producerConfig</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="99"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="100"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      　　　　<span class="hljs-tag">&lt;<span class="hljs-name">producerConfig</span>&gt;</span>batch-size=16384<span class="hljs-tag">&lt;/<span class="hljs-name">producerConfig</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="101"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      　　　　<span class="hljs-tag">&lt;<span class="hljs-name">producerConfig</span>&gt;</span>buffer-memory=33554432<span class="hljs-tag">&lt;/<span class="hljs-name">producerConfig</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="102"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      　　　　<span class="hljs-tag">&lt;<span class="hljs-name">producerConfig</span>&gt;</span>properties.max.request.size==2097152<span class="hljs-tag">&lt;/<span class="hljs-name">producerConfig</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="103"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="104"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="105"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="106"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="107"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="108"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="109"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="110"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment"><span class="hljs-comment">&lt;!--   &lt;logger name="com.alibaba.druid" additivity="false"  level="INFO"&gt;</span></span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="111"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">      &lt;appender-ref ref="DruidLog" /&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="112"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">   &lt;/logger&gt;--&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="113"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="114"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="115"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="116"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="117"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"org.springframework"</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"${SEF_Level}"</span> /&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="118"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"com.baomidou"</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"${SEF_Level}"</span> /&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="119"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"org.apache"</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"${SEF_Level}"</span> /&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="120"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"org.mybatis"</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"${SEF_Level}"</span> /&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="121"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"org.hibernate"</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"${SEF_Level}"</span> /&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="122"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"io.netty"</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"${SEF_Level}"</span> /&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="123"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"ch.qos"</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"${SEF_Level}"</span> /&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="124"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"org.eclipse"</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"${SEF_Level}"</span> /&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="125"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"org.thymeleaf"</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"${SEF_Level}"</span> /&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="126"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"io.lettuce"</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"${SEF_Level}"</span> /&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="127"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"com.xxl"</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"${SEF_Level}"</span> /&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="128"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"com.ctrip"</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"${SEF_Level}"</span> /&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="129"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"com.ulisesbocchio"</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"${SEF_Level}"</span> /&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="130"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"com.netflix"</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"${SEF_Level}"</span> /&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="131"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="132"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-comment">&lt;!--myibatis log configure--&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="133"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"com.apache.ibatis"</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"${SEF_Level}"</span>/&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="134"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"java.sql.Connection"</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"${SEF_Level}"</span>/&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="135"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"java.sql.Statement"</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"${SEF_Level}"</span>/&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="136"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"java.sql.PreparedStatement"</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"${SEF_Level}"</span>/&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="137"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"tk.mybatis.mapper"</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"${SEF_Level}"</span> /&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="138"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"com.github.pagehelperr"</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"${SEF_Level}"</span> /&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="139"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"org.apache.kafka"</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"${SEF_Level}"</span> /&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="140"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"c.u.jasyptspringboot"</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"${SEF_Level}"</span> /&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="141"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"com.ulisesbocchio.jasyptspringboot"</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"${SEF_Level}"</span> /&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="142"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"org.springframework.context.annotation"</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"${SEF_Level}"</span> /&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="143"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"org.springframework.beans.factory.annotation"</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"${SEF_Level}"</span> /&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="144"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"org.springframework.context.support"</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"${SEF_Level}"</span> /&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="145"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"com.netflix.discovery.shared.resolver.aws.ConfigClusterResolver"</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"${SEF_Level}"</span> /&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="146"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="147"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="148"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="149"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-comment"><span class="hljs-comment">&lt;!--   &lt;root level="${LOG_LEVEL}"&gt;</span></span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="150"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">         &lt;appender-ref ref="STDOUT" /&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="151"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">      &lt;/root&gt;--&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="152"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="153"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"${LOG_LEVEL}"</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="154"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">         <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"FILE"</span> /&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="155"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">         <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"STDOUT"</span> /&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="156"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">         <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"kafkaAppender"</span>  /&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="157"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="158"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="159"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre>

<p></p>

<p>&nbsp;</p>

<h3><a name="t3"></a><a name="t3"></a>二、加入日志打印代码</h3>

<p><span style="color:#f33b45;">1、日志格式化类、json工具类</span></p>

<p><span style="color:#f33b45;"><img alt class="has" src="https://img-blog.csdnimg.cn/20190302173532509.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pqaF83NDYxNDAxMjk=,size_16,color_FFFFFF,t_70"></span></p>

<p><span style="color:#f33b45;">2、日志打印方法调整</span><span style="color:#f33b45;">，这里后续可以在kibana中看到日志</span></p>

<p><span style="color:#f33b45;"><img alt class="has" src="https://img-blog.csdnimg.cn/2019030217360223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pqaF83NDYxNDAxMjk=,size_16,color_FFFFFF,t_70"></span></p>

<p><span style="color:#f33b45;">3、json工具类代码</span></p>

<pre class="has" name="code"><code class="hljs java"><ol class="hljs-ln"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">package</span> com.boot.config;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">import</span> com.google.gson.Gson;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">import</span> java.lang.reflect.Type;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">import</span> java.util.List;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">import</span> java.util.Map;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment"><span class="hljs-comment">/**</span></span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment"> * JSON工具类</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment"> *</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> zhoujh</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment"> */</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JSONUtil</span> </span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Gson gson = <span class="hljs-keyword">null</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="18"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="19"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">static</span> {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="20"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        gson = <span class="hljs-keyword">new</span> Gson();<span class="hljs-comment">// yyyy-MM-dd HH:mm:ss</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="21"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="22"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="23"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Gson <span class="hljs-title">newInstance</span><span class="hljs-params">()</span> </span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="24"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">if</span> (gson == <span class="hljs-keyword">null</span>) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="25"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            gson = <span class="hljs-keyword">new</span> Gson();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="26"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="27"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">return</span> gson;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="28"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="29"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="30"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-comment"><span class="hljs-comment">/**</span></span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="31"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">     * 从对象生成JSON字符串</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="32"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">     *</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="33"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> obj 任意对象</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="34"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">     */</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="35"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">toJson</span><span class="hljs-params">( Object obj )</span> </span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="36"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">return</span> gson.toJson(obj);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="37"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="38"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="39"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">toJsonByFastJson</span><span class="hljs-params">( Object obj )</span> </span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="40"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">return</span>  JSON.toJSONString(obj);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="41"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="42"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="43"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-comment"><span class="hljs-comment">/**</span></span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="44"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">     * JSON字符串转为JavaBean</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="45"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">     *</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="46"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> json JSON字符串</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="47"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">     */</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="48"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">jsonToBean</span><span class="hljs-params">( String json, Class&lt;T&gt; cls )</span> </span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="49"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">return</span> gson.fromJson(json, cls);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="50"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="51"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">jsonToBeanByFastJson</span><span class="hljs-params">( String json, Class&lt;T&gt; cls )</span> </span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="52"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">return</span> JSON.parseObject(json, cls);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="53"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="54"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="55"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-comment"><span class="hljs-comment">/**</span></span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="56"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">     * JSON字符串转为JavaBean</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="57"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">     *</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="58"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> json JSON字符串</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="59"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">     */</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="60"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">jsonToList</span><span class="hljs-params">( String json, Type type )</span> </span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="61"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">return</span> gson.fromJson(json, type);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="62"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="63"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="64"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">jsonToListByFastJson</span><span class="hljs-params">( String json, Class&lt;T&gt; cls)</span></span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="65"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">       <span class="hljs-keyword">return</span> JSON.parseArray(json,cls);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="66"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="67"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-comment"><span class="hljs-comment">/**</span></span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="68"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">     * JSON字符串转为JavaBean</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="69"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">     *</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="70"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> json JSON字符串</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="71"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">     */</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="72"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Map&lt;String, T&gt; <span class="hljs-title">jsonToMap</span><span class="hljs-params">( String json, Type type )</span> </span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="73"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">return</span> gson.fromJson(json, type);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="74"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="75"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="76"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">}</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="77"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre>

<p><span style="color:#f33b45;">4、日志工具类代码</span></p>

<pre class="has" name="code"><code class="hljs java"><ol class="hljs-ln hundred" style="width:1119px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">package</span> com.boot.config;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">import</span> com.google.gson.Gson;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">import</span> org.apache.commons.logging.Log;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">import</span> org.apache.commons.logging.LogFactory;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">import</span> java.util.HashMap;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment"><span class="hljs-comment">/**</span></span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment"> * 基础日志类</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment"> *</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> zhoujh</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 20180709</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment"> */</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogUtil</span> </span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Log log = LogFactory.getLog(LogUtil.class);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="18"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String thisClassName = LogUtil.class.getName();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="19"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-comment">//信息分隔符</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="20"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String msgSplit = <span class="hljs-string">":"</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="21"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-comment">//是否要定位服务</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="22"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> showLocSrc = <span class="hljs-keyword">true</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="23"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-comment">//是否显示日志</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="24"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> enabled = <span class="hljs-keyword">true</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="25"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-comment">//显示等级</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="26"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> level = <span class="hljs-number">1</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="27"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> debug = <span class="hljs-number">1</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="28"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> info = <span class="hljs-number">2</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="29"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> warn = <span class="hljs-number">3</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="30"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> error = <span class="hljs-number">4</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="31"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="32"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="33"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="34"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="35"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">     <span class="hljs-comment"><span class="hljs-comment">/*</span></span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="36"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">        日志记录具体使用规则如下：</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="37"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">        Error：所有异常捕获的Catch节点中异常内容用此级别进行记录（如：Exception对象的e.ToString()）</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="38"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">        Warn：所有验证未通过时用此级别进行记录（暂时只用来记录接口请求或通知等验证未通过需要警告进行跟进的操作）（如：签名解析失败记录）</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="39"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">        Info：功能日常交互信息类用此级别进行记录（如：请求接口参数、接口响应参数等）</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="40"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">        Debug：业务代码交互或调试使用此级别进行记录，但只存在于开发及测试环境，生产环境将会禁用不会记录（如：xx对象信息或xx对象json等）</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="41"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">        日志记录格式如下：</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="42"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">        【传入参数（如：操作ID、订单ID、票号、金额等）】【具体内容】 /n Exception堆栈信息（Exception记录必须使用e.ToString()记录堆栈信息）</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="43"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">    */</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="44"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="45"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-comment">/* 日志格式化文本 */</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="46"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String LOGFORMAT = <span class="hljs-string">"【%s】【%s】"</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="47"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="48"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">getLogContent</span><span class="hljs-params">(String pContent, Object... pParameters)</span> </span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="49"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="50"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        String fParameters = <span class="hljs-string">""</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="51"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != pParameters &amp;&amp; <span class="hljs-number">0</span> &lt; pParameters.length) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="52"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            Gson gson = <span class="hljs-keyword">new</span> Gson();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="53"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            fParameters = String.format(<span class="hljs-string">"参数：%s"</span>, gson.toJson(pParameters));</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="54"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="55"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="56"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">return</span> String.format(LOGFORMAT, pContent, fParameters);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="57"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="58"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="59"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="60"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="61"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-comment"><span class="hljs-comment">/**</span></span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="62"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">     * 记录Debug级日志[业务代码交互或调试使用此级别进行记录，但只存在于开发及测试环境，生产环境将会禁用不会记录（如：xx对象信息或xx对象json等）]</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="63"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">     *</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="64"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> content 信息综述</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="65"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>  parameters 详述</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="66"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">     */</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="67"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debug</span><span class="hljs-params">(String content)</span> </span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="68"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        debug(content,<span class="hljs-string">""</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="69"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="70"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="71"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debug</span><span class="hljs-params">(String content, Object parameters)</span> </span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="72"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        debug(content, JSONUtil.toJson(parameters));</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="73"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="74"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="75"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debug</span><span class="hljs-params">(String content, String parameters)</span> </span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="76"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">       String message=String.format(LOGFORMAT, content, parameters);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="77"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">if</span> (!enabled || debug &lt; level)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="78"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-keyword">return</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="79"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">if</span> (showLocSrc) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="80"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            log(debug, message, Thread.currentThread().getStackTrace(),<span class="hljs-keyword">null</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="81"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        } <span class="hljs-keyword">else</span> {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="82"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            log(debug, message, <span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="83"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="84"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="85"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="86"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="87"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="88"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="89"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="90"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="91"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-comment"><span class="hljs-comment">/**</span></span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="92"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">     * 记录Info级日志[功能日常交互信息类用此级别进行记录（如：请求接口参数、接口响应参数等）]</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="93"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">     *</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="94"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> content 信息综述</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="95"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>  parameters 详述</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="96"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">     */</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="97"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">info</span><span class="hljs-params">(String content)</span> </span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="98"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        info(content,<span class="hljs-string">""</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="99"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="100"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="101"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">info</span><span class="hljs-params">(String content, Object parameters)</span> </span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="102"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        info(content, JSONUtil.toJson(parameters));</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="103"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="104"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="105"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">info</span><span class="hljs-params">(String content, String parameters)</span> </span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="106"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        String message=String.format(LOGFORMAT, content, parameters);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="107"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">if</span> (!enabled || info &lt; level)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="108"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-keyword">return</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="109"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">if</span> (showLocSrc) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="110"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            log(info, message, Thread.currentThread().getStackTrace(),<span class="hljs-keyword">null</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="111"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        } <span class="hljs-keyword">else</span> {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="112"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            log(info, message, <span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="113"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="114"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="115"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="116"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="117"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="118"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="119"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-comment"><span class="hljs-comment">/**</span></span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="120"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">     * 记录Warn级日志[所有验证未通过时用此级别进行记录（暂时只用来记录接口请求或通知等验证未通过需要警告进行跟进的操作）（如：签名解析失败记录）]</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="121"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">     *</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="122"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> content 信息综述</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="123"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>  parameters 详述</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="124"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">     */</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="125"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">warn</span><span class="hljs-params">(String content)</span> </span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="126"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        warn(content,<span class="hljs-string">""</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="127"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="128"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="129"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">warn</span><span class="hljs-params">(String content, Object parameters)</span> </span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="130"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        warn(content, JSONUtil.toJson(parameters));</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="131"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="132"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="133"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">warn</span><span class="hljs-params">(String content, String parameters)</span> </span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="134"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        String message=String.format(LOGFORMAT, content, parameters);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="135"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">if</span> (!enabled || warn &lt; level)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="136"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-keyword">return</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="137"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">if</span> (showLocSrc) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="138"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            log(warn, message, Thread.currentThread().getStackTrace(),<span class="hljs-keyword">null</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="139"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        } <span class="hljs-keyword">else</span> {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="140"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            log(warn, message, <span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="141"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="142"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="143"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="144"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="145"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="146"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="147"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="148"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-comment"><span class="hljs-comment">/**</span></span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="149"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">     * Error：所有异常捕获的Catch节点中异常内容用此级别进行记录（如：Exception对象的e.ToString()）</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="150"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">     *</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="151"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span></span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="152"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> content 信息综述</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="153"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>  parameters 详述</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="154"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e          异常信息</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="155"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">     */</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="156"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">error</span><span class="hljs-params">(String content)</span> </span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="157"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        error(content,<span class="hljs-string">""</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="158"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="159"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="160"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">error</span><span class="hljs-params">(String content, Object parameters)</span> </span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="161"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        error(content, JSONUtil.toJson(parameters));</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="162"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="163"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="164"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">error</span><span class="hljs-params">(String content, String parameters)</span> </span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="165"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        String message=String.format(LOGFORMAT, content, parameters);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="166"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">if</span> (!enabled || error &lt; level)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="167"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-keyword">return</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="168"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">if</span> (showLocSrc) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="169"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            log(error, message, Thread.currentThread().getStackTrace(),<span class="hljs-keyword">null</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="170"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        } <span class="hljs-keyword">else</span> {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="171"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            log(error, message, <span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="172"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="173"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="174"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="175"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">error</span><span class="hljs-params">(String content,Exception e)</span> </span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="176"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        error(content,<span class="hljs-string">""</span>,e);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="177"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="178"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="179"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">error</span><span class="hljs-params">(String content, Object parameters,Exception e)</span> </span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="180"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        error(content, JSONUtil.toJson(parameters),e);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="181"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="182"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="183"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">error</span><span class="hljs-params">(String content, String parameters,Exception e)</span> </span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="184"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        String message=String.format(LOGFORMAT, content, parameters);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="185"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">if</span> (!enabled || error &lt; level)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="186"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-keyword">return</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="187"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">if</span> (showLocSrc) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="188"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            log(error, message, Thread.currentThread().getStackTrace(),e);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="189"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        } <span class="hljs-keyword">else</span> {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="190"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            log(error, message, <span class="hljs-keyword">null</span>,e);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="191"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="192"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="193"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="194"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="195"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getStackMsg</span><span class="hljs-params">(StackTraceElement[] ste)</span> </span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="196"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">if</span> (ste == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="197"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="198"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">boolean</span> srcFlag = <span class="hljs-keyword">false</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="199"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ste.length; i++) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="200"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            StackTraceElement s = ste[i];</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="201"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="202"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-keyword">if</span>(s==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">continue</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="203"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="204"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-comment">// 如果上一行堆栈代码是本类的堆栈，则该行代码则为源代码的最原始堆栈。</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="205"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-keyword">if</span> (srcFlag) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="206"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                <span class="hljs-keyword">if</span>(!thisClassName.equals(s.getClassName()))</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="207"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                    <span class="hljs-keyword">return</span> s.toString();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="208"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="209"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="210"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-comment">// 定位本类的堆栈</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="211"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-keyword">if</span> (thisClassName.equals(s.getClassName())) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="212"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                srcFlag = <span class="hljs-keyword">true</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="213"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="214"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="215"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="216"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="217"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="218"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="219"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-keyword">int</span> level, Object message, StackTraceElement[] ste, Exception e)</span> </span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="220"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">if</span> (ste != <span class="hljs-keyword">null</span>) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="221"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            message = getStackMsg(ste) + msgSplit + message;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="222"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="223"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="224"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">switch</span> (level) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="225"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-keyword">case</span> info:</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="226"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                log.info(message);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="227"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                <span class="hljs-keyword">break</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="228"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-keyword">case</span> debug:</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="229"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                log.debug(message);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="230"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                <span class="hljs-keyword">break</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="231"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-keyword">case</span> warn:</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="232"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                log.warn(message);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="233"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                <span class="hljs-keyword">break</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="234"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-keyword">case</span> error:</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="235"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                log.error(message,e);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="236"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                <span class="hljs-keyword">break</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="237"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-keyword">default</span>:</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="238"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                log.debug(message);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="239"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="240"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="241"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="242"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="243"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        debug(<span class="hljs-string">"ss"</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="244"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        debug(<span class="hljs-string">"sdf"</span>,<span class="hljs-string">"sdf"</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="245"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        debug(<span class="hljs-string">"sdf"</span>,<span class="hljs-keyword">new</span> HashMap());</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="246"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="247"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        info(<span class="hljs-string">"ss"</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="248"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        info(<span class="hljs-string">"sdf"</span>,<span class="hljs-string">"sdf"</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="249"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        info(<span class="hljs-string">"sdf"</span>,<span class="hljs-keyword">new</span> HashMap());</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="250"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="251"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        warn(<span class="hljs-string">"ss"</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="252"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        warn(<span class="hljs-string">"sdf"</span>,<span class="hljs-string">"sdf"</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="253"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        warn(<span class="hljs-string">"sdf"</span>,<span class="hljs-keyword">new</span> HashMap());</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="254"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="255"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="256"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        error(<span class="hljs-string">"ss"</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="257"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        error(<span class="hljs-string">"sdf"</span>,<span class="hljs-string">"sdf"</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="258"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        error(<span class="hljs-string">"sdf"</span>,<span class="hljs-keyword">new</span> HashMap());</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="259"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="260"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        error(<span class="hljs-string">"ss"</span>,<span class="hljs-keyword">new</span> Exception());</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="261"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        error(<span class="hljs-string">"sdf"</span>,<span class="hljs-string">"sdf"</span>,<span class="hljs-keyword">new</span> Exception());</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="262"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        error(<span class="hljs-string">"sdf"</span>,<span class="hljs-keyword">new</span> HashMap(),<span class="hljs-keyword">new</span> Exception());</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="263"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="264"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">}</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre>

<p>&nbsp;</p>

<h3><a name="t4"></a><a name="t4"></a>三、启动项目访问页面</h3>

<p><img alt class="has" src="https://img-blog.csdnimg.cn/20190224144302560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pqaF83NDYxNDAxMjk=,size_16,color_FFFFFF,t_70"></p>

<p>&nbsp;</p>

<h3><a name="t5"></a><a name="t5"></a>四、使用kafka查看消费者打印</h3>

<p><img alt class="has" src="https://img-blog.csdnimg.cn/20190224144344540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pqaF83NDYxNDAxMjk=,size_16,color_FFFFFF,t_70"></p>

<p>&nbsp;</p>

<h3><a name="t6"></a><a name="t6"></a>五、使用kibana建立日志索引</h3>

<p><img alt class="has" src="https://img-blog.csdnimg.cn/20190224144401610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pqaF83NDYxNDAxMjk=,size_16,color_FFFFFF,t_70"></p>

<p>已经看到日志&nbsp;</p>

<p><img alt class="has" src="https://img-blog.csdnimg.cn/20190224144643972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pqaF83NDYxNDAxMjk=,size_16,color_FFFFFF,t_70"></p>

<p>点击创建需要等待</p>

<p><img alt class="has" src="https://img-blog.csdnimg.cn/20190224144718433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pqaF83NDYxNDAxMjk=,size_16,color_FFFFFF,t_70"></p>

<p>成功后可以看到创建的索引</p>

<p>&nbsp;</p>

<p><img alt class="has" src="https://img-blog.csdnimg.cn/20190224144808539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pqaF83NDYxNDAxMjk=,size_16,color_FFFFFF,t_70"></p>

<p>&nbsp;</p>

<h3><a name="t7"></a><a name="t7"></a>六、使用kibana查询日志、es语法查询</h3>

<p>1、这里选择查询时间段</p>

<p><img alt class="has" src="https://img-blog.csdnimg.cn/20190224144911333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pqaF83NDYxNDAxMjk=,size_16,color_FFFFFF,t_70"></p>

<p>&nbsp;</p>

<p>可以查看到日志</p>

<p><img alt class="has" src="https://img-blog.csdnimg.cn/20190224144947581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pqaF83NDYxNDAxMjk=,size_16,color_FFFFFF,t_70"></p>

<p><img alt class="has" src="https://img-blog.csdnimg.cn/20190224145000217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pqaF83NDYxNDAxMjk=,size_16,color_FFFFFF,t_70"></p>

<p>2、&nbsp;用es语法查询</p>

<p><img alt class="has" src="https://img-blog.csdnimg.cn/20190224145035268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pqaF83NDYxNDAxMjk=,size_16,color_FFFFFF,t_70"></p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p><span style="color:#f33b45;">推荐笔者elk、kafka、Springboot相关博客：</span></p>

<p>ELK架构体系、ELK运行原理、ELK应用场景、ELK简单介绍（一）：<a href="https://blog.csdn.net/zjh_746140129/article/details/86483318" target="_blank" rel="noopener">https://blog.csdn.net/zjh_746140129/article/details/86483318</a></p>

<p>Linux安装ELK、elasticsearch部署安装（二）：<a href="https://blog.csdn.net/zjh_746140129/article/details/86483661" target="_blank" rel="noopener">https://blog.csdn.net/zjh_746140129/article/details/86483661</a></p>

<p>Linux安装ELK、logstash部署安装（三）：<a href="https://blog.csdn.net/zjh_746140129/article/details/86484586" target="_blank" rel="noopener">https://blog.csdn.net/zjh_746140129/article/details/86484586</a></p>

<p>Linux安装ELK、kibana部署安装（四）：<a href="https://blog.csdn.net/zjh_746140129/article/details/86484862" target="_blank" rel="noopener">https://blog.csdn.net/zjh_746140129/article/details/86484862</a></p>

<p>ELK启动报错：OpenJDK 64-Bit Server VM warning：<a href="https://blog.csdn.net/zjh_746140129/article/details/86601574" target="_blank" rel="noopener">https://blog.csdn.net/zjh_746140129/article/details/86601574</a></p>

<p>ELK常见错误问题、ELK的一些坑、Unable to connect to Elasticsearch at http://localhost:9200：<a href="https://blog.csdn.net/zjh_746140129/article/details/86601791" target="_blank" rel="noopener">https://blog.csdn.net/zjh_746140129/article/details/86601791</a></p>

<p>Centons7下安装配置Kafka、Linux下安装配置Kafka：<a href="https://blog.csdn.net/zjh_746140129/article/details/84191058" target="_blank" rel="noopener">Centons7下安装配置Kafka、Linux下安装配置Kafka</a></p>

<p>Spring Boot2.0系列教程之 JPA 和 Thymeleaf 实践（五）：<a href="https://blog.csdn.net/zjh_746140129/article/details/81254965" target="_blank" rel="noopener">Spring Boot2.0系列教程之 JPA 和 Thymeleaf 实践（五）</a></p>

<p>&nbsp;</p>

<p>&nbsp;</p>
                                    </div>]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>boot</tag>
      </tags>
  </entry>
</search>
