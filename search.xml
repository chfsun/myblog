<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java异常面试题</title>
    <url>/myblog/interview/Java%E5%BC%82%E5%B8%B8%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h4 id="Java异常架构与异常关键字"><a href="#Java异常架构与异常关键字" class="headerlink" title="Java异常架构与异常关键字"></a>Java异常架构与异常关键字</h4><a id="more"></a>
<h5 id="Java异常简介"><a href="#Java异常简介" class="headerlink" title="Java异常简介"></a>Java异常简介</h5><p>Java异常是Java提供的一种识别及响应错误的一致性机制。<br>Java异常机制可以使程序中异常处理代码和正常业务代码分离，保证程序代码更加优雅，并提高程序健壮性。在有效使用异常的情况下，异常能清晰的回答what, where, why这3个问题：异常类型回答了“什么”被抛出，异常堆栈跟踪回答了“在哪”抛出，异常信息回答了“为什么”会抛出。<br>Java异常架构</p>
<p><img src="https://img-blog.csdnimg.cn/20200314173417278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt></p>
<ol>
<li><h5 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h5></li>
</ol>
<p>Throwable 是 Java 语言中所有错误与异常的超类。</p>
<p>Throwable 包含两个子类：Error（错误）和 Exception（异常），它们通常用于指示发生了异常情况。</p>
<p>Throwable 包含了其线程创建时线程执行堆栈的快照，它提供了 printStackTrace() 等接口用于获取堆栈跟踪数据等信息。</p>
<!--more-->

<ol start="2">
<li><h5 id="Error（错误）"><a href="#Error（错误）" class="headerlink" title="Error（错误）"></a>Error（错误）</h5></li>
</ol>
<p>定义：Error 类及其子类。程序中无法处理的错误，表示运行应用程序中出现了严重的错误。</p>
<p>特点：此类错误一般表示代码运行时 JVM 出现问题。通常有 Virtual MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）等。比如 OutOfMemoryError：内存不足错误；StackOverflowError：栈溢出错误。此类错误发生时，JVM 将终止线程。</p>
<p>这些错误是不受检异常，非代码性错误。因此，当此类错误发生时，应用程序不应该去处理此类错误。按照Java惯例，我们是不应该实现任何新的Error子类的！<br>3. ##### Exception（异常）</p>
<p>程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。</p>
<p><strong>运行时异常</strong></p>
<p><strong>定义</strong>：RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。</p>
<p><strong>特点</strong>：Java 编译器不会检查它。也就是说，当程序中可能出现这类异常时，倘若既”没有通过throws声明抛出它”，也”没有用try-catch语句捕获它”，还是会编译通过。比如NullPointerException空指针异常、ArrayIndexOutBoundException数组下标越界异常、ClassCastException类型转换异常、ArithmeticExecption算术异常。此类异常属于不受检异常，一般是由程序逻辑错误引起的，在程序中可以选择捕获处理，也可以不处理。虽然 Java 编译器不会检查运行时异常，但是我们也可以通过 throws 进行声明抛出，也可以通过 try-catch 对它进行捕获处理。如果产生运行时异常，则需要通过修改代码来进行避免。例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！</p>
<p>RuntimeException 异常会由 Java 虚拟机自动抛出并自动捕获（<strong>就算我们没写异常捕获语句运行时也会抛出错误！！</strong>），此类异常的出现绝大数情况是代码本身有问题应该从逻辑上去解决并改进代码。</p>
<h6 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h6><p><strong>定义</strong>: Exception 中除 RuntimeException 及其子类之外的异常。</p>
<p><strong>特点</strong>: Java 编译器会检查它。如果程序中出现此类异常，比如 ClassNotFoundException（没有找到指定的类异常），IOException（IO流异常），要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。在程序中，通常不会自定义该类异常，而是直接使用系统提供的异常类。该异常我们必须手动在代码里添加捕获语句来处理该异常。</p>
<ol start="4">
<li><h5 id="受检异常与非受检异常"><a href="#受检异常与非受检异常" class="headerlink" title="受检异常与非受检异常"></a>受检异常与非受检异常</h5></li>
</ol>
<p>Java 的所有异常可以分为受检异常（checked exception）和非受检异常（unchecked exception）。</p>
<h6 id="受检异常"><a href="#受检异常" class="headerlink" title="受检异常"></a>受检异常</h6><p>编译器要求必须处理的异常。正确的程序在运行过程中，经常容易出现的、符合预期的异常情况。一旦发生此类异常，就必须采用某种方式进行处理。除 <strong>RuntimeException 及其子类外，其他的 Exception 异常都属于受检异常</strong>。编译器会检查此类异常，也就是说当编译器检查到应用中的某处可能会此类异常时，将会提示你处理本异常——要么使用try-catch捕获，要么使用方法签名中用 throws 关键字抛出，否则编译不通过。</p>
<h6 id="非受检异常"><a href="#非受检异常" class="headerlink" title="非受检异常"></a>非受检异常</h6><p>编译器不会进行检查并且不要求必须处理的异常，也就说当程序中出现此类异常时，即使我们没有try-catch捕获它，也没有使用throws抛出该异常，编译也会正常通过。<strong>该类异常包括运行时异常（RuntimeException极其子类）和错误（Error）。</strong></p>
<h5 id="Java异常关键字"><a href="#Java异常关键字" class="headerlink" title="Java异常关键字"></a>Java异常关键字</h5><p>• <strong>try</strong> – 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。<br>• <strong>catch</strong> – 用于捕获异常。catch用来捕获try语句块中发生的异常。<br>• <strong>finally</strong> – finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。<br>• <strong>throw</strong> – 用于抛出异常。<br>• <strong>throws</strong> – 用在方法签名中，用于声明该方法可能抛出的异常。</p>
<h5 id="Java异常处理"><a href="#Java异常处理" class="headerlink" title="Java异常处理"></a>Java异常处理</h5><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xMC8xNmU1NWYyYzMyMWQ5MDlk?x-oss-process=image/format,png" alt></p>
<p>Java 通过面向对象的方法进行异常处理，一旦方法抛出异常，系统自动根据该异常对象寻找合适异常处理器（Exception Handler）来处理该异常，把各种不同的异常进行分类，并提供了良好的接口。在 Java 中，每个异常都是一个对象，它是 Throwable 类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java 的异常处理是通过 5 个关键词来实现的：try、catch、throw、throws 和 finally。</p>
<p>在Java应用中，异常的处理机制分为声明异常，抛出异常和捕获异常。</p>
<h4 id="声明异常"><a href="#声明异常" class="headerlink" title="声明异常"></a>声明异常</h4><p>通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 throws 关键字声明可能会抛出的异常。</p>
<p>注意</p>
<ul>
<li>非检查异常（Error、RuntimeException 或它们的子类）不可使用 throws 关键字来声明要抛出的异常。</li>
<li>一个方法出现编译时异常，就需要 try-catch/ throws 处理，否则会导致编译错误。</li>
</ul>
<h4 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h4><p>如果你觉得解决不了某些异常问题，且不需要调用者处理，那么你可以抛出异常。</p>
<p>throw关键字作用是在方法内部抛出一个Throwable类型的异常。任何Java代码都可以通过throw语句抛出异常。</p>
<h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4><p>程序通常在运行之前不报错，但是运行后可能会出现某些未知的错误，但是还不想直接抛出到上一级，那么就需要通过try…catch…的形式进行异常捕获，之后根据不同的异常情况来进行相应的处理。</p>
<h4 id="如何选择异常类型"><a href="#如何选择异常类型" class="headerlink" title="如何选择异常类型"></a>如何选择异常类型</h4><p>可以根据下图来选择是捕获异常，声明异常还是抛出异常</p>
<p><img src="https://img-blog.csdnimg.cn/20200314173209267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt></p>
<h4 id="常见异常处理方式"><a href="#常见异常处理方式" class="headerlink" title="常见异常处理方式"></a>常见异常处理方式</h4><h5 id="直接抛出异常"><a href="#直接抛出异常" class="headerlink" title="直接抛出异常"></a>直接抛出异常</h5><p>通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 throws 关键字声明可能会抛出的异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">    String result;</span><br><span class="line">    BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(file));</span><br><span class="line">    <span class="keyword">while</span>((result = reader.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">    reader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="封装异常再抛出"><a href="#封装异常再抛出" class="headerlink" title="封装异常再抛出"></a>封装异常再抛出</h5><p>有时我们会从 catch 中抛出一个异常，目的是为了改变异常的类型。多用于在多系统集成时，当某个子系统故障，异常类型可能有多种，可以用统一的异常类型向外暴露，不需暴露太多内部异常细节。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> MyException </span>&#123;    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        MyException ex = <span class="keyword">new</span> MyException(<span class="string">"read file failed."</span>);</span><br><span class="line">        ex.initCause(e);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="捕获异常-1"><a href="#捕获异常-1" class="headerlink" title="捕获异常"></a>捕获异常</h5><p>在一个 try-catch 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// handle FileNotFoundException</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        <span class="comment">// handle IOException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同一个 catch 也可以捕获多种类型异常，用 | 隔开</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException | UnknownHostException e) &#123;</span><br><span class="line">        <span class="comment">// handle FileNotFoundException or UnknownHostException</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        <span class="comment">// handle IOException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h5><p>习惯上，定义一个异常类应包含两个构造函数，一个无参构造函数和一个带有详细描述信息的构造函数（Throwable 的 toString 方法会打印这些详细信息，调试时很有用）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h5><p>当方法中发生异常，异常处之后的代码不会再执行，如果之前获取了一些本地资源需要释放，则需要在方法正常结束时和 catch 语句中都调用释放本地资源的代码，显得代码比较繁琐，finally 语句可以解决这个问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> MyException </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">    String result;</span><br><span class="line">    BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(file));</span><br><span class="line">        <span class="keyword">while</span>((result = reader.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">"readFile method catch block."</span>);</span><br><span class="line">        MyException ex = <span class="keyword">new</span> MyException(<span class="string">"read file failed."</span>);</span><br><span class="line">        ex.initCause(e);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"readFile method finally block."</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != reader) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用该方法时，读取文件时若发生异常，代码会进入 catch 代码块，之后进入 finally 代码块；若读取文件时未发生异常，则会跳过 catch 代码块直接进入 finally 代码块。所以无论代码中是否发生异常，fianlly 中的代码都会执行。</p>
<p>若 catch 代码块中包含 return 语句，finally 中的代码还会执行吗？将以上代码中的 catch 子句修改如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">"readFile method catch block."</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 readFile 方法，观察当 catch 子句中调用 return 语句时，finally 子句是否执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">readFile method <span class="keyword">catch</span> block.</span><br><span class="line">readFile method <span class="keyword">finally</span> block.</span><br></pre></td></tr></table></figure>

<p>可见，即使 catch 中包含了 return 语句，finally 子句依然会执行。若 finally 中也包含 return 语句，finally 中的 return 会覆盖前面的 return.</p>
<h5 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a>try-with-resource</h5><p>上面例子中，finally 中的 close 方法也可能抛出 IOException, 从而覆盖了原始异常。JAVA 7 提供了更优雅的方式来实现资源的自动释放，自动释放的资源需要是实现了 AutoCloseable 接口的类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tryWithResourceTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (Scanner scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> FileInputStream(<span class="string">"c:/abc"</span>),<span class="string">"UTF-8"</span>))&#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        <span class="comment">// handle exception</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>try 代码块退出时，会自动调用 scanner.close 方法，和把 scanner.close 方法放在 finally 代码块中不同的是，若 scanner.close 抛出异常，则会被抑制，抛出的仍然为原始异常。被抑制的异常会由 addSusppressed 方法添加到原来的异常，如果想要获取被抑制的异常列表，可以调用 getSuppressed 方法来获取。</p>
<h4 id="Java异常常见面试题"><a href="#Java异常常见面试题" class="headerlink" title="Java异常常见面试题"></a>Java异常常见面试题</h4><ol>
<li><h5 id="Error-和-Exception-区别是什么？"><a href="#Error-和-Exception-区别是什么？" class="headerlink" title="Error 和 Exception 区别是什么？"></a>Error 和 Exception 区别是什么？</h5></li>
</ol>
<p>Error 类型的错误通常为虚拟机相关错误，如系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，JAVA 应用程序也不应对这类错误进行捕获，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复；</p>
<p>Exception 类的错误是可以在应用程序中进行捕获并处理的，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。<br>2. ##### 运行时异常和一般异常(受检异常)区别是什么？</p>
<p>运行时异常包括 RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。 Java 编译器不会检查运行时异常。</p>
<p>受检异常是Exception 中除 RuntimeException 及其子类之外的异常。 Java 编译器会检查受检异常。</p>
<p><strong>RuntimeException异常和受检异常之间的区别</strong>：是否强制要求调用者必须处理此异常，如果强制要求调用者必须进行处理，那么就使用受检异常，否则就选择非受检异常(RuntimeException)。一般来讲，如果没有特殊的要求，我们建议使用RuntimeException异常。</p>
<ol start="3">
<li><h5 id="JVM-是如何处理异常的？"><a href="#JVM-是如何处理异常的？" class="headerlink" title="JVM 是如何处理异常的？"></a>JVM 是如何处理异常的？</h5></li>
</ol>
<p>在一个方法中如果发生异常，这个方法会创建一个异常对象，并转交给 JVM，该异常对象包含异常名称，异常描述以及异常发生时应用程序的状态。创建异常对象并转交给 JVM 的过程称为抛出异常。可能有一系列的方法调用，最终才进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈。</p>
<p>JVM 会顺着调用栈去查找看是否有可以处理异常的代码，如果有，则调用异常处理代码。当 JVM 发现可以处理异常的代码时，会把发生的异常传递给它。如果 JVM 没有找到可以处理该异常的代码块，JVM 就会将该异常转交给默认的异常处理器（默认处理器为 JVM 的一部分），默认异常处理器打印出异常信息并终止应用程序。<br>4. ##### throw 和 throws 的区别是什么？</p>
<p>Java 中的异常处理除了包括捕获异常和处理异常之外，还包括声明异常和拋出异常，可以通过 throws 关键字在方法上声明该方法要拋出的异常，或者在方法内部通过 throw 拋出异常对象。</p>
<p><strong>throws 关键字和 throw 关键字在使用上的几点区别如下：</strong></p>
<ul>
<li>throw 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。</li>
<li>throws 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。</li>
</ul>
<ol start="5">
<li><h5 id="final、finally、finalize-有什么区别？"><a href="#final、finally、finalize-有什么区别？" class="headerlink" title="final、finally、finalize 有什么区别？"></a>final、finally、finalize 有什么区别？</h5><ul>
<li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。</li>
<li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li>
<li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，Java 中允许使用 finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。</li>
</ul>
</li>
<li><h5 id="NoClassDefFoundError-和-ClassNotFoundException-区别？"><a href="#NoClassDefFoundError-和-ClassNotFoundException-区别？" class="headerlink" title="NoClassDefFoundError 和 ClassNotFoundException 区别？"></a>NoClassDefFoundError 和 ClassNotFoundException 区别？</h5></li>
</ol>
<p>NoClassDefFoundError 是一个 Error 类型的异常，是由 JVM 引起的，不应该尝试捕获这个异常。</p>
<p>引起该异常的原因是 JVM 或 ClassLoader 尝试加载某类时在内存中找不到该类的定义，该动作发生在运行期间，即编译时该类存在，但是在运行时却找不到了，可能是变异后被删除了等原因导致；</p>
<p>ClassNotFoundException 是一个受查异常，需要显式地使用 try-catch 对其进行捕获和处理，或在方法签名中用 throws 关键字进行声明。当使用 Class.forName, ClassLoader.loadClass 或 ClassLoader.findSystemClass 动态加载类到内存的时候，通过传入的类路径参数没有找到该类，就会抛出该异常；另一种抛出该异常的可能原因是某个类已经由一个类加载器加载至内存中，另一个加载器又尝试去加载它。<br>7. ##### try-catch-finally 中哪个部分可以省略？</p>
<p>答：catch 可以省略</p>
<p><strong>原因</strong></p>
<p>更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以catch可以省略，你加上catch编译器也觉得无可厚非。</p>
<p>理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾处理，或者加上catch捕获以便进一步处理。</p>
<p>至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。<br>8. ##### try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</p>
<p>答：会执行，在 return 前执行。</p>
<p>注意：在 finally 中改变返回值的做法是不好的，因为如果存在 finally 代码块，try中的 return 语句不会立马返回调用者，而是记录下返回值待 finally 代码块执行完毕之后再向调用者返回其值，然后如果在 finally 中修改了返回值，就会返回修改后的值。显然，在 finally 中返回或者修改返回值会对程序造成很大的困扰，C#中直接用编译错误的方式来阻止程序员干这种龌龊的事情，Java 中也可以通过提升编译器的语法检查级别来产生警告或错误。</p>
<p>代码示例1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(a / <span class="number">0</span>);</span><br><span class="line">        a = <span class="number">20</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">        a = <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了</span></span><br><span class="line"><span class="comment">         * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40</span></span><br><span class="line"><span class="comment">         * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        a = <span class="number">40</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：30</p>
<p>代码示例2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(a / <span class="number">0</span>);</span><br><span class="line">        a = <span class="number">20</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">        a = <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        a = <span class="number">40</span>;</span><br><span class="line">        <span class="comment">//如果这样，就又重新形成了一条返回路径，由于只能通过1个return返回，所以这里直接返回40</span></span><br><span class="line">        <span class="keyword">return</span> a; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：40<br>9. 类 ExampleA 继承 Exception，类 ExampleB 继承ExampleA。</p>
<p>有如下代码片断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> ExampleB(<span class="string">"b"</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span>（ExampleA e）&#123;</span><br><span class="line">	System.out.println(<span class="string">"ExampleA"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>（Exception e）&#123;</span><br><span class="line">	System.out.println(<span class="string">"Exception"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问执行此段代码的输出是什么？</p>
<p>答：</p>
<p>输出：ExampleA。（根据里氏代换原则[能使用父类型的地方一定能使用子类型]，抓取 ExampleA 类型异常的 catch 块能够抓住 try 块中抛出的 ExampleB 类型的异常）</p>
<p>面试题 - 说出下面代码的运行结果。（此题的出处是《Java 编程思想》一书）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Annoyance</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sneeze</span> <span class="keyword">extends</span> <span class="title">Annoyance</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> Sneeze();</span><br><span class="line">			&#125; <span class="keyword">catch</span> ( Annoyance a ) &#123;</span><br><span class="line">				System.out.println(<span class="string">"Caught Annoyance"</span>);</span><br><span class="line">				<span class="keyword">throw</span> a;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> ( Sneeze s ) &#123;</span><br><span class="line">			System.out.println(<span class="string">"Caught Sneeze"</span>);</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Caught Annoyance</span><br><span class="line">Caught Sneeze</span><br><span class="line">Hello World!xxxxxxxxxx Caught AnnoyanceCaught SneezeHello World!<span class="number">123</span></span><br></pre></td></tr></table></figure>

<ol start="10">
<li><h5 id="常见的-RuntimeException-有哪些？"><a href="#常见的-RuntimeException-有哪些？" class="headerlink" title="常见的 RuntimeException 有哪些？"></a>常见的 RuntimeException 有哪些？</h5><ul>
<li><p>ClassCastException(类转换异常)</p>
</li>
<li><p>IndexOutOfBoundsException(数组越界)</p>
</li>
<li><p>NullPointerException(空指针)</p>
</li>
<li><p>ArrayStoreException(数据存储异常，操作数组时类型不一致)</p>
</li>
<li><p>还有IO操作的BufferOverflowException异常</p>
</li>
</ul>
</li>
</ol>
<ol start="11">
<li><h5 id="Java常见异常有哪些"><a href="#Java常见异常有哪些" class="headerlink" title="Java常见异常有哪些"></a>Java常见异常有哪些</h5></li>
</ol>
<p>java.lang.IllegalAccessError：违法访问错误。当一个应用试图访问、修改某个类的域（Field）或者调用其方法，但是又违反域或方法的可见性声明，则抛出该异常。</p>
<p>java.lang.InstantiationError：实例化错误。当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常.</p>
<p>java.lang.OutOfMemoryError：内存不足错误。当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。</p>
<p>java.lang.StackOverflowError：堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出或者陷入死循环时抛出该错误。</p>
<p>java.lang.ClassCastException：类造型异常。假设有类A和B（A不是B的父类或子类），O是A的实例，那么当强制将O构造为类B的实例时抛出该异常。该异常经常被称为强制类型转换异常。</p>
<p>java.lang.ClassNotFoundException：找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。</p>
<p>java.lang.ArithmeticException：算术条件异常。譬如：整数除零等。</p>
<p>java.lang.ArrayIndexOutOfBoundsException：数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</p>
<p>java.lang.IndexOutOfBoundsException：索引越界异常。当访问某个序列的索引值小于0或大于等于序列大小时，抛出该异常。</p>
<p>java.lang.InstantiationException：实例化异常。当试图通过newInstance()方法创建某个类的实例，而该类是一个抽象类或接口时，抛出该异常。</p>
<p>java.lang.NoSuchFieldException：属性不存在异常。当访问某个类的不存在的属性时抛出该异常。</p>
<p>java.lang.NoSuchMethodException：方法不存在异常。当访问某个类的不存在的方法时抛出该异常。</p>
<p>java.lang.NullPointerException：空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等。</p>
<p>java.lang.NumberFormatException：数字格式异常。当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。</p>
<p>java.lang.StringIndexOutOfBoundsException：字符串索引越界异常。当使用索引值访问某个字符串中的字符，而该索引值小于0或大于等于序列大小时，抛出该异常。</p>
<h5 id="Java异常处理最佳实践"><a href="#Java异常处理最佳实践" class="headerlink" title="Java异常处理最佳实践"></a>Java异常处理最佳实践</h5><p>在 Java 中处理异常并不是一个简单的事情。不仅仅初学者很难理解，即使一些有经验的开发者也需要花费很多时间来思考如何处理异常，包括需要处理哪些异常，怎样处理等等。这也是绝大多数开发团队都会制定一些规则来规范进行异常处理的原因。而团队之间的这些规范往往是截然不同的。</p>
<p>本文给出几个被很多团队使用的异常处理最佳实践。</p>
<ol>
<li><h5 id="在-finally-块中清理资源或者使用-try-with-resource-语句"><a href="#在-finally-块中清理资源或者使用-try-with-resource-语句" class="headerlink" title="在 finally 块中清理资源或者使用 try-with-resource 语句"></a>在 finally 块中清理资源或者使用 try-with-resource 语句</h5></li>
</ol>
<p>当使用类似InputStream这种需要使用后关闭的资源时，一个常见的错误就是在try块的最后关闭资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doNotCloseResourceInTry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FileInputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"./tmp.txt"</span>);</span><br><span class="line">        inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        <span class="comment">// use the inputStream to read a file</span></span><br><span class="line">        <span class="comment">// do NOT do this</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题就是，只有没有异常抛出的时候，这段代码才可以正常工作。try 代码块内代码会正常执行，并且资源可以正常关闭。但是，使用 try 代码块是有原因的，一般调用一个或多个可能抛出异常的方法，而且，你自己也可能会抛出一个异常，这意味着代码可能不会执行到 try 代码块的最后部分。结果就是，你并没有关闭资源。</p>
<p>所以，你应该把清理工作的代码放到 finally 里去，或者使用 try-with-resource 特性。</p>
<h5 id="1-1-使用-finally-代码块"><a href="#1-1-使用-finally-代码块" class="headerlink" title="1.1 使用 finally 代码块"></a>1.1 使用 finally 代码块</h5><p>与前面几行 try 代码块不同，finally 代码块总是会被执行。不管 try 代码块成功执行之后还是你在 catch 代码块中处理完异常后都会执行。因此，你可以确保你清理了所有打开的资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeResourceInFinally</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FileInputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"./tmp.txt"</span>);</span><br><span class="line">        inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        <span class="comment">// use the inputStream to read a file</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                log.error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-Java-7-的-try-with-resource-语法"><a href="#1-2-Java-7-的-try-with-resource-语法" class="headerlink" title="1.2 Java 7 的 try-with-resource 语法"></a>1.2 Java 7 的 try-with-resource 语法</h5><p>如果你的资源实现了 AutoCloseable 接口，你可以使用这个语法。大多数的 Java 标准资源都继承了这个接口。当你在 try 子句中打开资源，资源会在 try 代码块执行后或异常处理后自动关闭。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">automaticallyCloseResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"./tmp.txt"</span>);</span><br><span class="line">    <span class="keyword">try</span> (FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(file);) &#123;</span><br><span class="line">        <span class="comment">// use the inputStream to read a file</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><h5 id="优先明确的异常"><a href="#优先明确的异常" class="headerlink" title="优先明确的异常"></a>优先明确的异常</h5></li>
</ol>
<p>你抛出的异常越明确越好，永远记住，你的同事或者几个月之后的你，将会调用你的方法并且处理异常。</p>
<p>因此需要保证提供给他们尽可能多的信息。这样你的 API 更容易被理解。你的方法的调用者能够更好的处理异常并且避免额外的检查。</p>
<p>因此，总是尝试寻找最适合你的异常事件的类，例如，抛出一个 NumberFormatException 来替换一个 IllegalArgumentException 。避免抛出一个不明确的异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doNotDoThis</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doThis</span><span class="params">()</span> <span class="keyword">throws</span> NumberFormatException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><h5 id="对异常进行文档说明"><a href="#对异常进行文档说明" class="headerlink" title="对异常进行文档说明"></a>对异常进行文档说明</h5></li>
</ol>
<p>当在方法上声明抛出异常时，也需要进行文档说明。目的是为了给调用者提供尽可能多的信息，从而可以更好地避免或处理异常。<br>在 Javadoc 添加 @throws 声明，并且描述抛出异常的场景。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(String input)</span> <span class="keyword">throws</span> MyBusinessException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><h5 id="使用描述性消息抛出异常"><a href="#使用描述性消息抛出异常" class="headerlink" title="使用描述性消息抛出异常"></a>使用描述性消息抛出异常</h5></li>
</ol>
<p>在抛出异常时，需要尽可能精确地描述问题和相关信息，这样无论是打印到日志中还是在监控工具中，都能够更容易被人阅读，从而可以更好地定位具体错误信息、错误的严重程度等。</p>
<p>但这里并不是说要对错误信息长篇大论，因为本来 Exception 的类名就能够反映错误的原因，因此只需要用一到两句话描述即可。</p>
<p>如果抛出一个特定的异常，它的类名很可能已经描述了这种错误。所以，你不需要提供很多额外的信息。一个很好的例子是 NumberFormatException 。当你以错误的格式提供 String 时，它将被 java.lang.Long 类的构造函数抛出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> Long(<span class="string">"xyz"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><h5 id="优先捕获最具体的异常"><a href="#优先捕获最具体的异常" class="headerlink" title="优先捕获最具体的异常"></a>优先捕获最具体的异常</h5></li>
</ol>
<p>大多数 IDE 都可以帮助你实现这个最佳实践。当你尝试首先捕获较不具体的异常时，它们会报告无法访问的代码块。</p>
<p>但问题在于，只有匹配异常的第一个 catch 块会被执行。 因此，如果首先捕获 IllegalArgumentException ，则永远不会到达应该处理更具体的 NumberFormatException 的 catch 块，因为它是 IllegalArgumentException 的子类。</p>
<p>总是优先捕获最具体的异常类，并将不太具体的 catch 块添加到列表的末尾。</p>
<p>你可以在下面的代码片断中看到这样一个 try-catch 语句的例子。 第一个 catch 块处理所有 NumberFormatException 异常，第二个处理所有非 NumberFormatException 异常的IllegalArgumentException 异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">catchMostSpecificExceptionFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doSomething(<span class="string">"A message"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        log.error(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><h5 id="不要捕获-Throwable-类"><a href="#不要捕获-Throwable-类" class="headerlink" title="不要捕获 Throwable 类"></a>不要捕获 Throwable 类</h5></li>
</ol>
<p>Throwable 是所有异常和错误的超类。你可以在 catch 子句中使用它，但是你永远不应该这样做！</p>
<p>如果在 catch 子句中使用 Throwable ，它不仅会捕获所有异常，也将捕获所有的错误。JVM 抛出错误，指出不应该由应用程序处理的严重问题。 典型的例子是 OutOfMemoryError 或者 StackOverflowError 。两者都是由应用程序控制之外的情况引起的，无法处理。</p>
<p>所以，最好不要捕获 Throwable ，除非你确定自己处于一种特殊的情况下能够处理错误。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doNotCatchThrowable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// don't do this!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><h5 id="不要忽略异常"><a href="#不要忽略异常" class="headerlink" title="不要忽略异常"></a>不要忽略异常</h5></li>
</ol>
<p>很多时候，开发者很有自信不会抛出异常，因此写了一个catch块，但是没有做任何处理或者记录日志。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doNotIgnoreExceptions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        <span class="comment">// this will never happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但现实是经常会出现无法预料的异常，或者无法确定这里的代码未来是不是会改动(删除了阻止异常抛出的代码)，而此时由于异常被捕获，使得无法拿到足够的错误信息来定位问题。</p>
<p>合理的做法是至少要记录异常的信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logAnException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        log.error(<span class="string">"This should never happen: "</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li><h5 id="不要记录并抛出异常"><a href="#不要记录并抛出异常" class="headerlink" title="不要记录并抛出异常"></a>不要记录并抛出异常</h5></li>
</ol>
<p>这可能是本文中最常被忽略的最佳实践。可以发现很多代码甚至类库中都会有捕获异常、记录日志并再次抛出的逻辑。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> Long(<span class="string">"xyz"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个处理逻辑看着是合理的。但这经常会给同一个异常输出多条日志。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">17</span>:<span class="number">44</span>:<span class="number">28</span>,<span class="number">945</span> ERROR TestExceptionHandling:<span class="number">65</span> - java.lang.NumberFormatException: For input string: <span class="string">"xyz"</span></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.NumberFormatException: For input string: <span class="string">"xyz"</span></span><br><span class="line">at java.lang.NumberFormatException.forInputString(NumberFormatException.java:<span class="number">65</span>)</span><br><span class="line">at java.lang.Long.parseLong(Long.java:<span class="number">589</span>)</span><br><span class="line">at java.lang.Long.(Long.java:<span class="number">965</span>)</span><br><span class="line">at com.stackify.example.TestExceptionHandling.logAndThrowException(TestExceptionHandling.java:<span class="number">63</span>)</span><br><span class="line">at com.stackify.example.TestExceptionHandling.main(TestExceptionHandling.java:<span class="number">58</span>)</span><br></pre></td></tr></table></figure>

<p>如上所示，后面的日志也没有附加更有用的信息。如果想要提供更加有用的信息，那么可以将异常包装为自定义异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wrapException</span><span class="params">(String input)</span> <span class="keyword">throws</span> MyBusinessException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MyBusinessException(<span class="string">"A message that describes the error."</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，仅仅当想要处理异常时才去捕获，否则只需要在方法签名中声明让调用者去处理。<br>9. ##### 包装异常时不要抛弃原始的异常</p>
<p>捕获标准异常并包装为自定义异常是一个很常见的做法。这样可以添加更为具体的异常信息并能够做针对的异常处理。<br>在你这样做时，请确保将原始异常设置为原因（注：参考下方代码 NumberFormatException e 中的原始异常 e ）。Exception 类提供了特殊的构造函数方法，它接受一个 Throwable 作为参数。否则，你将会丢失堆栈跟踪和原始异常的消息，这将会使分析导致异常的异常事件变得困难。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wrapException</span><span class="params">(String input)</span> <span class="keyword">throws</span> MyBusinessException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MyBusinessException(<span class="string">"A message that describes the error."</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="10">
<li><h5 id="不要使用异常控制程序的流程"><a href="#不要使用异常控制程序的流程" class="headerlink" title="不要使用异常控制程序的流程"></a>不要使用异常控制程序的流程</h5></li>
</ol>
<p>不应该使用异常控制应用的执行流程，例如，本应该使用if语句进行条件判断的情况下，你却使用异常处理，这是非常不好的习惯，会严重影响应用的性能。<br>11. ##### 使用标准异常</p>
<p>如果使用内建的异常可以解决问题，就不要定义自己的异常。Java API 提供了上百种针对不同情况的异常类型，在开发中首先尽可能使用 Java API 提供的异常，如果标准的异常不能满足你的要求，这时候创建自己的定制异常。尽可能得使用标准异常有利于新加入的开发者看懂项目代码。<br>12. ##### 异常会影响性能</p>
<p>异常处理的性能成本非常高，每个 Java 程序员在开发时都应牢记这句话。创建一个异常非常慢，抛出一个异常又会消耗1~5ms，当一个异常在应用的多个层级之间传递时，会拖累整个应用的性能。</p>
<ul>
<li>仅在异常情况下使用异常；</li>
<li>在可恢复的异常情况下使用异常；</li>
</ul>
<p>尽管使用异常有利于 Java 开发，但是在应用中最好不要捕获太多的调用栈，因为在很多情况下都不需要打印调用栈就知道哪里出错了。因此，异常消息应该提供恰到好处的信息。<br>13. 总结</p>
<p>综上所述，当你抛出或捕获异常的时候，有很多不同的情况需要考虑，而且大部分事情都是为了改善代码的可读性或者 API 的可用性。</p>
<p>异常不仅仅是一个错误控制机制，也是一个通信媒介。因此，为了和同事更好的合作，一个团队必须要制定出一个最佳实践和规则，只有这样，团队成员才能理解这些通用概念，同时在工作中使用它。</p>
<h5 id="异常处理-阿里巴巴Java开发手册"><a href="#异常处理-阿里巴巴Java开发手册" class="headerlink" title="异常处理-阿里巴巴Java开发手册"></a>异常处理-阿里巴巴Java开发手册</h5><ol>
<li><p>【强制】Java 类库中定义的可以通过预检查方式规避的RuntimeException异常不应该通过catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException等等。 说明：无法通过预检查的异常除外，比如，在解析字符串形式的数字时，可能存在数字格式错误，不得不通过catch NumberFormatException来实现。 正例：if (obj != null) {…} 反例：try { obj.method(); } catch (NullPointerException e) {…}</p>
</li>
<li><p>【强制】异常不要用来做流程控制，条件控制。 说明：异常设计的初衷是解决程序运行中的各种意外情况，且异常的处理效率比条件判断方式要低很多。</p>
</li>
<li><p>【强制】catch时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的catch尽可能进行区分异常类型，再做对应的异常处理。 说明：对大段代码进行try-catch，使程序无法根据不同的异常做出正确的应激反应，也不利于定位问题，这是一种不负责任的表现。 正例：用户注册的场景中，如果用户输入非法字符，或用户名称已存在，或用户输入密码过于简单，在程序上作出分门别类的判断，并提示给用户。</p>
</li>
<li><p>【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。</p>
</li>
<li><p>【强制】有try块放到了事务代码中，catch异常后，如果需要回滚事务，一定要注意手动回滚事务。</p>
</li>
<li><p>【强制】finally块必须对资源对象、流对象进行关闭，有异常也要做try-catch。 说明：如果JDK7及以上，可以使用try-with-resources方式。</p>
</li>
<li><p>【强制】不要在finally块中使用return。 说明：try块中的return语句执行成功后，并不马上返回，而是继续执行finally块中的语句，如果此处存在return语句，则在此直接返回，无情丢弃掉try块中的返回点。 反例：</p>
<p> private int x = 0;<br> public int checkReturn() {</p>
<pre><code>try {
    // x等于1，此处不返回
    return ++x;
} finally {
    // 返回的结果是2
    return ++x;
}</code></pre><p> }</p>
</li>
<li><p>【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。 说明：如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况。</p>
</li>
<li><p>【强制】在调用RPC、二方包、或动态生成类的相关方法时，捕捉异常必须使用Throwable类来进行拦截。 说明：通过反射机制来调用方法，如果找不到方法，抛出NoSuchMethodException。什么情况会抛出NoSuchMethodError呢？二方包在类冲突时，仲裁机制可能导致引入非预期的版本使类的方法签名不匹配，或者在字节码修改框架（比如：ASM）动态创建或修改类时，修改了相应的方法签名。这些情况，即使代码编译期是正确的，但在代码运行期时，会抛出NoSuchMethodError。</p>
</li>
<li><p>【推荐】方法的返回值可以为null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回null值。 说明：本手册明确防止NPE是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回null的情况。</p>
</li>
<li><p>【推荐】防止NPE，是程序员的基本修养，注意NPE产生的场景： 1） 返回类型为基本数据类型，return包装数据类型的对象时，自动拆箱有可能产生NPE。 反例：public int f() { return Integer对象}， 如果为null，自动解箱抛NPE。 2） 数据库的查询结果可能为null。 3） 集合里的元素即使isNotEmpty，取出的数据元素也可能为null。 4） 远程调用返回对象时，一律要求进行空指针判断，防止NPE。 5） 对于Session中获取的数据，建议进行NPE检查，避免空指针。 6） 级联调用obj.getA().getB().getC()；一连串调用，易产生NPE。<br>正例：使用JDK8的Optional类来防止NPE问题。</p>
</li>
<li><p>【推荐】定义时区分unchecked / checked 异常，避免直接抛出new RuntimeException()，更不允许抛出Exception或者Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：DAOException / ServiceException等。</p>
</li>
<li><p>【参考】对于公司外的http/api开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间RPC调用优先考虑使用Result方式，封装isSuccess()方法、“错误码”、“错误简短信息”。 说明：关于RPC方法返回方式使用Result方式的理由： 1）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。 2）如果不加栈信息，只是new自定义异常，加入自己的理解的error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。</p>
</li>
<li><p>【参考】避免出现重复的代码（Don’t Repeat Yourself），即DRY原则。 说明：随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是组件化。 正例：一个类中有多个public方法，都需要进行数行相同的参数校验操作，这个时候请抽取：<br>private boolean checkParam(DTO dto) {…}</p>
</li>
</ol>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>Java虚拟机(JVM)面试题</title>
    <url>/myblog/interview/Java%E8%99%9A%E6%8B%9F%E6%9C%BA(JVM)%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h4 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h4><a id="more"></a>
<h5 id="说一下-JVM-的主要组成部分及其作用？"><a href="#说一下-JVM-的主要组成部分及其作用？" class="headerlink" title="说一下 JVM 的主要组成部分及其作用？"></a>说一下 JVM 的主要组成部分及其作用？</h5><p><img src="https://img-blog.csdnimg.cn/20200103213149526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<p>JVM包含两个子系统和两个组件，两个子系统为Class loader(类装载)、Execution engine(执行引擎)；两个组件为Runtime data area(运行时数据区)、Native Interface(本地接口)。</p>
<ul>
<li>Class loader(类装载)：根据给定的全限定名类名(如：java.lang.Object)来装载class文件到Runtime data area中的method area。</li>
<li>Execution engine（执行引擎）：执行classes中的指令。</li>
<li>Native Interface(本地接口)：与native libraries交互，是其它编程语言交互的接口。</li>
<li>Runtime data area(运行时数据区域)：这就是我们常说的JVM的内存。</li>
</ul>
<p><strong>作用</strong> ：首先通过编译器把 Java 代码转换成字节码，类加载器（ClassLoader）再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方法区内，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p>
<!--more-->

<p><strong>下面是Java程序运行机制详细说明</strong></p>
<p>Java程序运行机制步骤</p>
<ul>
<li>首先利用IDE集成开发工具编写Java源代码，源文件的后缀为.java；</li>
<li>再利用编译器(javac命令)将源代码编译成字节码文件，字节码文件的后缀名为.class；</li>
<li>运行字节码的工作是由解释器(java命令)来完成的。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2020031416414486.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt></p>
<p>从上图可以看，java文件通过编译器变成了.class文件，接下来类加载器又将这些.class文件加载到JVM中。<br>其实可以一句话来解释：类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class对象，用来封装类在方法区内的数据结构。</p>
<h5 id="说一下-JVM-运行时数据区"><a href="#说一下-JVM-运行时数据区" class="headerlink" title="说一下 JVM 运行时数据区"></a>说一下 JVM 运行时数据区</h5><p><strong>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存区域</strong>划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有些区域随着虚拟机进程的启动而存在，有些区域则是依赖线程的启动和结束而建立和销毁。Java 虚拟机所管理的内存被划分为如下几个区域：<br><img src="https://img-blog.csdnimg.cn/20200103213220764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<p>不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：</p>
<ul>
<li>程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；</li>
<li>Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；</li>
<li>本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；</li>
<li>Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；</li>
<li>方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</li>
</ul>
<h5 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h5><p>浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址，</p>
<p>深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存，</p>
<p>使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的错误。</p>
<p>浅复制：仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改变。</p>
<p>深复制：在计算机中开辟一块新的内存地址用于存放复制的对象。</p>
<h5 id="说一下堆栈的区别？"><a href="#说一下堆栈的区别？" class="headerlink" title="说一下堆栈的区别？"></a>说一下堆栈的区别？</h5><p>物理地址</p>
<p>堆的物理地址分配对对象是不连续的。因此性能慢些。在GC的时候也要考虑到不连续的分配，所以有各种算法。比如，标记-消除，复制，标记-压缩，分代（即新生代使用复制算法，老年代使用标记——压缩）</p>
<p>栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。</p>
<p>内存分别</p>
<p>堆因为是不连续的，所以分配的内存是在运行期确认的，因此大小不固定。一般堆大小远远大于栈。</p>
<p>栈是连续的，所以分配的内存大小要在编译期就确认，大小是固定的。</p>
<p>存放的内容</p>
<p>堆存放的是对象的实例和数组。因此该区更关注的是数据的存储</p>
<p>栈存放：局部变量，操作数栈，返回结果。该区更关注的是程序方法的执行。</p>
<p>PS：</p>
<ol>
<li>静态变量放在方法区</li>
<li>静态的对象还是放在堆。</li>
</ol>
<p>程序的可见度</p>
<p>堆对于整个应用程序都是共享、可见的。</p>
<p>栈只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同。</p>
<h5 id="队列和栈是什么？有什么区别？"><a href="#队列和栈是什么？有什么区别？" class="headerlink" title="队列和栈是什么？有什么区别？"></a>队列和栈是什么？有什么区别？</h5><p>队列和栈都是被用来预存储数据的。</p>
<ul>
<li>操作的名称不同。队列的插入称为入队，队列的删除称为出队。栈的插入称为进栈，栈的删除称为出栈。</li>
<li>可操作的方式不同。队列是在队尾入队，队头出队，即两边都可操作。而栈的进栈和出栈都是在栈顶进行的，无法对栈底直接进行操作。</li>
<li>操作的方法不同。队列是先进先出（FIFO），即队列的修改是依先进先出的原则进行的。新来的成员总是加入队尾（不能从中间插入），每次离开的成员总是队列头上（不允许中途离队）。而栈为后进先出（LIFO）,即每次删除（出栈）的总是当前栈中最新的元素，即最后插入（进栈）的元素，而最先插入的被放在栈的底部，要到最后才能删除。</li>
</ul>
<h4 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h4><h5 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h5><p>说到对象的创建，首先让我们看看 Java 中提供的几种对象创建方式：</p>
<table>
<thead>
<tr>
<th>Header</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>使用new关键字</td>
<td>调用了构造函数</td>
</tr>
<tr>
<td>使用Class的newInstance方法</td>
<td>调用了构造函数</td>
</tr>
<tr>
<td>使用Constructor类的newInstance方法</td>
<td>调用了构造函数</td>
</tr>
<tr>
<td>使用clone方法</td>
<td>没有调用构造函数</td>
</tr>
<tr>
<td>使用反序列化</td>
<td>没有调用构造函数</td>
</tr>
</tbody></table>
<p>下面是对象创建的主要流程:</p>
<p><img src="https://img-blog.csdnimg.cn/20200103213726902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<p>虚拟机遇到一条new指令时，先检查常量池是否已经加载相应的类，如果没有，必须先执行相应的类加载。类加载通过后，接下来分配内存。若Java堆中内存是绝对规整的，使用“指针碰撞“方式分配内存；如果不是规整的，就从空闲列表中分配，叫做”空闲列表“方式。划分内存时还需要考虑一个问题-并发，也有两种方式: CAS同步处理，或者本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)。然后内存空间初始化操作，接着是做一些必要的对象设置(元信息、哈希码…)，最后执行<init>方法。</init></p>
<h5 id="为对象分配内存"><a href="#为对象分配内存" class="headerlink" title="为对象分配内存"></a>为对象分配内存</h5><p>类加载完成后，接着会在Java堆中划分一块内存分配给对象。内存分配根据Java堆是否规整，有两种方式：</p>
<ul>
<li>指针碰撞：如果Java堆的内存是规整，即所有用过的内存放在一边，而空闲的的放在另一边。分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离，这样便完成分配内存工作。</li>
<li>空闲列表：如果Java堆的内存不是规整的，则需要由虚拟机维护一个列表来记录那些内存是可用的，这样在分配的时候可以从列表中查询到足够大的内存分配给对象，并在分配后更新列表记录。</li>
</ul>
<p>选择哪种分配方式是由 Java 堆是否规整来决定的，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<p><img src="https://img-blog.csdnimg.cn/20200103213812259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<h5 id="处理并发安全问题"><a href="#处理并发安全问题" class="headerlink" title="处理并发安全问题"></a>处理并发安全问题</h5><p>对象的创建在虚拟机中是一个非常频繁的行为，哪怕只是修改一个指针所指向的位置，在并发情况下也是不安全的，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案：</p>
<ul>
<li>对分配内存空间的动作进行同步处理（采用 CAS + 失败重试来保障更新操作的原子性）；\</li>
<li>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。哪个线程要分配内存，就在哪个线程的 TLAB 上分配。只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁。通过-XX:+/-UserTLAB参数来设定虚拟机是否使用TLAB。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200103213833317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<h5 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h5><p>Java程序需要通过 JVM 栈上的引用访问堆中的具体对象。对象的访问方式取决于 JVM 虚拟机的实现。目前主流的访问方式有 句柄 和 直接指针 两种方式。</p>
<pre><code>指针： 指向对象，代表一个对象在内存中的起始地址。
句柄： 可以理解为指向指针的指针，维护着对象的指针。句柄不直接指向对象，而是指向对象的指针（句柄不发生变化，指向固定内存地址），再由对象的指针指向对象的真实内存地址。</code></pre><h5 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h5><p>Java堆中划分出一块内存来作为句柄池，引用中存储对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息，具体构造如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20200103213926911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<p><strong>优势</strong>：引用中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而引用本身不需要修改。</p>
<h5 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h5><p>如果使用直接指针访问，引用 中存储的直接就是对象地址，那么Java堆对象内部的布局中就必须考虑如何放置访问类型数据的相关信息。</p>
<p><img src="https://img-blog.csdnimg.cn/20200103213948956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<p><strong>优势：</strong>速度更快，节省了<strong>一次指针定位</strong>的时间开销。由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。HotSpot 中采用的就是这种方式。</p>
<h4 id="内存溢出异常"><a href="#内存溢出异常" class="headerlink" title="内存溢出异常"></a>内存溢出异常</h4><h5 id="Java会存在内存泄漏吗？请简单描述"><a href="#Java会存在内存泄漏吗？请简单描述" class="headerlink" title="Java会存在内存泄漏吗？请简单描述"></a>Java会存在内存泄漏吗？请简单描述</h5><p>内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说，Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。</p>
<p>但是，即使这样，Java也还是存在着内存泄漏的情况，java导致内存泄露的原因很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。</p>
<h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><h5 id="简述Java垃圾回收机制"><a href="#简述Java垃圾回收机制" class="headerlink" title="简述Java垃圾回收机制"></a>简述Java垃圾回收机制</h5><p>在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</p>
<h5 id="GC是什么？为什么要GC"><a href="#GC是什么？为什么要GC" class="headerlink" title="GC是什么？为什么要GC"></a>GC是什么？为什么要GC</h5><p>GC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存</p>
<p>回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动</p>
<p>回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。</p>
<h5 id="垃圾回收的优点和原理。并考虑2种回收机制"><a href="#垃圾回收的优点和原理。并考虑2种回收机制" class="headerlink" title="垃圾回收的优点和原理。并考虑2种回收机制"></a>垃圾回收的优点和原理。并考虑2种回收机制</h5><p>java语言最显著的特点就是引入了垃圾回收机制，它使java程序员在编写程序时不再考虑内存管理的问题。</p>
<p>由于有这个垃圾回收机制，java中的对象不再有“作用域”的概念，只有引用的对象才有“作用域”。</p>
<p>垃圾回收机制有效的防止了内存泄露，可以有效的使用可使用的内存。</p>
<p>垃圾回收器通常作为一个单独的低级别的线程运行，在不可预知的情况下对内存堆中已经死亡的或很长时间没有用过的对象进行清除和回收。</p>
<p>程序员不能实时的对某个对象或所有对象调用垃圾回收器进行垃圾回收。</p>
<p>垃圾回收有分代复制垃圾回收、标记垃圾回收、增量垃圾回收。</p>
<h5 id="垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？"><a href="#垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？" class="headerlink" title="垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？"></a>垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？</h5><p>对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。</p>
<p>通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。</p>
<p>可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。</p>
<h5 id="Java-中都有哪些引用类型？"><a href="#Java-中都有哪些引用类型？" class="headerlink" title="Java 中都有哪些引用类型？"></a>Java 中都有哪些引用类型？</h5><ul>
<li>强引用：发生 gc 的时候不会被回收。</li>
<li>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。</li>
<li>弱引用：有用但不是必须的对象，在下一次GC时会被回收。</li>
<li>虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。</li>
</ul>
<h5 id="怎么判断对象是否可以被回收？"><a href="#怎么判断对象是否可以被回收？" class="headerlink" title="怎么判断对象是否可以被回收？"></a>怎么判断对象是否可以被回收？</h5><p>垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收的，哪些对象是「存活」的，是不可以被回收的；哪些对象已经「死掉」了，需要被回收。</p>
<p>一般有两种方法来判断：</p>
<ul>
<li>引用计数器法：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；</li>
<li>可达性分析算法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</li>
</ul>
<h5 id="在Java中，对象什么时候可以被垃圾回收"><a href="#在Java中，对象什么时候可以被垃圾回收" class="headerlink" title="在Java中，对象什么时候可以被垃圾回收"></a>在Java中，对象什么时候可以被垃圾回收</h5><p>当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。<br>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。</p>
<h5 id="JVM中的永久代中会发生垃圾回收吗"><a href="#JVM中的永久代中会发生垃圾回收吗" class="headerlink" title="JVM中的永久代中会发生垃圾回收吗"></a>JVM中的永久代中会发生垃圾回收吗</h5><p>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。请参考下Java8：从永久代到元数据区<br>(译者注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区)</p>
<h5 id="说一下-JVM-有哪些垃圾回收算法？"><a href="#说一下-JVM-有哪些垃圾回收算法？" class="headerlink" title="说一下 JVM 有哪些垃圾回收算法？"></a>说一下 JVM 有哪些垃圾回收算法？</h5><ul>
<li>标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。</li>
<li>复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。</li>
<li>标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</li>
<li>分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</li>
</ul>
<h5 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h5><p>标记无用对象，然后进行清除回收。</p>
<p>标记-清除算法（Mark-Sweep）是一种常见的基础垃圾收集算法，它将垃圾收集分为两个阶段：</p>
<ul>
<li>标记阶段：标记出可以回收的对象。</li>
<li>清除阶段：回收被标记的对象所占用的空间。</li>
</ul>
<p>标记-清除算法之所以是基础的，是因为后面讲到的垃圾收集算法都是在此算法的基础上进行改进的。</p>
<p><strong>优点：</strong>实现简单，不需要对象进行移动。</p>
<p><strong>缺点</strong>：标记、清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的频率。</p>
<p>标记-清除算法的执行的过程如下图所示</p>
<p><img src="https://img-blog.csdnimg.cn/20200104115917418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>为了解决标记-清除算法的效率不高的问题，产生了复制算法。它把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾收集时，遍历当前使用的区域，把存活对象复制到另外一个区域中，最后将当前使用的区域的可回收的对象进行回收。</p>
<p><strong>优点</strong>：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。</p>
<p><strong>缺点</strong>：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。</p>
<p>复制算法的执行过程如下图所示</p>
<p><img src="https://img-blog.csdnimg.cn/20200104115940771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<h5 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h5><p>在新生代中可以使用复制算法，但是在老年代就不能选择复制算法了，因为老年代的对象存活率会较高，这样会有较多的复制操作，导致效率变低。标记-清除算法可以应用在老年代中，但是它效率不高，在内存回收后容易产生大量内存碎片。因此就出现了一种标记-整理算法（Mark-Compact）算法，与标记-整理算法不同的是，在标记可回收的对象后将所有存活的对象压缩到内存的一端，使他们紧的排列在一起，然后对端边界以外的内存进行回收。回收后，已用和未用的内存都各自一边。</p>
<p><strong>优点</strong>：解决了标记-清理算法存在的内存碎片问题。</p>
<p><strong>缺点</strong>：仍需要进行局部对象移动，一定程度上降低了效率。</p>
<p>标记-整理算法的执行过程如下图所示</p>
<p><img src="https://img-blog.csdnimg.cn/20200104120006513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<p><strong>分代收集算法</strong></p>
<p>当前商业虚拟机都采用<strong>分代收集</strong>的垃圾收集算法。分代收集算法，顾名思义是根据对象的<strong>存活周期</strong>将内存划分为几块。一般包括年轻代、<strong>老年</strong>代 和 <strong>永久代</strong>，如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20200104120031885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<h5 id="说一下-JVM-有哪些垃圾回收器？"><a href="#说一下-JVM-有哪些垃圾回收器？" class="headerlink" title="说一下 JVM 有哪些垃圾回收器？"></a>说一下 JVM 有哪些垃圾回收器？</h5><p>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。下图展示了7种作用于不同分代的收集器，其中用于回收新生代的收集器包括Serial、PraNew、Parallel Scavenge，回收老年代的收集器包括Serial Old、Parallel Old、CMS，还有用于回收整个Java堆的G1收集器。不同收集器之间的连线表示它们可以搭配使用。</p>
<p><img src="https://img-blog.csdnimg.cn/20200104120144820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<ul>
<li>Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；</li>
<li>ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；</li>
<li>Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；</li>
<li>Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本；</li>
<li>Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；</li>
<li>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。</li>
<li>G1(Garbage First)收集器 (标记-整理算法)： Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。</li>
</ul>
<h5 id="详细介绍一下-CMS-垃圾回收器？"><a href="#详细介绍一下-CMS-垃圾回收器？" class="headerlink" title="详细介绍一下 CMS 垃圾回收器？"></a>详细介绍一下 CMS 垃圾回收器？</h5><p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。</p>
<p>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p>
<h5 id="新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？"><a href="#新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？" class="headerlink" title="新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？"></a>新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？</h5><ul>
<li>新生代回收器：Serial、ParNew、Parallel Scavenge</li>
<li>老年代回收器：Serial Old、Parallel Old、CMS</li>
<li>整堆回收器：G1</li>
</ul>
<p>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</p>
<h5 id="简述分代垃圾回收器是怎么工作的？"><a href="#简述分代垃圾回收器是怎么工作的？" class="headerlink" title="简述分代垃圾回收器是怎么工作的？"></a>简述分代垃圾回收器是怎么工作的？</h5><p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。</p>
<p>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p>
<ul>
<li>把 Eden + From Survivor 存活的对象放入 To Survivor 区；</li>
<li>清空 Eden 和 From Survivor 分区；</li>
<li>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。</li>
</ul>
<p>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</p>
<p>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p>
<h4 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h4><h5 id="简述java内存分配与回收策率以及Minor-GC和Major-GC"><a href="#简述java内存分配与回收策率以及Minor-GC和Major-GC" class="headerlink" title="简述java内存分配与回收策率以及Minor GC和Major GC"></a>简述java内存分配与回收策率以及Minor GC和Major GC</h5><p>所谓自动内存管理，最终要解决的也就是内存分配和内存回收两个问题。前面我们介绍了内存回收，这里我们再来聊聊内存分配。</p>
<p>对象的内存分配通常是在 Java 堆上分配（随着虚拟机优化技术的诞生，某些场景下也会在栈上分配，后面会详细介绍），对象主要分配在新生代的 Eden 区，如果启动了本地线程缓冲，将按照线程优先在 TLAB 上分配。少数情况下也会直接在老年代上分配。总的来说分配规则不是百分百固定的，其细节取决于哪一种垃圾收集器组合以及虚拟机相关参数有关，但是虚拟机对于内存的分配还是会遵循以下几种「普世」规则：</p>
<h5 id="对象优先在-Eden-区分配"><a href="#对象优先在-Eden-区分配" class="headerlink" title="对象优先在 Eden 区分配"></a>对象优先在 Eden 区分配</h5><p>多数情况，对象都在新生代 Eden 区分配。当 Eden 区分配没有足够的空间进行分配时，虚拟机将会发起一次 Minor GC。如果本次 GC 后还是没有足够的空间，则将启用分配担保机制在老年代中分配内存。</p>
<p>这里我们提到 Minor GC，如果你仔细观察过 GC 日常，通常我们还能从日志中发现 Major GC/Full GC。</p>
<ul>
<li>Minor GC 是指发生在新生代的 GC，因为 Java 对象大多都是朝生夕死，所有 Minor GC 非常频繁，一般回收速度也非常快；</li>
<li>Major GC/Full GC 是指发生在老年代的 GC，出现了 Major GC 通常会伴随至少一次 Minor GC。Major GC 的速度通常会比 Minor GC 慢 10 倍以上。</li>
</ul>
<h5 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h5><p>所谓大对象是指需要大量连续内存空间的对象，频繁出现大对象是致命的，会导致在内存还有不少空间的情况下提前触发 GC 以获取足够的连续空间来安置新对象。</p>
<p>前面我们介绍过新生代使用的是标记-清除算法来处理垃圾回收的，如果大对象直接在新生代分配就会导致 Eden 区和两个 Survivor 区之间发生大量的内存复制。因此对于大对象都会直接在老年代进行分配。</p>
<h5 id="长期存活对象将进入老年代"><a href="#长期存活对象将进入老年代" class="headerlink" title="长期存活对象将进入老年代"></a>长期存活对象将进入老年代</h5><p>虚拟机采用分代收集的思想来管理内存，那么内存回收时就必须判断哪些对象应该放在新生代，哪些对象应该放在老年代。因此虚拟机给每个对象定义了一个对象年龄的计数器，如果对象在 Eden 区出生，并且能够被 Survivor 容纳，将被移动到 Survivor 空间中，这时设置对象年龄为 1。对象在 Survivor 区中每「熬过」一次 Minor GC 年龄就加 1，当年龄达到一定程度（默认 15） 就会被晋升到老年代。</p>
<h4 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h4><h5 id="简述java类加载机制"><a href="#简述java类加载机制" class="headerlink" title="简述java类加载机制?"></a>简述java类加载机制?</h5><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的java类型。</p>
<h5 id="描述一下JVM加载Class文件的原理机制"><a href="#描述一下JVM加载Class文件的原理机制" class="headerlink" title="描述一下JVM加载Class文件的原理机制"></a>描述一下JVM加载Class文件的原理机制</h5><p>Java中的所有类，都需要由类加载器装载到JVM中才能运行。类加载器本身也是一个类，而它的工作就是把class文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。</p>
<p>类装载方式，有两种 ：</p>
<p>1.隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中，</p>
<p>2.显式装载， 通过class.forname()等方法，显式加载需要的类</p>
<p>Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到jvm中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。</p>
<h5 id="什么是类加载器，类加载器有哪些"><a href="#什么是类加载器，类加载器有哪些" class="headerlink" title="什么是类加载器，类加载器有哪些?"></a>什么是类加载器，类加载器有哪些?</h5><p>实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。</p>
<p>主要有一下四种类加载器:</p>
<ol>
<li>启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。</li>
<li>扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li>
<li>系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。</li>
<li>用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。</li>
</ol>
<h5 id="说一下类装载的执行过程？"><a href="#说一下类装载的执行过程？" class="headerlink" title="说一下类装载的执行过程？"></a>说一下类装载的执行过程？</h5><p>类装载分为以下 5 个步骤：</p>
<ul>
<li>加载：根据查找路径找到相应的 class 文件然后导入；</li>
<li>验证：检查加载的 class 文件的正确性；</li>
<li>准备：给类中的静态变量分配内存空间；</li>
<li>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</li>
<li>初始化：对静态变量和静态代码块执行初始化工作。</li>
</ul>
<h5 id="什么是双亲委派模型？"><a href="#什么是双亲委派模型？" class="headerlink" title="什么是双亲委派模型？"></a>什么是双亲委派模型？</h5><p>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</p>
<p><img src="https://img-blog.csdnimg.cn/20200104165551656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<p>类加载器分类：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；</li>
<li>其他类加载器：</li>
<li>扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；</li>
<li>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</li>
</ul>
<p>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</p>
<p>当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。</p>
<h4 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h4><h5 id="说一下-JVM-调优的工具？"><a href="#说一下-JVM-调优的工具？" class="headerlink" title="说一下 JVM 调优的工具？"></a>说一下 JVM 调优的工具？</h5><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p>
<ul>
<li>jconsole：用于对 JVM 中的内存、线程和类等进行监控；</li>
<li>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</li>
</ul>
<h5 id="常用的-JVM-调优的参数都有哪些？"><a href="#常用的-JVM-调优的参数都有哪些？" class="headerlink" title="常用的 JVM 调优的参数都有哪些？"></a>常用的 JVM 调优的参数都有哪些？</h5><ul>
<li>-Xms2g：初始化推大小为 2g；</li>
<li>-Xmx2g：堆最大内存为 2g；</li>
<li>-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；</li>
<li>-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；</li>
<li>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；</li>
<li>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；</li>
<li>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；</li>
<li>-XX:+PrintGC：开启打印 gc 信息；</li>
<li>-XX:+PrintGCDetails：打印 gc 详细信息。</li>
</ul>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis面试题</title>
    <url>/myblog/interview/MyBatis%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h4 id="MyBatis简介"><a href="#MyBatis简介" class="headerlink" title="MyBatis简介"></a>MyBatis简介</h4><a id="more"></a>
<h5 id="MyBatis是什么？"><a href="#MyBatis是什么？" class="headerlink" title="MyBatis是什么？"></a>MyBatis是什么？</h5><p>MyBatis 是一款优秀的持久层框架，一个半 ORM（对象关系映射）框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p>
<h5 id="ORM是什么"><a href="#ORM是什么" class="headerlink" title="ORM是什么"></a>ORM是什么</h5><p>ORM（Object Relational Mapping），对象关系映射，是一种为了解决关系型数据库数据与简单Java对象（POJO）的映射关系的技术。简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系型数据库中。</p>
<h5 id="为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"><a href="#为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？" class="headerlink" title="为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"></a>为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</h5><p>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。</p>
<p>而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</p>
<!--more-->

<h5 id="传统JDBC开发存在的问题"><a href="#传统JDBC开发存在的问题" class="headerlink" title="传统JDBC开发存在的问题"></a>传统JDBC开发存在的问题</h5><ul>
<li>频繁创建数据库连接对象、释放，容易造成系统资源浪费，影响系统性能。可以使用连接池解决这个问题。但是使用jdbc需要自己实现连接池。</li>
<li>sql语句定义、参数设置、结果集处理存在硬编码。实际项目中sql语句变化的可能性较大，一旦发生变化，需要修改java代码，系统需要重新编译，重新发布。不好维护。</li>
<li>使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护。</li>
<li>结果集处理存在重复代码，处理麻烦。如果可以映射成Java对象会比较方便。</li>
</ul>
<h5 id="JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？"><a href="#JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？" class="headerlink" title="JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？"></a>JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？</h5><p>1、数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库连接池可解决此问题。</p>
<p>解决：在mybatis-config.xml中配置数据链接池，使用连接池管理数据库连接。</p>
<p>2、Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。</p>
<p>解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。</p>
<p>3、向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。</p>
<p>解决： Mybatis自动将java对象映射至sql语句。</p>
<p>4、对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。</p>
<p>解决：Mybatis自动将sql执行结果映射至java对象。</p>
<h5 id="Mybatis优缺点"><a href="#Mybatis优缺点" class="headerlink" title="Mybatis优缺点"></a>Mybatis优缺点</h5><p><strong>优点</strong></p>
<p>与传统的数据库访问技术相比，ORM有以下优点：</p>
<ul>
<li>基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用</li>
<li>与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接</li>
<li>很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）</li>
<li>提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护</li>
<li>能够与Spring很好的集成</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求</li>
<li>SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库</li>
</ul>
<h5 id="MyBatis框架适用场景"><a href="#MyBatis框架适用场景" class="headerlink" title="MyBatis框架适用场景"></a>MyBatis框架适用场景</h5><ul>
<li>MyBatis专注于SQL本身，是一个足够灵活的DAO层解决方案。</li>
<li>对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis将是不错的选择。</li>
</ul>
<h5 id="Hibernate-和-MyBatis-的区别"><a href="#Hibernate-和-MyBatis-的区别" class="headerlink" title="Hibernate 和 MyBatis 的区别"></a>Hibernate 和 MyBatis 的区别</h5><p><strong>相同点</strong></p>
<p>都是对jdbc的封装，都是持久层的框架，都用于dao层的开发。</p>
<p><strong>不同点</strong></p>
<p>映射关系</p>
<ul>
<li>MyBatis 是一个半自动映射的框架，配置Java对象与sql语句执行结果的对应关系，多表关联关系配置简单</li>
<li>Hibernate 是一个全表映射的框架，配置Java对象与数据库表的对应关系，多表关联关系配置复杂</li>
</ul>
<p>SQL优化和移植性</p>
<ul>
<li>Hibernate 对SQL语句封装，提供了日志、缓存、级联（级联比 MyBatis 强大）等特性，此外还提供 HQL（Hibernate Query Language）操作数据库，数据库无关性支持好，但会多消耗性能。如果项目需要支持多种数据库，代码开发量少，但SQL语句优化困难。</li>
<li>MyBatis 需要手动编写 SQL，支持动态 SQL、处理列表、动态生成表名、支持存储过程。开发工作量相对大些。直接使用SQL语句操作数据库，不支持数据库无关性，但sql语句优化容易。</li>
</ul>
<p>开发难易程度和学习成本</p>
<ul>
<li>Hibernate 是重量级框架，学习使用门槛高，适合于需求相对稳定，中小型的项目，比如：办公自动化系统</li>
<li>MyBatis 是轻量级框架，学习使用门槛低，适合于需求变化频繁，大型的项目，比如：互联网电子商务系统</li>
</ul>
<p><strong>总结</strong></p>
<p>MyBatis 是一个小巧、方便、高效、简单、直接、半自动化的持久层框架，</p>
<p>Hibernate 是一个强大、方便、高效、复杂、间接、全自动化的持久层框架。</p>
<h4 id="MyBatis的解析和运行原理"><a href="#MyBatis的解析和运行原理" class="headerlink" title="MyBatis的解析和运行原理"></a>MyBatis的解析和运行原理</h4><h5 id="MyBatis编程步骤是什么样的？"><a href="#MyBatis编程步骤是什么样的？" class="headerlink" title="MyBatis编程步骤是什么样的？"></a>MyBatis编程步骤是什么样的？</h5><p>1、 创建SqlSessionFactory</p>
<p>2、 通过SqlSessionFactory创建SqlSession</p>
<p>3、 通过sqlsession执行数据库操作</p>
<p>4、 调用session.commit()提交事务</p>
<p>5、 调用session.close()关闭会话</p>
<h5 id="请说说MyBatis的工作原理"><a href="#请说说MyBatis的工作原理" class="headerlink" title="请说说MyBatis的工作原理"></a>请说说MyBatis的工作原理</h5><p>在学习 MyBatis 程序之前，需要了解一下 MyBatis 工作原理，以便于理解程序。MyBatis 的工作原理如下图</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL015QmF0aXMlRTYlQTElODYlRTYlOUUlQjYlRTYlODAlQkIlRTclQkIlOTMvTXlCYXRpcyVFNSVCNyVBNSVFNCVCRCU5QyVFNSU4RSU5RiVFNyU5MCU4Ni5wbmc" alt></p>
<p>1）读取 MyBatis 配置文件：mybatis-config.xml 为 MyBatis 的全局配置文件，配置了 MyBatis 的运行环境等信息，例如数据库连接信息。</p>
<p>2）加载映射文件。映射文件即 SQL 映射文件，该文件中配置了操作数据库的 SQL 语句，需要在 MyBatis 配置文件 mybatis-config.xml 中加载。mybatis-config.xml 文件可以加载多个映射文件，每个文件对应数据库中的一张表。</p>
<p>3）构造会话工厂：通过 MyBatis 的环境等配置信息构建会话工厂 SqlSessionFactory。</p>
<p>4）创建会话对象：由会话工厂创建 SqlSession 对象，该对象中包含了执行 SQL 语句的所有方法。</p>
<p>5）Executor 执行器：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据 SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。</p>
<p>6）MappedStatement 对象：在 Executor 接口的执行方法中有一个 MappedStatement 类型的参数，该参数是对映射信息的封装，用于存储要映射的 SQL 语句的 id、参数等信息。</p>
<p>7）输入参数映射：输入参数类型可以是 Map、List 等集合类型，也可以是基本数据类型和 POJO 类型。输入参数映射过程类似于 JDBC 对 preparedStatement 对象设置参数的过程。</p>
<p>8）输出结果映射：输出结果类型可以是 Map、 List 等集合类型，也可以是基本数据类型和 POJO 类型。输出结果映射过程类似于 JDBC 对结果集的解析过程。</p>
<h5 id="MyBatis的功能架构是怎样的"><a href="#MyBatis的功能架构是怎样的" class="headerlink" title="MyBatis的功能架构是怎样的"></a>MyBatis的功能架构是怎样的</h5><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL015QmF0aXMlRTYlQTElODYlRTYlOUUlQjYlRTYlODAlQkIlRTclQkIlOTMvTXlCYXRpcyVFNSU4QSU5RiVFOCU4MyVCRCVFNiU5RSVCNiVFNiU5RSU4NC5wbmc" alt></p>
<p>我们把Mybatis的功能架构分为三层：</p>
<ul>
<li>API接口层：提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。</li>
<li>数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。</li>
<li>基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。</li>
</ul>
<h5 id="MyBatis的框架架构设计是怎么样的"><a href="#MyBatis的框架架构设计是怎么样的" class="headerlink" title="MyBatis的框架架构设计是怎么样的"></a>MyBatis的框架架构设计是怎么样的</h5><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL015QmF0aXMlRTYlQTElODYlRTYlOUUlQjYlRTYlODAlQkIlRTclQkIlOTMvTXlCYXRpcyVFNiVBMSU4NiVFNiU5RSVCNiVFNiU5RSVCNiVFNiU5RSU4NC5wbmc" alt></p>
<p>这张图从上往下看。MyBatis的初始化，会从mybatis-config.xml配置文件，解析构造成Configuration这个类，就是图中的红框。</p>
<p>(1)加载配置：配置来源于两个地方，一处是配置文件，一处是Java代码的注解，将SQL的配置信息加载成为一个个MappedStatement对象（包括了传入参数映射配置、执行的SQL语句、结果映射配置），存储在内存中。</p>
<p>(2)SQL解析：当API接口层接收到调用请求时，会接收到传入SQL的ID和传入对象（可以是Map、JavaBean或者基本数据类型），Mybatis会根据SQL的ID找到对应的MappedStatement，然后根据传入参数对象对MappedStatement进行解析，解析后可以得到最终要执行的SQL语句和参数。</p>
<p>(3)SQL执行：将最终得到的SQL和参数拿到数据库进行执行，得到操作数据库的结果。</p>
<p>(4)结果映射：将操作数据库的结果按照映射的配置进行转换，可以转换成HashMap、JavaBean或者基本数据类型，并将最终结果返回。</p>
<h5 id="为什么需要预编译"><a href="#为什么需要预编译" class="headerlink" title="为什么需要预编译"></a>为什么需要预编译</h5><ol>
<li>定义：<br>SQL 预编译指的是数据库驱动在发送 SQL 语句和参数给 DBMS 之前对 SQL 语句进行编译，这样 DBMS 执行 SQL 时，就不需要重新编译。</li>
<li>为什么需要预编译<br>JDBC 中使用对象 PreparedStatement 来抽象预编译语句，使用预编译。预编译阶段可以优化 SQL 的执行。预编译之后的 SQL 多数情况下可以直接执行，DBMS 不需要再次编译，越复杂的SQL，编译的复杂度将越大，预编译阶段可以合并多次操作为一个操作。同时预编译语句对象可以重复利用。把一个 SQL 预编译后产生的 PreparedStatement 对象缓存下来，下次对于同一个SQL，可以直接使用这个缓存的 PreparedState 对象。Mybatis默认情况下，将对所有的 SQL 进行预编译。</li>
</ol>
<h5 id="Mybatis都有哪些Executor执行器？它们之间的区别是什么？"><a href="#Mybatis都有哪些Executor执行器？它们之间的区别是什么？" class="headerlink" title="Mybatis都有哪些Executor执行器？它们之间的区别是什么？"></a>Mybatis都有哪些Executor执行器？它们之间的区别是什么？</h5><p>Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。</p>
<p><strong>SimpleExecutor</strong>：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</p>
<p><strong>ReuseExecutor</strong>：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用Statement对象。</p>
<p>BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</p>
<p>作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。</p>
<h5 id="Mybatis中如何指定使用哪一种Executor执行器？"><a href="#Mybatis中如何指定使用哪一种Executor执行器？" class="headerlink" title="Mybatis中如何指定使用哪一种Executor执行器？"></a>Mybatis中如何指定使用哪一种Executor执行器？</h5><p>在Mybatis配置文件中，在设置（settings）可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数，如SqlSession openSession(ExecutorType execType)。</p>
<p>配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。</p>
<h5 id="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"></a>Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</h5><p>Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。</p>
<p>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p>
<p>当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</p>
<h4 id="映射器"><a href="#映射器" class="headerlink" title="映射器"></a>映射器</h4><h5 id="和-的区别"><a href="#和-的区别" class="headerlink" title="#{}和${}的区别"></a>#{}和${}的区别</h5><ul>
<li>#{}是占位符，预编译处理；${}是拼接符，字符串替换，没有预编译处理。</li>
<li>Mybatis在处理#{}时，#{}传入参数是以字符串传入，会将SQL中的#{}替换为?号，调用PreparedStatement的set方法来赋值。</li>
<li>Mybatis在处理时，是原值传入，就是把{}替换成变量的值，相当于JDBC中的Statement编译</li>
<li>变量替换后，#{} 对应的变量自动加上单引号 ‘’；变量替换后，${} 对应的变量不会加上单引号 ‘’</li>
<li>#{} 可以有效的防止SQL注入，提高系统安全性；${} 不能防止SQL 注入</li>
<li>#{} 的变量替换是在DBMS 中；${} 的变量替换是在 DBMS 外</li>
</ul>
<h5 id="模糊查询like语句该怎么写"><a href="#模糊查询like语句该怎么写" class="headerlink" title="模糊查询like语句该怎么写"></a>模糊查询like语句该怎么写</h5><p>（1）’%${question}%’ 可能引起SQL注入，不推荐</p>
<p>（2）”%”#{question}”%” 注意：因为#{…}解析成sql语句时候，会在变量外侧自动加单引号’ ‘，所以这里 % 需要使用双引号” “，不能使用单引号 ’ ‘，不然会查不到任何结果。</p>
<p>（3）CONCAT(’%’,#{question},’%’) 使用CONCAT()函数，推荐</p>
<p>（4）使用bind标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"listUserLikeUsername"</span> <span class="attr">resultType</span>=<span class="string">"com.jourwon.pojo.User"</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">"pattern"</span> <span class="attr">value</span>=<span class="string">"'%' + username + '%'"</span> /&gt;</span></span><br><span class="line">　　select id,sex,age,username,password from person where username LIKE #&#123;pattern&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="在mapper中如何传递多个参数"><a href="#在mapper中如何传递多个参数" class="headerlink" title="在mapper中如何传递多个参数"></a>在mapper中如何传递多个参数</h5><p><strong>方法1：顺序传参法</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">public User selectUser(String name, int deptId);</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUser"</span> <span class="attr">resultMap</span>=<span class="string">"UserResultMap"</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line">    where user_name = #&#123;0&#125; and dept_id = #&#123;1&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>#{}里面的数字代表传入参数的顺序。</p>
<p>这种方法不建议使用，sql层表达不直观，且一旦顺序调整容易出错。</p>
<p><strong>方法2：@Param注解传参法</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">public User selectUser(@Param("userName") String name, int @Param("deptId") deptId);</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUser"</span> <span class="attr">resultMap</span>=<span class="string">"UserResultMap"</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line">    where user_name = #&#123;userName&#125; and dept_id = #&#123;deptId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>#{}里面的名称对应的是注解@Param括号里面修饰的名称。</p>
<p>这种方法在参数不多的情况还是比较直观的，推荐使用。</p>
<p><strong>方法3：Map传参法</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">public User selectUser(Map<span class="tag">&lt;<span class="name">String,</span> <span class="attr">Object</span>&gt;</span> params);</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUser"</span> <span class="attr">parameterType</span>=<span class="string">"java.util.Map"</span> <span class="attr">resultMap</span>=<span class="string">"UserResultMap"</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line">    where user_name = #&#123;userName&#125; and dept_id = #&#123;deptId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>#{}里面的名称对应的是Map里面的key名称。</p>
<p>这种方法适合传递多个参数，且参数易变能灵活传递的情况。</p>
<p><strong>方法4：Java Bean传参法</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">public User selectUser(User user);</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUser"</span> <span class="attr">parameterType</span>=<span class="string">"com.jourwon.pojo.User"</span> <span class="attr">resultMap</span>=<span class="string">"UserResultMap"</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line">    where user_name = #&#123;userName&#125; and dept_id = #&#123;deptId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>#{}里面的名称对应的是User类里面的成员属性。</p>
<p>这种方法直观，需要建一个实体类，扩展不容易，需要加属性，但代码可读性强，业务逻辑处理方便，推荐使用。</p>
<h4 id="Mybatis如何执行批量操作"><a href="#Mybatis如何执行批量操作" class="headerlink" title="Mybatis如何执行批量操作"></a>Mybatis如何执行批量操作</h4><h5 id="使用foreach标签"><a href="#使用foreach标签" class="headerlink" title="使用foreach标签"></a>使用foreach标签</h5><p>foreach的主要用在构建in条件中，它可以在SQL语句中进行迭代一个集合。foreach标签的属性主要有item，index，collection，open，separator，close。</p>
<ul>
<li>item　　表示集合中每一个元素进行迭代时的别名，随便起的变量名；</li>
<li>index　　指定一个名字，用于表示在迭代过程中，每次迭代到的位置，不常用；</li>
<li>open　　表示该语句以什么开始，常用“(”；</li>
<li>separator表示在每次进行迭代之间以什么符号作为分隔符，常用“,”；</li>
<li>close　　表示以什么结束，常用“)”。</li>
</ul>
<p>在使用foreach的时候最关键的也是最容易出错的就是collection属性，该属性是必须指定的，但是在不同情况下，该属性的值是不一样的，主要有一下3种情况：</p>
<ol>
<li>如果传入的是单参数且参数类型是一个List的时候，collection属性值为list</li>
<li>如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array</li>
<li>如果传入的参数是多个的时候，我们就需要把它们封装成一个Map了，当然单参数也可以封装成map，实际上如果你在传入参数的时候，在MyBatis里面也是会把它封装成一个Map的，<br>map的key就是参数名，所以这个时候collection属性值就是传入的List或array对象在自己封装的map里面的key</li>
</ol>
<p>具体用法如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 批量保存(foreach插入多条数据两种方法)</span></span><br><span class="line"><span class="comment">       int addEmpsBatch(@Param("emps") List&lt;Employee&gt; emps); --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- MySQL下批量保存，可以foreach遍历 mysql支持values(),(),()语法 --&gt;</span> //推荐使用</span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addEmpsBatch"</span>&gt;</span></span><br><span class="line">    INSERT INTO emp(ename,gender,email,did)</span><br><span class="line">    VALUES</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"emps"</span> <span class="attr">item</span>=<span class="string">"emp"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">        (#&#123;emp.eName&#125;,#&#123;emp.gender&#125;,#&#123;emp.email&#125;,#&#123;emp.dept.id&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这种方式需要数据库连接属性allowMutiQueries=true的支持</span></span><br><span class="line"><span class="comment"> 如jdbc.url=jdbc:mysql://localhost:3306/mybatis?allowMultiQueries=true --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addEmpsBatch"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"emps"</span> <span class="attr">item</span>=<span class="string">"emp"</span> <span class="attr">separator</span>=<span class="string">";"</span>&gt;</span>                                 </span><br><span class="line">        INSERT INTO emp(ename,gender,email,did)</span><br><span class="line">        VALUES(#&#123;emp.eName&#125;,#&#123;emp.gender&#125;,#&#123;emp.email&#125;,#&#123;emp.dept.id&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="使用ExecutorType-BATCH"><a href="#使用ExecutorType-BATCH" class="headerlink" title="使用ExecutorType.BATCH"></a>使用ExecutorType.BATCH</h5><p>Mybatis内置的ExecutorType有3种，默认为simple,该模式下它为每个语句的执行创建一个新的预处理语句，单条提交sql；而batch模式重复使用已经预处理的语句，并且批量执行所有更新语句，显然batch性能将更优； 但batch模式也有自己的问题，比如在Insert操作时，在事务没有提交之前，是没有办法获取到自增的id，这在某型情形下是不符合业务要求的</p>
<p>具体用法如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//批量保存方法测试</span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBatch</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();</span><br><span class="line">    <span class="comment">//可以执行批量操作的sqlSession</span></span><br><span class="line">    SqlSession openSession = sqlSessionFactory.openSession(ExecutorType.BATCH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//批量保存执行前时间</span></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        EmployeeMapper mapper = openSession.getMapper(EmployeeMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            mapper.addEmp(<span class="keyword">new</span> Employee(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>), <span class="string">"b"</span>, <span class="string">"1"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        openSession.commit();</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//批量保存执行后的时间</span></span><br><span class="line">        System.out.println(<span class="string">"执行时长"</span> + (end - start));</span><br><span class="line">        <span class="comment">//批量 预编译sql一次==》设置参数==》10000次==》执行1次   677</span></span><br><span class="line">        <span class="comment">//非批量  （预编译=设置参数=执行 ）==》10000次   1121</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        openSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mapper和mapper.xml如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmployeeMapper</span> </span>&#123;   </span><br><span class="line">    <span class="comment">//批量保存员工</span></span><br><span class="line">    <span class="function">Long <span class="title">addEmp</span><span class="params">(Employee employee)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;mapper namespace=<span class="string">"com.jourwon.mapper.EmployeeMapper"</span></span><br><span class="line">     &lt;!--批量保存员工 --&gt;</span><br><span class="line">    &lt;insert id=<span class="string">"addEmp"</span>&gt;</span><br><span class="line">        <span class="function">insert into <span class="title">employee</span><span class="params">(lastName,email,gender)</span></span></span><br><span class="line"><span class="function">        <span class="title">values</span><span class="params">(#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;)</span></span></span><br><span class="line"><span class="function">    &lt;/insert&gt;</span></span><br><span class="line"><span class="function">&lt;/mapper&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="如何获取生成的主键"><a href="#如何获取生成的主键" class="headerlink" title="如何获取生成的主键"></a>如何获取生成的主键</h5><p><strong>对于支持主键自增的数据库（MySQL）</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertUser"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"userId"</span> &gt;</span></span><br><span class="line">    insert into user( </span><br><span class="line">    user_name, user_password, create_time) </span><br><span class="line">    values(#&#123;userName&#125;, #&#123;userPassword&#125; , #&#123;createTime, jdbcType= TIMESTAMP&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>parameterType 可以不写，Mybatis可以推断出传入的数据类型。如果想要访问主键，那么应当parameterType 应当是java实体或者Map。这样数据在插入之后 可以通过ava实体或者Map 来获取主键值。通过 getUserId获取主键</p>
<h5 id="不支持主键自增的数据库（Oracle）"><a href="#不支持主键自增的数据库（Oracle）" class="headerlink" title="不支持主键自增的数据库（Oracle）"></a>不支持主键自增的数据库（Oracle）</h5><p>对于像Oracle这样的数据，没有提供主键自增的功能，而是使用序列的方式获取自增主键。<br>可以使用＜selectKey＞标签来获取主键的值，这种方式不仅适用于不提供主键自增功能的数据库，也适用于提供主键自增功能的数据库<br>＜selectKey＞一般的用法</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyColumn</span>=<span class="string">"id"</span> <span class="attr">resultType</span>=<span class="string">"long"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> <span class="attr">order</span>=<span class="string">"BEFORE"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>属性     描述<br>keyProperty     selectKey 语句结果应该被设置的目标属性。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。<br>keyColumn     匹配属性的返回结果集中的列名称。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。<br>resultType     结果的类型，MyBatis 通常可以推算出来。MyBatis 允许任何简单类型用作主键的类型，包括字符串。如果希望作用于多个生成的列，则可以使用一个包含期望属性的 Object 或一个 Map。<br>order     值可为BEFORE 或 AFTER。如果是 BEFORE，那么它会先执行selectKey设置 keyProperty 然后执行插入语句。如果为AFTER则相反。<br>statementType     使用何种语句类型，默认PREPARED。 有STATEMENT，PREPARED 和 CALLABLE 语句的映射类型。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>keyProperty</td>
<td>selectKey 语句结果应该被设置的目标属性。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</td>
</tr>
<tr>
<td>keyColumn</td>
<td>匹配属性的返回结果集中的列名称。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</td>
</tr>
<tr>
<td>resultType</td>
<td>结果的类型，MyBatis 通常可以推算出来。MyBatis 允许任何简单类型用作主键的类型，包括字符串。如果希望作用于多个生成的列，则可以使用一个包含期望属性的 Object 或一个 Map。</td>
</tr>
<tr>
<td>order</td>
<td>值可为BEFORE 或 AFTER。如果是 BEFORE，那么它会先执行selectKey设置 keyProperty 然后执行插入语句。如果为AFTER则相反。</td>
</tr>
<tr>
<td>statementType</td>
<td>使用何种语句类型，默认PREPARED。 有STATEMENT，PREPARED 和 CALLABLE 语句的映射类型。</td>
</tr>
</tbody></table>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertUser"</span> &gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyColumn</span>=<span class="string">"id"</span> <span class="attr">resultType</span>=<span class="string">"long"</span> <span class="attr">keyProperty</span>=<span class="string">"userId"</span> <span class="attr">order</span>=<span class="string">"BEFORE"</span>&gt;</span></span><br><span class="line">		SELECT USER_ID.nextval as id from dual </span><br><span class="line">	<span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span> </span><br><span class="line">	insert into user( </span><br><span class="line">	user_id,user_name, user_password, create_time) </span><br><span class="line">	values(#&#123;userId&#125;,#&#123;userName&#125;, #&#123;userPassword&#125; , #&#123;createTime, jdbcType= TIMESTAMP&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此时会将Oracle生成的主键值赋予userId变量。这个userId 就是USER对象的属性，这样就可以将生成的主键值返回了。如果仅仅是在insert语句中使用但是不返回，此时keyProperty=“任意自定义变量名”，resultType 可以不写。<br>Oracle 数据库中的值要设置为 BEFORE ，这是因为 Oracle中需要先从序列获取值，然后将值作为主键插入到数据库中。</p>
<p><strong>扩展</strong><br>如果Mysql 使用selectKey的方式获取主键，需要注意下面两点：</p>
<p>order ： AFTER<br>获取递增主键值 ：SELECT LAST_INSERT_ID()<br>当实体类中的属性名和表中的字段名不一样 ，怎么办</p>
<p>第1种： 通过在查询的SQL语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getOrder"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"com.jourwon.pojo.Order"</span>&gt;</span></span><br><span class="line">       select order_id id, order_no orderno ,order_price price form orders where order_id=#&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第2种： 通过<resultMap>来映射字段名和实体类属性名的一一对应的关系。</resultMap></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getOrder"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultMap</span>=<span class="string">"orderResultMap"</span>&gt;</span></span><br><span class="line">	select * from orders where order_id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.jourwon.pojo.Order"</span> <span class="attr">id</span>=<span class="string">"orderResultMap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">!–用id属性来映射主键字段–</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"order_id"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">!–用result属性来映射非主键字段，property为实体类属性名，column为数据库表中的属性–</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span> =<span class="string">"orderno"</span> <span class="attr">column</span> =<span class="string">"order_no"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"price"</span> <span class="attr">column</span>=<span class="string">"order_price"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">reslutMap</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h5 id="Mapper-编写有哪几种方式？"><a href="#Mapper-编写有哪几种方式？" class="headerlink" title="Mapper 编写有哪几种方式？"></a>Mapper 编写有哪几种方式？</h5><p>第一种：接口实现类继承 SqlSessionDaoSupport：使用此种方法需要编写mapper 接口，mapper 接口实现类、mapper.xml 文件。</p>
<p>（1）在 sqlMapConfig.xml 中配置 mapper.xml 的位置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"mapper.xml 文件的地址"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"mapper.xml 文件的地址"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）定义 mapper 接口</p>
<p>（3）实现类集成 SqlSessionDaoSupport</p>
<p>mapper 方法中可以 this.getSqlSession()进行数据增删改查。</p>
<p>（4）spring 配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">" "</span> <span class="attr">class</span>=<span class="string">"mapper 接口的实现"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactory"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第二种：使用 org.mybatis.spring.mapper.MapperFactoryBean：</p>
<p>（1）在 sqlMapConfig.xml 中配置 mapper.xml 的位置，如果 mapper.xml 和mappre 接口的名称相同且在同一个目录，这里可以不用配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"mapper.xml 文件的地址"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"mapper.xml 文件的地址"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）定义 mapper 接口：</p>
<p>（3）mapper.xml 中的 namespace 为 mapper 接口的地址</p>
<p>（4）mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致</p>
<p>（5）Spring 中定义</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperInterface"</span> <span class="attr">value</span>=<span class="string">"mapper 接口地址"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第三种：使用 mapper 扫描器：</p>
<p>（1）mapper.xml 文件编写：</p>
<p>mapper.xml 中的 namespace 为 mapper 接口的地址；</p>
<p>mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致；</p>
<p>如果将 mapper.xml 和 mapper 接口的名称保持一致则不用在 sqlMapConfig.xml中进行配置。</p>
<p>（2）定义 mapper 接口：</p>
<p>注意 mapper.xml 的文件名和 mapper 的接口名称保持一致，且放在同一个目录</p>
<p>（3）配置 mapper 扫描器：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"mapper 接口包地址</span></span></span><br><span class="line"><span class="tag"><span class="string">    "</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactoryBeanName"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">value</span>=<span class="string">"sqlSessionFactory"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（4）使用扫描器后从 spring 容器中获取 mapper 的实现对象。</p>
<h5 id="什么是MyBatis的接口绑定？有哪些实现方式？"><a href="#什么是MyBatis的接口绑定？有哪些实现方式？" class="headerlink" title="什么是MyBatis的接口绑定？有哪些实现方式？"></a>什么是MyBatis的接口绑定？有哪些实现方式？</h5><p>接口绑定，就是在MyBatis中任意定义接口，然后把接口里面的方法和SQL语句绑定，我们直接调用接口方法就可以，这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置。</p>
<p>接口绑定有两种实现方式</p>
<p>通过注解绑定，就是在接口的方法上面加上 @Select、@Update等注解，里面包含Sql语句来绑定；</p>
<p>通过xml里面写SQL来绑定， 在这种情况下，要指定xml映射文件里面的namespace必须为接口的全路径名。当Sql语句比较简单时候，用注解绑定， 当SQL语句比较复杂时候，用xml绑定，一般用xml绑定的比较多。</p>
<h5 id="使用MyBatis的mapper接口调用时有哪些要求？"><a href="#使用MyBatis的mapper接口调用时有哪些要求？" class="headerlink" title="使用MyBatis的mapper接口调用时有哪些要求？"></a>使用MyBatis的mapper接口调用时有哪些要求？</h5><p>1、Mapper接口方法名和mapper.xml中定义的每个sql的id相同。</p>
<p>2、Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同。</p>
<p>3、Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同。</p>
<p>4、Mapper.xml文件中的namespace即是mapper接口的类路径。</p>
<h5 id="最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗"><a href="#最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗" class="headerlink" title="最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗"></a>最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗</h5><p>Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。在Mybatis中，每一个<select>、<insert>、<update>、<delete>标签，都会被解析为一个MappedStatement对象。</delete></update></insert></select></p>
<p>Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</p>
<p>Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</p>
<h5 id="Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"><a href="#Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？" class="headerlink" title="Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"></a>Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</h5><p>不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。</p>
<p>原因就是namespace+id是作为Map&lt;String, MappedStatement&gt;的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。</p>
<h4 id="简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"><a href="#简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？" class="headerlink" title="简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"></a>简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？</h4><p>答：Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，<parameterMap>标签会被解析为ParameterMap对象，其每个子元素会被解析为ParameterMapping对象。<resultMap>标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个<select>、<insert>、<update>、<delete>标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。</delete></update></insert></select></resultMap></parameterMap></p>
<h5 id="Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h5><p>第一种是使用<resultMap>标签，逐一定义列名和对象属性名之间的映射关系。</resultMap></p>
<p>第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。</p>
<p>有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>
<h5 id="Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？"><a href="#Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？" class="headerlink" title="Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？"></a>Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？</h5><p>还有很多其他的标签，<resultMap>、<parameterMap>、<sql>、<include>、<selectKey>，加上动态sql的9个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，其中<sql>为sql片段标签，通过<include>标签引入sql片段，<selectKey>为不支持自增的主键生成策略标签。</selectKey></include></sql></selectKey></include></sql></parameterMap></resultMap></p>
<h5 id="Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？"><a href="#Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？" class="headerlink" title="Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？"></a>Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？</h5><p>虽然Mybatis解析Xml映射文件是按照顺序解析的，但是，被引用的B标签依然可以定义在任何地方，Mybatis都可以正确识别。</p>
<p>原理是，Mybatis解析A标签，发现A标签引用了B标签，但是B标签尚未解析到，尚不存在，此时，Mybatis会将A标签标记为未解析状态，然后继续解析余下的标签，包含B标签，待所有标签解析完毕，Mybatis会重新解析那些被标记为未解析的标签，此时再解析A标签时，B标签已经存在，A标签也就可以正常解析完成了。</p>
<h4 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h4><h5 id="MyBatis实现一对一，一对多有几种方式，怎么操作的？"><a href="#MyBatis实现一对一，一对多有几种方式，怎么操作的？" class="headerlink" title="MyBatis实现一对一，一对多有几种方式，怎么操作的？"></a>MyBatis实现一对一，一对多有几种方式，怎么操作的？</h5><p>有联合查询和嵌套查询。联合查询是几个表联合查询，只查询一次，通过在resultMap里面的association，collection节点配置一对一，一对多的类就可以完成</p>
<p>嵌套查询是先查一个表，根据这个表里面的结果的外键id，去再另外一个表里面查询数据，也是通过配置association，collection，但另外一个表的查询通过select节点配置。</p>
<h5 id="Mybatis是否可以映射Enum枚举类？"><a href="#Mybatis是否可以映射Enum枚举类？" class="headerlink" title="Mybatis是否可以映射Enum枚举类？"></a>Mybatis是否可以映射Enum枚举类？</h5><p>Mybatis可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列上。映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和getResult()接口方法。</p>
<p>TypeHandler有两个作用，一是完成从javaType至jdbcType的转换，二是完成jdbcType至javaType的转换，体现为setParameter()和getResult()两个方法，分别代表设置sql问号占位符参数和获取列查询结果。</p>
<h4 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h4><h5 id="Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？"><a href="#Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？" class="headerlink" title="Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？"></a>Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？</h5><p>Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能，Mybatis提供了9种动态sql标签trim|where|set|foreach|if|choose|when|otherwise|bind。</p>
<p>其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。</p>
<h4 id="插件模块"><a href="#插件模块" class="headerlink" title="插件模块"></a>插件模块</h4><h5 id="Mybatis是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis是如何进行分页的？分页插件的原理是什么？"></a>Mybatis是如何进行分页的？分页插件的原理是什么？</h5><p>Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p>
<p>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p>
<p>举例：select * from student，拦截sql后重写为：select t.* from (select * from student) t limit 0, 10</p>
<h5 id="简述Mybatis的插件运行原理，以及如何编写一个插件。"><a href="#简述Mybatis的插件运行原理，以及如何编写一个插件。" class="headerlink" title="简述Mybatis的插件运行原理，以及如何编写一个插件。"></a>简述Mybatis的插件运行原理，以及如何编写一个插件。</h5><p>Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</p>
<p>实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><h5 id="Mybatis的一级、二级缓存"><a href="#Mybatis的一级、二级缓存" class="headerlink" title="Mybatis的一级、二级缓存"></a>Mybatis的一级、二级缓存</h5><p>1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。</p>
<p>2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<cache> ；</cache></p>
<p>3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot面试题</title>
    <url>/myblog/interview/Spring%20Boot%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><a id="more"></a>
<h5 id="什么是-Spring-Boot？"><a href="#什么是-Spring-Boot？" class="headerlink" title="什么是 Spring Boot？"></a>什么是 Spring Boot？</h5><p>Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。</p>
<h5 id="Spring-Boot-有哪些优点？"><a href="#Spring-Boot-有哪些优点？" class="headerlink" title="Spring Boot 有哪些优点？"></a>Spring Boot 有哪些优点？</h5><p>Spring Boot 主要有如下优点：</p>
<ol>
<li>容易上手，提升开发效率，为 Spring 开发提供一个更快、更广泛的入门体验。</li>
<li>开箱即用，远离繁琐的配置。</li>
<li>提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等。</li>
<li>没有代码生成，也不需要XML配置。</li>
<li>避免大量的 Maven 导入和各种版本冲突。</li>
</ol>
<h5 id="Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？"><a href="#Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？" class="headerlink" title="Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？"></a>Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</h5><p>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：</p>
<p>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</p>
<p>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。</p>
<p>@ComponentScan：Spring组件扫描。</p>
<!--more-->

<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><h5 id="什么是-JavaConfig？"><a href="#什么是-JavaConfig？" class="headerlink" title="什么是 JavaConfig？"></a>什么是 JavaConfig？</h5><p>Spring JavaConfig 是 Spring 社区的产品，它提供了配置 Spring IoC 容器的纯Java 方法。因此它有助于避免使用 XML 配置。使用 JavaConfig 的优点在于：</p>
<p>（1）面向对象的配置。由于配置被定义为 JavaConfig 中的类，因此用户可以充分利用 Java 中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean 方法等。</p>
<p>（2）减少或消除 XML 配置。基于依赖注入原则的外化配置的好处已被证明。但是，许多开发人员不希望在 XML 和 Java 之间来回切换。JavaConfig 为开发人员提供了一种纯 Java 方法来配置与 XML 配置概念相似的 Spring 容器。从技术角度来讲，只使用 JavaConfig 配置类来配置容器是可行的，但实际上很多人认为将JavaConfig 与 XML 混合匹配是理想的。</p>
<p>（3）类型安全和重构友好。JavaConfig 提供了一种类型安全的方法来配置 Spring容器。由于 Java 5.0 对泛型的支持，现在可以按类型而不是按名称检索 bean，不需要任何强制转换或基于字符串的查找。</p>
<h5 id="Spring-Boot-自动配置原理是什么？"><a href="#Spring-Boot-自动配置原理是什么？" class="headerlink" title="Spring Boot 自动配置原理是什么？"></a>Spring Boot 自动配置原理是什么？</h5><p>注解 @EnableAutoConfiguration, @Configuration, @ConditionalOnClass 就是自动配置的核心，</p>
<p>@EnableAutoConfiguration 给容器导入META-INF/spring.factories 里定义的自动配置类。</p>
<p>筛选有效的自动配置类。</p>
<p>每一个自动配置类结合对应的 xxxProperties.java 读取配置文件进行自动配置功能</p>
<h5 id="你如何理解-Spring-Boot-配置加载顺序？"><a href="#你如何理解-Spring-Boot-配置加载顺序？" class="headerlink" title="你如何理解 Spring Boot 配置加载顺序？"></a>你如何理解 Spring Boot 配置加载顺序？</h5><p>在 Spring Boot 里面，可以使用以下几种方式来加载配置。</p>
<p>1）properties文件；</p>
<p>2）YAML文件；</p>
<p>3）系统环境变量；</p>
<p>4）命令行参数；</p>
<p>等等……</p>
<h5 id="什么是-YAML？"><a href="#什么是-YAML？" class="headerlink" title="什么是 YAML？"></a>什么是 YAML？</h5><p>YAML 是一种人类可读的数据序列化语言。它通常用于配置文件。与属性文件相比，如果我们想要在配置文件中添加复杂的属性，YAML 文件就更加结构化，而且更少混淆。可以看出 YAML 具有分层配置数据。</p>
<h5 id="YAML-配置的优势在哪里"><a href="#YAML-配置的优势在哪里" class="headerlink" title="YAML 配置的优势在哪里 ?"></a>YAML 配置的优势在哪里 ?</h5><p>YAML 现在可以算是非常流行的一种配置文件格式了，无论是前端还是后端，都可以见到 YAML 配置。那么 YAML 配置和传统的 properties 配置相比到底有哪些优势呢？</p>
<ol>
<li>配置有序，在一些特殊的场景下，配置有序很关键</li>
<li>支持数组，数组中的元素可以是基本数据类型也可以是对象</li>
<li>简洁</li>
</ol>
<p>相比 properties 配置文件，YAML 还有一个缺点，就是不支持 @PropertySource 注解导入自定义的 YAML 配置。</p>
<h5 id="Spring-Boot-是否可以使用-XML-配置"><a href="#Spring-Boot-是否可以使用-XML-配置" class="headerlink" title="Spring Boot 是否可以使用 XML 配置 ?"></a>Spring Boot 是否可以使用 XML 配置 ?</h5><p>Spring Boot 推荐使用 Java 配置而非 XML 配置，但是 Spring Boot 中也可以使用 XML 配置，通过 @ImportResource 注解可以引入一个 XML 配置。</p>
<h5 id="spring-boot-核心配置文件是什么？bootstrap-properties-和-application-properties-有何区别"><a href="#spring-boot-核心配置文件是什么？bootstrap-properties-和-application-properties-有何区别" class="headerlink" title="spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?"></a>spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?</h5><p>单纯做 Spring Boot 开发，可能不太容易遇到 bootstrap.properties 配置文件，但是在结合 Spring Cloud 时，这个配置就会经常遇到了，特别是在需要加载一些远程配置文件的时侯。</p>
<p>spring boot 核心的两个配置文件：</p>
<ul>
<li>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效。一般来说我们在 Spring Cloud Config 或者 Nacos 中会用到它。且 boostrap 里面的属性不能被覆盖；</li>
<li>application (. yml 或者 . properties)： 由ApplicatonContext 加载，用于 spring boot 项目的自动化配置。</li>
</ul>
<h5 id="什么是-Spring-Profiles？"><a href="#什么是-Spring-Profiles？" class="headerlink" title="什么是 Spring Profiles？"></a>什么是 Spring Profiles？</h5><p>Spring Profiles 允许用户根据配置文件（dev，test，prod 等）来注册 bean。因此，当应用程序在开发中运行时，只有某些 bean 可以加载，而在 PRODUCTION中，某些其他 bean 可以加载。假设我们的要求是 Swagger 文档仅适用于 QA 环境，并且禁用所有其他文档。这可以使用配置文件来完成。Spring Boot 使得使用配置文件非常简单。</p>
<h5 id="如何在自定义端口上运行-Spring-Boot-应用程序？"><a href="#如何在自定义端口上运行-Spring-Boot-应用程序？" class="headerlink" title="如何在自定义端口上运行 Spring Boot 应用程序？"></a>如何在自定义端口上运行 Spring Boot 应用程序？</h5><p>为了在自定义端口上运行 Spring Boot 应用程序，您可以在application.properties 中指定端口。server.port = 8090</p>
<h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><h5 id="如何实现-Spring-Boot-应用程序的安全性？"><a href="#如何实现-Spring-Boot-应用程序的安全性？" class="headerlink" title="如何实现 Spring Boot 应用程序的安全性？"></a>如何实现 Spring Boot 应用程序的安全性？</h5><p>为了实现 Spring Boot 的安全性，我们使用 spring-boot-starter-security 依赖项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩展WebSecurityConfigurerAdapter 并覆盖其方法。</p>
<h5 id="比较一下-Spring-Security-和-Shiro-各自的优缺点"><a href="#比较一下-Spring-Security-和-Shiro-各自的优缺点" class="headerlink" title="比较一下 Spring Security 和 Shiro 各自的优缺点 ?"></a>比较一下 Spring Security 和 Shiro 各自的优缺点 ?</h5><p>由于 Spring Boot 官方提供了大量的非常方便的开箱即用的 Starter ，包括 Spring Security 的 Starter ，使得在 Spring Boot 中使用 Spring Security 变得更加容易，甚至只需要添加一个依赖就可以保护所有的接口，所以，如果是 Spring Boot 项目，一般选择 Spring Security 。当然这只是一个建议的组合，单纯从技术上来说，无论怎么组合，都是没有问题的。Shiro 和 Spring Security 相比，主要有如下一些特点：</p>
<ol>
<li>Spring Security 是一个重量级的安全管理框架；Shiro 则是一个轻量级的安全管理框架</li>
<li>Spring Security 概念复杂，配置繁琐；Shiro 概念简单、配置简单</li>
<li>Spring Security 功能强大；Shiro 功能简单</li>
</ol>
<h5 id="Spring-Boot-中如何解决跨域问题"><a href="#Spring-Boot-中如何解决跨域问题" class="headerlink" title="Spring Boot 中如何解决跨域问题 ?"></a>Spring Boot 中如何解决跨域问题 ?</h5><p>跨域可以在前端通过 JSONP 来解决，但是 JSONP 只可以发送 GET 请求，无法发送其他类型的请求，在 RESTful 风格的应用中，就显得非常鸡肋，因此我们推荐在后端通过 （CORS，Cross-origin resource sharing） 来解决跨域问题。这种解决方案并非 Spring Boot 特有的，在传统的 SSM 框架中，就可以通过 CORS 来解决跨域问题，只不过之前我们是在 XML 文件中配置 CORS ，现在可以通过实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">"/**"</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">"*"</span>)</span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>)</span><br><span class="line">                .allowedMethods(<span class="string">"GET"</span>, <span class="string">"POST"</span>, <span class="string">"PUT"</span>, <span class="string">"DELETE"</span>, <span class="string">"OPTIONS"</span>)</span><br><span class="line">                .maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>项目中前后端分离部署，所以需要解决跨域的问题。<br>我们使用cookie存放用户登录的信息，在spring拦截器进行权限控制，当权限不符合时，直接返回给用户固定的json结果。<br>当用户登录以后，正常使用；当用户退出登录状态时或者token过期时，由于拦截器和跨域的顺序有问题，出现了跨域的现象。<br>我们知道一个http请求，先走filter，到达servlet后才进行拦截器的处理，如果我们把cors放在filter里，就可以优先于权限拦截器执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CorsConfiguration corsConfiguration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        corsConfiguration.addAllowedOrigin(<span class="string">"*"</span>);</span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="string">"*"</span>);</span><br><span class="line">        corsConfiguration.addAllowedMethod(<span class="string">"*"</span>);</span><br><span class="line">        corsConfiguration.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">        UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        urlBasedCorsConfigurationSource.registerCorsConfiguration(<span class="string">"/**"</span>, corsConfiguration);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(urlBasedCorsConfigurationSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="什么是-CSRF-攻击？"><a href="#什么是-CSRF-攻击？" class="headerlink" title="什么是 CSRF 攻击？"></a>什么是 CSRF 攻击？</h5><p>CSRF 代表跨站请求伪造。这是一种攻击，迫使最终用户在当前通过身份验证的Web 应用程序上执行不需要的操作。CSRF 攻击专门针对状态改变请求，而不是数据窃取，因为攻击者无法查看对伪造请求的响应。</p>
<h4 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h4><h5 id="Spring-Boot-中的监视器是什么？"><a href="#Spring-Boot-中的监视器是什么？" class="headerlink" title="Spring Boot 中的监视器是什么？"></a>Spring Boot 中的监视器是什么？</h5><p>Spring boot actuator 是 spring 启动框架中的重要功能之一。Spring boot 监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为 HTTP URL 访问的REST 端点来检查状态。</p>
<h5 id="如何在-Spring-Boot-中禁用-Actuator-端点安全性？"><a href="#如何在-Spring-Boot-中禁用-Actuator-端点安全性？" class="headerlink" title="如何在 Spring Boot 中禁用 Actuator 端点安全性？"></a>如何在 Spring Boot 中禁用 Actuator 端点安全性？</h5><p>默认情况下，所有敏感的 HTTP 端点都是安全的，只有具有 ACTUATOR 角色的用户才能访问它们。安全性是使用标准的 HttpServletRequest.isUserInRole 方法实施的。 我们可以使用来禁用安全性。只有在执行机构端点在防火墙后访问时，才建议禁用安全性。</p>
<h5 id="我们如何监视所有-Spring-Boot-微服务？"><a href="#我们如何监视所有-Spring-Boot-微服务？" class="headerlink" title="我们如何监视所有 Spring Boot 微服务？"></a>我们如何监视所有 Spring Boot 微服务？</h5><p>Spring Boot 提供监视器端点以监控各个微服务的度量。这些端点对于获取有关应用程序的信息（如它们是否已启动）以及它们的组件（如数据库等）是否正常运行很有帮助。但是，使用监视器的一个主要缺点或困难是，我们必须单独打开应用程序的知识点以了解其状态或健康状况。想象一下涉及 50 个应用程序的微服务，管理员将不得不击中所有 50 个应用程序的执行终端。为了帮助我们处理这种情况，我们将使用位于的开源项目。 它建立在 Spring Boot Actuator 之上，它提供了一个 Web UI，使我们能够可视化多个应用程序的度量。</p>
<h4 id="整合第三方项目"><a href="#整合第三方项目" class="headerlink" title="整合第三方项目"></a>整合第三方项目</h4><h5 id="什么是-WebSockets？"><a href="#什么是-WebSockets？" class="headerlink" title="什么是 WebSockets？"></a>什么是 WebSockets？</h5><p>WebSocket 是一种计算机通信协议，通过单个 TCP 连接提供全双工通信信道。</p>
<p>1、WebSocket 是双向的 -使用 WebSocket 客户端或服务器可以发起消息发送。</p>
<p>2、WebSocket 是全双工的 -客户端和服务器通信是相互独立的。</p>
<p>3、单个 TCP 连接 -初始连接使用 HTTP，然后将此连接升级到基于套接字的连接。然后这个单一连接用于所有未来的通信</p>
<p>4、Light -与 http 相比，WebSocket 消息数据交换要轻得多。</p>
<h5 id="什么是-Spring-Data"><a href="#什么是-Spring-Data" class="headerlink" title="什么是 Spring Data ?"></a>什么是 Spring Data ?</h5><p>Spring Data 是 Spring 的一个子项目。用于简化数据库访问，支持NoSQL 和 关系数据存储。其主要目标是使数据库的访问变得方便快捷。Spring Data 具有如下特点：</p>
<p>SpringData 项目支持 NoSQL 存储：</p>
<ol>
<li>MongoDB （文档数据库）</li>
<li>Neo4j（图形数据库）</li>
<li>Redis（键/值存储）</li>
<li>Hbase（列族数据库）</li>
</ol>
<p>SpringData 项目所支持的关系数据存储技术：</p>
<ol>
<li>JDBC</li>
<li>JPA</li>
</ol>
<p>Spring Data Jpa 致力于减少数据访问层 (DAO) 的开发量. 开发者唯一要做的，就是声明持久层的接口，其他都交给 Spring Data JPA 来帮你完成！Spring Data JPA 通过规范方法的名字，根据符合规范的名字来确定方法需要实现什么样的逻辑。</p>
<h5 id="什么是-Spring-Batch？"><a href="#什么是-Spring-Batch？" class="headerlink" title="什么是 Spring Batch？"></a>什么是 Spring Batch？</h5><p>Spring Boot Batch 提供可重用的函数，这些函数在处理大量记录时非常重要，包括日志/跟踪，事务管理，作业处理统计信息，作业重新启动，跳过和资源管理。它还提供了更先进的技术服务和功能，通过优化和分区技术，可以实现极高批量和高性能批处理作业。简单以及复杂的大批量批处理作业可以高度可扩展的方式利用框架处理重要大量的信息。</p>
<h5 id="什么是-FreeMarker-模板？"><a href="#什么是-FreeMarker-模板？" class="headerlink" title="什么是 FreeMarker 模板？"></a>什么是 FreeMarker 模板？</h5><p>FreeMarker 是一个基于 Java 的模板引擎，最初专注于使用 MVC 软件架构进行动态网页生成。使用 Freemarker 的主要优点是表示层和业务层的完全分离。程序员可以处理应用程序代码，而设计人员可以处理 html 页面设计。最后使用freemarker 可以将这些结合起来，给出最终的输出页面。</p>
<h5 id="如何集成-Spring-Boot-和-ActiveMQ？"><a href="#如何集成-Spring-Boot-和-ActiveMQ？" class="headerlink" title="如何集成 Spring Boot 和 ActiveMQ？"></a>如何集成 Spring Boot 和 ActiveMQ？</h5><p>对于集成 Spring Boot 和 ActiveMQ，我们使用依赖关系。 它只需要很少的配置，并且不需要样板代码。</p>
<h5 id="什么是-Apache-Kafka？"><a href="#什么是-Apache-Kafka？" class="headerlink" title="什么是 Apache Kafka？"></a>什么是 Apache Kafka？</h5><p>Apache Kafka 是一个分布式发布 - 订阅消息系统。它是一个可扩展的，容错的发布 - 订阅消息系统，它使我们能够构建分布式应用程序。这是一个 Apache 顶级项目。Kafka 适合离线和在线消息消费。</p>
<h5 id="什么是-Swagger？你用-Spring-Boot-实现了它吗？"><a href="#什么是-Swagger？你用-Spring-Boot-实现了它吗？" class="headerlink" title="什么是 Swagger？你用 Spring Boot 实现了它吗？"></a>什么是 Swagger？你用 Spring Boot 实现了它吗？</h5><p>Swagger 广泛用于可视化 API，使用 Swagger UI 为前端开发人员提供在线沙箱。Swagger 是用于生成 RESTful Web 服务的可视化表示的工具，规范和完整框架实现。它使文档能够以与服务器相同的速度更新。当通过 Swagger 正确定义时，消费者可以使用最少量的实现逻辑来理解远程服务并与其进行交互。因此，Swagger消除了调用服务时的猜测。</p>
<h5 id="前后端分离，如何维护接口文档"><a href="#前后端分离，如何维护接口文档" class="headerlink" title="前后端分离，如何维护接口文档 ?"></a>前后端分离，如何维护接口文档 ?</h5><p>前后端分离开发日益流行，大部分情况下，我们都是通过 Spring Boot 做前后端分离开发，前后端分离一定会有接口文档，不然会前后端会深深陷入到扯皮中。一个比较笨的方法就是使用 word 或者 md 来维护接口文档，但是效率太低，接口一变，所有人手上的文档都得变。在 Spring Boot 中，这个问题常见的解决方案是 Swagger ，使用 Swagger 我们可以快速生成一个接口文档网站，接口一旦发生变化，文档就会自动更新，所有开发工程师访问这一个在线网站就可以获取到最新的接口文档，非常方便。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h5 id="如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？Spring-Boot项目如何热部署？"><a href="#如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？Spring-Boot项目如何热部署？" class="headerlink" title="如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？"></a>如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？</h5><p>这可以使用 DEV 工具来实现。通过这种依赖关系，您可以节省任何更改，嵌入式tomcat 将重新启动。Spring Boot 有一个开发工具（DevTools）模块，它有助于提高开发人员的生产力。Java 开发人员面临的一个主要挑战是将文件更改自动部署到服务器并自动重启服务器。开发人员可以重新加载 Spring Boot 上的更改，而无需重新启动服务器。这将消除每次手动部署更改的需要。Spring Boot 在发布它的第一个版本时没有这个功能。这是开发人员最需要的功能。DevTools 模块完全满足开发人员的需求。该模块将在生产环境中被禁用。它还提供 H2 数据库控制台以更好地测试应用程序。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="您使用了哪些-starter-maven-依赖项？"><a href="#您使用了哪些-starter-maven-依赖项？" class="headerlink" title="您使用了哪些 starter maven 依赖项？"></a>您使用了哪些 starter maven 依赖项？</h5><p>使用了下面的一些依赖项</p>
<p>spring-boot-starter-activemq</p>
<p>spring-boot-starter-security</p>
<p>这有助于增加更少的依赖关系，并减少版本的冲突。</p>
<h5 id="Spring-Boot-中的-starter-到底是什么"><a href="#Spring-Boot-中的-starter-到底是什么" class="headerlink" title="Spring Boot 中的 starter 到底是什么 ?"></a>Spring Boot 中的 starter 到底是什么 ?</h5><p>首先，这个 Starter 并非什么新的技术点，基本上还是基于 Spring 已有功能来实现的。首先它提供了一个自动化配置类，一般命名为 XXXAutoConfiguration ，在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 Spring 中原本就有的），然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置，然后通过类型安全的属性注入将这些配置属性注入进来，新注入的属性会代替掉默认属性。正因为如此，很多第三方框架，我们只需要引入依赖就可以直接使用了。当然，开发者也可以自定义 Starter</p>
<h5 id="spring-boot-starter-parent-有什么用"><a href="#spring-boot-starter-parent-有什么用" class="headerlink" title="spring-boot-starter-parent 有什么用 ?"></a>spring-boot-starter-parent 有什么用 ?</h5><p>我们都知道，新创建一个 Spring Boot 项目，默认都是有 parent 的，这个 parent 就是 spring-boot-starter-parent ，spring-boot-starter-parent 主要有如下作用：</p>
<ol>
<li>定义了 Java 编译版本为 1.8 。</li>
<li>使用 UTF-8 格式编码。</li>
<li>继承自 spring-boot-dependencies，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。</li>
<li>执行打包操作的配置。</li>
<li>自动化的资源过滤。</li>
<li>自动化的插件配置。</li>
<li>针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配置文件，例如 application-dev.properties 和 application-dev.yml。</li>
</ol>
<h5 id="Spring-Boot-打成的-jar-和普通的-jar-有什么区别"><a href="#Spring-Boot-打成的-jar-和普通的-jar-有什么区别" class="headerlink" title="Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?"></a>Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?</h5><p>Spring Boot 项目最终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 java -jar xxx.jar 命令来运行，这种 jar 不可以作为普通的 jar 被其他项目依赖，即使依赖了也无法使用其中的类。</p>
<p>Spring Boot 的 jar 无法被其他项目依赖，主要还是他和普通 jar 的结构不同。普通的 jar 包，解压后直接就是包名，包里就是我们的代码，而 Spring Boot 打包成的可执行 jar 解压后，在 \BOOT-INF\classes 目录下才是我们的代码，因此无法被直接引用。如果非要引用，可以在 pom.xml 文件中增加配置，将 Spring Boot 项目打包成两个 jar ，一个可执行，一个可引用。</p>
<h5 id="运行-Spring-Boot-有哪几种方式？"><a href="#运行-Spring-Boot-有哪几种方式？" class="headerlink" title="运行 Spring Boot 有哪几种方式？"></a>运行 Spring Boot 有哪几种方式？</h5><p>1）打包用命令或者放到容器中运行</p>
<p>2）用 Maven/ Gradle 插件运行</p>
<p>3）直接执行 main 方法运行</p>
<h5 id="Spring-Boot-需要独立的容器运行吗？"><a href="#Spring-Boot-需要独立的容器运行吗？" class="headerlink" title="Spring Boot 需要独立的容器运行吗？"></a>Spring Boot 需要独立的容器运行吗？</h5><p>可以不需要，内置了 Tomcat/ Jetty 等容器。</p>
<h5 id="开启-Spring-Boot-特性有哪几种方式？"><a href="#开启-Spring-Boot-特性有哪几种方式？" class="headerlink" title="开启 Spring Boot 特性有哪几种方式？"></a>开启 Spring Boot 特性有哪几种方式？</h5><p>1）继承spring-boot-starter-parent项目</p>
<p>2）导入spring-boot-dependencies项目依赖</p>
<h5 id="如何使用-Spring-Boot-实现异常处理？"><a href="#如何使用-Spring-Boot-实现异常处理？" class="headerlink" title="如何使用 Spring Boot 实现异常处理？"></a>如何使用 Spring Boot 实现异常处理？</h5><p>Spring 提供了一种使用 ControllerAdvice 处理异常的非常有用的方法。 我们通过实现一个 ControlerAdvice 类，来处理控制器类抛出的所有异常。</p>
<h5 id="如何使用-Spring-Boot-实现分页和排序？"><a href="#如何使用-Spring-Boot-实现分页和排序？" class="headerlink" title="如何使用 Spring Boot 实现分页和排序？"></a>如何使用 Spring Boot 实现分页和排序？</h5><p>使用 Spring Boot 实现分页非常简单。使用 Spring Data-JPA 可以实现将可分页的传递给存储库方法。</p>
<h5 id="微服务中如何实现-session-共享"><a href="#微服务中如何实现-session-共享" class="headerlink" title="微服务中如何实现 session 共享 ?"></a>微服务中如何实现 session 共享 ?</h5><p>在微服务中，一个完整的项目被拆分成多个不相同的独立的服务，各个服务独立部署在不同的服务器上，各自的 session 被从物理空间上隔离开了，但是经常，我们需要在不同微服务之间共享 session ，常见的方案就是 Spring Session + Redis 来实现 session 共享。将所有微服务的 session 统一保存在 Redis 上，当各个微服务对 session 有相关的读写操作时，都去操作 Redis 上的 session 。这样就实现了 session 共享，Spring Session 基于 Spring 中的代理过滤器实现，使得 session 的同步操作对开发人员而言是透明的，非常简便。</p>
<h5 id="Spring-Boot-中如何实现定时任务"><a href="#Spring-Boot-中如何实现定时任务" class="headerlink" title="Spring Boot 中如何实现定时任务 ?"></a>Spring Boot 中如何实现定时任务 ?</h5><p>定时任务也是一个常见的需求，Spring Boot 中对于定时任务的支持主要还是来自 Spring 框架。</p>
<p>在 Spring Boot 中使用定时任务主要有两种不同的方式，一个就是使用 Spring 中的 @Scheduled 注解，另一个则是使用第三方框架 Quartz。</p>
<p>使用 Spring 中的 @Scheduled 的方式主要通过 @Scheduled 注解来实现。</p>
<p>使用 Quartz ，则按照 Quartz 的方式，定义 Job 和 Trigger 即可。</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis面试题</title>
    <url>/myblog/interview/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><a id="more"></a>
<h5 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h5><p>Redis(Remote Dictionary Server) 是一个使用 C 语言编写的，开源的（BSD许可）高性能非关系型（NoSQL）的键值对数据库。</p>
<p>Redis 可以存储键和五种不同类型的值之间的映射。键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。</p>
<p>与传统数据库不同的是 Redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。另外，Redis 也经常用来做分布式锁。除此之外，Redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。</p>
<h5 id="Redis有哪些优缺点"><a href="#Redis有哪些优缺点" class="headerlink" title="Redis有哪些优缺点"></a>Redis有哪些优缺点</h5><p>优点</p>
<ul>
<li><p>读写性能优异， Redis能读的速度是110000次/s，写的速度是81000次/s。</p>
</li>
<li><p>支持数据持久化，支持AOF和RDB两种持久化方式。</p>
</li>
<li><p>支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。</p>
</li>
<li><p>数据结构丰富，除了支持string类型的value外还支持hash、set、zset、list等数据结构。</p>
</li>
<li><p>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。</p>
<!--more-->

</li>
</ul>
<p>缺点</p>
<ul>
<li>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</li>
<li>Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。</li>
<li>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。</li>
<li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</li>
</ul>
<h5 id="为什么要用-Redis-为什么要用缓存"><a href="#为什么要用-Redis-为什么要用缓存" class="headerlink" title="为什么要用 Redis /为什么要用缓存"></a>为什么要用 Redis /为什么要用缓存</h5><p>主要从“高性能”和“高并发”这两点来看待这个问题。</p>
<p><strong>高性能：</strong></p>
<p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDUzNDg2OS02N2YxOGVmY2FmZTQ2NjlhLmpwZw?x-oss-process=image/format,png" alt></p>
<p><strong>高并发：</strong></p>
<p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDUzNDg2OS0wOWIxZDI3OWEwNWVmNWJjLmpwZw?x-oss-process=image/format,png" alt></p>
<h5 id="为什么要用-Redis-而不用-map-guava-做缓存"><a href="#为什么要用-Redis-而不用-map-guava-做缓存" class="headerlink" title="为什么要用 Redis 而不用 map/guava 做缓存?"></a>为什么要用 Redis 而不用 map/guava 做缓存?</h5><p>缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。</p>
<p>使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。</p>
<h5 id="Redis为什么这么快"><a href="#Redis为什么这么快" class="headerlink" title="Redis为什么这么快"></a>Redis为什么这么快</h5><p>1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)；</p>
<p>2、数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；</p>
<p>3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p>
<p>4、使用多路 I/O 复用模型，非阻塞 IO；</p>
<p>5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；<br>数据类型</p>
<h5 id="Redis有哪些数据类型"><a href="#Redis有哪些数据类型" class="headerlink" title="Redis有哪些数据类型"></a>Redis有哪些数据类型</h5><p>Redis主要有5种数据类型，包括String，List，Set，Zset，Hash，满足大部分的使用要求4</p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">可以存储的值</th>
<th align="center">操作</th>
<th align="center">应用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">STRING</td>
<td align="center">字符串、整数或者浮点数</td>
<td align="center">对整个字符串或者字符串的其中一部分执行操作 对整数和浮点数执行自增或者自减操作</td>
<td align="center">做简单的键值对缓存</td>
</tr>
<tr>
<td align="center">LIST</td>
<td align="center">列表</td>
<td align="center">从两端压入或者弹出元素 对单个或者多个元素进行修剪， 只保留一个范围内的元素</td>
<td align="center">存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的数据</td>
</tr>
<tr>
<td align="center">SET</td>
<td align="center">无序集合</td>
<td align="center">添加、获取、移除单个元素 检查一个元素是否存在于集合中  计算交集、并集、差集 从集合里面随机获取元素</td>
<td align="center">交集、并集、差集的操作，比如交集，可以把两个人的粉丝列表整一个交集</td>
</tr>
<tr>
<td align="center">HASH</td>
<td align="center">包含键值对的无序散列表</td>
<td align="center">添加、获取、移除单个键值对 获取所有键值对  检查某个键是否存在</td>
<td align="center">结构化的数据，比如一个对象</td>
</tr>
<tr>
<td align="center">ZSET</td>
<td align="center">有序集合</td>
<td align="center">添加、获取、删除元素 根据分值范围或者成员来获取元素  计算一个键的排名</td>
<td align="center">去重但可以排序，如获取排名前几名的用户</td>
</tr>
</tbody></table>
<h5 id="Redis的应用场景"><a href="#Redis的应用场景" class="headerlink" title="Redis的应用场景"></a>Redis的应用场景</h5><p><strong>总结一</strong></p>
<p>计数器</p>
<p>可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</p>
<p>缓存</p>
<p>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</p>
<p>会话缓存</p>
<p>可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</p>
<p>全页缓存（FPC）</p>
<p>除基本的会话token之外，Redis还提供很简便的FPC平台。以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</p>
<p>查找表</p>
<p>例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。</p>
<p>消息队列(发布/订阅功能)</p>
<p>List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。</p>
<p>分布式锁实现</p>
<p>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</p>
<p>其它</p>
<p>Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet 可以实现有序性操作，从而实现排行榜等功能。</p>
<p><strong>总结二</strong></p>
<p>Redis相比其他缓存，有一个非常大的优势，就是支持多种数据类型。</p>
<p>数据类型说明string字符串，最简单的k-v存储hashhash格式，value为field和value，适合ID-Detail这样的场景。list简单的list，顺序列表，支持首位或者末尾插入数据set无序list，查找速度快，适合交集、并集、差集处理sorted set有序的set</p>
<p>其实，通过上面的数据类型的特性，基本就能想到合适的应用场景了。</p>
<p>string——适合最简单的k-v存储，类似于memcached的存储结构，短信验证码，配置信息等，就用这种类型来存储。</p>
<p>hash——一般key为ID或者唯一标示，value对应的就是详情了。如商品详情，个人信息详情，新闻详情等。</p>
<p>list——因为list是有序的，比较适合存储一些有序且数据相对固定的数据。如省市区表、字典表等。因为list是有序的，适合根据写入的时间来排序，如：最新的***，消息队列等。</p>
<p>set——可以简单的理解为ID-List的模式，如微博中一个人有哪些好友，set最牛的地方在于，可以对两个set提供交集、并集、差集操作。例如：查找两个人共同的好友等。</p>
<p>Sorted Set——是set的增强版本，增加了一个score参数，自动会根据score的值进行排序。比较适合类似于top 10等不根据插入的时间来排序的数据。</p>
<p>如上所述，虽然Redis不像关系数据库那么复杂的数据结构，但是，也能适合很多场景，比一般的缓存数据结构要多。了解每种数据结构适合的业务场景，不仅有利于提升开发效率，也能有效利用Redis的性能。</p>
<h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><h5 id="什么是Redis持久化？"><a href="#什么是Redis持久化？" class="headerlink" title="什么是Redis持久化？"></a>什么是Redis持久化？</h5><p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。</p>
<h5 id="Redis-的持久化机制是什么？各自的优缺点？"><a href="#Redis-的持久化机制是什么？各自的优缺点？" class="headerlink" title="Redis 的持久化机制是什么？各自的优缺点？"></a>Redis 的持久化机制是什么？各自的优缺点？</h5><p>Redis 提供两种持久化机制 RDB（默认） 和 AOF 机制:</p>
<p>RDB：是Redis DataBase缩写快照</p>
<p>RDB是Redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MDU1NjY2LWMwNzAyMjIzMTUxODUyMjkucG5n?x-oss-process=image/format,png" alt></p>
<p>优点：</p>
<ul>
<li>1、只有一个文件 dump.rdb，方便持久化。</li>
<li>2、容灾性好，一个文件可以保存到安全的磁盘。</li>
<li>3、性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能</li>
<li>4.相对于数据集大时，比 AOF 的启动效率更高。</li>
</ul>
<p>缺点：</p>
<ul>
<li>1、数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)</li>
<li>2、AOF（Append-only file)持久化方式： 是指所有的命令行记录以 redis 命令请 求协议的格式完全持久化存储)保存为 aof 文件。</li>
</ul>
<p>AOF：持久化</p>
<p>AOF持久化(即Append Only File持久化)，则是将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。</p>
<p>当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MDU1NjY2LWUxN2NlNTY0NGZjN2FjZjMucG5n?x-oss-process=image/format,png" alt></p>
<p>优点：</p>
<ul>
<li>1、数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。</li>
<li>2、通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</li>
<li>3、AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)</li>
</ul>
<p>缺点：</p>
<ul>
<li>1、AOF 文件比 RDB 文件大，且恢复速度慢。</li>
<li>2、数据集大的时候，比 rdb 启动效率低。</li>
</ul>
<p>优缺点是什么？</p>
<ul>
<li>AOF文件比RDB更新频率高，优先使用AOF还原数据。</li>
<li>AOF比RDB更安全也更大</li>
<li>RDB性能比AOF好</li>
<li>如果两个都配了优先加载AOF</li>
</ul>
<p>如何选择合适的持久化方式</p>
<ul>
<li>一般来说， 如果想达到足以媲美PostgreSQL的数据安全性，你应该同时使用两种持久化功能。在这种情况下，当 Redis 重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</li>
<li>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用RDB持久化。</li>
<li>有很多用户都只使用AOF持久化，但并不推荐这种方式，因为定时生成RDB快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快，除此之外，使用RDB还可以避免AOF程序的bug。</li>
<li>如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。</li>
</ul>
<h5 id="Redis持久化数据和缓存怎么做扩容？"><a href="#Redis持久化数据和缓存怎么做扩容？" class="headerlink" title="Redis持久化数据和缓存怎么做扩容？"></a>Redis持久化数据和缓存怎么做扩容？</h5><ul>
<li>如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。</li>
<li>如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。</li>
</ul>
<h4 id="过期键的删除策略"><a href="#过期键的删除策略" class="headerlink" title="过期键的删除策略"></a>过期键的删除策略</h4><h5 id="Redis的过期键的删除策略"><a href="#Redis的过期键的删除策略" class="headerlink" title="Redis的过期键的删除策略"></a>Redis的过期键的删除策略</h5><p>我们都知道，Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。</p>
<p>过期策略通常有以下三种：</p>
<ul>
<li>定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</li>
<li>惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</li>
<li>定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。<br>(expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)</li>
</ul>
<p>Redis中同时使用了惰性过期和定期过期两种过期策略。</p>
<h5 id="Redis-key的过期时间和永久有效分别怎么设置？"><a href="#Redis-key的过期时间和永久有效分别怎么设置？" class="headerlink" title="Redis key的过期时间和永久有效分别怎么设置？"></a>Redis key的过期时间和永久有效分别怎么设置？</h5><p>EXPIRE和PERSIST命令。</p>
<h5 id="我们知道通过expire来设置key-的过期时间，那么对过期的数据怎么处理呢"><a href="#我们知道通过expire来设置key-的过期时间，那么对过期的数据怎么处理呢" class="headerlink" title="我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢?"></a>我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢?</h5><p>除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p>
<ol>
<li>定时去清理过期的缓存；</li>
<li>当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</li>
</ol>
<p>两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</p>
<h4 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a>内存相关</h4><h5 id="MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"><a href="#MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据" class="headerlink" title="MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"></a>MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据</h5><p>redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</p>
<h5 id="Redis的内存淘汰策略有哪些"><a href="#Redis的内存淘汰策略有哪些" class="headerlink" title="Redis的内存淘汰策略有哪些"></a>Redis的内存淘汰策略有哪些</h5><p>Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。</p>
<p><strong>全局的键空间选择性移除</strong></p>
<ul>
<li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。</li>
<li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（这个是最常用的）</li>
<li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。</li>
</ul>
<p><strong>设置过期时间的键空间选择性移除</strong></p>
<ul>
<li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。</li>
<li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。</li>
<li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。</li>
</ul>
<p>总结</p>
<p>Redis的内存淘汰策略的选取并不会影响过期的key的处理。内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；过期策略用于处理过期的缓存数据。</p>
<h5 id="Redis主要消耗什么物理资源？"><a href="#Redis主要消耗什么物理资源？" class="headerlink" title="Redis主要消耗什么物理资源？"></a>Redis主要消耗什么物理资源？</h5><p>内存。</p>
<h5 id="Redis的内存用完了会发生什么？"><a href="#Redis的内存用完了会发生什么？" class="headerlink" title="Redis的内存用完了会发生什么？"></a>Redis的内存用完了会发生什么？</h5><p>如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以配置内存淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。</p>
<h5 id="Redis如何做内存优化？"><a href="#Redis如何做内存优化？" class="headerlink" title="Redis如何做内存优化？"></a>Redis如何做内存优化？</h5><p>可以好好利用Hash,list,sorted set,set等集合类型数据，因为通常情况下很多小的Key-Value可以用更紧凑的方式存放到一起。尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key，而是应该把这个用户的所有信息存储到一张散列表里面</p>
<h4 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h4><h5 id="Redis线程模型"><a href="#Redis线程模型" class="headerlink" title="Redis线程模型"></a>Redis线程模型</h5><p>Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器（file event handler）。它的组成结构为4部分：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。</p>
<ul>
<li>文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li>
<li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li>
</ul>
<p>虽然文件事件处理器以单线程方式运行， 但通过使用 I/O 多路复用程序来监听多个套接字， 文件事件处理器既实现了高性能的网络通信模型， 又可以很好地与 redis 服务器中其他同样以单线程方式运行的模块进行对接， 这保持了 Redis 内部单线程设计的简单性。</p>
<p>参考：<a href="https://www.cnblogs.com/barrywxx/p/8570821.html" target="_blank" rel="noopener">https://www.cnblogs.com/barrywxx/p/8570821.html</a></p>
<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><h5 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h5><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。<br>Redis事务的概念</p>
<p>Redis 事务的本质是通过MULTI、EXEC、WATCH等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p>
<p>总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p>
<h5 id="Redis事务的三个阶段"><a href="#Redis事务的三个阶段" class="headerlink" title="Redis事务的三个阶段"></a>Redis事务的三个阶段</h5><ol>
<li>事务开始 MULTI</li>
<li>命令入队</li>
<li>事务执行 EXEC</li>
</ol>
<p>事务执行过程中，如果服务端收到有EXEC、DISCARD、WATCH、MULTI之外的请求，将会把请求放入队列中排队</p>
<h5 id="Redis事务相关命令"><a href="#Redis事务相关命令" class="headerlink" title="Redis事务相关命令"></a>Redis事务相关命令</h5><p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的</p>
<p>Redis会将一个事务中的所有命令序列化，然后按顺序执行。</p>
<ol>
<li>redis 不支持回滚，“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。</li>
<li>如果在一个事务中的命令出现错误，那么所有的命令都不会执行；</li>
<li>如果在一个事务中出现运行错误，那么正确的命令会被执行。</li>
</ol>
<ul>
<li>WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。</li>
<li>MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。</li>
<li>EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。</li>
<li>通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。</li>
<li>UNWATCH命令可以取消watch对所有key的监控。</li>
</ul>
<h4 id="事务管理（ACID）概述"><a href="#事务管理（ACID）概述" class="headerlink" title="事务管理（ACID）概述"></a>事务管理（ACID）概述</h4><p>原子性（Atomicity）<br>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</p>
<p>一致性（Consistency）<br>事务前后数据的完整性必须保持一致。</p>
<p>隔离性（Isolation）<br>多个事务并发执行时，一个事务的执行不应影响其他事务的执行</p>
<p>持久性（Durability）<br>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响</p>
<p><strong>Redis的事务总是具有ACID中的一致性和隔离性</strong>，其他特性是不支持的。当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，事务也具有耐久性。</p>
<h5 id="Redis事务支持隔离性吗"><a href="#Redis事务支持隔离性吗" class="headerlink" title="Redis事务支持隔离性吗"></a>Redis事务支持隔离性吗</h5><p>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，<strong>Redis 的事务是总是带有隔离性的。</strong></p>
<h5 id="Redis事务保证原子性吗，支持回滚吗"><a href="#Redis事务保证原子性吗，支持回滚吗" class="headerlink" title="Redis事务保证原子性吗，支持回滚吗"></a>Redis事务保证原子性吗，支持回滚吗</h5><p>Redis中，单条命令是原子性执行的，但<strong>事务不保证原子性，且没有回滚</strong>。事务中任意命令执行失败，其余的命令仍会被执行。</p>
<h5 id="Redis事务其他实现"><a href="#Redis事务其他实现" class="headerlink" title="Redis事务其他实现"></a>Redis事务其他实现</h5><ul>
<li>基于Lua脚本，Redis可以保证脚本内的命令一次性、按顺序地执行，<br>其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完<br>、</li>
<li>基于中间标记变量，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐</li>
</ul>
<h4 id="集群方案"><a href="#集群方案" class="headerlink" title="集群方案"></a>集群方案</h4><h5 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h5><p><img src="https://img-blog.csdnimg.cn/20200115174006561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<h5 id="哨兵的介绍"><a href="#哨兵的介绍" class="headerlink" title="哨兵的介绍"></a>哨兵的介绍</h5><p>sentinel，中文名是哨兵。哨兵是 redis 集群机构中非常重要的一个组件，主要有以下功能：</p>
<ul>
<li>集群监控：负责监控 redis master 和 slave 进程是否正常工作。</li>
<li>消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</li>
<li>故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。</li>
<li>配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。</li>
</ul>
<p><strong>哨兵用于实现 redis 集群的高可用</strong>，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。</p>
<ul>
<li>故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题。</li>
<li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身是单点的，那就很坑爹了。</li>
</ul>
<p><strong>哨兵的核心知识</strong></p>
<ul>
<li>哨兵至少需要 3 个实例，来保证自己的健壮性。</li>
<li>哨兵 + redis 主从的部署架构，是不保证数据零丢失的，只能保证 redis 集群的高可用性。</li>
<li>对于哨兵 + redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。</li>
</ul>
<h5 id="官方Redis-Cluster-方案-服务端路由查询"><a href="#官方Redis-Cluster-方案-服务端路由查询" class="headerlink" title="官方Redis Cluster 方案(服务端路由查询)"></a>官方Redis Cluster 方案(服务端路由查询)</h5><p><img src="https://img-blog.csdnimg.cn/20200115173621637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<p>redis 集群模式的工作原理能说一下么？在集群模式下，redis 的 key 是如何寻址的？分布式寻址都有哪些算法？了解一致性 hash 算法吗？</p>
<p><strong>简介</strong></p>
<p>Redis Cluster是一种服务端Sharding技术，3.0版本开始正式提供。Redis Cluster并没有使用一致性hash，而是采用slot(槽)的概念，一共分成16384个槽。将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行</p>
<p><strong>方案说明</strong></p>
<ol>
<li>通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽(哈希值)区间的数据，默认分配了16384 个槽位</li>
<li>每份数据分片会存储在多个互为主从的多节点上</li>
<li>数据写入先写主节点，再同步到从节点(支持配置为阻塞同步)</li>
<li>同一分片多个节点间的数据不保持一致性</li>
<li>读取数据时，当客户端操作的key没有分配在该节点上时，redis会返回转向指令，指向正确的节点</li>
<li>扩容时时需要需要把旧节点的数据迁移一部分到新节点</li>
</ol>
<p>在 redis cluster 架构下，每个 redis 要放开两个端口号，比如一个是 6379，另外一个就是 加1w 的端口号，比如 16379。</p>
<p>16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议，gossip 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。</p>
<p><strong>节点间的内部通信机制</strong></p>
<p>基本通信原理</p>
<p>集群元数据的维护有两种方式：集中式、Gossip 协议。redis cluster 节点间采用 gossip 协议进行通信。</p>
<p><strong>分布式寻址算法</strong></p>
<ul>
<li>hash 算法（大量缓存重建）</li>
<li>一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）</li>
<li>redis cluster 的 hash slot 算法</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>无中心架构，支持动态扩容，对业务透明</li>
<li>具备Sentinel的监控和自动Failover(故障转移)能力</li>
<li>客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可</li>
<li>高性能，客户端直连redis服务，免去了proxy代理的损耗</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>运维也很复杂，数据迁移需要人工干预</li>
<li>只能使用0号数据库</li>
<li>不支持批量操作(pipeline管道操作)</li>
<li>分布式逻辑和存储模块耦合等</li>
</ul>
<p>基于客户端分配</p>
<p><img src="https://img-blog.csdnimg.cn/20200115173640248.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<p><strong>简介</strong></p>
<p>Redis Sharding是Redis Cluster出来之前，业界普遍使用的多Redis实例集群方法。其主要思想是采用哈希算法将Redis数据的key进行散列，通过hash函数，特定的key会映射到特定的Redis节点上。Java redis客户端驱动jedis，支持Redis Sharding功能，即ShardedJedis以及结合缓存池的ShardedJedisPool</p>
<p><strong>优点</strong></p>
<p>优势在于非常简单，服务端的Redis实例彼此独立，相互无关联，每个Redis实例像单服务器一样运行，非常容易线性扩展，系统的灵活性很强</p>
<p><strong>缺点</strong></p>
<ul>
<li>由于sharding处理放到客户端，规模进一步扩大时给运维带来挑战。</li>
<li>客户端sharding不支持动态增删节点。服务端Redis实例群拓扑结构有变化时，每个客户端都需要更新调整。连接不能共享，当应用规模增大时，资源浪费制约优化</li>
</ul>
<h5 id="基于代理服务器分片"><a href="#基于代理服务器分片" class="headerlink" title="基于代理服务器分片"></a>基于代理服务器分片</h5><p><img src="https://img-blog.csdnimg.cn/20200115173630730.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<p><strong>简介</strong></p>
<p>客户端发送请求到一个代理组件，代理解析客户端的数据，并将请求转发至正确的节点，最后将结果回复给客户端</p>
<p><strong>特征</strong></p>
<ul>
<li>透明接入，业务程序不用关心后端Redis实例，切换成本低</li>
<li>Proxy 的逻辑和存储的逻辑是隔离的</li>
<li>代理层多了一次转发，性能有所损耗</li>
</ul>
<p><strong>业界开源方案</strong></p>
<ul>
<li>Twtter开源的Twemproxy</li>
<li>豌豆荚开源的Codis</li>
</ul>
<h5 id="Redis-主从架构"><a href="#Redis-主从架构" class="headerlink" title="Redis 主从架构"></a>Redis 主从架构</h5><p>单机的 redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑读<strong>高并发</strong>的。因此架构做成主从(master-slave)架构，一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。所有的<strong>读请求全部走从节点</strong>。这样也可以很轻松实现水平扩容，<strong>支撑读高并发。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200115180329317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<p>redis replication -&gt; 主从架构 -&gt; 读写分离 -&gt; 水平扩容支撑读高并发</p>
<h5 id="redis-replication-的核心机制"><a href="#redis-replication-的核心机制" class="headerlink" title="redis replication 的核心机制"></a>redis replication 的核心机制</h5><ul>
<li>redis 采用异步方式复制数据到 slave 节点，不过 redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量；</li>
<li>一个 master node 是可以配置多个 slave node 的；</li>
<li>slave node 也可以连接其他的 slave node；</li>
<li>slave node 做复制的时候，不会 block master node 的正常工作；</li>
<li>slave node 在做复制的时候，也不会 block 对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了；</li>
<li>slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量。</li>
</ul>
<p>注意，如果采用了主从架构，那么建议必须<strong>开启</strong> master node 的持久化，不建议用 slave node 作为 master node 的数据热备，因为那样的话，如果你关掉 master 的持久化，可能在 master 宕机重启的时候数据是空的，然后可能一经过复制， slave node 的数据也丢了。</p>
<p>另外，master 的各种备份方案，也需要做。万一本地的所有文件丢失了，从备份中挑选一份 rdb 去恢复 master，这样才能<strong>确保启动的时候，是有数据的</strong>，即使采用了后续讲解的高可用机制，slave node 可以自动接管 master node，但也可能 sentinel 还没检测到 master failure，master node 就自动重启了，还是可能导致上面所有的 slave node 数据被清空。</p>
<p><strong>redis 主从复制的核心原理</strong></p>
<p>当启动一个 slave node 的时候，它会发送一个 PSYNC 命令给 master node。</p>
<p>如果这是 slave node 初次连接到 master node，那么会触发一次 full resynchronization 全量复制。此时 master 会启动一个后台线程，开始生成一份 RDB 快照文件，</p>
<p>同时还会将从客户端 client 新收到的所有写命令缓存在内存中。RDB 文件生成完毕后， master 会将这个 RDB 发送给 slave，slave 会<strong>先写入本地磁盘，然后再从本地磁盘加载到内存</strong>中，</p>
<p>接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。</p>
<p>slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。</p>
<p><img src="https://img-blog.csdnimg.cn/20200115180337645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<p><strong>过程原理</strong></p>
<ol>
<li>当从库和主库建立MS关系后，会向主数据库发送SYNC命令</li>
<li>主库接收到SYNC命令后会开始在后台保存快照(RDB持久化过程)，并将期间接收到的写命令缓存起来</li>
<li>当快照完成后，主Redis会将快照文件和所有缓存的写命令发送给从Redis</li>
<li>从Redis接收到后，会载入快照文件并且执行收到的缓存的命令</li>
<li>之后，主Redis每当接收到写命令时就会将命令发送从Redis，从而保证数据的一致</li>
</ol>
<p><strong>缺点</strong></p>
<p>所有的slave节点数据的复制和同步都由master节点来处理，会照成master节点压力太大，使用主从从结构来解决</p>
<h5 id="Redis集群的主从复制模型是怎样的？"><a href="#Redis集群的主从复制模型是怎样的？" class="headerlink" title="Redis集群的主从复制模型是怎样的？"></a>Redis集群的主从复制模型是怎样的？</h5><p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型，每个节点都会有N-1个复制品</p>
<h5 id="生产环境中的-redis-是怎么部署的？"><a href="#生产环境中的-redis-是怎么部署的？" class="headerlink" title="生产环境中的 redis 是怎么部署的？"></a>生产环境中的 redis 是怎么部署的？</h5><p>redis cluster，10 台机器，5 台机器部署了 redis 主实例，另外 5 台机器部署了 redis 的从实例，每个主实例挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰qps可能可以达到每秒 5 万，5 台机器最多是 25 万读写请求/s。</p>
<p>机器是什么配置？32G 内存+ 8 核 CPU + 1T 磁盘，但是分配给 redis 进程的是10g内存，一般线上生产环境，redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。</p>
<p>5 台机器对外提供读写，一共有 50g 内存。</p>
<p>因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，redis 从实例会自动变成主实例继续提供读写服务。</p>
<p>你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是 10kb。100 条数据是 1mb，10 万条数据是 1g。常驻内存的是 200 万条商品数据，占用内存是 20g，仅仅不到总内存的 50%。目前高峰期每秒就是 3500 左右的请求量。</p>
<p>其实大型的公司，会有基础架构的 team 负责缓存集群的运维。</p>
<h5 id="说说Redis哈希槽的概念？"><a href="#说说Redis哈希槽的概念？" class="headerlink" title="说说Redis哈希槽的概念？"></a>说说Redis哈希槽的概念？</h5><p>Redis集群没有使用一致性hash,而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。</p>
<h5 id="Redis集群会有写操作丢失吗？为什么？"><a href="#Redis集群会有写操作丢失吗？为什么？" class="headerlink" title="Redis集群会有写操作丢失吗？为什么？"></a>Redis集群会有写操作丢失吗？为什么？</h5><p>Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。</p>
<h5 id="Redis集群之间是如何复制的？"><a href="#Redis集群之间是如何复制的？" class="headerlink" title="Redis集群之间是如何复制的？"></a>Redis集群之间是如何复制的？</h5><p>异步复制</p>
<h5 id="Redis集群最大节点个数是多少？"><a href="#Redis集群最大节点个数是多少？" class="headerlink" title="Redis集群最大节点个数是多少？"></a>Redis集群最大节点个数是多少？</h5><p>16384个</p>
<h5 id="Redis集群如何选择数据库？"><a href="#Redis集群如何选择数据库？" class="headerlink" title="Redis集群如何选择数据库？"></a>Redis集群如何选择数据库？</h5><p>Redis集群目前无法做数据库选择，默认在0数据库。<br>分区</p>
<h5 id="Redis是单线程的，如何提高多核CPU的利用率？"><a href="#Redis是单线程的，如何提高多核CPU的利用率？" class="headerlink" title="Redis是单线程的，如何提高多核CPU的利用率？"></a>Redis是单线程的，如何提高多核CPU的利用率？</h5><p>可以在同一个服务器部署多个Redis的实例，并把他们当作不同的服务器来使用，在某些时候，无论如何一个服务器是不够的， 所以，如果你想使用多个CPU，你可以考虑一下分片（shard）。</p>
<h5 id="为什么要做Redis分区？"><a href="#为什么要做Redis分区？" class="headerlink" title="为什么要做Redis分区？"></a>为什么要做Redis分区？</h5><p>分区可以让Redis管理更大的内存，Redis将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。分区使Redis的计算能力通过简单地增加计算机得到成倍提升，Redis的网络带宽也会随着计算机和网卡的增加而成倍增长。</p>
<h5 id="你知道有哪些Redis分区实现方案？"><a href="#你知道有哪些Redis分区实现方案？" class="headerlink" title="你知道有哪些Redis分区实现方案？"></a>你知道有哪些Redis分区实现方案？</h5><ul>
<li>客户端分区就是在客户端就已经决定数据会被存储到哪个redis节点或者从哪个redis节点读取。大多数客户端已经实现了客户端分区。</li>
<li>代理分区 意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些Redis实例，然后根据Redis的响应结果返回给客户端。redis和memcached的一种代理实现就是Twemproxy</li>
<li>查询路由(Query routing) 的意思是客户端随机地请求任意一个redis实例，然后由Redis将请求转发给正确的Redis节点。Redis Cluster实现了一种混合形式的查询路由，但并不是直接将请求从一个redis节点转发到另一个redis节点，而是在客户端的帮助下直接redirected到正确的redis节点。</li>
</ul>
<h5 id="Redis分区有什么缺点？"><a href="#Redis分区有什么缺点？" class="headerlink" title="Redis分区有什么缺点？"></a>Redis分区有什么缺点？</h5><ul>
<li>涉及多个key的操作通常不会被支持。例如你不能对两个集合求交集，因为他们可能被存储到不同的Redis实例（实际上这种情况也有办法，但是不能直接使用交集指令）。</li>
<li>同时操作多个key,则不能使用Redis事务.</li>
<li>分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集（The partitioning granularity is the key, so it is not possible to shard a dataset with a single huge key like a very big sorted set）</li>
<li>当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的Redis实例和主机同时收集RDB / AOF文件。</li>
<li>分区时动态扩容或缩容可能非常复杂。Redis集群在运行时增加或者删除Redis节点，能做到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这种特性。然而，有一种预分片的技术也可以较好的解决这个问题。</li>
</ul>
<h4 id="分布式问题"><a href="#分布式问题" class="headerlink" title="分布式问题"></a>分布式问题</h4><h5 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h5><p>Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用SETNX命令实现分布式锁。</p>
<p>当且仅当 key 不存在，将 key 的值设为 value。 若给定的 key 已经存在，则 SETNX 不做任何动作</p>
<p>SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p>
<p>返回值：设置成功，返回 1 。设置失败，返回 0 。</p>
<p><img src="https://img-blog.csdnimg.cn/20191213103148681.png" alt></p>
<p>使用SETNX完成同步锁的流程及事项如下：</p>
<p>使用SETNX命令获取锁，若返回0（key已存在，锁已存在）则获取失败，反之获取成功</p>
<p>为了防止获取锁后程序出现异常，导致其他线程/进程调用SETNX命令总是返回0而进入死锁状态，需要为该key设置一个“合理”的过期时间</p>
<p>释放锁，使用DEL命令将锁数据删除</p>
<h5 id="如何解决-Redis-的并发竞争-Key-问题"><a href="#如何解决-Redis-的并发竞争-Key-问题" class="headerlink" title="如何解决 Redis 的并发竞争 Key 问题"></a>如何解决 Redis 的并发竞争 Key 问题</h5><p>所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！</p>
<p>推荐一种方案：分布式锁（zookeeper 和 redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）</p>
<p>基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</p>
<p>在实践中，当然是从以可靠性为主。所以首推Zookeeper。</p>
<p>参考：<a href="https://www.jianshu.com/p/8bddd381de06" target="_blank" rel="noopener">https://www.jianshu.com/p/8bddd381de06</a></p>
<h5 id="分布式Redis是前期做还是后期规模上来了再做好？为什么？"><a href="#分布式Redis是前期做还是后期规模上来了再做好？为什么？" class="headerlink" title="分布式Redis是前期做还是后期规模上来了再做好？为什么？"></a>分布式Redis是前期做还是后期规模上来了再做好？为什么？</h5><p>既然Redis是如此的轻量（单实例只使用1M内存），为防止以后的扩容，最好的办法就是一开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让Redis以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。</p>
<p>一开始就多设置几个Redis实例，例如32或者64个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看做这点牺牲是值得的。</p>
<p>这样的话，当你的数据不断增长，需要更多的Redis服务器时，你需要做的就是仅仅将Redis实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了另一台服务器，你需要将你一半的Redis实例从第一台机器迁移到第二台机器。</p>
<h5 id="什么是-RedLock"><a href="#什么是-RedLock" class="headerlink" title="什么是 RedLock"></a>什么是 RedLock</h5><p>Redis 官方站提出了一种权威的基于 Redis 实现分布式锁的方式名叫 Redlock，此种方式比原先的单节点的方法更安全。它可以保证以下特性：</p>
<ol>
<li>安全特性：互斥访问，即永远只有一个 client 能拿到锁</li>
<li>避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源的 client crash 了或者出现了网络分区</li>
<li>容错性：只要大部分 Redis 节点存活就可以正常提供服务</li>
</ol>
<h4 id="缓存异常"><a href="#缓存异常" class="headerlink" title="缓存异常"></a>缓存异常</h4><h5 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h5><p><strong>缓存雪崩</strong>是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p>解决方案</p>
<ol>
<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li>
<li>一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。</li>
<li>给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。</li>
</ol>
<h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p><strong>缓存穿透</strong>是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p><strong>解决方案</strong></p>
<ol>
<li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；</li>
<li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</li>
<li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力</li>
</ol>
<p><strong>附加</strong></p>
<p>对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。<br>Bitmap： 典型的就是哈希表<br>缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了。</p>
<p>布隆过滤器（推荐）</p>
<p>就是引入了k(k&gt;1)k(k&gt;1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。<br>它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。<br>Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。<br>Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是Bloom-Filter的基本思想。<br>Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。</p>
<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p><strong>缓存击穿</strong>是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p>
<p><strong>解决方案</strong></p>
<ol>
<li>设置热点数据永远不过期。</li>
<li>加互斥锁，互斥锁</li>
</ol>
<h4 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h4><p><strong>缓存预热</strong>就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p>
<p>解决方案</p>
<ol>
<li>直接写个缓存刷新页面，上线时手工操作一下；</li>
<li>数据量不大，可以在项目启动的时候自动进行加载；</li>
<li>定时刷新缓存；</li>
</ol>
<h4 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h4><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p>
<p><strong>缓存降级</strong>的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p>
<p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p>
<ol>
<li>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li>
<li>警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</li>
<li>错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</li>
<li>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</li>
</ol>
<p>服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。</p>
<h4 id="热点数据和冷数据"><a href="#热点数据和冷数据" class="headerlink" title="热点数据和冷数据"></a>热点数据和冷数据</h4><p>热点数据，缓存才有价值</p>
<p>对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存</p>
<p>对于热点数据，比如我们的某IM产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。</p>
<p>数据更新前至少读取两次，缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。</p>
<p>那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到Redis缓存，减少数据库压力。</p>
<h4 id="缓存热点key"><a href="#缓存热点key" class="headerlink" title="缓存热点key"></a>缓存热点key</h4><p>缓存中的一个Key(比如一个促销商品)，在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p>
<p><strong>解决方案</strong></p>
<p>对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询</p>
<h4 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h4><h5 id="Redis支持的Java客户端都有哪些？官方推荐用哪个？"><a href="#Redis支持的Java客户端都有哪些？官方推荐用哪个？" class="headerlink" title="Redis支持的Java客户端都有哪些？官方推荐用哪个？"></a>Redis支持的Java客户端都有哪些？官方推荐用哪个？</h5><p>Redisson、Jedis、lettuce等等，官方推荐使用Redisson。</p>
<h5 id="Redis和Redisson有什么关系？"><a href="#Redis和Redisson有什么关系？" class="headerlink" title="Redis和Redisson有什么关系？"></a>Redis和Redisson有什么关系？</h5><p>Redisson是一个高级的分布式协调Redis客服端，能帮助用户在分布式环境中轻松实现一些Java的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。</p>
<h5 id="Jedis与Redisson对比有什么优缺点？"><a href="#Jedis与Redisson对比有什么优缺点？" class="headerlink" title="Jedis与Redisson对比有什么优缺点？"></a>Jedis与Redisson对比有什么优缺点？</h5><p>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
<h4 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h4><h5 id="Redis与Memcached的区别"><a href="#Redis与Memcached的区别" class="headerlink" title="Redis与Memcached的区别"></a>Redis与Memcached的区别</h5><p>两者都是非关系型内存键值数据库，现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！Redis 与 Memcached 主要有以下不同：</p>
<table>
<thead>
<tr>
<th align="center">对比参数</th>
<th align="center">Redis</th>
<th align="center">Memcached</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类型</td>
<td align="center">1. 支持内存 2. 非关系型数据库</td>
<td align="center">1. 支持内存 2. 键值对形式 3. 缓存形式</td>
</tr>
<tr>
<td align="center"><strong>数据存储类型</strong></td>
<td align="center">1. String 2. List 3. Set 4. Hash 5. Sort Set 【俗称ZSet】</td>
<td align="center">1. 文本型 2. 二进制类型</td>
</tr>
<tr>
<td align="center">查询【操作】类型</td>
<td align="center">1. 批量操作 2. 事务支持 3. 每个类型不同的CRUD</td>
<td align="center">1.常用的CRUD 2. 少量的其他命令</td>
</tr>
<tr>
<td align="center">附加功能</td>
<td align="center">1. 发布/订阅模式 2. 主从分区 3. 序列化支持 4. 脚本支持【Lua脚本】</td>
<td align="center">1. 多线程服务支持</td>
</tr>
<tr>
<td align="center"><strong>网络IO模型</strong></td>
<td align="center">1. 单线程的多路 IO 复用模型</td>
<td align="center">1. 多线程，非阻塞IO模式</td>
</tr>
<tr>
<td align="center">事件库</td>
<td align="center">自封转简易事件库AeEvent</td>
<td align="center">贵族血统的LibEvent事件库</td>
</tr>
<tr>
<td align="center"><strong>持久化支持</strong></td>
<td align="center">1. RDB 2. AOF</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center"><strong>集群模式</strong></td>
<td align="center">原生支持 cluster 模式，可以实现主从复制，读写分离</td>
<td align="center">没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据</td>
</tr>
<tr>
<td align="center">内存管理机制</td>
<td align="center">在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘</td>
<td align="center">Memcached 的数据则会一直在内存中，Memcached  将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储  100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</td>
</tr>
<tr>
<td align="center"><strong>适用场景</strong></td>
<td align="center">复杂数据结构，有持久化，高可用需求，value存储内容较大</td>
<td align="center">纯key-value，数据量非常大，并发量非常大的业务</td>
</tr>
</tbody></table>
<p>(1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</p>
<p>(2) redis的速度比memcached快很多</p>
<p>(3) redis可以持久化其数据</p>
<h5 id="如何保证缓存与数据库双写时的数据一致性？"><a href="#如何保证缓存与数据库双写时的数据一致性？" class="headerlink" title="如何保证缓存与数据库双写时的数据一致性？"></a>如何保证缓存与数据库双写时的数据一致性？</h5><p>你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？</p>
<p>一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况</p>
<p>串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p>
<p>还有一种方式就是可能会暂时产生不一致的情况，但是发生的几率特别小，就是<strong>先更新数据库，然后再删除缓存。</strong></p>
<table>
<thead>
<tr>
<th>问题场景</th>
<th>描述</th>
<th>解决</th>
</tr>
</thead>
<tbody><tr>
<td>先写缓存，再写数据库，缓存写成功，数据库写失败</td>
<td>缓存写成功，但写数据库失败或者响应延迟，则下次读取（并发读）缓存时，就出现脏读</td>
<td>这个写缓存的方式，本身就是错误的，需要改为先写数据库，把旧缓存置为失效；读取数据的时候，如果缓存不存在，则读取数据库再写缓存</td>
</tr>
<tr>
<td>先写数据库，再写缓存，数据库写成功，缓存写失败</td>
<td>写数据库成功，但写缓存失败，则下次读取（并发读）缓存时，则读不到数据</td>
<td>缓存使用时，假如读缓存失败，先读数据库，再回写缓存的方式实现</td>
</tr>
<tr>
<td>需要缓存异步刷新</td>
<td>指数据库操作和写缓存不在一个操作步骤中，比如在分布式场景下，无法做到同时写缓存或需要异步刷新（补救措施）时候</td>
<td>确定哪些数据适合此类场景，根据经验值确定合理的数据不一致时间，用户数据刷新的时间间隔</td>
</tr>
</tbody></table>
<h5 id="Redis常见性能问题和解决方案？"><a href="#Redis常见性能问题和解决方案？" class="headerlink" title="Redis常见性能问题和解决方案？"></a>Redis常见性能问题和解决方案？</h5><ol>
<li>Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化。</li>
<li>如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。</li>
<li>为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内。</li>
<li>尽量避免在压力较大的主库上增加从库</li>
<li>Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。</li>
<li>为了Master的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master&lt;–Slave1&lt;–Slave2&lt;–Slave3…，这样的结构也方便解决单点故障问题，实现Slave对Master的替换，也即，如果Master挂了，可以立马启用Slave1做Master，其他不变。</li>
</ol>
<h5 id="Redis官方为什么不提供Windows版本？"><a href="#Redis官方为什么不提供Windows版本？" class="headerlink" title="Redis官方为什么不提供Windows版本？"></a>Redis官方为什么不提供Windows版本？</h5><p>因为目前Linux版本已经相当稳定，而且用户量很大，无需开发windows版本，反而会带来兼容性等问题。</p>
<h5 id="一个字符串类型的值能存储最大容量是多少？"><a href="#一个字符串类型的值能存储最大容量是多少？" class="headerlink" title="一个字符串类型的值能存储最大容量是多少？"></a>一个字符串类型的值能存储最大容量是多少？</h5><p>512M</p>
<h5 id="Redis如何做大量数据插入？"><a href="#Redis如何做大量数据插入？" class="headerlink" title="Redis如何做大量数据插入？"></a>Redis如何做大量数据插入？</h5><p>Redis2.6开始redis-cli支持一种新的被称之为pipe mode的新模式用于执行大量数据插入工作。</p>
<h5 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h5><p>使用keys指令可以扫出指定模式的key列表。<br>对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？<br>这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p>
<h5 id="使用Redis做过异步队列吗，是如何实现的"><a href="#使用Redis做过异步队列吗，是如何实现的" class="headerlink" title="使用Redis做过异步队列吗，是如何实现的"></a>使用Redis做过异步队列吗，是如何实现的</h5><p>使用list类型保存数据信息，rpush生产消息，lpop消费消息，当lpop没有消息时，可以sleep一段时间，然后再检查有没有信息，如果不想sleep的话，可以使用blpop, 在没有信息的时候，会一直阻塞，直到信息的到来。redis可以通过pub/sub主题订阅模式实现一个生产者，多个消费者，当然也存在一定的缺点，当消费者下线时，生产的消息会丢失。</p>
<h5 id="Redis如何实现延时队列"><a href="#Redis如何实现延时队列" class="headerlink" title="Redis如何实现延时队列"></a>Redis如何实现延时队列</h5><p>使用sortedset，使用时间戳做score, 消息内容作为key,调用zadd来生产消息，消费者使用zrangbyscore获取n秒之前的数据做轮询处理。<br>Redis回收进程如何工作的？</p>
<ol>
<li>一个客户端运行了新的命令，添加了新的数据。</li>
<li>Redis检查内存使用情况，如果大于maxmemory的限制， 则根据设定好的策略进行回收。</li>
<li>一个新的命令被执行，等等。</li>
<li>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。</li>
</ol>
<p>如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。</p>
<h5 id="Redis回收使用的是什么算法？"><a href="#Redis回收使用的是什么算法？" class="headerlink" title="Redis回收使用的是什么算法？"></a>Redis回收使用的是什么算法？</h5><p>LRU算法</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud面试题</title>
    <url>/myblog/interview/Spring%20Cloud%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h4 id="为什么需要学习Spring-Cloud"><a href="#为什么需要学习Spring-Cloud" class="headerlink" title="为什么需要学习Spring Cloud"></a>为什么需要学习Spring Cloud</h4><a id="more"></a>
<p>不论是商业应用还是用户应用，在业务初期都很简单，我们通常会把它实现为单体结构的应用。但是，随着业务逐渐发展，产品思想会变得越来越复杂，单体结构的应用也会越来越复杂。这就会给应用带来如下的几个问题：</p>
<ul>
<li>代码结构混乱：业务复杂，导致代码量很大，管理会越来越困难。同时，这也会给业务的快速迭代带来巨大挑战；</li>
<li>开发效率变低：开发人员同时开发一套代码，很难避免代码冲突。开发过程会伴随着不断解决冲突的过程，这会严重的影响开发效率；</li>
<li>排查解决问题成本高：线上业务发现 bug，修复 bug 的过程可能很简单。但是，由于只有一套代码，需要重新编译、打包、上线，成本很高。</li>
</ul>
<p>由于单体结构的应用随着系统复杂度的增高，会暴露出各种各样的问题。近些年来，微服务架构逐渐取代了单体架构，且这种趋势将会越来越流行。Spring Cloud是目前最常用的微服务开发框架，已经在企业级开发中大量的应用。</p>
<h5 id="什么是Spring-Cloud"><a href="#什么是Spring-Cloud" class="headerlink" title="什么是Spring Cloud"></a>什么是Spring Cloud</h5><p>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p>
<!--more-->

<h4 id="设计目标与优缺点"><a href="#设计目标与优缺点" class="headerlink" title="设计目标与优缺点"></a>设计目标与优缺点</h4><h5 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h5><p>协调各个微服务，简化分布式系统开发。</p>
<h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p>微服务的框架那么多比如：dubbo、Kubernetes，为什么就要使用Spring Cloud的呢？</p>
<p>优点：</p>
<ul>
<li>产出于Spring大家族，Spring在企业级开发框架中无人能敌，来头很大，可以保证后续的更新、完善</li>
<li>组件丰富，功能齐全。Spring Cloud 为微服务架构提供了非常完整的支持。例如、配置管理、服务发现、断路器、微服务网关等；</li>
<li>Spring Cloud 社区活跃度很高，教程很丰富，遇到问题很容易找到解决方案</li>
<li>服务拆分粒度更细，耦合度比较低，有利于资源重复利用，有利于提高开发效率</li>
<li>可以更精准的制定优化服务方案，提高系统的可维护性</li>
<li>减轻团队的成本，可以并行开发，不用关注其他人怎么开发，先关注自己的开发</li>
<li>微服务可以是跨平台的，可以用任何一种语言开发</li>
<li>适于互联网时代，产品迭代周期更短</li>
</ul>
<p>缺点：</p>
<ul>
<li>微服务过多，治理成本高，不利于维护系统</li>
<li>分布式系统开发的成本高（容错，分布式事务等）对团队挑战大</li>
</ul>
<p>总的来说优点大过于缺点，目前看来Spring Cloud是一套非常完善的分布式框架，目前很多企业开始用微服务、Spring Cloud的优势是显而易见的。因此对于想研究微服务架构的同学来说，学习Spring Cloud是一个不错的选择。</p>
<h5 id="Spring-Cloud发展前景"><a href="#Spring-Cloud发展前景" class="headerlink" title="Spring Cloud发展前景"></a>Spring Cloud发展前景</h5><p>Spring Cloud对于中小型互联网公司来说是一种福音，因为这类公司往往没有实力或者没有足够的资金投入去开发自己的分布式系统基础设施，使用Spring Cloud一站式解决方案能在从容应对业务发展的同时大大减少开发成本。同时，随着近几年微服务架构和Docker容器概念的火爆，也会让Spring Cloud在未来越来越“云”化的软件开发风格中立有一席之地，尤其是在五花八门的分布式解决方案中提供了标准化的、全站式的技术方案，意义可能会堪比当年Servlet规范的诞生，有效推进服务端软件系统技术水平的进步。</p>
<h4 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h4><p><img src="https://img-blog.csdnimg.cn/20191226143921760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt></p>
<h5 id="主要项目"><a href="#主要项目" class="headerlink" title="主要项目"></a>主要项目</h5><p>Spring Cloud的子项目，大致可分成两类，一类是对现有成熟框架”Spring Boot化”的封装和抽象，也是数量最多的项目；第二类是开发了一部分分布式系统的基础设施的实现，如Spring Cloud Stream扮演的就是kafka, ActiveMQ这样的角色。</p>
<h5 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h5><p>集中配置管理工具，分布式系统中统一的外部配置管理，默认使用Git来存储配置，可以支持客户端配置的刷新及加密、解密操作。</p>
<h5 id="Spring-Cloud-Netflix"><a href="#Spring-Cloud-Netflix" class="headerlink" title="Spring Cloud Netflix"></a>Spring Cloud Netflix</h5><p>Netflix OSS 开源组件集成，包括Eureka、Hystrix、Ribbon、Feign、Zuul等核心组件。</p>
<ul>
<li>Eureka：服务治理组件，包括服务端的注册中心和客户端的服务发现机制；</li>
<li>Ribbon：负载均衡的服务调用组件，具有多种负载均衡调用策略；</li>
<li>Hystrix：服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；</li>
<li>Feign：基于Ribbon和Hystrix的声明式服务调用组件；</li>
<li>Zuul：API网关组件，对请求提供路由及过滤功能。</li>
</ul>
<h5 id="Spring-Cloud-Bus"><a href="#Spring-Cloud-Bus" class="headerlink" title="Spring Cloud Bus"></a>Spring Cloud Bus</h5><p>用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置。</p>
<h5 id="Spring-Cloud-Consul"><a href="#Spring-Cloud-Consul" class="headerlink" title="Spring Cloud Consul"></a>Spring Cloud Consul</h5><p>基于Hashicorp Consul的服务治理组件。</p>
<h5 id="Spring-Cloud-Security"><a href="#Spring-Cloud-Security" class="headerlink" title="Spring Cloud Security"></a>Spring Cloud Security</h5><p>安全工具包，对Zuul代理中的负载均衡OAuth2客户端及登录认证进行支持。</p>
<h5 id="Spring-Cloud-Sleuth"><a href="#Spring-Cloud-Sleuth" class="headerlink" title="Spring Cloud Sleuth"></a>Spring Cloud Sleuth</h5><p>Spring Cloud应用程序的分布式请求链路跟踪，支持使用Zipkin、HTrace和基于日志（例如ELK）的跟踪。</p>
<h5 id="Spring-Cloud-Stream"><a href="#Spring-Cloud-Stream" class="headerlink" title="Spring Cloud Stream"></a>Spring Cloud Stream</h5><p>轻量级事件驱动微服务框架，可以使用简单的声明式模型来发送及接收消息，主要实现为Apache Kafka及RabbitMQ。</p>
<h5 id="Spring-Cloud-Task"><a href="#Spring-Cloud-Task" class="headerlink" title="Spring Cloud Task"></a>Spring Cloud Task</h5><p>用于快速构建短暂、有限数据处理任务的微服务框架，用于向应用中添加功能性和非功能性的特性。</p>
<h5 id="Spring-Cloud-Zookeeper"><a href="#Spring-Cloud-Zookeeper" class="headerlink" title="Spring Cloud Zookeeper"></a>Spring Cloud Zookeeper</h5><p>基于Apache Zookeeper的服务治理组件。</p>
<h5 id="Spring-Cloud-Gateway"><a href="#Spring-Cloud-Gateway" class="headerlink" title="Spring Cloud Gateway"></a>Spring Cloud Gateway</h5><p>API网关组件，对请求提供路由及过滤功能。</p>
<h5 id="Spring-Cloud-OpenFeign"><a href="#Spring-Cloud-OpenFeign" class="headerlink" title="Spring Cloud OpenFeign"></a>Spring Cloud OpenFeign</h5><p>基于Ribbon和Hystrix的声明式服务调用组件，可以动态创建基于Spring MVC注解的接口实现用于服务调用，在Spring Cloud 2.0中已经取代Feign成为了一等公民。</p>
<h5 id="Spring-Cloud的版本关系"><a href="#Spring-Cloud的版本关系" class="headerlink" title="Spring Cloud的版本关系"></a>Spring Cloud的版本关系</h5><p>Spring Cloud是一个由许多子项目组成的综合项目，各子项目有不同的发布节奏。 为了管理Spring Cloud与各子项目的版本依赖关系，发布了一个清单，其中包括了某个Spring Cloud版本对应的子项目版本。 为了避免Spring Cloud版本号与子项目版本号混淆，Spring Cloud版本采用了名称而非版本号的命名，这些版本的名字采用了伦敦地铁站的名字，根据字母表的顺序来对应版本时间顺序，例如Angel是第一个版本，Brixton是第二个版本。 当Spring Cloud的发布内容积累到临界点或者一个重大BUG被解决后，会发布一个”service releases”版本，简称SRX版本，比如Greenwich.SR2就是Spring Cloud发布的Greenwich版本的第2个SRX版本。目前Spring Cloud的最新版本是Hoxton。</p>
<h5 id="Spring-Cloud和SpringBoot版本对应关系"><a href="#Spring-Cloud和SpringBoot版本对应关系" class="headerlink" title="Spring Cloud和SpringBoot版本对应关系"></a>Spring Cloud和SpringBoot版本对应关系</h5><table>
<thead>
<tr>
<th align="center">Spring Cloud Version</th>
<th align="center">SpringBoot Version</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Hoxton</td>
<td align="center">2.2.x</td>
</tr>
<tr>
<td align="center">Greenwich</td>
<td align="center">2.1.x</td>
</tr>
<tr>
<td align="center">Finchley</td>
<td align="center">2.0.x</td>
</tr>
<tr>
<td align="center">Edgware</td>
<td align="center">1.5.x</td>
</tr>
<tr>
<td align="center">Dalston</td>
<td align="center">1.5.x</td>
</tr>
</tbody></table>
<h5 id="Spring-Cloud和各子项目版本对应关系"><a href="#Spring-Cloud和各子项目版本对应关系" class="headerlink" title="Spring Cloud和各子项目版本对应关系"></a>Spring Cloud和各子项目版本对应关系</h5><table>
<thead>
<tr>
<th align="center">Component</th>
<th align="center">Edgware.SR6</th>
<th align="center">Greenwich.SR2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">spring-cloud-bus</td>
<td align="center">1.3.4.RELEASE</td>
<td align="center">2.1.2.RELEASE</td>
</tr>
<tr>
<td align="center">spring-cloud-commons</td>
<td align="center">1.3.6.RELEASE</td>
<td align="center">2.1.2.RELEASE</td>
</tr>
<tr>
<td align="center">spring-cloud-config</td>
<td align="center">1.4.7.RELEASE</td>
<td align="center">2.1.3.RELEASE</td>
</tr>
<tr>
<td align="center">spring-cloud-netflix</td>
<td align="center">1.4.7.RELEASE</td>
<td align="center">2.1.2.RELEASE</td>
</tr>
<tr>
<td align="center">spring-cloud-security</td>
<td align="center">1.2.4.RELEASE</td>
<td align="center">2.1.3.RELEASE</td>
</tr>
<tr>
<td align="center">spring-cloud-consul</td>
<td align="center">1.3.6.RELEASE</td>
<td align="center">2.1.2.RELEASE</td>
</tr>
<tr>
<td align="center">spring-cloud-sleuth</td>
<td align="center">1.3.6.RELEASE</td>
<td align="center">2.1.1.RELEASE</td>
</tr>
<tr>
<td align="center">spring-cloud-stream</td>
<td align="center">Ditmars.SR5</td>
<td align="center">Fishtown.SR3</td>
</tr>
<tr>
<td align="center">spring-cloud-zookeeper</td>
<td align="center">1.2.3.RELEASE</td>
<td align="center">2.1.2.RELEASE</td>
</tr>
<tr>
<td align="center">spring-boot</td>
<td align="center">1.5.21.RELEASE</td>
<td align="center">2.1.5.RELEASE</td>
</tr>
<tr>
<td align="center">spring-cloud-task</td>
<td align="center">1.2.4.RELEASE</td>
<td align="center">2.1.2.RELEASE</td>
</tr>
<tr>
<td align="center">spring-cloud-gateway</td>
<td align="center">1.0.3.RELEASE</td>
<td align="center">2.1.2.RELEASE</td>
</tr>
<tr>
<td align="center">spring-cloud-openfeign</td>
<td align="center">暂无</td>
<td align="center">2.1.2.RELEASE</td>
</tr>
</tbody></table>
<p><strong>注意：Hoxton版本是基于SpringBoot 2.2.x版本构建的，不适用于1.5.x版本。随着2019年8月SpringBoot 1.5.x版本停止维护，Edgware版本也将停止维护</strong>。</p>
<h5 id="SpringBoot和SpringCloud的区别？"><a href="#SpringBoot和SpringCloud的区别？" class="headerlink" title="SpringBoot和SpringCloud的区别？"></a>SpringBoot和SpringCloud的区别？</h5><p>SpringBoot专注于快速方便的开发单个个体微服务。</p>
<p>SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，</p>
<p>为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务</p>
<p>SpringBoot可以离开SpringCloud独立使用开发项目， 但是SpringCloud离不开SpringBoot ，属于依赖的关系</p>
<p>SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。</p>
<h5 id="使用-Spring-Boot-开发分布式微服务时，我们面临以下问题"><a href="#使用-Spring-Boot-开发分布式微服务时，我们面临以下问题" class="headerlink" title="使用 Spring Boot 开发分布式微服务时，我们面临以下问题"></a>使用 Spring Boot 开发分布式微服务时，我们面临以下问题</h5><p>（1）与分布式系统相关的复杂性-这种开销包括网络问题，延迟开销，带宽问题，安全问题。</p>
<p>（2）服务发现-服务发现工具管理群集中的流程和服务如何查找和互相交谈。它涉及一个服务目录，在该目录中注册服务，然后能够查找并连接到该目录中的服务。</p>
<p>（3）冗余-分布式系统中的冗余问题。</p>
<p>（4）负载平衡 –负载平衡改善跨多个计算资源的工作负荷，诸如计算机，计算机集群，网络链路，中央处理单元，或磁盘驱动器的分布。</p>
<p>（5）性能-问题 由于各种运营开销导致的性能问题。</p>
<p>（6）部署复杂性-Devops 技能的要求。</p>
<h5 id="服务注册和发现是什么意思？Spring-Cloud-如何实现？"><a href="#服务注册和发现是什么意思？Spring-Cloud-如何实现？" class="headerlink" title="服务注册和发现是什么意思？Spring Cloud 如何实现？"></a>服务注册和发现是什么意思？Spring Cloud 如何实现？</h5><p>当我们开始一个项目时，我们通常在属性文件中进行所有的配置。随着越来越多的服务开发和部署，添加和修改这些属性变得更加复杂。有些服务可能会下降，而某些位置可能会发生变化。手动更改属性可能会产生问题。 Eureka 服务注册和发现可以在这种情况下提供帮助。由于所有服务都在 Eureka 服务器上注册并通过调用 Eureka 服务器完成查找，因此无需处理服务地点的任何更改和处理。</p>
<h5 id="Spring-Cloud-和dubbo区别"><a href="#Spring-Cloud-和dubbo区别" class="headerlink" title="Spring Cloud 和dubbo区别?"></a>Spring Cloud 和dubbo区别?</h5><p>（1）服务调用方式 dubbo是RPC springcloud Rest Api</p>
<p>（2）注册中心,dubbo 是zookeeper springcloud是eureka，也可以是zookeeper</p>
<p>（3）服务网关,dubbo本身没有实现，只能通过其他第三方技术整合，springcloud有Zuul路由网关，作为路由服务器，进行消费者的请求分发,springcloud支持断路器，与git完美集成配置文件支持版本控制，事物总线实现配置文件的更新与服务自动装配等等一系列的微服务架构要素。</p>
<h5 id="负载平衡的意义什么？"><a href="#负载平衡的意义什么？" class="headerlink" title="负载平衡的意义什么？"></a>负载平衡的意义什么？</h5><p>在计算中，负载平衡可以改善跨计算机，计算机集群，网络链接，中央处理单元或磁盘驱动器等多种计算资源的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间并避免任何单一资源的过载。使用多个组件进行负载平衡而不是单个组件可能会通过冗余来提高可靠性和可用性。负载平衡通常涉及专用软件或硬件，例如多层交换机或域名系统服务器进程。</p>
<h5 id="什么是-Hystrix？它如何实现容错？"><a href="#什么是-Hystrix？它如何实现容错？" class="headerlink" title="什么是 Hystrix？它如何实现容错？"></a>什么是 Hystrix？它如何实现容错？</h5><p>Hystrix 是一个延迟和容错库，旨在隔离远程系统，服务和第三方库的访问点，当出现故障是不可避免的故障时，停止级联故障并在复杂的分布式系统中实现弹性。</p>
<p>通常对于使用微服务架构开发的系统，涉及到许多微服务。这些微服务彼此协作。</p>
<p>思考以下微服务</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8zMC8xNmY1NWZiZmQzZTNmZDI4?x-oss-process=image/format,png" alt></p>
<p>假设如果上图中的微服务 9 失败了，那么使用传统方法我们将传播一个异常。但这仍然会导致整个系统崩溃。</p>
<p>随着微服务数量的增加，这个问题变得更加复杂。微服务的数量可以高达 1000.这是 hystrix 出现的地方 我们将使用 Hystrix 在这种情况下的 Fallback 方法功能。我们有两个服务 employee-consumer 使用由 employee-consumer 公开的服务。</p>
<p>简化图如下所示</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8zMC8xNmY1NWZiZmNlNjcxYjgz?x-oss-process=image/format,png" alt></p>
<p>现在假设由于某种原因，employee-producer 公开的服务会抛出异常。我们在这种情况下使用 Hystrix 定义了一个回退方法。这种后备方法应该具有与公开服务相同的返回类型。如果暴露服务中出现异常，则回退方法将返回一些值。</p>
<h5 id="什么是-Hystrix-断路器？我们需要它吗？"><a href="#什么是-Hystrix-断路器？我们需要它吗？" class="headerlink" title="什么是 Hystrix 断路器？我们需要它吗？"></a>什么是 Hystrix 断路器？我们需要它吗？</h5><p>由于某些原因，employee-consumer 公开服务会引发异常。在这种情况下使用Hystrix 我们定义了一个回退方法。如果在公开服务中发生异常，则回退方法返回一些默认值。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8zMC8xNmY1NWZiZmNlZWZhOTJh?x-oss-process=image/format,png" alt></p>
<p>如果 firstPage method() 中的异常继续发生，则 Hystrix 电路将中断，并且员工使用者将一起跳过 firtsPage 方法，并直接调用回退方法。 断路器的目的是给第一页方法或第一页方法可能调用的其他方法留出时间，并导致异常恢复。可能发生的情况是，在负载较小的情况下，导致异常的问题有更好的恢复机会 。</p>
<p><img src="http://zhao.zcycomputer.cn/16f55fbfd4e33ae7.webp" alt></p>
<h5 id="什么是-Netflix-Feign？它的优点是什么？"><a href="#什么是-Netflix-Feign？它的优点是什么？" class="headerlink" title="什么是 Netflix Feign？它的优点是什么？"></a>什么是 Netflix Feign？它的优点是什么？</h5><p>Feign 是受到 Retrofit，JAXRS-2.0 和 WebSocket 启发的 java 客户端联编程序。</p>
<p>Feign 的第一个目标是将约束分母的复杂性统一到 http apis，而不考虑其稳定性。</p>
<p>在 employee-consumer 的例子中，我们使用了 employee-producer 使用 REST模板公开的 REST 服务。</p>
<p>但是我们必须编写大量代码才能执行以下步骤</p>
<p>（1）使用功能区进行负载平衡。</p>
<p>（2）获取服务实例，然后获取基本 URL。</p>
<p>（3）利用 REST 模板来使用服务。 前面的代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerControllerClient</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> LoadBalancerClient loadBalancer;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getEmployee</span><span class="params">()</span> <span class="keyword">throws</span> RestClientException, IOException </span>&#123;</span><br><span class="line">	ServiceInstance serviceInstance=loadBalancer.choose(<span class="string">"employee-producer"</span>);</span><br><span class="line">	System.out.println(serviceInstance.getUri());</span><br><span class="line">	String baseUrl=serviceInstance.getUri().toString();</span><br><span class="line">	baseUrl=baseUrl+<span class="string">"/employee"</span>;</span><br><span class="line">	RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">	ResponseEntity&lt;String&gt; response=<span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		response=restTemplate.exchange(baseUrl,</span><br><span class="line">					HttpMethod.GET, getHeaders(),String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Exception ex)</span><br><span class="line">		&#123;</span><br><span class="line">		System.out.println(ex);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(response.getBody());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前的代码，有像 NullPointer 这样的例外的机会，并不是最优的。我们将看到如何使用 Netflix Feign 使呼叫变得更加轻松和清洁。如果 Netflix Ribbon 依赖关系也在类路径中，那么 Feign 默认也会负责负载平衡。</p>
<h5 id="什么是-Spring-Cloud-Bus？我们需要它吗？"><a href="#什么是-Spring-Cloud-Bus？我们需要它吗？" class="headerlink" title="什么是 Spring Cloud Bus？我们需要它吗？"></a>什么是 Spring Cloud Bus？我们需要它吗？</h5><p>考虑以下情况：我们有多个应用程序使用 Spring Cloud Config 读取属性，而Spring Cloud Config 从 GIT 读取这些属性。</p>
<p>下面的例子中多个员工生产者模块从 Employee Config Module 获取 Eureka 注册的财产。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8zMC8xNmY1NWZiZmQ3NzQ0YzQ3?x-oss-process=image/format,png" alt></p>
<p>如果假设 GIT 中的 Eureka 注册属性更改为指向另一台 Eureka 服务器，会发生什么情况。在这种情况下，我们将不得不重新启动服务以获取更新的属性。</p>
<p>还有另一种使用执行器端点/刷新的方式。但是我们将不得不为每个模块单独调用这个 url。例如，如果 Employee Producer1 部署在端口 8080 上，则调用 http：// localhost：8080 / refresh。同样对于 Employee Producer2 http：//localhost：8081 / refresh 等等。这又很麻烦。这就是 Spring Cloud Bus 发挥作用的地方。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8zMC8xNmY1NWZiZmY0OTgxYWU5?x-oss-process=image/format,png" alt></p>
<p>Spring Cloud Bus 提供了跨多个实例刷新配置的功能。因此，在上面的示例中，如果我们刷新 Employee Producer1，则会自动刷新所有其他必需的模块。如果我们有多个微服务启动并运行，这特别有用。这是通过将所有微服务连接到单个消息代理来实现的。无论何时刷新实例，此事件都会订阅到侦听此代理的所有微服务，并且它们也会刷新。可以通过使用端点/总线/刷新来实现对任何单个实例的刷新。</p>
<h5 id="Spring-Cloud断路器的作用"><a href="#Spring-Cloud断路器的作用" class="headerlink" title="Spring Cloud断路器的作用"></a>Spring Cloud断路器的作用</h5><p>当一个服务调用另一个服务由于网络原因或自身原因出现问题，调用者就会等待被调用者的响应 当更多的服务请求到这些资源导致更多的请求等待，发生连锁效应（雪崩效应）</p>
<p>断路器有完全打开状态:一段时间内 达到一定的次数无法调用 并且多次监测没有恢复的迹象 断路器完全打开 那么下次请求就不会请求到该服务</p>
<p>半开:短时间内 有恢复迹象 断路器会将部分请求发给该服务，正常调用时 断路器关闭</p>
<p>关闭：当服务一直处于正常状态 能正常调用</p>
<h5 id="什么是Spring-Cloud-Config"><a href="#什么是Spring-Cloud-Config" class="headerlink" title="什么是Spring Cloud Config?"></a>什么是Spring Cloud Config?</h5><p>在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是config server，二是config client。</p>
<p>使用：</p>
<p>（1）添加pom依赖</p>
<p>（2）配置文件添加相关配置</p>
<p>（3）启动类添加注解@EnableConfigServer</p>
<h5 id="什么是Spring-Cloud-Gateway"><a href="#什么是Spring-Cloud-Gateway" class="headerlink" title="什么是Spring Cloud Gateway?"></a>什么是Spring Cloud Gateway?</h5><p>Spring Cloud Gateway是Spring Cloud官方推出的第二代网关框架，取代Zuul网关。网关作为流量的，在微服务系统中有着非常作用，网关常见的功能有路由转发、权限校验、限流控制等作用。</p>
<p>使用了一个RouteLocatorBuilder的bean去创建路由，除了创建路由RouteLocatorBuilder可以让你添加各种predicates和filters，predicates断言的意思，顾名思义就是根据具体的请求的规则，由具体的route去处理，filters是各种过滤器，用来对请求做各种判断和修改。</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring面试题</title>
    <url>/myblog/interview/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>Spring概述</p>
<a id="more"></a>
<p>什么是spring?</p>
<h5 id="什么是spring"><a href="#什么是spring" class="headerlink" title="什么是spring?"></a>什么是spring?</h5><p>Spring是<strong>一个轻量级Java开发框架</strong>，最早有<strong>Rod Johnson</strong>创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的JavaSE/JavaEE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。</p>
<p>Spring最根本的使命是<strong>解决企业级应用开发的复杂性，即简化Java开发</strong>。</p>
<p>Spring可以做很多事情，它为企业级开发提供给了丰富的功能，但是这些功能的底层都依赖于它的两个核心特性，也就是<strong>依赖注入（dependency injection，DI</strong>）和<strong>面向切面编程（aspect-oriented programming，AOP）</strong>。</p>
<p>为了降低Java开发的复杂性，Spring采取了以下4种关键策略</p>
<ul>
<li>基于POJO的轻量级和最小侵入性编程；</li>
<li>通过依赖注入和面向接口实现松耦合；</li>
<li>基于切面和惯例进行声明式编程；</li>
<li>通过切面和模板减少样板式代码。</li>
</ul>
<h5 id="Spring框架的设计目标，设计理念，和核心是什么"><a href="#Spring框架的设计目标，设计理念，和核心是什么" class="headerlink" title="Spring框架的设计目标，设计理念，和核心是什么"></a>Spring框架的设计目标，设计理念，和核心是什么</h5><p><strong>Spring设计目标</strong>：Spring为开发者提供一个一站式轻量级应用开发平台；</p>
<p><strong>Spring设计理念</strong>：在JavaEE开发中，支持POJO和JavaBean开发方式，使应用面向接口开发，充分支持OO（面向对象）设计方法；Spring通过IoC容器实现对象耦合关系的管理，并实现依赖反转，将对象之间的依赖关系交给IoC容器，实现解耦；</p>
<p><strong>Spring框架的核心：</strong>IoC容器和AOP模块。通过IoC容器管理POJO对象以及他们之间的耦合关系；通过AOP以动态非侵入的方式增强服务。</p>
<p>IoC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。、</p>
<!--more-->

<h5 id="Spring的优缺点是什么？"><a href="#Spring的优缺点是什么？" class="headerlink" title="Spring的优缺点是什么？"></a>Spring的优缺点是什么？</h5><p>优点</p>
<ul>
<li>方便解耦，简化开发</li>
</ul>
<p>Spring就是一个大工厂，可以将所有对象的创建和依赖关系的维护，交给Spring管理。</p>
<ul>
<li>AOP编程的支持</li>
</ul>
<p>Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。</p>
<ul>
<li>声明式事务的支持</li>
</ul>
<p>只需要通过配置就可以完成对事务的管理，而无需手动编程。</p>
<ul>
<li>方便程序的测试</li>
</ul>
<p>Spring对Junit4支持，可以通过注解方便的测试Spring程序。</p>
<ul>
<li>方便集成各种优秀框架</li>
</ul>
<p>Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持（如：Struts、Hibernate、MyBatis等）。</p>
<ul>
<li>降低JavaEE API的使用难度</li>
</ul>
<p>Spring对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低。</p>
<p>缺点</p>
<ul>
<li>Spring明明一个很轻量级的框架，却给人感觉大而全</li>
<li>Spring依赖反射，反射影响性能</li>
<li>使用门槛升高，入门Spring需要较长时间</li>
</ul>
<h5 id="Spring有哪些应用场景"><a href="#Spring有哪些应用场景" class="headerlink" title="Spring有哪些应用场景"></a>Spring有哪些应用场景</h5><p><strong>应用场景</strong>：JavaEE企业应用开发，包括SSH、SSM等</p>
<p><strong>Spring价值：</strong></p>
<ul>
<li>Spring是非侵入式的框架，目标是使应用程序代码对框架依赖最小化；</li>
<li>Spring提供一个一致的编程模型，使应用直接使用POJO开发，与运行环境隔离开来；</li>
<li>Spring推动应用设计风格向面向对象和面向接口开发转变，提高了代码的重用性和可测试性；</li>
</ul>
<h5 id="Spring由哪些模块组成？"><a href="#Spring由哪些模块组成？" class="headerlink" title="Spring由哪些模块组成？"></a>Spring由哪些模块组成？</h5><p>Spring 总共大约有 20 个模块， 由 1300 多个不同的文件构成。 而这些组件被分别整合在核心容器（Core Container） 、 AOP（Aspect Oriented Programming）和设备支持（Instrmentation） 、数据访问与集成（Data Access/Integeration） 、 Web、 消息（Messaging） 、 Test等 6 个模块中。 以下是 Spring 5 的模块结构图：</p>
<p><img src="https://img-blog.csdnimg.cn/2019102923475419.png" alt></p>
<ul>
<li>spring core：提供了框架的基本组成部分，包括控制反转（Inversion of Control，IOC）和依赖注入（Dependency Injection，DI）功能。</li>
<li>spring beans：提供了BeanFactory，是工厂模式的一个经典实现，Spring将管理对象称为Bean。</li>
<li>spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。</li>
<li>spring jdbc：提供了一个JDBC的抽象层，消除了烦琐的JDBC编码和数据库厂商特有的错误代码解析， 用于简化JDBC。</li>
<li>spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。</li>
<li>spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。</li>
<li>spring test：主要为测试提供支持的，支持使用JUnit或TestNG对Spring组件进行单元测试和集成测试。</li>
</ul>
<h5 id="Spring-框架中都用到了哪些设计模式？"><a href="#Spring-框架中都用到了哪些设计模式？" class="headerlink" title="Spring 框架中都用到了哪些设计模式？"></a>Spring 框架中都用到了哪些设计模式？</h5><ul>
<li>工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；</li>
<li>单例模式：Bean默认为单例模式。</li>
<li>代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；</li>
<li>模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</li>
<li>观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。</li>
</ul>
<h5 id="详细讲解一下核心容器（spring-context应用上下文-模块"><a href="#详细讲解一下核心容器（spring-context应用上下文-模块" class="headerlink" title="详细讲解一下核心容器（spring context应用上下文) 模块"></a>详细讲解一下核心容器（spring context应用上下文) 模块</h5><p>这是基本的Spring模块，提供spring 框架的基础功能，BeanFactory 是 任何以spring为基础的应用的核心。Spring 框架建立在此模块之上，它使Spring成为一个容器。</p>
<p>Bean 工厂是工厂模式的一个实现，提供了控制反转功能，用来把应用的配置和依赖从真正的应用代码中分离。最常用的就是org.springframework.beans.factory.xml.XmlBeanFactory ，它根据XML文件中的定义加载beans。该容器从XML 文件读取配置元数据并用它去创建一个完全配置的系统或应用。<br>Spring框架中有哪些不同类型的事件</p>
<h5 id="Spring-提供了以下5种标准的事件："><a href="#Spring-提供了以下5种标准的事件：" class="headerlink" title="Spring 提供了以下5种标准的事件："></a>Spring 提供了以下5种标准的事件：</h5><ol>
<li>上下文更新事件（ContextRefreshedEvent）：在调用ConfigurableApplicationContext 接口中的refresh()方法时被触发。</li>
<li>上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始/重新开始容器时触发该事件。</li>
<li>上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。</li>
<li>上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。</li>
<li>请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。如果一个bean实现了ApplicationListener接口，当一个ApplicationEvent 被发布以后，bean会自动被通知。</li>
</ol>
<h5 id="Spring-应用程序有哪些不同组件？"><a href="#Spring-应用程序有哪些不同组件？" class="headerlink" title="Spring 应用程序有哪些不同组件？"></a>Spring 应用程序有哪些不同组件？</h5><p>Spring 应用一般有以下组件：</p>
<ul>
<li>接口 - 定义功能。</li>
<li>Bean 类 - 它包含属性，setter 和 getter 方法，函数等。</li>
<li>Bean 配置文件 - 包含类的信息以及如何配置它们。</li>
<li>Spring 面向切面编程（AOP） - 提供面向切面编程的功能。</li>
<li>用户程序 - 它使用接口。</li>
</ul>
<h5 id="使用-Spring-有哪些方式？"><a href="#使用-Spring-有哪些方式？" class="headerlink" title="使用 Spring 有哪些方式？"></a>使用 Spring 有哪些方式？</h5><p>使用 Spring 有以下方式：</p>
<ul>
<li>作为一个成熟的 Spring Web 应用程序。</li>
<li>作为第三方 Web 框架，使用 Spring Frameworks 中间层。</li>
<li>作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java Objects）。</li>
<li>用于远程使用。</li>
</ul>
<h4 id="Spring控制反转-IOC"><a href="#Spring控制反转-IOC" class="headerlink" title="Spring控制反转(IOC)"></a>Spring控制反转(IOC)</h4><h5 id="什么是Spring-IOC-容器？"><a href="#什么是Spring-IOC-容器？" class="headerlink" title="什么是Spring IOC 容器？"></a>什么是Spring IOC 容器？</h5><p>控制反转即IoC (Inversion of Control)，它把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。</p>
<p>Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</p>
<h5 id="控制反转-IoC-有什么作用"><a href="#控制反转-IoC-有什么作用" class="headerlink" title="控制反转(IoC)有什么作用"></a>控制反转(IoC)有什么作用</h5><ul>
<li>管理对象的创建和依赖关系的维护。对象的创建并不是一件简单的事，在对象关系比较复杂时，如果依赖关系需要程序猿来维护的话，那是相当头疼的</li>
<li>解耦，由容器去维护具体的对象</li>
<li>托管了类的产生过程，比如我们需要在类的产生过程中做一些处理，最直接的例子就是代理，如果有容器程序可以把这部分处理交给容器，应用程序则无需去关心类是如何完成代理的</li>
</ul>
<h5 id="IOC的优点是什么？"><a href="#IOC的优点是什么？" class="headerlink" title="IOC的优点是什么？"></a>IOC的优点是什么？</h5><ul>
<li>IOC 或 依赖注入把应用的代码量降到最低。</li>
<li>它使应用容易测试，单元测试不再需要单例和JNDI查找机制。</li>
<li>最小的代价和最小的侵入性使松散耦合得以实现。</li>
<li>IOC容器支持加载服务时的饿汉式初始化和懒加载</li>
</ul>
<h5 id="Spring-IoC-的实现机制"><a href="#Spring-IoC-的实现机制" class="headerlink" title="Spring IoC 的实现机制"></a>Spring IoC 的实现机制</h5><p>Spring 中的 IoC 的实现原理就是工厂模式加反射机制。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Apple"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Orange"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">getInstance</span><span class="params">(String ClassName)</span> </span>&#123;</span><br><span class="line">        Fruit f=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f=(Fruit)Class.forName(ClassName).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] a)</span> </span>&#123;</span><br><span class="line">        Fruit f=Factory.getInstance(<span class="string">"io.github.dunwu.spring.Apple"</span>);</span><br><span class="line">        <span class="keyword">if</span>(f!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            f.eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Spring-的-IoC支持哪些功能"><a href="#Spring-的-IoC支持哪些功能" class="headerlink" title="Spring 的 IoC支持哪些功能"></a>Spring 的 IoC支持哪些功能</h5><p>Spring 的 IoC 设计支持以下功能：</p>
<ul>
<li>依赖注入</li>
<li>依赖检查</li>
<li>自动装配</li>
<li>支持集合</li>
<li>指定初始化方法和销毁方法</li>
<li>支持回调某些方法（但是需要实现 Spring 接口，略有侵入）</li>
</ul>
<p>其中，最重要的就是依赖注入，从 XML 的配置上说，即 ref 标签。对应 Spring RuntimeBeanReference 对象。</p>
<p>对于 IoC 来说，最重要的就是容器。容器管理着 Bean 的生命周期，控制着 Bean 的依赖注入。</p>
<h5 id="BeanFactory-和-ApplicationContext有什么区别？"><a href="#BeanFactory-和-ApplicationContext有什么区别？" class="headerlink" title="BeanFactory 和 ApplicationContext有什么区别？"></a>BeanFactory 和 ApplicationContext有什么区别？</h5><p>BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。</p>
<p>依赖关系</p>
<p>BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。</p>
<p>ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：</p>
<ul>
<li>继承MessageSource，因此支持国际化。</li>
<li>统一的资源文件访问方式。</li>
<li>提供在监听器中注册bean的事件。</li>
<li>同时加载多个配置文件。</li>
<li>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</li>
</ul>
<p>加载方式</p>
<p>BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</p>
<p>ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</p>
<p>相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p>
<p>创建方式</p>
<p>BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。</p>
<p>注册方式</p>
<p>BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</p>
<h5 id="Spring-如何设计容器的，BeanFactory和ApplicationContext的关系详解"><a href="#Spring-如何设计容器的，BeanFactory和ApplicationContext的关系详解" class="headerlink" title="Spring 如何设计容器的，BeanFactory和ApplicationContext的关系详解"></a>Spring 如何设计容器的，BeanFactory和ApplicationContext的关系详解</h5><p>Spring 作者 Rod Johnson 设计了两个接口用以表示容器。</p>
<ul>
<li>BeanFactory</li>
<li>ApplicationContext</li>
</ul>
<p>BeanFactory 简单粗暴，可以理解为就是个 HashMap，Key 是 BeanName，Value 是 Bean 实例。通常只提供注册（put），获取（get）这两个功能。我们可以称之为 “低级容器”。</p>
<p>ApplicationContext 可以称之为 <strong>“高级容器”</strong>。因为他比 BeanFactory 多了更多的功能。他继承了多个接口。因此具备了更多的功能。例如资源的获取，支持多种消息（例如 JSP tag 的支持），对 BeanFactory 多了工具级别的支持等待。所以你看他的名字，已经不是 BeanFactory 之类的工厂了，而是 “应用上下文”， 代表着整个大容器的所有功能。该接口定义了一个 refresh 方法，此方法是所有阅读 Spring 源码的人的最熟悉的方法，用于刷新整个容器，即重新加载/刷新所有的 bean。</p>
<p>当然，除了这两个大接口，还有其他的辅助接口，这里就不介绍他们了。</p>
<p>BeanFactory和ApplicationContext的关系</p>
<p>为了更直观的展示 “低级容器” 和 “高级容器” 的关系，这里通过常用的 ClassPathXmlApplicationContext 类来展示整个容器的层级 UML 关系。</p>
<p><img src="https://img-blog.csdnimg.cn/20191105111441363.png" alt></p>
<p>有点复杂？ 先不要慌，我来解释一下。</p>
<p>最上面的是 BeanFactory，下面的 3 个绿色的，都是功能扩展接口，这里就不展开讲。</p>
<p>看下面的隶属 ApplicationContext 粉红色的 “高级容器”，依赖着 “低级容器”，这里说的是依赖，不是继承哦。他依赖着 “低级容器” 的 getBean 功能。而高级容器有更多的功能：支持不同的信息源头，可以访问文件资源，支持应用事件（Observer 模式）。</p>
<p>通常用户看到的就是 “高级容器”。 但 BeanFactory 也非常够用啦！</p>
<p>左边灰色区域的是 “低级容器”， 只负载加载 Bean，获取 Bean。容器其他的高级功能是没有的。例如上图画的 refresh 刷新 Bean 工厂所有配置，生命周期事件回调等。</p>
<p>小结</p>
<p>说了这么多，不知道你有没有理解Spring IoC？ 这里小结一下：IoC 在 Spring 里，只需要低级容器就可以实现，2 个步骤：</p>
<ol>
<li>加载配置文件，解析成 BeanDefinition 放在 Map 里。</li>
<li>调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入。</li>
</ol>
<p>上面就是 Spring 低级容器（BeanFactory）的 IoC。</p>
<p>至于高级容器 ApplicationContext，他包含了低级容器的功能，当他执行 refresh 模板方法的时候，将刷新整个容器的 Bean。同时其作为高级容器，包含了太多的功能。一句话，他不仅仅是 IoC。他支持不同信息源头，支持 BeanFactory 工具类，支持层级容器，支持访问文件资源，支持事件发布通知，支持接口回调等等。</p>
<h5 id="ApplicationContext通常的实现是什么？"><a href="#ApplicationContext通常的实现是什么？" class="headerlink" title="ApplicationContext通常的实现是什么？"></a>ApplicationContext通常的实现是什么？</h5><p><strong>FileSystemXmlApplicationContext</strong> ：此容器从一个XML文件中加载beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。</p>
<p><strong>ClassPathXmlApplicationContext</strong>：此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。</p>
<p><strong>WebXmlApplicationContext</strong>：此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。</p>
<h5 id="什么是Spring的依赖注入？"><a href="#什么是Spring的依赖注入？" class="headerlink" title="什么是Spring的依赖注入？"></a>什么是Spring的依赖注入？</h5><p>控制反转IoC是一个很大的概念，可以用不同的方式来实现。其主要实现方式有两种：依赖注入和依赖查找</p>
<p>依赖注入：相对于IoC而言，依赖注入(DI)更加准确地描述了IoC的设计理念。所谓依赖注入（Dependency Injection），即组件之间的依赖关系由容器在应用系统运行期来决定，也就是由容器动态地将某种依赖关系的目标对象实例注入到应用系统中的各个关联的组件之中。组件不做定位查询，只提供普通的Java方法让容器去决定依赖关系。</p>
<h5 id="依赖注入的基本原则"><a href="#依赖注入的基本原则" class="headerlink" title="依赖注入的基本原则"></a>依赖注入的基本原则</h5><p>依赖注入的基本原则是：应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由IoC容器负责，“查找资源”的逻辑应该从应用组件的代码中抽取出来，交给IoC容器负责。容器全权负责组件的装配，它会把符合依赖关系的对象通过属性（JavaBean中的setter）或者是构造器传递给需要的对象。</p>
<h5 id="依赖注入有什么优势"><a href="#依赖注入有什么优势" class="headerlink" title="依赖注入有什么优势"></a>依赖注入有什么优势</h5><p>依赖注入之所以更流行是因为它是一种更可取的方式：让容器全权负责依赖查询，受管组件只需要暴露JavaBean的setter方法或者带参数的构造器或者接口，使容器可以在初始化时组装对象的依赖关系。其与依赖查找方式相比，主要优势为：</p>
<ul>
<li>查找定位操作与应用代码完全无关。</li>
<li>不依赖于容器的API，可以很容易地在任何容器以外使用应用对象。</li>
<li>不需要特殊的接口，绝大多数对象可以做到完全不必依赖容器。</li>
</ul>
<h5 id="有哪些不同类型的依赖注入实现方式？"><a href="#有哪些不同类型的依赖注入实现方式？" class="headerlink" title="有哪些不同类型的依赖注入实现方式？"></a>有哪些不同类型的依赖注入实现方式？</h5><p>依赖注入是时下最流行的IoC实现方式，依赖注入分为接口注入（Interface Injection），Setter方法注入（Setter Injection）和构造器注入（Constructor Injection）三种方式。其中接口注入由于在灵活性和易用性比较差，现在从Spring4开始已被废弃。</p>
<p><strong>构造器依赖注入</strong>：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</p>
<p><strong>Setter方法注入</strong>：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。</p>
<h5 id="构造器依赖注入和-Setter方法注入的区别"><a href="#构造器依赖注入和-Setter方法注入的区别" class="headerlink" title="构造器依赖注入和 Setter方法注入的区别"></a>构造器依赖注入和 Setter方法注入的区别</h5><table>
<thead>
<tr>
<th align="center"><strong>构造函数注入</strong></th>
<th align="center"><strong>setter</strong> <strong>注入</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">没有部分注入</td>
<td align="center">有部分注入</td>
</tr>
<tr>
<td align="center">不会覆盖 setter 属性</td>
<td align="center">会覆盖 setter 属性</td>
</tr>
<tr>
<td align="center">任意修改都会创建一个新实例</td>
<td align="center">任意修改不会创建一个新实例</td>
</tr>
<tr>
<td align="center">适用于设置很多属性</td>
<td align="center">适用于设置少量属性</td>
</tr>
</tbody></table>
<p>两种依赖方式都可以使用，构造器注入和Setter方法注入。最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖。</p>
<h4 id="Spring-Beans（19）"><a href="#Spring-Beans（19）" class="headerlink" title="Spring Beans（19）"></a>Spring Beans（19）</h4><h5 id="什么是Spring-beans？"><a href="#什么是Spring-beans？" class="headerlink" title="什么是Spring beans？"></a>什么是Spring beans？</h5><p>Spring beans 是那些形成Spring应用的主干的java对象。它们被Spring IOC容器初始化，装配，和管理。这些beans通过容器中配置的元数据创建。比如，以XML文件中 的形式定义。</p>
<h5 id="一个-Spring-Bean-定义-包含什么？"><a href="#一个-Spring-Bean-定义-包含什么？" class="headerlink" title="一个 Spring Bean 定义 包含什么？"></a>一个 Spring Bean 定义 包含什么？</h5><p>一个Spring Bean 的定义包含容器必知的所有配置元数据，包括如何创建一个bean，它的生命周期详情及它的依赖。<br>如何给Spring 容器提供配置元数据？Spring有几种配置方式</p>
<p>这里有三种重要的方法给Spring 容器提供配置元数据。</p>
<ul>
<li>XML配置文件。</li>
<li>基于注解的配置。</li>
<li>基于java的配置。</li>
</ul>
<h4 id="Spring配置文件包含了哪些信息"><a href="#Spring配置文件包含了哪些信息" class="headerlink" title="Spring配置文件包含了哪些信息"></a>Spring配置文件包含了哪些信息</h4><p>Spring配置文件是个XML 文件，这个文件包含了类信息，描述了如何配置它们，以及如何相互调用。</p>
<h5 id="Spring基于xml注入bean的几种方式"><a href="#Spring基于xml注入bean的几种方式" class="headerlink" title="Spring基于xml注入bean的几种方式"></a>Spring基于xml注入bean的几种方式</h5><ol>
<li>Set方法注入；</li>
<li>构造器注入：①通过index设置参数的位置；②通过type设置参数类型；</li>
<li>静态工厂注入；</li>
<li>实例工厂；</li>
</ol>
<h5 id="你怎样定义类的作用域？"><a href="#你怎样定义类的作用域？" class="headerlink" title="你怎样定义类的作用域？"></a>你怎样定义类的作用域？</h5><p>当定义一个 在Spring里，我们还能给这个bean声明一个作用域。它可以通过bean 定义中的scope属性来定义。如，当Spring要在需要的时候每次生产一个新的bean实例，bean的scope属性被指定为prototype。另一方面，一个bean每次使用的时候必须返回同一个实例，这个bean的scope 属性 必须设为 singleton。<br>解释Spring支持的几种bean的作用域</p>
<h5 id="Spring框架支持以下五种bean的作用域："><a href="#Spring框架支持以下五种bean的作用域：" class="headerlink" title="Spring框架支持以下五种bean的作用域："></a>Spring框架支持以下五种bean的作用域：</h5><ul>
<li><p>singleton : bean在每个Spring ioc 容器中只有一个实例。</p>
</li>
<li><p>prototype：一个bean的定义可以有多个实例。</p>
</li>
<li><p>request：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。</p>
</li>
<li><p>session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</p>
</li>
<li><p>global-session：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring </p>
<p>ApplicationContext情形下有效。</p>
</li>
</ul>
<p><strong>注意</strong>： 缺省的Spring bean 的作用域是Singleton。使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</p>
<h5 id="Spring框架中的单例bean是线程安全的吗？"><a href="#Spring框架中的单例bean是线程安全的吗？" class="headerlink" title="Spring框架中的单例bean是线程安全的吗？"></a><strong>Spring框架中的单例bean是线程安全的吗？</strong></h5><p>不是，Spring框架中的单例bean不是线程安全的。</p>
<p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。</p>
<p>实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。</p>
<ul>
<li>有状态就是有数据存储功能。</li>
<li>无状态就是不会保存数据。</li>
</ul>
<h5 id="Spring如何处理线程并发问题？"><a href="#Spring如何处理线程并发问题？" class="headerlink" title="Spring如何处理线程并发问题？"></a>Spring如何处理线程并发问题？</h5><p>在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域，因为Spring对一些Bean中非线程安全状态采用ThreadLocal进行处理，解决线程安全问题。</p>
<p>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。</p>
<p>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p>
<h5 id="解释Spring框架中bean的生命周期"><a href="#解释Spring框架中bean的生命周期" class="headerlink" title="解释Spring框架中bean的生命周期"></a>解释Spring框架中bean的生命周期</h5><p>在传统的Java应用中，bean的生命周期很简单。使用Java关键字new进行bean实例化，然后该bean就可以使用了。一旦该bean不再被使用，则由Java自动进行垃圾回收。相比之下，Spring容器中的bean的生命周期就显得相对复杂多了。正确理解Spring bean的生命周期非常重要，因为你或许要利用Spring提供的扩展点来自定义bean的创建过程。下图展示了bean装载到Spring应用上下文中的一个典型的生命周期过程。</p>
<p><img src="https://img-blog.csdnimg.cn/201911012343410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt></p>
<p>bean在Spring容器中从创建到销毁经历了若干阶段，每一阶段都可以针对Spring如何管理bean进行个性化定制。</p>
<p>正如你所见，在bean准备就绪之前，bean工厂执行了若干启动步骤。</p>
<p>我们对上图进行详细描述：</p>
<p>Spring对bean进行实例化；</p>
<p>Spring将值和bean的引用注入到bean对应的属性中；</p>
<p>如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBean-Name()方法；</p>
<p>如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入；</p>
<p>如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来；</p>
<p>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessBeforeInitialization()方法；</p>
<p>如果bean实现了InitializingBean接口，Spring将调用它们的after-PropertiesSet()方法。类似地，如果bean使用initmethod声明了初始化方法，该方法也会被调用；</p>
<p>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessAfterInitialization()方法；</p>
<p>此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；</p>
<p>如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用。</p>
<p>现在你已经了解了如何创建和加载一个Spring容器。但是一个空的容器并没有太大的价值，在你把东西放进去之前，它里面什么都没有。为了从Spring的DI(依赖注入)中受益，我们必须将应用对象装配进Spring容器中。</p>
<h5 id="哪些是重要的bean生命周期方法？-你能重载它们吗？"><a href="#哪些是重要的bean生命周期方法？-你能重载它们吗？" class="headerlink" title="哪些是重要的bean生命周期方法？ 你能重载它们吗？"></a>哪些是重要的bean生命周期方法？ 你能重载它们吗？</h5><p>有两个重要的bean 生命周期方法，第一个是setup ， 它是在容器加载bean的时候被调用。第二个方法是 teardown 它是在容器卸载类的时候被调用。</p>
<p>bean 标签有两个重要的属性（init-method和destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct和@PreDestroy）。</p>
<h5 id="什么是Spring的内部bean？什么是Spring-inner-beans？"><a href="#什么是Spring的内部bean？什么是Spring-inner-beans？" class="headerlink" title="什么是Spring的内部bean？什么是Spring inner beans？"></a>什么是Spring的内部bean？什么是Spring inner beans？</h5><p>在Spring框架中，当一个bean仅被用作另一个bean的属性时，它能被声明为一个内部bean。内部bean可以用setter注入“属性”和构造方法注入“构造参数”的方式来实现，内部bean通常是匿名的，它们的Scope一般是prototype。</p>
<h5 id="在-Spring中如何注入一个java集合？"><a href="#在-Spring中如何注入一个java集合？" class="headerlink" title="在 Spring中如何注入一个java集合？"></a>在 Spring中如何注入一个java集合？</h5><p>Spring提供以下几种集合的配置元素：</p>
<p>类型用于注入一列值，允许有相同的值。</p>
<p>类型用于注入一组值，不允许有相同的值。</p>
<p>类型用于注入一组键值对，键和值都可以为任意类型。</p>
<p>类型用于注入一组键值对，键和值都只能为String类型。</p>
<h5 id="什么是bean装配？"><a href="#什么是bean装配？" class="headerlink" title="什么是bean装配？"></a>什么是bean装配？</h5><p>装配，或bean 装配是指在Spring 容器中把bean组装到一起，前提是容器需要知道bean的依赖关系，如何通过依赖注入来把它们装配到一起。</p>
<h5 id="什么是bean的自动装配？"><a href="#什么是bean的自动装配？" class="headerlink" title="什么是bean的自动装配？"></a>什么是bean的自动装配？</h5><p>在Spring框架中，在配置文件中设定bean的依赖关系是一个很好的机制，Spring 容器能够自动装配相互合作的bean，这意味着容器不需要和配置，能通过Bean工厂自动处理bean之间的协作。这意味着 Spring可以通过向Bean Factory中注入的方式自动搞定bean之间的依赖关系。自动装配可以设置在每个bean上，也可以设定在特定的bean上。</p>
<h5 id="解释不同方式的自动装配，spring-自动装配-bean-有哪些方式？"><a href="#解释不同方式的自动装配，spring-自动装配-bean-有哪些方式？" class="headerlink" title="解释不同方式的自动装配，spring 自动装配 bean 有哪些方式？"></a>解释不同方式的自动装配，spring 自动装配 bean 有哪些方式？</h5><p>在spring中，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象，使用autowire来配置自动装载模式。</p>
<p>在Spring框架xml配置中共有5种自动装配：</p>
<ul>
<li>no：默认的方式是不进行自动装配的，通过手工设置ref属性来进行装配bean。</li>
<li>byName：通过bean的名称进行自动装配，如果一个bean的 property 与另一bean 的name 相同，就进行自动装配。</li>
<li>byType：通过参数的数据类型进行自动装配。</li>
<li>constructor：利用构造函数进行装配，并且构造函数的参数通过byType进行装配。</li>
<li>autodetect：自动探测，如果有构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。</li>
</ul>
<h5 id="使用-Autowired注解自动装配的过程是怎样的？"><a href="#使用-Autowired注解自动装配的过程是怎样的？" class="headerlink" title="使用@Autowired注解自动装配的过程是怎样的？"></a>使用@Autowired注解自动装配的过程是怎样的？</h5><p>使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，&lt;context:annotation-config /&gt;。</p>
<p>在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：</p>
<ul>
<li>如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；</li>
<li>如果查询的结果不止一个，那么@Autowired会根据名称来查找；</li>
<li>如果上述查找的结果为空，那么会抛出异常。解决方法时，使用required=false。</li>
</ul>
<h5 id="自动装配有哪些局限性？"><a href="#自动装配有哪些局限性？" class="headerlink" title="自动装配有哪些局限性？"></a>自动装配有哪些局限性？</h5><p>自动装配的局限性是：</p>
<p><strong>重写</strong>：你仍需用 和 配置来定义依赖，意味着总要重写自动装配。</p>
<p><strong>基本数据类型</strong>：你不能自动装配简单的属性，如基本数据类型，String字符串，和类。</p>
<p><strong>模糊特性</strong>：自动装配不如显式装配精确，如果有可能，建议使用显式装配。</p>
<h5 id="你可以在Spring中注入一个null-和一个空字符串吗？"><a href="#你可以在Spring中注入一个null-和一个空字符串吗？" class="headerlink" title="你可以在Spring中注入一个null 和一个空字符串吗？"></a>你可以在Spring中注入一个null 和一个空字符串吗？</h5><p>可以。</p>
<h4 id="Spring注解（8）"><a href="#Spring注解（8）" class="headerlink" title="Spring注解（8）"></a>Spring注解（8）</h4><h5 id="什么是基于Java的Spring注解配置-给一些注解的例子"><a href="#什么是基于Java的Spring注解配置-给一些注解的例子" class="headerlink" title="什么是基于Java的Spring注解配置? 给一些注解的例子"></a>什么是基于Java的Spring注解配置? 给一些注解的例子</h5><p>基于Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring配置而非通过XML文件。</p>
<p>以@Configuration 注解为例，它用来标记类可以当做一个bean的定义，被Spring IOC容器使用。</p>
<p>另一个例子是@Bean注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StudentBean <span class="title">myStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StudentBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="怎样开启注解装配？"><a href="#怎样开启注解装配？" class="headerlink" title="怎样开启注解装配？"></a>怎样开启注解装配？</h5><p>注解装配在默认情况下是不开启的，为了使用注解装配，我们必须在Spring配置文件中配置 <a href="context:annotation-config/">context:annotation-config/</a>元素。</p>
<h5 id="Component-Controller-Repository-Service-有何区别？"><a href="#Component-Controller-Repository-Service-有何区别？" class="headerlink" title="@Component, @Controller, @Repository, @Service 有何区别？"></a>@Component, @Controller, @Repository, @Service 有何区别？</h5><p>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</p>
<p>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</p>
<p>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。</p>
<p>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</p>
<h5 id="Required-注解有什么作用"><a href="#Required-注解有什么作用" class="headerlink" title="@Required 注解有什么作用"></a>@Required 注解有什么作用</h5><p>这个注解表明bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动装配，若@Required注解的bean属性未被设置，容器将抛出BeanInitializationException。示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Required</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> string <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Autowired-注解有什么作用"><a href="#Autowired-注解有什么作用" class="headerlink" title="@Autowired 注解有什么作用"></a>@Autowired 注解有什么作用</h5><p>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。@Autowired 注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它的用法和@Required一样，修饰setter方法、构造器、属性或者具有任意名称和/或多个参数的PN方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> string <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Autowired和-Resource之间的区别"><a href="#Autowired和-Resource之间的区别" class="headerlink" title="@Autowired和@Resource之间的区别"></a>@Autowired和@Resource之间的区别</h5><p>@Autowired可用于：构造函数、成员变量、Setter方法</p>
<p>@Autowired和@Resource之间的区别</p>
<ul>
<li>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。</li>
<li>@Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。</li>
</ul>
<h5 id="Qualifier-注解有什么作用"><a href="#Qualifier-注解有什么作用" class="headerlink" title="@Qualifier 注解有什么作用"></a>@Qualifier 注解有什么作用</h5><p>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。</p>
<h5 id="RequestMapping-注解有什么用？"><a href="#RequestMapping-注解有什么用？" class="headerlink" title="@RequestMapping 注解有什么用？"></a>@RequestMapping 注解有什么用？</h5><p>@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。此注释可应用于两个级别：</p>
<ul>
<li>类级别：映射请求的 URL</li>
<li>方法级别：映射 URL 以及 HTTP 请求方法</li>
</ul>
<h4 id="Spring数据访问（14）"><a href="#Spring数据访问（14）" class="headerlink" title="Spring数据访问（14）"></a>Spring数据访问（14）</h4><h5 id="解释对象-关系映射集成模块"><a href="#解释对象-关系映射集成模块" class="headerlink" title="解释对象/关系映射集成模块"></a>解释对象/关系映射集成模块</h5><p>Spring 通过提供ORM模块，支持我们在直接JDBC之上使用一个对象/关系映射映射(ORM)工具，Spring 支持集成主流的ORM框架，如Hiberate，JDO和 iBATIS，JPA，TopLink，JDO，OJB 。Spring的事务管理同样支持以上所有ORM框架及JDBC。</p>
<h5 id="在Spring框架中如何更有效地使用JDBC？"><a href="#在Spring框架中如何更有效地使用JDBC？" class="headerlink" title="在Spring框架中如何更有效地使用JDBC？"></a>在Spring框架中如何更有效地使用JDBC？</h5><p>使用Spring JDBC 框架，资源管理和错误处理的代价都会被减轻。所以开发者只需写statements 和 queries从数据存取数据，JDBC也可以在Spring框架提供的模板类的帮助下更有效地被使用，这个模板叫JdbcTemplate</p>
<h5 id="解释JDBC抽象和DAO模块"><a href="#解释JDBC抽象和DAO模块" class="headerlink" title="解释JDBC抽象和DAO模块"></a>解释JDBC抽象和DAO模块</h5><p>通过使用JDBC抽象和DAO模块，保证数据库代码的简洁，并能避免数据库资源错误关闭导致的问题，它在各种不同的数据库的错误信息之上，提供了一个统一的异常访问层。它还利用Spring的AOP 模块给Spring应用中的对象提供事务管理服务。</p>
<h5 id="spring-DAO-有什么用？"><a href="#spring-DAO-有什么用？" class="headerlink" title="spring DAO 有什么用？"></a>spring DAO 有什么用？</h5><p>Spring DAO（数据访问对象） 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。</p>
<h5 id="spring-JDBC-API-中存在哪些类？"><a href="#spring-JDBC-API-中存在哪些类？" class="headerlink" title="spring JDBC API 中存在哪些类？"></a>spring JDBC API 中存在哪些类？</h5><p>JdbcTemplate</p>
<p>SimpleJdbcTemplate</p>
<p>NamedParameterJdbcTemplate</p>
<p>SimpleJdbcInsert</p>
<p>SimpleJdbcCall</p>
<h5 id="JdbcTemplate是什么"><a href="#JdbcTemplate是什么" class="headerlink" title="JdbcTemplate是什么"></a>JdbcTemplate是什么</h5><p>JdbcTemplate 类提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</p>
<h5 id="使用Spring通过什么方式访问Hibernate？使用-Spring-访问-Hibernate-的方法有哪些？"><a href="#使用Spring通过什么方式访问Hibernate？使用-Spring-访问-Hibernate-的方法有哪些？" class="headerlink" title="使用Spring通过什么方式访问Hibernate？使用 Spring 访问 Hibernate 的方法有哪些？"></a>使用Spring通过什么方式访问Hibernate？使用 Spring 访问 Hibernate 的方法有哪些？</h5><p>在Spring中有两种方式访问Hibernate：</p>
<ul>
<li>使用 Hibernate 模板和回调进行控制反转</li>
<li>扩展 HibernateDAOSupport 并应用 AOP 拦截器节点</li>
</ul>
<h5 id="如何通过HibernateDaoSupport将Spring和Hibernate结合起来？"><a href="#如何通过HibernateDaoSupport将Spring和Hibernate结合起来？" class="headerlink" title="如何通过HibernateDaoSupport将Spring和Hibernate结合起来？"></a>如何通过HibernateDaoSupport将Spring和Hibernate结合起来？</h5><p>用Spring的 SessionFactory 调用 LocalSessionFactory。集成过程分三步：</p>
<ul>
<li>配置the Hibernate SessionFactory</li>
<li>继承HibernateDaoSupport实现一个DAO</li>
<li>在AOP支持的事务中装配</li>
</ul>
<h5 id="Spring支持的事务管理类型，-spring-事务实现方式有哪些？"><a href="#Spring支持的事务管理类型，-spring-事务实现方式有哪些？" class="headerlink" title="Spring支持的事务管理类型， spring 事务实现方式有哪些？"></a>Spring支持的事务管理类型， spring 事务实现方式有哪些？</h5><p>Spring支持两种类型的事务管理：</p>
<p><strong>编程式事务管理</strong>：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。</p>
<p><strong>声明式事务管理</strong>：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。</p>
<h5 id="Spring事务的实现方式和实现原理"><a href="#Spring事务的实现方式和实现原理" class="headerlink" title="Spring事务的实现方式和实现原理"></a>Spring事务的实现方式和实现原理</h5><p>Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。真正的数据库层的事务提交和回滚是通过binlog或者redo log实现的。</p>
<h5 id="说一下Spring的事务传播行为"><a href="#说一下Spring的事务传播行为" class="headerlink" title="说一下Spring的事务传播行为"></a>说一下Spring的事务传播行为</h5><p>spring事务的传播行为说的是，当多个事务同时存在的时候，spring如何处理这些事务的行为。</p>
<pre><code>① PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。

② PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。

③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。

④ PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。

⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。

⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。

⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。</code></pre><h5 id="说一下-spring-的事务隔离？"><a href="#说一下-spring-的事务隔离？" class="headerlink" title="说一下 spring 的事务隔离？"></a>说一下 spring 的事务隔离？</h5><p>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</p>
<ol>
<li>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</li>
<li>ISOLATION_READ_UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；</li>
<li>ISOLATION_READ_COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；</li>
<li>ISOLATION_REPEATABLE_READ：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；</li>
<li>ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</li>
</ol>
<p><strong>脏读</strong> ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p>
<p><strong>不可重复读</strong> ：是指在一个事务内，多次读同一数据。</p>
<p><strong>幻读</strong> ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p>
<h5 id="Spring框架的事务管理有哪些优点？"><a href="#Spring框架的事务管理有哪些优点？" class="headerlink" title="Spring框架的事务管理有哪些优点？"></a>Spring框架的事务管理有哪些优点？</h5><ul>
<li>为不同的事务API 如 JTA，JDBC，Hibernate，JPA 和JDO，提供一个不变的编程模式。</li>
<li>为编程式事务管理提供了一套简单的API而不是一些复杂的事务API</li>
<li>支持声明式事务管理。</li>
<li>和Spring各种数据访问抽象层很好得集成。</li>
</ul>
<h5 id="你更倾向用那种事务管理类型？"><a href="#你更倾向用那种事务管理类型？" class="headerlink" title="你更倾向用那种事务管理类型？"></a>你更倾向用那种事务管理类型？</h5><p>大多数Spring框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务管理，虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</p>
<h4 id="Spring面向切面编程-AOP-（13）"><a href="#Spring面向切面编程-AOP-（13）" class="headerlink" title="Spring面向切面编程(AOP)（13）"></a>Spring面向切面编程(AOP)（13）</h4><h5 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h5><p>OOP(Object-Oriented Programming)面向对象编程，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。</p>
<p>AOP(Aspect-Oriented Programming)，一般称为面向切面编程，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等。</p>
<h5 id="Spring-AOP-and-AspectJ-AOP-有什么区别？AOP-有哪些实现方式？"><a href="#Spring-AOP-and-AspectJ-AOP-有什么区别？AOP-有哪些实现方式？" class="headerlink" title="Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？"></a>Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？</h5><p>AOP实现的关键在于 代理模式，AOP代理主要分为静态代理和动态代理。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。</p>
<p>（1）AspectJ是静态代理的增强，所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的AOP对象。</p>
<p>（2）Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p>
<h5 id="JDK动态代理和CGLIB动态代理的区别"><a href="#JDK动态代理和CGLIB动态代理的区别" class="headerlink" title="JDK动态代理和CGLIB动态代理的区别"></a>JDK动态代理和CGLIB动态代理的区别</h5><p>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：</p>
<ul>
<li>JDK动态代理只提供接口的代理，不支持类的代理。核心InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的实例, 生成目标类的代理对象。</li>
<li>如果代理类没有实现 InvocationHandler 接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</li>
</ul>
<p>静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。</p>
<pre><code>InvocationHandler 的 invoke(Object proxy,Method method,Object[] args)：proxy是最终生成的代理实例; method 是被代理目标实例的某个具体方法; args 是被代理目标实例某个方法的具体入参, 在方法反射调用时使用。</code></pre><h5 id="如何理解-Spring-中的代理？"><a href="#如何理解-Spring-中的代理？" class="headerlink" title="如何理解 Spring 中的代理？"></a>如何理解 Spring 中的代理？</h5><p>将 Advice 应用于目标对象后创建的对象称为代理。在客户端对象的情况下，目标对象和代理对象是相同的。</p>
<p>Advice + Target Object = Proxy</p>
<h5 id="解释一下Spring-AOP里面的几个名词"><a href="#解释一下Spring-AOP里面的几个名词" class="headerlink" title="解释一下Spring AOP里面的几个名词"></a>解释一下Spring AOP里面的几个名词</h5><p>（1）切面（Aspect）：切面是通知和切点的结合。通知和切点共同定义了切面的全部内容。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @AspectJ 注解来实现。</p>
<p>（2）连接点（Join point）：指方法，在Spring AOP中，一个连接点 总是 代表一个方法的执行。 应用可能有数以千计的时机应用通知。这些时机被称为连接点。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</p>
<p>（3）通知（Advice）：在AOP术语中，切面的工作被称为通知。</p>
<p>（4）切入点（Pointcut）：切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。</p>
<p>（5）引入（Introduction）：引入允许我们向现有类添加新方法或属性。</p>
<p>（6）目标对象（Target Object）： 被一个或者多个切面（aspect）所通知（advise）的对象。它通常是一个代理对象。也有人把它叫做 被通知（adviced） 对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。</p>
<p>（7）织入（Weaving）：织入是把切面应用到目标对象并创建新的代理对象的过程。在目标对象的生命周期里有多少个点可以进行织入：</p>
<ul>
<li>编译期：切面在目标类编译时被织入。AspectJ的织入编译器是以这种方式织入切面的。</li>
<li>类加载期：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入就支持以这种方式织入切面。</li>
<li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面。</li>
</ul>
<h5 id="Spring在运行时通知对象"><a href="#Spring在运行时通知对象" class="headerlink" title="Spring在运行时通知对象"></a>Spring在运行时通知对象</h5><p>通过在代理类中包裹切面，Spring在运行期把切面织入到Spring管理的bean中。代理封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标bean。当代理拦截到方法调用时，在调用目标bean方法之前，会执行切面逻辑。</p>
<p>直到应用需要被代理的bean时，Spring才创建代理对象。如果使用的是ApplicationContext的话，在ApplicationContext从BeanFactory中加载所有bean的时候，Spring才会创建被代理的对象。因为Spring运行时才创建代理对象，所以我们不需要特殊的编译器来织入SpringAOP的切面。</p>
<h5 id="Spring只支持方法级别的连接点"><a href="#Spring只支持方法级别的连接点" class="headerlink" title="Spring只支持方法级别的连接点"></a>Spring只支持方法级别的连接点</h5><p>因为Spring基于动态代理，所以Spring只支持方法连接点。Spring缺少对字段连接点的支持，而且它不支持构造器连接点。方法之外的连接点拦截功能，我们可以利用Aspect来补充。</p>
<h5 id="在Spring-AOP-中，关注点和横切关注的区别是什么？在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处"><a href="#在Spring-AOP-中，关注点和横切关注的区别是什么？在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处" class="headerlink" title="在Spring AOP 中，关注点和横切关注的区别是什么？在 spring aop 中 concern 和 cross-cutting concern 的不同之处"></a>在Spring AOP 中，关注点和横切关注的区别是什么？在 spring aop 中 concern 和 cross-cutting concern 的不同之处</h5><p>关注点（concern）是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。</p>
<p>横切关注点（cross-cutting concern）是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。</p>
<h5 id="Spring通知有哪些类型？"><a href="#Spring通知有哪些类型？" class="headerlink" title="Spring通知有哪些类型？"></a>Spring通知有哪些类型？</h5><p>在AOP术语中，切面的工作被称为通知，实际上是程序执行时要通过SpringAOP框架触发的代码段。</p>
<p>Spring切面可以应用5种类型的通知：</p>
<ol>
<li><p>前置通知（Before）：在目标方法被调用之前调用通知功能；</p>
</li>
<li><p>后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</p>
</li>
<li><p>返回通知（After-returning ）：在目标方法成功执行之后调用通知；</p>
</li>
<li><p>异常通知（After-throwing）：在目标方法抛出异常后调用通知；</p>
</li>
<li><p>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</p>
<p> 同一个aspect，不同advice的执行顺序：<br> ①没有异常情况下的执行顺序：<br> around before advice<br> before advice<br> target method 执行<br> around after advice<br> after advice<br> afterReturning<br> ②有异常情况下的执行顺序：<br> around before advice<br> before advice<br> target method 执行<br> around after advice<br> after advice<br> afterThrowing:异常发生<br> java.lang.RuntimeException: 异常发生</p>
</li>
</ol>
<h5 id="什么是切面-Aspect？"><a href="#什么是切面-Aspect？" class="headerlink" title="什么是切面 Aspect？"></a>什么是切面 Aspect？</h5><p>aspect 由 pointcount 和 advice 组成，切面是通知和切点的结合。 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP 就是负责实施切面的框架, 它将切面所定义的横切逻辑编织到切面所指定的连接点中.<br>AOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:</p>
<ul>
<li>如何通过 pointcut 和 advice 定位到特定的 joinpoint 上</li>
<li>如何在 advice 中编写切面代码.</li>
</ul>
<p>可以简单地认为, 使用 @Aspect 注解的类就是切面.</p>
<p><img src="https://img-blog.csdnimg.cn/2020021212264438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt></p>
<h5 id="解释基于XML-Schema方式的切面实现"><a href="#解释基于XML-Schema方式的切面实现" class="headerlink" title="解释基于XML Schema方式的切面实现"></a>解释基于XML Schema方式的切面实现</h5><p>在这种情况下，切面由常规类以及基于XML的配置实现。</p>
<h5 id="解释基于注解的切面实现"><a href="#解释基于注解的切面实现" class="headerlink" title="解释基于注解的切面实现"></a>解释基于注解的切面实现</h5><p>在这种情况下(基于@AspectJ的实现)，涉及到的切面声明的风格与带有java5标注的普通java类一致。</p>
<h5 id="有几种不同类型的自动代理？"><a href="#有几种不同类型的自动代理？" class="headerlink" title="有几种不同类型的自动代理？"></a>有几种不同类型的自动代理？</h5><p>BeanNameAutoProxyCreator</p>
<p>DefaultAdvisorAutoProxyCreator</p>
<p>Metadata autoproxying</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>Welcome</title>
    <url>/myblog/uncategorized/Welcome/</url>
    <content><![CDATA[<img src="http://chfsun.gitee.io/cdn/bg_music.jpg">
<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>Redis的主从复制和哨兵模式</title>
    <url>/myblog/interview/dis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%92%8C%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="主从复制概念"><a href="#主从复制概念" class="headerlink" title="主从复制概念"></a>主从复制概念</h4><p>主从复制指将一台redis的数据复制另外一台redis服务器上，前者称为主节点（master）,后者称为从节点（slave）。</p>
<a id="more"></a>
<p>注意复制的过程是单向的，只能从主节点到从节点，主节点以写为主，从节点以读为主。</p>
<p>主从复制的作用</p>
<p>数据冗余：主从复制实现了数据的热备份</p>
<p>故障恢复：当主节点出现问题时，可以由从节点提供服务，快速恢复故障</p>
<p>负载均衡：主节点复制写数据，从节点负责读数据，实现读写分离分担服务器负载。</p>
<p>最常见的主从复制架构如下图所示</p>
<p><img src="https://img-blog.csdnimg.cn/20200914143255408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h6 id="手动实现主从复制"><a href="#手动实现主从复制" class="headerlink" title="手动实现主从复制"></a>手动实现主从复制</h6><p>开启三个redis服务，例如开启三个端口分别为6379、6380、6381三台redis服务，未设置谁是主节点之前，默认每台服务都是主节点的。</p>
<p><code>info replication</code>  #查看节点信息:</p>
<p><img src="https://img-blog.csdnimg.cn/20200914143400711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>这里为了演示所以配置了伪集群，即一台机器启动三个redis服务，只是不同端口。注意启动6380和6381需要增加一个redis配置文件，例如启动6380时复制一份redis.conf修改名字为redis6380.conf，然后修改配置文件中的以下几个地方:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">daemonize yes  #后台启动修改为yes</span><br><span class="line"></span><br><span class="line">pidfile /var/run/redis_6380.pid  #修改进程文件的名称</span><br><span class="line"></span><br><span class="line">logfile "6380.log" #日志文件的名称</span><br><span class="line"></span><br><span class="line">dbfilename dump6380.rdb   #rdb文件的名称</span><br><span class="line"></span><br><span class="line">port 6380  #端口号</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200914143459173.png#pic_center" alt="在这里插入图片描述"></p>
<h5 id="正式配置一主二从"><a href="#正式配置一主二从" class="headerlink" title="正式配置一主二从"></a>正式配置一主二从</h5><p>因为redis启动默认是主节点，所以主需要将6380和6379的设置为6379的从节点就行了，设置redis6380的主节点为6379，使用slaveof [主节点IP] [主节点端口]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">slaveof <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200914143602623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>使用同样的方式设置6381，最后回到主节点6379进行查看节点信息</p>
<p><img src="https://img-blog.csdnimg.cn/20200914143626326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>至此我们就把一主二从的架构的配置好了，下面测试一下，主机写入数据后，会不会将数据自动同步到从机中。</p>
<p>主机设置一个key为test1</p>
<p><img src="https://img-blog.csdnimg.cn/20200914143648514.png#pic_center" alt="在这里插入图片描述"><br>从机进行获取test1<br><img src="https://img-blog.csdnimg.cn/2020091414370940.png#pic_center" alt="在这里插入图片描述"><br>进过测试，没问题，大功告成！</p>
<p>你以为这就完了么，有的同学会问，当主机挂了会怎么样，这个问题问的好。这种手动模式的一主二从架构，当主机挂了之后需要人为的手动重新设置一个主机，才能正常工作。说到这里，是不是会觉得这也太low了吧，讲这个有啥用，其实讲这个是为了让你清楚主从复制真正的工作原理。那么为了解决这个当主机挂了，需要手动重新设置一个主节点的问题，就需要使用我们的哨兵模式。</p>
<h4 id="什么是哨兵"><a href="#什么是哨兵" class="headerlink" title="什么是哨兵"></a>什么是哨兵</h4><p>顾名思义，哨兵就是用来巡逻检查的，哨兵每隔一段时间会向redis发送命令，等待redis响应，如果得不到响应，此时这个哨兵会认为这台redis服务以挂掉。一般情况会启动多个哨兵，判断redis主机是否挂掉，哨兵会进行投票。例如启动三个哨兵，其中有两个哨兵认为当前redis主机以挂掉，一个认为没有，那么2:1，那可以认为当前redis挂掉了。当主节点挂掉后，哨兵会通过投票的方式重新选举一个主机。</p>
<p><img src="https://img-blog.csdnimg.cn/20200914143804214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>哨兵的作用</p>
<p>通过发送命令，让redis服务器返回运行状态，包括主服务器和从服务器。</p>
<p>当哨兵检测到master宕机后，会通过投票选举新的master，然后通过发布订阅模式通知其它从机切换主机。</p>
<p>配置哨兵</p>
<p>在/opt/redis-6.0.7/myconf目录下添加哨兵配置文件 sentinel.conf内容如下</p>
<p>sentinel monitor myredis 127.0.0.1 6379 1</p>
<p>意思监控master，后面的1表示当master挂了后是否发起投票。</p>
<p>开启一个终端，进入redis目录</p>
<p>启动哨兵：./src/redis-sentinel myconf/sentinel.conf</p>
<p><img src="https://img-blog.csdnimg.cn/202009141438372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>下面测试如果master宕机了，会不会重新选举一个新的master。</p>
<p>现在手动把master关掉，等待几秒钟可以看到master主机变成了6380</p>
<p><img src="https://img-blog.csdnimg.cn/20200914143856774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>如果此时原来的主机恢复正常了呢，会不会重新选举其为master，答案是否定的，原来的主机恢复正常后，只能作为新主机的从节点。</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat面试题</title>
    <url>/myblog/interview/Tomcat%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h5 id="Tomcat是什么？"><a href="#Tomcat是什么？" class="headerlink" title="Tomcat是什么？"></a>Tomcat是什么？</h5><a id="more"></a>
<p>Tomcat 服务器Apache软件基金会项目中的一个核心项目，是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。</p>
<h5 id="Tomcat的缺省端口是多少，怎么修改"><a href="#Tomcat的缺省端口是多少，怎么修改" class="headerlink" title="Tomcat的缺省端口是多少，怎么修改"></a>Tomcat的缺省端口是多少，怎么修改</h5><ol>
<li>找到Tomcat目录下的conf文件夹</li>
<li>进入conf文件夹里面找到server.xml文件</li>
<li>打开server.xml文件</li>
<li>在server.xml文件里面找到下列信息</li>
<li>把Connector标签的8080端口改成你想要的端口</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">"Catalina"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span> </span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span> </span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="tomcat-有哪几种Connector-运行模式-优化-？"><a href="#tomcat-有哪几种Connector-运行模式-优化-？" class="headerlink" title="tomcat 有哪几种Connector 运行模式(优化)？"></a>tomcat 有哪几种Connector 运行模式(优化)？</h5><!--more-->

<p>下面，我们先大致了解Tomcat Connector的三种运行模式。</p>
<ul>
<li><p><strong>BIO</strong>：同步并阻塞 一个线程处理一个请求。缺点：并发量高时，线程数较多，浪费资源。Tomcat7或以下，在Linux系统中默认使用这种方式。</p>
<p>配制项：protocol=”HTTP/1.1”</p>
</li>
<li><p>NIO：同步非阻塞IO</p>
</li>
<li><p>利用Java的异步IO处理，可以通过少量的线程处理大量的请求，可以复用同一个线程处理多个connection(多路复用)。</p>
</li>
<li><p>Tomcat8在Linux系统中默认使用这种方式。</p>
</li>
<li><p>Tomcat7必须修改Connector配置来启动。</p>
</li>
<li><p><strong>配制项</strong>：protocol=”org.apache.coyote.http11.Http11NioProtocol”</p>
</li>
<li><p><strong>备注</strong>：我们常用的Jetty，Mina，ZooKeeper等都是基于java nio实现.</p>
</li>
<li><p>APR：即Apache Portable Runtime，从操作系统层面解决io阻塞问题。<strong>AIO方式，</strong>异步非阻塞IO(Java NIO2又叫AIO) 主要与NIO的区别主要是操作系统的底层区别.可以做个比喻:比作快递，NIO就是网购后要自己到官网查下快递是否已经到了(可能是多次)，然后自己去取快递；AIO就是快递员送货上门了(不用关注快递进度)。</p>
</li>
<li><p><strong>配制项</strong>：protocol=”org.apache.coyote.http11.Http11AprProtocol”</p>
</li>
<li><p><strong>备注</strong>：需在本地服务器安装APR库。Tomcat7或Tomcat8在Win7或以上的系统中启动默认使用这种方式。Linux如果安装了apr和native，Tomcat直接启动就支持apr。</p>
</li>
</ul>
<h5 id="Tomcat有几种部署方式？"><a href="#Tomcat有几种部署方式？" class="headerlink" title="Tomcat有几种部署方式？"></a>Tomcat有几种部署方式？</h5><p><strong>在Tomcat中部署Web应用的方式主要有如下几种：</strong></p>
<ol>
<li><p>利用Tomcat的自动部署。</p>
<p>把web应用拷贝到webapps目录。Tomcat在启动时会加载目录下的应用，并将编译后的结果放入work目录下。</p>
</li>
<li><p>使用Manager App控制台部署。</p>
<p>在tomcat主页点击“Manager App” 进入应用管理控制台，可以指定一个web应用的路径或war文件。</p>
</li>
<li><p>修改conf/server.xml文件部署。</p>
<p>修改conf/server.xml文件，增加Context节点可以部署应用。</p>
</li>
<li><p>增加自定义的Web部署文件。</p>
</li>
</ol>
<p>​        在conf/Catalina/localhost/ 路径下增加 xyz.xml文件，内容是Context节点，可以部署应用。</p>
<h5 id="tomcat容器是如何创建servlet类实例？用到了什么原理？"><a href="#tomcat容器是如何创建servlet类实例？用到了什么原理？" class="headerlink" title="tomcat容器是如何创建servlet类实例？用到了什么原理？"></a>tomcat容器是如何创建servlet类实例？用到了什么原理？</h5><ol>
<li>当容器启动时，会读取在webapps目录下所有的web应用中的web.xml文件，然后对 xml文件进行解析，并读取servlet注册信息。然后，将每个应用中注册的servlet类都进行加载，并通过 反射的方式实例化。（有时候也是在第一次请求时实例化）</li>
<li>在servlet注册时加上1如果为正数，则在一开始就实例化，如果不写或为负数，则第一次请求实例化。</li>
</ol>
<h5 id="Tomcat工作模式"><a href="#Tomcat工作模式" class="headerlink" title="Tomcat工作模式"></a>Tomcat工作模式</h5><p>Tomcat作为servlet容器，有三种工作模式：</p>
<ul>
<li>1、独立的servlet容器，servlet容器是web服务器的一部分；</li>
<li>2、进程内的servlet容器，servlet容器是作为web服务器的插件和java容器的实现，web服务器插件在内部地址空间打开一个jvm使得java容器在内部得以运行。反应速度快但伸缩性不足；</li>
<li>3、进程外的servlet容器，servlet容器运行于web服务器之外的地址空间，并作为web服务器的插件和java容器实现的结合。反应时间不如进程内但伸缩性和稳定性比进程内优；</li>
</ul>
<p>进入Tomcat的请求可以根据Tomcat的工作模式分为如下两类：</p>
<ul>
<li>Tomcat作为应用程序服务器：请求来自于前端的web服务器，这可能是Apache, IIS, Nginx等；</li>
<li>Tomcat作为独立服务器：请求来自于web浏览器；</li>
</ul>
<p>面试时问到Tomcat相关问题的几率并不高，正式因为如此，很多人忽略了对Tomcat相关技能的掌握，下面这一篇文章整理了Tomcat相关的系统架构，介绍了Server、Service、Connector、Container之间的关系，各个模块的功能，可以说把这几个掌握住了，Tomcat相关的面试题你就不会有任何问题了！另外，在面试的时候你还要有意识无意识的往Tomcat这个地方引，就比如说常见的Spring MVC的执行流程，一个URL的完整调用链路，这些相关的题目你是可以往Tomcat处理请求的这个过程去说的！掌握了Tomcat这些技能，面试官一定会佩服你的！</p>
<p>学了本章之后你应该明白的是：</p>
<ul>
<li>Server、Service、Connector、Container四大组件之间的关系和联系，以及他们的主要功能点；</li>
<li>Tomcat执行的整体架构，请求是如何被一步步处理的；</li>
<li>Engine、Host、Context、Wrapper相关的概念关系；</li>
<li>Container是如何处理请求的；</li>
<li>Tomcat用到的相关设计模式；</li>
</ul>
<h5 id="Tomcat顶层架构"><a href="#Tomcat顶层架构" class="headerlink" title="Tomcat顶层架构"></a>Tomcat顶层架构</h5><p>俗话说，站在巨人的肩膀上看世界，一般学习的时候也是先总览一下整体，然后逐个部分个个击破，最后形成思路，了解具体细节，Tomcat的结构很复杂，但是 Tomcat 非常的模块化，找到了 Tomcat 最核心的模块，问题才可以游刃而解，了解了 Tomcat 的整体架构对以后深入了解 Tomcat 来说至关重要！</p>
<p>先上一张Tomcat的顶层结构图（图A），如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20191021215330153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt></p>
<p>Tomcat中最顶层的容器是Server，代表着整个服务器，从上图中可以看出，一个Server可以包含至少一个Service，即可以包含多个Service，用于具体提供服务。</p>
<p>Service主要包含两个部分：Connector和Container。从上图中可以看出 Tomcat 的心脏就是这两个组件，他们的作用如下：</p>
<ul>
<li>Connector用于处理连接相关的事情，并提供Socket与Request请求和Response响应相关的转化;</li>
<li>Container用于封装和管理Servlet，以及具体处理Request请求；</li>
</ul>
<p>一个Tomcat中只有一个Server，一个Server可以包含多个Service，一个Service只有一个Container，但是可以有多个Connectors，这是因为一个服务可以有多个连接，如同时提供Http和Https链接，也可以提供向相同协议不同端口的连接，示意图如下（Engine、Host、Context下面会说到）：</p>
<p><img src="https://img-blog.csdnimg.cn/20191021215344811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt></p>
<p>多个 Connector 和一个 Container 就形成了一个 Service，有了 Service 就可以对外提供服务了，但是 Service 还要一个生存的环境，必须要有人能够给她生命、掌握其生死大权，那就非 Server 莫属了！所以整个 Tomcat 的生命周期由 Server 控制。</p>
<p>另外，上述的包含关系或者说是父子关系，都可以在tomcat的conf目录下的server.xml配置文件中看出，下图是删除了注释内容之后的一个完整的server.xml配置文件（Tomcat版本为8.0）</p>
<p><img src="https://img-blog.csdnimg.cn/20191021215355649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt></p>
<p>详细的配置文件内容可以到Tomcat官网查看：Tomcat配置文件</p>
<p>上边的配置文件，还可以通过下边的一张结构图更清楚的理解：</p>
<p><img src="https://img-blog.csdnimg.cn/2019102121541531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt></p>
<p>Server标签设置的端口号为8005，shutdown=”SHUTDOWN” ，表示在8005端口监听“SHUTDOWN”命令，如果接收到了就会关闭Tomcat。一个Server有一个Service，当然还可以进行配置，一个Service有多个Connector，Service左边的内容都属于Container的，Service下边是Connector。</p>
<h5 id="Tomcat顶层架构小结"><a href="#Tomcat顶层架构小结" class="headerlink" title="Tomcat顶层架构小结"></a>Tomcat顶层架构小结</h5><ol>
<li>Tomcat中只有一个Server，一个Server可以有多个Service，一个Service可以有多个Connector和一个Container；</li>
<li>Server掌管着整个Tomcat的生死大权；</li>
<li>Service 是对外提供服务的；</li>
<li>Connector用于接受请求并将请求封装成Request和Response来具体处理；</li>
<li>Container用于封装和管理Servlet，以及具体处理request请求；</li>
</ol>
<p>知道了整个Tomcat顶层的分层架构和各个组件之间的关系以及作用，对于绝大多数的开发人员来说Server和Service对我们来说确实很远，而我们开发中绝大部分进行配置的内容是属于Connector和Container的，所以接下来介绍一下Connector和Container。</p>
<h5 id="Connector和Container的微妙关系"><a href="#Connector和Container的微妙关系" class="headerlink" title="Connector和Container的微妙关系"></a>Connector和Container的微妙关系</h5><p>由上述内容我们大致可以知道一个请求发送到Tomcat之后，首先经过Service然后会交给我们的Connector，Connector用于接收请求并将接收的请求封装为Request和Response来具体处理，Request和Response封装完之后再交由Container进行处理，Container处理完请求之后再返回给Connector，最后在由Connector通过Socket将处理的结果返回给客户端，这样整个请求的就处理完了！</p>
<p>Connector最底层使用的是Socket来进行连接的，Request和Response是按照HTTP协议来封装的，所以Connector同时需要实现TCP/IP协议和HTTP协议！</p>
<p>Tomcat既然需要处理请求，那么肯定需要先接收到这个请求，接收请求这个东西我们首先就需要看一下Connector！</p>
<p>Connector架构分析</p>
<p>Connector用于接受请求并将请求封装成Request和Response，然后交给Container进行处理，Container处理完之后在交给Connector返回给客户端。</p>
<p>因此，我们可以把Connector分为四个方面进行理解：</p>
<ol>
<li>Connector如何接受请求的？</li>
<li>如何将请求封装成Request和Response的？</li>
<li>封装完之后的Request和Response如何交给Container进行处理的？</li>
<li>Container处理完之后如何交给Connector并返回给客户端的？</li>
</ol>
<p>首先看一下Connector的结构图（图B），如下所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20191021215430677.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt></p>
<p>Connector就是使用ProtocolHandler来处理请求的，不同的ProtocolHandler代表不同的连接类型，比如：Http11Protocol使用的是普通Socket来连接的，Http11NioProtocol使用的是NioSocket来连接的。</p>
<p>其中ProtocolHandler由包含了三个部件：Endpoint、Processor、Adapter。</p>
<ol>
<li>Endpoint用来处理底层Socket的网络连接，Processor用于将Endpoint接收到的Socket封装成Request，Adapter用于将Request交给Container进行具体的处理。</li>
<li>Endpoint由于是处理底层的Socket网络连接，因此Endpoint是用来实现TCP/IP协议的，而Processor用来实现HTTP协议的，Adapter将请求适配到Servlet容器进行具体的处理。</li>
<li>Endpoint的抽象实现AbstractEndpoint里面定义的Acceptor和AsyncTimeout两个内部类和一个Handler接口。Acceptor用于监听请求，AsyncTimeout用于检查异步Request的超时，Handler用于处理接收到的Socket，在内部调用Processor进行处理。</li>
</ol>
<p>至此，我们应该很轻松的回答1，2，3的问题了，但是4还是不知道，那么我们就来看一下Container是如何进行处理的以及处理完之后是如何将处理完的结果返回给Connector的？</p>
<h5 id="Container架构分析"><a href="#Container架构分析" class="headerlink" title="Container架构分析"></a>Container架构分析</h5><p>Container用于封装和管理Servlet，以及具体处理Request请求，在Container内部包含了4个子容器，结构图如下（图C）：</p>
<p><img src="https://img-blog.csdnimg.cn/20191021215443306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt></p>
<p>4个子容器的作用分别是：</p>
<ol>
<li>Engine：引擎，用来管理多个站点，一个Service最多只能有一个Engine；</li>
<li>Host：代表一个站点，也可以叫虚拟主机，通过配置Host就可以添加站点；</li>
<li>Context：代表一个应用程序，对应着平时开发的一套程序，或者一个WEB-INF目录以及下面的web.xml文件；</li>
<li>Wrapper：每一Wrapper封装着一个Servlet；</li>
</ol>
<p>下面找一个Tomcat的文件目录对照一下，如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20191021215455991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt></p>
<p>Context和Host的区别是Context表示一个应用，我们的Tomcat中默认的配置下webapps下的每一个文件夹目录都是一个Context，其中ROOT目录中存放着主应用，其他目录存放着子应用，而整个webapps就是一个Host站点。</p>
<p>我们访问应用Context的时候，如果是ROOT下的则直接使用域名就可以访问，例如：<a href="http://www.baidu.com，如果是Host（webapps）下的其他应用，则可以使用www.baidu.com/docs进行访问，当然默认指定的根应用（ROOT）是可以进行设定的，只不过Host站点下默认的主应用是ROOT目录下的。" target="_blank" rel="noopener">www.baidu.com，如果是Host（webapps）下的其他应用，则可以使用www.baidu.com/docs进行访问，当然默认指定的根应用（ROOT）是可以进行设定的，只不过Host站点下默认的主应用是ROOT目录下的。</a></p>
<p>看到这里我们知道Container是什么，但是还是不知道Container是如何进行请求处理的以及处理完之后是如何将处理完的结果返回给Connector的？别急！下边就开始探讨一下Container是如何进行处理的！</p>
<h5 id="Container如何处理请求的"><a href="#Container如何处理请求的" class="headerlink" title="Container如何处理请求的"></a>Container如何处理请求的</h5><p>Container处理请求是使用Pipeline-Valve管道来处理的！（Valve是阀门之意）</p>
<p>Pipeline-Valve是责任链模式，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将处理后的结果返回，再让下一个处理者继续处理。</p>
<p><img src="https://img-blog.csdnimg.cn/20191021215507725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt></p>
<p>但是！Pipeline-Valve使用的责任链模式和普通的责任链模式有些不同！区别主要有以下两点：</p>
<ul>
<li>每个Pipeline都有特定的Valve，而且是在管道的最后一个执行，这个Valve叫做BaseValve，BaseValve是不可删除的；</li>
<li>在上层容器的管道的BaseValve中会调用下层容器的管道。</li>
</ul>
<p>我们知道Container包含四个子容器，而这四个子容器对应的BaseValve分别在：StandardEngineValve、StandardHostValve、StandardContextValve、StandardWrapperValve。</p>
<p>Pipeline的处理流程图如下（图D）：</p>
<p><img src="https://img-blog.csdnimg.cn/20191021215519408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt></p>
<ul>
<li>Connector在接收到请求后会首先调用最顶层容器的Pipeline来处理，这里的最顶层容器的Pipeline就是EnginePipeline（Engine的管道）；</li>
<li>在Engine的管道中依次会执行EngineValve1、EngineValve2等等，最后会执行StandardEngineValve，在StandardEngineValve中会调用Host管道，然后再依次执行Host的HostValve1、HostValve2等，最后在执行StandardHostValve，然后再依次调用Context的管道和Wrapper的管道，最后执行到StandardWrapperValve。</li>
<li>当执行到StandardWrapperValve的时候，会在StandardWrapperValve中创建FilterChain，并调用其doFilter方法来处理请求，这个FilterChain包含着我们配置的与请求相匹配的Filter和Servlet，其doFilter方法会依次调用所有的Filter的doFilter方法和Servlet的service方法，这样请求就得到了处理！</li>
<li>当所有的Pipeline-Valve都执行完之后，并且处理完了具体的请求，这个时候就可以将返回的结果交给Connector了，Connector在通过Socket的方式将结果返回给客户端。</li>
</ul>
<p><strong>总结</strong></p>
<p>至此，我们已经对Tomcat的整体架构有了大致的了解，从图A、B、C、D可以看出来每一个组件的基本要素和作用。我们在脑海里应该有一个大概的轮廓了！如果你面试的时候，让你简单的聊一下Tomcat，上面的内容你能脱口而出吗？当你能够脱口而出的时候，面试官一定会对你刮目相看的！</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>java端生成token</title>
    <url>/myblog/token/ava%E7%AB%AF%E7%94%9F%E6%88%90token/</url>
    <content><![CDATA[<h2 id="java后端生成token"><a href="#java后端生成token" class="headerlink" title="java后端生成token"></a>java后端生成token</h2><a id="more"></a>
<h4 id="一、创建一个Token-类"><a href="#一、创建一个Token-类" class="headerlink" title="一、创建一个Token 类"></a>一、创建一个Token 类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lxl.utils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * token编码工具类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ouyangjun</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Token</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 编码密码,可自定义</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ENCODED_PASSWORD = <span class="string">"ouyangjun"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 编码</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encoded</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> strToHex(encodedString(str, ENCODED_PASSWORD));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 转换</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">encodedString</span><span class="params">(String str, String password)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">char</span>[] pwd = password.toCharArray();</span><br><span class="line">		<span class="keyword">int</span> pwdLen = pwd.length;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">char</span>[] strArray = str.toCharArray();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strArray.length; i++) &#123;</span><br><span class="line">			strArray[i] = (<span class="keyword">char</span>) (strArray[i] ^ pwd[i % pwdLen] ^ pwdLen);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> String(strArray);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">strToHex</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> bytesToHexStr(s.getBytes());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">bytesToHexStr</span><span class="params">(<span class="keyword">byte</span>[] bytesArray)</span> </span>&#123;</span><br><span class="line">		StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		String hexStr;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">byte</span> bt : bytesArray) &#123;</span><br><span class="line">			hexStr = Integer.toHexString(bt &amp; <span class="number">0xFF</span>);</span><br><span class="line">			<span class="keyword">if</span> (hexStr.length() == <span class="number">1</span>) &#123;</span><br><span class="line">				builder.append(<span class="string">"0"</span>);</span><br><span class="line">				builder.append(hexStr);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				builder.append(hexStr);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> builder.toString();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 解码</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decoded</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">		String hexStr = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			hexStr = hexStrToStr(str);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (hexStr != <span class="keyword">null</span>) &#123;</span><br><span class="line">			hexStr = encodedString(hexStr, ENCODED_PASSWORD);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> hexStr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">hexStrToStr</span><span class="params">(String hexStr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> String(hexStrToBytes(hexStr));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] hexStrToBytes(String hexStr) &#123;</span><br><span class="line">		String hex;</span><br><span class="line">		<span class="keyword">int</span> val;</span><br><span class="line">		<span class="keyword">byte</span>[] btHexStr = <span class="keyword">new</span> <span class="keyword">byte</span>[hexStr.length() / <span class="number">2</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; btHexStr.length; i++) &#123;</span><br><span class="line">			hex = hexStr.substring(<span class="number">2</span> * i, <span class="number">2</span> * i + <span class="number">2</span>);</span><br><span class="line">			val = Integer.valueOf(hex, <span class="number">16</span>);</span><br><span class="line">			btHexStr[i] = (<span class="keyword">byte</span>) val;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> btHexStr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二、再创建一个TokenUtils类"><a href="#二、再创建一个TokenUtils类" class="headerlink" title="二、再创建一个TokenUtils类"></a>二、再创建一个TokenUtils类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lxl.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.lxl.utils.Token;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * token生成和校验</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ouyangjun</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, String&gt; MAP_TOKENS = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VALID_TIME = <span class="number">60</span> * <span class="number">60</span> * <span class="number">2</span>; <span class="comment">// token有效期(秒)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOKEN_ERROR = <span class="string">"F"</span>; <span class="comment">// 非法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOKEN_OVERDUE = <span class="string">"G"</span>; <span class="comment">// 过期</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOKEN_FAILURE = <span class="string">"S"</span>; <span class="comment">// 失效</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 生成token,该token长度不一致,如需一致,可自行MD5或者其它方式加密一下 </span></span><br><span class="line"><span class="comment">                 * 该方式的token只存在磁盘上,如果项目是分布式,最好用redis存储</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> str: 该字符串可自定义,在校验token时要保持一致</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getToken</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">		String token = Token.encoded(getCurrentTime() + <span class="string">","</span> + str);</span><br><span class="line">		MAP_TOKENS.put(str, token);</span><br><span class="line">		<span class="keyword">return</span> token;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 校验token的有效性</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">checkToken</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (token == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> TOKEN_ERROR;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			String[] tArr = Token.decoded(token).split(<span class="string">","</span>);</span><br><span class="line">			<span class="keyword">if</span> (tArr.length != <span class="number">2</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> TOKEN_ERROR;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// token生成时间戳</span></span><br><span class="line">			<span class="keyword">int</span> tokenTime = Integer.parseInt(tArr[<span class="number">0</span>]);</span><br><span class="line">			<span class="comment">// 当前时间戳</span></span><br><span class="line">			<span class="keyword">int</span> currentTime = getCurrentTime();</span><br><span class="line">			<span class="keyword">if</span> (currentTime - tokenTime &lt; VALID_TIME) &#123;</span><br><span class="line">				String tokenStr = tArr[<span class="number">1</span>];</span><br><span class="line">				String mToken = MAP_TOKENS.get(tokenStr);</span><br><span class="line">				<span class="keyword">if</span> (mToken == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">return</span> TOKEN_OVERDUE;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mToken.equals(token)) &#123;</span><br><span class="line">					<span class="keyword">return</span> TOKEN_FAILURE;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> tokenStr;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> TOKEN_OVERDUE;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> TOKEN_ERROR;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 获取当前时间戳（10位整数） */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCurrentTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">int</span>) (System.currentTimeMillis() / <span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 移除过期的token</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeInvalidToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> currentTime = getCurrentTime();</span><br><span class="line">		<span class="keyword">for</span> (Entry&lt;String, String&gt; entry : MAP_TOKENS.entrySet()) &#123;</span><br><span class="line">			String[] tArr = Token.decoded(entry.getValue()).split(<span class="string">","</span>);</span><br><span class="line">			<span class="keyword">int</span> tokenTime = Integer.parseInt(tArr[<span class="number">0</span>]);</span><br><span class="line">			<span class="keyword">if</span> (currentTime - tokenTime &gt; VALID_TIME) &#123;</span><br><span class="line">				MAP_TOKENS.remove(entry.getKey());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>三、测试类测试调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 测试</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String str = <span class="string">"username_and_password"</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 获取token</span></span><br><span class="line">		String token = TokenUtils.getToken(str);</span><br><span class="line">		System.out.println(<span class="string">"token Result: "</span> + token);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 校验token</span></span><br><span class="line">		String checkToken = TokenUtils.checkToken(token);</span><br><span class="line">		System.out.println(<span class="string">"checkToken Result: "</span> + checkToken);</span><br><span class="line">		<span class="keyword">if</span>(str.equals(checkToken)) &#123;</span><br><span class="line">			System.out.println(<span class="string">"==&gt;token verification succeeded!"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>token</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>token</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring MVC面试</title>
    <url>/myblog/interview/Spring%20MVC%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><a id="more"></a>
<h5 id="什么是Spring-MVC？简单介绍下你对Spring-MVC的理解？"><a href="#什么是Spring-MVC？简单介绍下你对Spring-MVC的理解？" class="headerlink" title="什么是Spring MVC？简单介绍下你对Spring MVC的理解？"></a>什么是Spring MVC？简单介绍下你对Spring MVC的理解？</h5><p>Spring MVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把模型-视图-控制器分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。</p>
<h5 id="Spring-MVC的优点"><a href="#Spring-MVC的优点" class="headerlink" title="Spring MVC的优点"></a>Spring MVC的优点</h5><p>（1）可以支持各种视图技术,而不仅仅局限于JSP；</p>
<p>（2）与Spring框架集成（如IoC容器、AOP等）；</p>
<p>（3）清晰的角色分配：前端控制器(dispatcherServlet) , 请求到处理器映射（handlerMapping), 处理器适配器（HandlerAdapter), 视图解析器（ViewResolver）。</p>
<p>（4） 支持各种请求资源的映射策略。</p>
<!--more-->

<h4 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h4><h5 id="Spring-MVC的主要组件？"><a href="#Spring-MVC的主要组件？" class="headerlink" title="Spring MVC的主要组件？"></a>Spring MVC的主要组件？</h5><p>（1）前端控制器 DispatcherServlet（不需要程序员开发）</p>
<p>作用：接收请求、响应结果，相当于转发器，有了DispatcherServlet 就减少了其它组件之间的耦合度。</p>
<p>（2）处理器映射器HandlerMapping（不需要程序员开发）</p>
<p>作用：根据请求的URL来查找Handler</p>
<p>（3）处理器适配器HandlerAdapter</p>
<p>注意：在编写Handler的时候要按照HandlerAdapter要求的规则去编写，这样适配器HandlerAdapter才可以正确的去执行Handler。</p>
<p>（4）处理器Handler（需要程序员开发）</p>
<p>（5）视图解析器 ViewResolver（不需要程序员开发）</p>
<p>作用：进行视图的解析，根据视图逻辑名解析成真正的视图（view）</p>
<p>（6）视图View（需要程序员开发jsp）</p>
<p>View是一个接口， 它的实现类支持不同的视图类型（jsp，freemarker，pdf等等）</p>
<h5 id="什么是DispatcherServlet"><a href="#什么是DispatcherServlet" class="headerlink" title="什么是DispatcherServlet"></a>什么是DispatcherServlet</h5><p>Spring的MVC框架是围绕DispatcherServlet来设计的，它用来处理所有的HTTP请求和响应。</p>
<h5 id="什么是Spring-MVC框架的控制器？"><a href="#什么是Spring-MVC框架的控制器？" class="headerlink" title="什么是Spring MVC框架的控制器？"></a>什么是Spring MVC框架的控制器？</h5><p>控制器提供一个访问应用程序的行为，此行为通常通过服务接口实现。控制器解析用户输入并将其转换为一个由视图呈现给用户的模型。Spring用一个非常抽象的方式实现了一个控制层，允许用户创建多种用途的控制器。<br>Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？</p>
<p>答：是单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的,解决方案是在控制器里面不能写字段。</p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><h5 id="请描述Spring-MVC的工作流程？描述一下-DispatcherServlet-的工作流程？"><a href="#请描述Spring-MVC的工作流程？描述一下-DispatcherServlet-的工作流程？" class="headerlink" title="请描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？"></a>请描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？</h5><p>（1）用户发送请求至前端控制器DispatcherServlet；<br>（2） DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handle；<br>（3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet；<br>（4）DispatcherServlet 调用 HandlerAdapter处理器适配器；<br>（5）HandlerAdapter 经过适配调用 具体处理器(Handler，也叫后端控制器)；<br>（6）Handler执行完成返回ModelAndView；<br>（7）HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet；<br>（8）DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析；<br>（9）ViewResolver解析后返回具体View；<br>（10）DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）<br>（11）DispatcherServlet响应用户。</p>
<p><img src="https://img-blog.csdnimg.cn/20200208211439106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt></p>
<h4 id="MVC框架"><a href="#MVC框架" class="headerlink" title="MVC框架"></a>MVC框架</h4><h5 id="MVC是什么？MVC设计模式的好处有哪些"><a href="#MVC是什么？MVC设计模式的好处有哪些" class="headerlink" title="MVC是什么？MVC设计模式的好处有哪些"></a>MVC是什么？MVC设计模式的好处有哪些</h5><p>mvc是一种设计模式（设计模式就是日常开发中编写代码的一种好的方法和经验的总结）。模型（model）-视图（view）-控制器（controller），三层架构的设计模式。用于实现前端页面的展现与后端业务数据处理的分离。</p>
<p>mvc设计模式的好处</p>
<p>1.分层设计，实现了业务系统各个组件之间的解耦，有利于业务系统的可扩展性，可维护性。</p>
<p>2.有利于系统的并行开发，提升开发效率。</p>
<h4 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h4><h5 id="注解原理是什么"><a href="#注解原理是什么" class="headerlink" title="注解原理是什么"></a>注解原理是什么</h5><p>注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。</p>
<h5 id="Spring-MVC常用的注解有哪些？"><a href="#Spring-MVC常用的注解有哪些？" class="headerlink" title="Spring MVC常用的注解有哪些？"></a>Spring MVC常用的注解有哪些？</h5><p>@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。</p>
<p>@RequestBody：注解实现接收http请求的json数据，将json转换为java对象。</p>
<p>@ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。</p>
<h5 id="SpingMvc中的控制器的注解一般用哪个-有没有别的注解可以替代？"><a href="#SpingMvc中的控制器的注解一般用哪个-有没有别的注解可以替代？" class="headerlink" title="SpingMvc中的控制器的注解一般用哪个,有没有别的注解可以替代？"></a>SpingMvc中的控制器的注解一般用哪个,有没有别的注解可以替代？</h5><p>答：一般用@Controller注解,也可以使用@RestController,@RestController注解相当于@ResponseBody ＋ @Controller,表示是表现层,除此之外，一般不用别的注解代替。</p>
<h5 id="Controller注解的作用"><a href="#Controller注解的作用" class="headerlink" title="@Controller注解的作用"></a>@Controller注解的作用</h5><p>在Spring MVC 中，控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。在Spring MVC 中提供了一个非常简便的定义Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用@Controller 标记一个类是Controller ，然后使用@RequestMapping 和@RequestParam 等一些注解用以定义URL 请求和Controller 方法之间的映射，这样的Controller 就能被外界访问到。此外Controller 不会直接依赖于HttpServletRequest 和HttpServletResponse 等HttpServlet 对象，它们可以通过Controller 的方法参数灵活的获取到。</p>
<p>@Controller 用于标记在一个类上，使用它标记的类就是一个Spring MVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping 注解。@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。单单使用@Controller 标记在一个类上还不能真正意义上的说它就是Spring MVC 的一个控制器类，因为这个时候Spring 还不认识它。那么要如何做Spring 才能认识它呢？这个时候就需要我们把这个控制器类交给Spring 来管理。有两种方式：</p>
<ul>
<li>在Spring MVC 的配置文件中定义MyController 的bean 对象。</li>
<li>在Spring MVC 的配置文件中告诉Spring 该到哪里去找标记为@Controller 的Controller 控制器。</li>
</ul>
<h5 id="RequestMapping注解的作用"><a href="#RequestMapping注解的作用" class="headerlink" title="@RequestMapping注解的作用"></a>@RequestMapping注解的作用</h5><p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p>
<p>RequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。</p>
<p><strong>value， method</strong></p>
<p>value： 指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；</p>
<p>method： 指定请求的method类型， GET、POST、PUT、DELETE等；</p>
<p><strong>consumes，produces</strong></p>
<p>consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;</p>
<p>produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；</p>
<p><strong>params，headers</strong></p>
<p>params： 指定request中必须包含某些参数值是，才让该方法处理。</p>
<p>headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。</p>
<h5 id="ResponseBody注解的作用"><a href="#ResponseBody注解的作用" class="headerlink" title="@ResponseBody注解的作用"></a>@ResponseBody注解的作用</h5><p>作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。</p>
<p>使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；</p>
<h5 id="PathVariable和-RequestParam的区别"><a href="#PathVariable和-RequestParam的区别" class="headerlink" title="@PathVariable和@RequestParam的区别"></a>@PathVariable和@RequestParam的区别</h5><p>请求路径上有个id的变量值，可以通过@PathVariable来获取 @RequestMapping(value = “/page/{id}”, method = RequestMethod.GET)</p>
<p>@RequestParam用来获得静态的URL请求入参 spring注解时action里用到。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h5 id="Spring-MVC与Struts2区别"><a href="#Spring-MVC与Struts2区别" class="headerlink" title="Spring MVC与Struts2区别"></a>Spring MVC与Struts2区别</h5><p>相同点</p>
<p>都是基于mvc的表现层框架，都用于web项目的开发。</p>
<p>不同点</p>
<p>1.前端控制器不一样。Spring MVC的前端控制器是servlet：DispatcherServlet。struts2的前端控制器是filter：StrutsPreparedAndExcutorFilter。</p>
<p>2.请求参数的接收方式不一样。Spring MVC是使用方法的形参接收请求的参数，基于方法的开发，线程安全，可以设计为单例或者多例的开发，推荐使用单例模式的开发（执行效率更高），默认就是单例开发模式。struts2是通过类的成员变量接收请求的参数，是基于类的开发，线程不安全，只能设计为多例的开发。</p>
<p>3.Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，Spring MVC通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl。</p>
<p>4.与spring整合不一样。Spring MVC是spring框架的一部分，不需要整合。在企业项目中，Spring MVC使用更多一些。</p>
<h5 id="Spring-MVC怎么样设定重定向和转发的？"><a href="#Spring-MVC怎么样设定重定向和转发的？" class="headerlink" title="Spring MVC怎么样设定重定向和转发的？"></a>Spring MVC怎么样设定重定向和转发的？</h5><p>（1）转发：在返回值前面加”forward:”，譬如”forward:user.do?name=method4”</p>
<p>（2）重定向：在返回值前面加”redirect:”，譬如”redirect:<a href="http://www.baidu.com&quot;" target="_blank" rel="noopener">http://www.baidu.com&quot;</a></p>
<h5 id="Spring-MVC怎么和AJAX相互调用的？"><a href="#Spring-MVC怎么和AJAX相互调用的？" class="headerlink" title="Spring MVC怎么和AJAX相互调用的？"></a>Spring MVC怎么和AJAX相互调用的？</h5><p>通过Jackson框架就可以把Java里面的对象直接转化成Js可以识别的Json对象。具体步骤如下 ：</p>
<p>（1）加入Jackson.jar</p>
<p>（2）在配置文件中配置json的映射</p>
<p>（3）在接受Ajax方法里面可以直接返回Object,List等,但方法前面要加上@ResponseBody注解。</p>
<h5 id="如何解决POST请求中文乱码问题，GET的又如何处理呢？"><a href="#如何解决POST请求中文乱码问题，GET的又如何处理呢？" class="headerlink" title="如何解决POST请求中文乱码问题，GET的又如何处理呢？"></a>如何解决POST请求中文乱码问题，GET的又如何处理呢？</h5><p>（1）解决post请求乱码问题：</p>
<p>在web.xml中配置一个CharacterEncodingFilter过滤器，设置成utf-8；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）get请求中文参数出现乱码解决方法有两个：</p>
<p>①修改tomcat配置文件添加编码与工程编码一致，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ConnectorURIEncoding="utf-8"</span> <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>②另外一种方法对参数进行重新编码：</p>
<p>String userName = new String(request.getParamter(“userName”).getBytes(“ISO8859-1”),“utf-8”)</p>
<p>ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码。</p>
<h5 id="Spring-MVC的异常处理？"><a href="#Spring-MVC的异常处理？" class="headerlink" title="Spring MVC的异常处理？"></a>Spring MVC的异常处理？</h5><p>答：可以将异常抛给Spring框架，由Spring框架来处理；我们只需要配置简单的异常处理器，在异常处理器中添视图页面即可。</p>
<h5 id="如果在拦截请求中，我想拦截get方式提交的方法-怎么配置"><a href="#如果在拦截请求中，我想拦截get方式提交的方法-怎么配置" class="headerlink" title="如果在拦截请求中，我想拦截get方式提交的方法,怎么配置"></a>如果在拦截请求中，我想拦截get方式提交的方法,怎么配置</h5><p>答：可以在@RequestMapping注解里面加上method=RequestMethod.GET。</p>
<h5 id="怎样在方法里面得到Request-或者Session？"><a href="#怎样在方法里面得到Request-或者Session？" class="headerlink" title="怎样在方法里面得到Request,或者Session？"></a>怎样在方法里面得到Request,或者Session？</h5><p>答：直接在方法的形参中声明request,Spring MVC就自动把request对象传入。</p>
<h5 id="如果想在拦截的方法里面得到从前台传入的参数-怎么得到？"><a href="#如果想在拦截的方法里面得到从前台传入的参数-怎么得到？" class="headerlink" title="如果想在拦截的方法里面得到从前台传入的参数,怎么得到？"></a>如果想在拦截的方法里面得到从前台传入的参数,怎么得到？</h5><p>答：直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样。</p>
<h5 id="如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？"><a href="#如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？" class="headerlink" title="如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？"></a>如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？</h5><p>答：直接在方法中声明这个对象,Spring MVC就自动会把属性赋值到这个对象里面。</p>
<h5 id="Spring-MVC中函数的返回值是什么？"><a href="#Spring-MVC中函数的返回值是什么？" class="headerlink" title="Spring MVC中函数的返回值是什么？"></a>Spring MVC中函数的返回值是什么？</h5><p>答：返回值可以有很多类型,有String, ModelAndView。ModelAndView类把视图和数据都合并的一起的，但一般用String比较好。</p>
<h5 id="Spring-MVC用什么对象从后台向前台传递数据的？"><a href="#Spring-MVC用什么对象从后台向前台传递数据的？" class="headerlink" title="Spring MVC用什么对象从后台向前台传递数据的？"></a>Spring MVC用什么对象从后台向前台传递数据的？</h5><p>答：通过ModelMap对象,可以在这个对象里面调用put方法,把对象加到里面,前台就可以通过el表达式拿到。</p>
<h5 id="怎么样把ModelMap里面的数据放入Session里面？"><a href="#怎么样把ModelMap里面的数据放入Session里面？" class="headerlink" title="怎么样把ModelMap里面的数据放入Session里面？"></a>怎么样把ModelMap里面的数据放入Session里面？</h5><p>答：可以在类上面加上@SessionAttributes注解,里面包含的字符串就是要放入session里面的key。</p>
<h5 id="Spring-MVC里面拦截器是怎么写的"><a href="#Spring-MVC里面拦截器是怎么写的" class="headerlink" title="Spring MVC里面拦截器是怎么写的"></a>Spring MVC里面拦截器是怎么写的</h5><p>有两种写法,一种是实现HandlerInterceptor接口，另外一种是继承适配器类，接着在接口方法当中，实现处理逻辑；然后在Spring MVC的配置文件中配置拦截器即可：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置Spring MVC的拦截器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置一个拦截器的Bean就可以了 默认是对所有请求都拦截 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myInterceptor"</span> <span class="attr">class</span>=<span class="string">"com.zwp.action.MyHandlerInterceptor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 只针对部分请求拦截 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/modelMap.do"</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.zwp.action.MyHandlerInterceptorAdapter"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="介绍一下-WebApplicationContext"><a href="#介绍一下-WebApplicationContext" class="headerlink" title="介绍一下 WebApplicationContext"></a>介绍一下 WebApplicationContext</h5><p>WebApplicationContext 继承了ApplicationContext 并增加了一些WEB应用必备的特有功能，它不同于一般的ApplicationContext ，因为它能处理主题，并找到被关联的servlet。</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 中 Redis的使用 及Spring Session共享实现</title>
    <url>/myblog/spring-boot/Spring-Boot-%E4%B8%AD-Redis%E7%9A%84%E4%BD%BF%E7%94%A8-%E5%8F%8ASpring-Session%E5%85%B1%E4%BA%AB%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="一、关于Redis"><a href="#一、关于Redis" class="headerlink" title="一、关于Redis"></a>一、关于Redis</h2> <a id="more"></a>                                     
<p><img src="https://img-blog.csdnimg.cn/20181119212947332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyODk0ODk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>最近阅读了《Redis开发与运维》，非常不错。这里对书中的知识整理一下，方便自己回顾Redis的整个体系，来对相关知识点查漏补缺。</strong></p>
<p><strong>按照五点把书中的内容进行一下整理：</strong></p>
<p>1、为什么要选择Redis：介绍Redis的使用场景与使用Redis的原因；</p>
<p>2、Redis常用命令总结：包括时间复杂度总结与具体数据类型在Redis内部使用的数据结构；</p>
<p>3、Redis的高级功能：包括持久化、复制、哨兵、集群介绍；</p>
<p>4、理解Redis：理解内存、阻塞，这部分是非常重要的，前面介绍的都可以成为术，这里应该属于道的部分；</p>
<p>5、开发技巧：主要是一些开发实战的总结，包括缓存设计与常见坑点。</p>
<p>先来开启第一部分的内容，对Redis来一次重新打量。</p>
<p><strong>Redis不是万金油</strong></p>
<p>在面试的时候，常被问比较下Redis与Memcache的优缺点，个人觉得这二者并不适合一起比较，一个是非关系型数据库不仅可以做缓存还能干其他事情，一个是仅用做缓存。常常让我们对这二者进行比较，主要也是由于Redis最广泛的应用场景就是Cache，那么Redis到底能干什么？又不能干什么呢？</p>
<p><img src="https://img-blog.csdnimg.cn/20181119213020882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyODk0ODk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

<h2 id="Redis都可以干什么事儿"><a href="#Redis都可以干什么事儿" class="headerlink" title="Redis都可以干什么事儿"></a>Redis都可以干什么事儿</h2><p>缓存，毫无疑问这是Redis当今最为人熟知的使用场景，再提升服务器性能方面非常有效。</p>
<p><strong>1.排行榜</strong>，如果使用传统的关系型数据库来做，非常麻烦，而利用Redis的SortSet数据结构能够非常方便搞定；</p>
<p><strong>2.计算器/限速器</strong>，利用Redis中原子性的自增操作，我们可以统计类似用户点赞数、用户访问数等，这类操作如果用MySQL，频繁的读写会带来相当大的压力；限速器比较典型的使用场景是限制某个用户访问某个API的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力；</p>
<p><strong>3.好友关系</strong>，利用集合的一些命令，比如求交集、并集、差集等，可以方便搞定一些共同好友、共同爱好之类的功能；</p>
<p><strong>4.简单消息队列</strong>，除了Redis自身的发布/订阅模式，我们也可以利用List来实现一个队列机制，比如到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的DB压力，完全可以用List来完成异步解耦；</p>
<p><strong>5.Session共享</strong>，以PHP为例，默认Session是保存在服务器的文件中，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登陆；采用Redis保存Session后，无论用户落在那台机器上都能够获取到对应的Session信息。</p>
<h2><a name="t1"></a><a name="t1"></a><a id="Redis_41"></a>Redis不能干什么事儿</h2>
<p>Redis感觉能干的事情特别多，但它不是万能的，合适的地方用它事半功倍，如果滥用可能导致系统的不稳定、成本增高等问题。</p>
<p>1.比如，用Redis去保存用户的基本信息，虽然它能够支持持久化，但是它的持久化方案并不能保证数据绝对的落地，并且还可能带来Redis性能下降，因为持久化太过频繁会增大Redis服务的压力。</p>
<p>2.简单总结就是数据量太大、数据访问频率非常低的业务都不适合使用Redis，数据太大会增加成本，访问频率太低，保存在内存中纯属浪费资源。</p>
<h2><a name="t2"></a><a name="t2"></a><a id="_51"></a>选择总需要找个理由</h2>
<p>上面说了Redis的一些使用场景，那么这些场景的解决方案也有很多其它选择，比如缓存可以用Memcache，Session共享还能用MySql来实现，消息队列可以用RabbitMQ，我们为什么一定要用Redis呢？</p>
<p>速度快，完全基于内存，使用C语言实现，网络层使用epoll解决高并发问题，单线程模型避免了不必要的上下文切换及竞争条件；</p>
<p><strong>注意：单线程仅仅是说在网络请求这一模块上用一个请求处理客户端的请求，像持久化它就会重开一个线程/进程去进行处理。</strong></p>
<p>丰富的数据类型，Redis有8种数据类型，当然常用的主要是 String、Hash、List、Set、 SortSet 这5种类型，他们都是基于键值的方式组织数据。每一种数据类型提供了非常丰富的操作命令，可以满足绝大部分需求，如果有特殊需求还能自己通过 lua 脚本自己创建新的命令（具备原子性）；</p>
<p><img src="https://img-blog.csdnimg.cn/20181119213123717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyODk0ODk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>除了提供的丰富的数据类型，Redis还提供了像慢查询分析、性能测试、Pipeline、事务、Lua自定义命令、Bitmaps、HyperLogLog、发布/订阅、Geo等个性化功能。</p>
<p>Redis的代码开源在GitHub，代码非常简单优雅，任何人都能够吃透它的源码；它的编译安装也是非常的简单，没有任何的系统依赖；有非常活跃的社区，各种客户端的语言支持也是非常完善。另外它还支持事务（没用过）、持久化、主从复制让高可用、分布式成为可能。</p>
<p><img src="https://img-blog.csdnimg.cn/20181119213141787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyODk0ODk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>做为一个开发者，对于我们使用的东西不能让它成为一个黑盒子，我们应该深入进去，对它更了解、更熟悉，今天简单说了下Redis的使用场景，以及为什么选择了Redis而不是其他。</p>

<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <!-- flowchart 箭头图标 勿删 -->
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"/>
                    </svg>
                                            <div id="article_content" class="article_content clearfix csdn-tracking-statistics">



<h2 id="二、为什么选择Redis"><a href="#二、为什么选择Redis" class="headerlink" title="二、为什么选择Redis"></a>二、为什么选择Redis</h2><h2 id="首先，要知道缓存技术，这里主要说一下这两个的（memcached，Redis）区别。"><a href="#首先，要知道缓存技术，这里主要说一下这两个的（memcached，Redis）区别。" class="headerlink" title="首先，要知道缓存技术，这里主要说一下这两个的（memcached，Redis）区别。"></a><p>首先，要知道缓存技术，这里主要说一下这两个的（memcached，Redis）区别。</p></h2></div></div><p>缓存：</p>
<p>&nbsp; &nbsp; &nbsp;1）定义</p>
<p><u>缓存就是在内存中存储的数据备份，当数据没有发生本质变化的时候，我们避免数据的查询操作直接连接数据库，而是去&nbsp; &nbsp; 内容中读取数据，这样就大大降低了数据库的读写次数，而且从内存中读数据的速度要比从数据库查询要快很多。</u></p>
<p>&nbsp; &nbsp; 2）缓存的形式</p>
<p>页面缓存（smarty静态化技术）：页面缓存经常用在CMS（content manage system）内存管理系统里面。</p>
<p>数据缓存：经常会用在页面的具体数据里面。</p>
<blockquote>
<p>1，memcached</p>
</blockquote>
<ul><li>
    <p>协议简单、基于libevent的事件处理、内置内存存储方式、memcached不互相通信的分布式。 各个memcached不会互相通信以共享信息，分布策略由客户端实现。不会对数据进行持久化，重启memcached、重启操作系统会导致全部数据消失。</p>
    </li>
    <li>
    <p>Memcached常见的应用场景是存储一些读取频繁但更新较少的数据，如静态网页、系统配置及规则数据、活跃用户的基本数据和个性化定制数据、准实时统计信息等。</p>
    </li>
</ul><blockquote>
<p>2，Redis</p>
</blockquote>
<ul><li>
    <p>Redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string、list、set、zset(有序集合)和hash。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序和算法。</p>
    </li>
    <li>
    <p>与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件（RDB和AOF两种方式），并且在此基础上实现了master-slave(主从)同步，机器重启后能通过持久化数据自动重建内存，使用Redis作为Cache时机器宕机后热点数据不会丢失。</p>
    </li>
    <li>
    <p>Redis丰富的数据结构也使其拥有更加丰富的应用场景。Redis的命令都是原子性的，可以简单地利用INCR和DECR实现计数功能。使用list可以实现获取最近N个数的操作。sort set支持对数据排序，可以应用在排行榜中。set集合可以应用到数据排重。Redis还支持过期时间设置，可以应用到需要设定精确过期时间的应用。只要可以使用Redis支持的数据结构表示的场景，就可以使用Redis进行存储。</p>
    </li>
    <li>
    <p>Redis基于乐观锁</p>
    </li>
</ul><p>为什么选择Redis？</p>
<blockquote>
<p>&nbsp; &nbsp; 1）Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。<br>
&nbsp; &nbsp; 2）Redis支持master-slave(主-从)模式应用<br>
&nbsp; &nbsp; 3）Redis支持数据持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。<br>
&nbsp; &nbsp; 4）Redis单个value的最大限制是1GB，memcached只能保存1MB的数据。</p>
</blockquote><p>主要是从两个角度去考虑:<strong>性能</strong>和<strong>并发</strong>。当然，redis还具备可以做分布式锁等其他功能，但是如果只是为了分布式锁这些其他功能，完全还有其他中间件(如zookpeer等)代替，并不是非要使用redis。因此，这个问题主要从性能和并发两个角度去答。</p>

<p><strong>一、Redis简介</strong></p>
<blockquote>
<p>REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p>
</blockquote>
<p><strong>二、支持的数据类型</strong></p>
<blockquote>
<p>Redis是Remote Dictionary Server(远程数据服务)的缩写，由意大利人antirez(Salvatore Sanfilippo)开发的一款内存高速缓存数据库，该软件使用C语言编写，它的数据模型为key-value。它支持丰富的数据结构(类型)，比如string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型，类似于<a href="http://lib.csdn.net/base/17" rel="nofollow" target="_blank">Java</a>中的map）。</p>
</blockquote>
<p>&nbsp;</p>
<p><strong>（一）性能</strong><br>
如下图所示，我们在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够<strong>迅速响应</strong>。<br><img alt class="has" src="https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk56fVjL0HJXvibicrE4666HwC9ibHNxGcIict6GSmQbA8Rn3RNvHsRkIgW8D97zhnfzNEiamA5C607FnWjg/640?wx_fmt=png"><br><strong>题外话：</strong>忽然想聊一下这个<strong>迅速响应</strong>的标准。其实根据交互效果的不同，这个响应时间没有固定标准。不过曾经有人这么告诉我:"在理想状态下，我们的页面跳转需要在<strong>瞬间</strong>解决，对于页内操作则需要在<strong>刹那</strong>间解决。另外，超过<strong>一弹指</strong>的耗时操作要有进度提示，并且可以随时中止或取消，这样才能给用户最好的体验。"</p>
<p><br>
那么<strong>瞬间、刹那、一弹指</strong>具体是多少时间呢？</p>
<p><br>
根据《摩诃僧祗律》记载</p>
<p>一刹那者为一念，二十念为一瞬，二十瞬为一弹指，二十弹指为一罗预，二十罗预为一须臾，一日一夜有三十须臾。<br>
&nbsp;</p>
<p>那么，经过周密的计算，一<strong>瞬间</strong>为0.36 秒,一<strong>刹那</strong>有 0.018 秒.一<strong>弹指</strong>长达 7.2 秒。</p>
<p><br><strong>（二）并发</strong></p>
<p><br>
如下图所示，在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问数据库。<br><img alt class="has" src="https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk56fVjL0HJXvibicrE4666HwC95NCicgQR2aYVARNYzjB1ZlgrL1HIxyicrlnBibQXFB537v6APjAKCoSfA/640?wx_fmt=png"></p>
<h3><a name="t0"></a><a name="t0"></a>&nbsp;</h3>
<p>2、使用redis有什么缺点</p>
<p><strong>&nbsp;</strong></p>
<p><strong>分析</strong>:大家用redis这么久，这个问题是必须要了解的，基本上使用redis都会碰到一些问题，常见的也就几个。</p>
<p><br><strong>回答</strong>:主要是四个问题<br>
(一)缓存和数据库双写一致性问题<br>
(二)缓存雪崩问题<br>
(三)缓存击穿问题<br>
(四)缓存的并发竞争问题<br>
这四个问题，我个人是觉得在项目中，比较常遇见的，具体解决方案，后文给出。</p>
<p>&nbsp;</p>
<h3><a name="t1"></a><a name="t1"></a>&nbsp;</h3>
<p>3、单线程的redis为什么这么快</p>
<p><strong>&nbsp;</strong></p>
<p><strong>分析</strong>:这个问题其实是对redis内部机制的一个考察。其实根据博主的面试经验，很多人其实都不知道redis是单线程工作模型。所以，这个问题还是应该要复习一下的。</p>
<p><br><strong>回答</strong>:主要是以下三点<br>
(一)纯内存操作<br>
(二)单线程操作，避免了频繁的上下文切换<br>
(三)采用了非阻塞<strong>I/O多路复用机制</strong></p>
<p><strong>&nbsp;</strong></p>
<p><strong>题外话：</strong>我们现在要仔细的说一说I/O多路复用机制，因为这个说法实在是太通俗了，通俗到一般人都不懂是什么意思。博主打一个比方：小曲在S城开了一家快递店，负责同城快送服务。小曲因为资金限制，雇佣了<strong>一批</strong>快递员，然后小曲发现资金不够了，只够买<strong>一辆</strong>车送快递。</p>
<p><br><strong>经营方式一</strong><br>
客户每送来一份快递，小曲就让一个快递员盯着，然后快递员开车去送快递。慢慢的小曲就发现了这种经营方式存在下述问题</p>
<ul><li>
    <p>几十个快递员基本上时间都花在了抢车上了，大部分快递员都处在闲置状态，谁抢到了车，谁就能去送快递</p>
    </li>
    <li>
    <p>随着快递的增多，快递员也越来越多，小曲发现快递店里越来越挤，没办法雇佣新的快递员了</p>
    </li>
    <li>
    <p>快递员之间的协调很花时间</p>
    </li>
</ul><p>综合上述缺点，小曲痛定思痛，提出了下面的经营方式</p>
<p><br><strong>经营方式二</strong><br>
小曲只雇佣一个快递员。然后呢，客户送来的快递，小曲按<strong>送达地点</strong>标注好，然后<strong>依次</strong>放在一个地方。最后，那个快递员<strong>依次</strong>的去取快递，一次拿一个，然后开着车去送快递，送好了就回来拿下一个快递。</p>
<p>&nbsp;</p>
<p><strong>对比</strong><br>
上述两种经营方式对比，是不是明显觉得第二种，效率更高，更好呢。在上述比喻中:</p>
<ul><li>
    <p>每个快递员----------&gt;每个线程</p>
    </li>
    <li>
    <p>每个快递------------&gt;每个socket(I/O流)</p>
    </li>
    <li>
    <p>快递的送达地点------&gt;socket的不同状态</p>
    </li>
    <li>
    <p>客户送快递请求------&gt;来自客户端的请求</p>
    </li>
    <li>
    <p>小曲的经营方式------&gt;服务端运行的代码</p>
    </li>
    <li>
    <p>一辆车---------------&gt;CPU的核数</p>
    </li>
</ul><p>&nbsp;</p>
<p>于是我们有如下结论<br>
1、经营方式一就是传统的并发模型，每个I/O流(快递)都有一个新的线程(快递员)管理。<br>
2、经营方式二就是I/O多路复用。只有单个线程(一个快递员)，通过跟踪每个I/O流的状态(每个快递的送达地点)，来管理多个I/O流。</p>
<p>下面类比到真实的redis线程模型，如图所示<br><img alt class="has" src="https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk56fVjL0HJXvibicrE4666HwC93yQahTTjSKTSVBicx4XcyOpD9l00KSyXeDjltA4gmnVpeTYGPuM3e5Q/640?wx_fmt=png"><br>
参照上图，简单来说，就是。我们的redis-client在操作的时候，会产生具有不同事件类型的socket。在服务端，有一段I/0多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。</p>
<p><br>
需要说明的是，这个I/O多路复用机制，redis还提供了select、epoll、evport、kqueue等多路复用函数库，大家可以自行去了解。</p>
<p>&nbsp;</p>
<h3><a name="t2"></a><a name="t2"></a>&nbsp;</h3>
<p>4、redis的数据类型，以及每种数据类型的使用场景</p>
<p><strong>&nbsp;</strong></p>
<p><strong>分析</strong>：是不是觉得这个问题很基础，其实我也这么觉得。然而根据面试经验发现，至少百分八十的人答不上这个问题。建议，在项目中用到后，再类比记忆，体会更深，不要硬记。基本上，一个合格的程序员，五种类型都会用到。</p>
<p><br><strong>回答</strong>：一共五种</p>
<p><br>
(一)String<br>
这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。一般做<strong>一些复杂的计数功能的缓存。</strong></p>
<p><br>
(二)hash<br>
这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做<strong>单点登录</strong>的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。</p>
<p><br>
(三)list<br>
使用List的数据结构，可以<strong>做简单的消息队列的功能</strong>。另外还有一个就是，可以利用lrange命令，<strong>做基于redis的分页功能</strong>，性能极佳，用户体验好。</p>
<p><br>
(四)set<br>
因为set堆放的是一堆不重复值的集合。所以可以做<strong>全局去重的功能</strong>。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。</p>
<p><br>
另外，就是利用交集、并集、差集等操作，可以<strong>计算共同喜好，全部的喜好，自己独有的喜好等功能</strong>。</p>
<p><br>
(五)sorted set<br>
sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做<strong>排行榜应用，取TOP N操作</strong>。sorted set可以用来做<strong>延时任务</strong>。最后一个应用就是可以做<strong>范围查找</strong>。</p>
<p>&nbsp;</p>
<p>5、redis的过期策略以及内存淘汰机制</p>
<p><strong>&nbsp;</strong></p>
<p><strong>分析</strong>:这个问题其实相当重要，到底redis有没用到家，这个问题就可以看出来。比如你redis只能存5G数据，可是你写了10G，那会删5G的数据。怎么删的，这个问题思考过么？还有，你的数据已经设置了过期时间，但是时间到了，内存占用率还是比较高，有思考过原因么?<br>
&nbsp;</p>
<p><strong>回答</strong>:<br>
redis采用的是定期删除+惰性删除策略。</p>
<p><br><strong>为什么不用定时删除策略?</strong><br>
定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.</p>
<p><br><strong>定期删除+惰性删除是如何工作的呢?</strong><br>
定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。</p>
<p><br>
于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。</p>
<p><br><strong>采用定期删除+惰性删除就没其他问题了么?</strong><br>
不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用<strong>内存淘汰机制</strong>。</p>
<p><br>
在redis.conf中有一行配置</p>
<p># maxmemory-policy volatile-lru<br>
&nbsp;</p>
<p>该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己)<br>
1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。<strong>应该没人用吧。</strong><br>
2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。<strong>推荐使用，目前项目在用这种。</strong><br>
3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。<strong>应该也没人用吧，你不删最少使用Key,去随机删。</strong><br>
4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。<strong>这种情况一般是把redis既当缓存，又做持久化存储的时候才用。不推荐</strong><br>
5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。<strong>依然不推荐</strong><br>
6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。<strong>不推荐</strong><br>
ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。</p>
<p>&nbsp;</p>
<h3><a name="t3"></a><a name="t3"></a>&nbsp;</h3>
<p>6、redis和数据库双写一致性问题</p>
<h3><a name="t4"></a><a name="t4"></a>&nbsp;</h3>
<p><strong>分析</strong>:一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。答这个问题，先明白一个前提。就是<strong>如果对数据有强一致性要求，不能放缓存。</strong>我们所做的一切，只能保证最终一致性。另外，我们所做的方案其实从根本上来说，只能说<strong>降低不一致发生的概率</strong>，无法完全避免。因此，有强一致性要求的数据，不能放缓存。</p>
<p><br><strong>回答</strong>:首先，采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。</p>
<p>&nbsp;</p>
<h3><a name="t5"></a><a name="t5"></a>&nbsp;</h3>
<p>7、如何应对缓存穿透和缓存雪崩问题</p>
<h3><a name="t6"></a><a name="t6"></a>&nbsp;</h3>
<p><strong>分析</strong>:这两个问题，说句实在话，一般中小型传统软件企业，很难碰到这个问题。如果有大并发的项目，流量有几百万左右。这两个问题一定要深刻考虑。</p>
<p><br><strong>回答</strong>:如下所示</p>
<p><br><strong>缓存穿透</strong>，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。</p>
<p><br><strong>解决方案</strong>:<br>
(一)利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试<br>
(二)采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做<strong>缓存预热</strong>(项目启动前，先加载缓存)操作。<br>
(三)提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。</p>
<p><br><strong>缓存雪崩</strong>，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。</p>
<p><br><strong>解决方案</strong>:<br>
(一)给缓存的失效时间，加上一个随机值，避免集体失效。<br>
(二)使用互斥锁，但是该方案吞吐量明显下降了。<br>
(三)双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。自己做缓存预热操作。然后细分以下几个小点</p>
<ul><li>
    <p>I 从缓存A读数据库，有则直接返回</p>
    </li>
    <li>
    <p>II A没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程。</p>
    </li>
    <li>
    <p>III 更新线程同时更新缓存A和缓存B。</p>
    </li>
</ul><p>&nbsp;</p>
<h3><a name="t7"></a><a name="t7"></a>&nbsp;</h3>
<p>8、如何解决redis的并发竞争key问题</p>
<h3><a name="t8"></a><a name="t8"></a>&nbsp;</h3>
<p><strong>分析</strong>:这个问题大致就是，同时有多个子系统去set一个key。这个时候要注意什么呢？大家思考过么。需要说明一下，博主提前百度了一下，发现答案基本都是推荐用redis事务机制。博主<strong>不推荐使用redis的事务机制。</strong>因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上。因此，<strong>redis的事务机制，十分鸡肋。</strong></p>
<p><br><strong>回答:</strong>如下所示<br>
(1)如果对这个key操作，<strong>不要求顺序</strong><br>
这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。<br>
(2)如果对这个key操作，<strong>要求顺序</strong><br>
假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC.<br>
期望按照key1的value值按照 valueA--&gt;valueB--&gt;valueC的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。假设时间戳如下</p>
<p>系统A key 1 {valueA &nbsp;3:00}<br>
系统B key 1 {valueB &nbsp;3:05}<br>
系统C key 1 {valueC &nbsp;3:10}</p>
<p>那么，假设这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。</p>
<p>其他方法，比如利用队列，将set方法变成串行访问也可以。总之，灵活变通。</p>
<p>&nbsp;</p>
<p>9 总结</p>
<p>本文对redis的常见问题做了一个总结。大部分是博主自己在工作中遇到，以及以前面试别人的时候，爱问的一些问题。另外，<strong>不推荐大家临时抱佛脚</strong>，真正碰到一些有经验的工程师，其实几下就能把你问懵。最后，希望大家有所收获吧。</p>



<h2 id="Redis的一些优点。"><a href="#Redis的一些优点。" class="headerlink" title="Redis的一些优点。"></a>Redis的一些优点。</h2><blockquote>
<p>异常快 - Redis非常快，每秒可执行大约110000次的设置(SET)操作，每秒大约可执行81000次的读取/获取(GET)操作。<br>支持丰富的数据类型 -<br>Redis支持开发人员常用的大多数数据类型，例如列表，集合，排序集和散列等等。这使得Redis很容易被用来解决各种问题，因为我们知道哪些问题可以更好使用地哪些数据类型来处理解决。<br>操作具有原子性 - 所有Redis操作都是原子操作，这确保如果两个客户端并发访问，Redis服务器能接收更新的值。 多实用工具 -<br>Redis是一个多实用工具，可用于多种用例，如：缓存，消息队列(Redis本地支持发布/订阅)，应用程序中的任何短期数据，例如，web应用程序中的会话，网页命中计数等。</p>
</blockquote>
<h2 id="三、-spring-boot-集成Redis"><a href="#三、-spring-boot-集成Redis" class="headerlink" title="三、 spring boot 集成Redis"></a>三、 spring boot 集成Redis</h2><p>1、添加依赖</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">  &lt;<span class="selector-tag">dependency</span>&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;<span class="selector-tag">dependency</span>&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;<span class="selector-tag">dependency</span>&gt;</span><br><span class="line">	&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;2.1.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;<span class="selector-tag">dependency</span>&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-cloud-context&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;2.1.2.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;<span class="selector-tag">dependency</span>&gt;</span><br><span class="line">  &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.5.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!<span class="selector-tag">--</span> <span class="selector-tag">Spring</span> <span class="selector-tag">Boot</span> 2<span class="selector-class">.0</span>中<span class="selector-tag">spring-boot-starter-data-redis</span>默认使用<span class="selector-tag">Lettuce</span>方式替代了<span class="selector-tag">Jedis</span>。使用<span class="selector-tag">Jedis</span>的话先排除掉<span class="selector-tag">Lettuce</span>的依赖，然后手动引入<span class="selector-tag">Jedis</span>的依赖。 <span class="selector-tag">--</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">dependency</span>&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">     &lt;<span class="selector-tag">exclusions</span>&gt;</span><br><span class="line">         &lt;<span class="selector-tag">exclusion</span>&gt;</span><br><span class="line">             &lt;groupId&gt;io.lettuce&lt;/groupId&gt;</span><br><span class="line">             &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;</span><br><span class="line">         &lt;/exclusion&gt;</span><br><span class="line">     &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;<span class="selector-tag">dependency</span>&gt;</span><br><span class="line">     &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;<span class="selector-tag">dependency</span>&gt;</span><br><span class="line">	&lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">	&lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>2、配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring.redis.host=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">#Redis服务器连接端口</span><br><span class="line">spring.redis.port=<span class="number">6379</span></span><br><span class="line">#Redis服务器连接密码（默认为空）</span><br><span class="line">spring.redis.password=</span><br><span class="line">#连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">spring.redis.pool.max-active=<span class="number">8</span></span><br><span class="line">#连接池最大阻塞等待时间（使用负值表示没有限制）</span><br><span class="line">spring.redis.pool.max-wait=-<span class="number">1</span></span><br><span class="line">#连接池中的最大空闲连接</span><br><span class="line">spring.redis.pool.max-idle=<span class="number">8</span></span><br><span class="line">#连接池中的最小空闲连接</span><br><span class="line">spring.redis.pool.min-idle=<span class="number">0</span></span><br><span class="line">#连接超时时间（毫秒）</span><br><span class="line">spring.redis.timeout=<span class="number">30000</span></span><br></pre></td></tr></table></figure>
<p>3、配置类RedisConfig</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.CacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CachingConfigurerSupport;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.EnableCaching;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.interceptor.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.context.config.annotation.RefreshScope;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.jedis.JedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor; </span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> <span class="keyword">extends</span> <span class="title">CachingConfigurerSupport</span></span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.redis.host&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.redis.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.redis.timeout&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> timeout;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.redis.password&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.redis.pool.max-active&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxActive;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.redis.pool.max-wait&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxWait;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.redis.pool.max-idle&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxIdle;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.redis.pool.min-idle&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minIdle;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RefreshScope</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KeyGenerator <span class="title">wiselyKeyGenerator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KeyGenerator() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">generate</span><span class="params">(Object target, Method method, Object... params)</span> </span>&#123;</span><br><span class="line">                StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                sb.append(target.getClass().getName());</span><br><span class="line">                sb.append(method.getName());</span><br><span class="line">                <span class="keyword">for</span> (Object obj : params) &#123;</span><br><span class="line">                    sb.append(obj.toString());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sb.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RefreshScope</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JedisConnectionFactory <span class="title">redisConnectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JedisConnectionFactory factory = <span class="keyword">new</span> JedisConnectionFactory();</span><br><span class="line">        factory.setHostName(host);</span><br><span class="line">        factory.setPort(port);</span><br><span class="line">        factory.setTimeout(timeout); <span class="comment">//设置连接超时时间</span></span><br><span class="line">        factory.setPassword(password);</span><br><span class="line">        factory.getPoolConfig().setMaxIdle(maxIdle);</span><br><span class="line">        factory.getPoolConfig().setMinIdle(minIdle);</span><br><span class="line">        factory.getPoolConfig().setMaxTotal(maxActive);</span><br><span class="line">        factory.getPoolConfig().setMaxWaitMillis(maxWait);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RefreshScope</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">		RedisCacheManager cacheManager = RedisCacheManager.create(connectionFactory);</span><br><span class="line">		<span class="comment">// Number of seconds before expiration. Defaults to unlimited (0)</span></span><br><span class="line">		<span class="comment">// cacheManager.setDefaultExpiration(10); // 设置key-value超时时间</span></span><br><span class="line">		<span class="keyword">return</span> cacheManager;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RefreshScope</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, String&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate(factory);</span><br><span class="line">        setSerializer(template); <span class="comment">//设置序列化工具，这样ReportBean不需要实现Serializable接口</span></span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RefreshScope</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setSerializer</span><span class="params">(StringRedisTemplate template)</span> </span>&#123;</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、RedisUtils类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.HashOperations;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.ListOperations;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.SetOperations;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.ValueOperations;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.ZSetOperations;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisUtils</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写入缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(<span class="keyword">final</span> String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ValueOperations&lt;Serializable, Object&gt; operations = redisTemplate.opsForValue();</span><br><span class="line">            operations.set(key, value);</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写入缓存设置时效时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(<span class="keyword">final</span> String key, Object value, Long expireTime ,TimeUnit timeUnit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ValueOperations&lt;Serializable, Object&gt; operations = redisTemplate.opsForValue();</span><br><span class="line">            operations.set(key, value);</span><br><span class="line">            redisTemplate.expire(key, expireTime, timeUnit);</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量删除对应的value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keys</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">final</span> String... keys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            remove(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量删除key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pattern</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removePattern</span><span class="params">(<span class="keyword">final</span> String pattern)</span> </span>&#123;</span><br><span class="line">        Set&lt;Serializable&gt; keys = redisTemplate.keys(pattern);</span><br><span class="line">        <span class="keyword">if</span> (keys.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            redisTemplate.delete(keys);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除对应的value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (exists(key)) &#123;</span><br><span class="line">            redisTemplate.delete(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断缓存中是否有对应的value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.hasKey(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        ValueOperations&lt;Serializable, Object&gt; operations = redisTemplate.opsForValue();</span><br><span class="line">        result = operations.get(key);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈希 添加</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hashKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hmSet</span><span class="params">(String key, Object hashKey, Object value)</span></span>&#123;</span><br><span class="line">        HashOperations&lt;String, Object, Object&gt; hash = redisTemplate.opsForHash();</span><br><span class="line">        hash.put(key,hashKey,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈希获取数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hashKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">hmGet</span><span class="params">(String key, Object hashKey)</span></span>&#123;</span><br><span class="line">        HashOperations&lt;String, Object, Object&gt;  hash = redisTemplate.opsForHash();</span><br><span class="line">        <span class="keyword">return</span> hash.get(key,hashKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 列表添加</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lPush</span><span class="params">(String k,Object v)</span></span>&#123;</span><br><span class="line">        ListOperations&lt;String, Object&gt; list = redisTemplate.opsForList();</span><br><span class="line">        list.rightPush(k,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 列表获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> l</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> l1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">lRange</span><span class="params">(String k, <span class="keyword">long</span> l, <span class="keyword">long</span> l1)</span></span>&#123;</span><br><span class="line">        ListOperations&lt;String, Object&gt; list = redisTemplate.opsForList();</span><br><span class="line">        <span class="keyword">return</span> list.range(k,l,l1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 集合添加</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String key,Object value)</span></span>&#123;</span><br><span class="line">        SetOperations&lt;String, Object&gt; set = redisTemplate.opsForSet();</span><br><span class="line">        set.add(key,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 集合获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">setMembers</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        SetOperations&lt;String, Object&gt; set = redisTemplate.opsForSet();</span><br><span class="line">        <span class="keyword">return</span> set.members(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有序集合添加</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> scoure</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zAdd</span><span class="params">(String key,Object value,<span class="keyword">double</span> scoure)</span></span>&#123;</span><br><span class="line">        ZSetOperations&lt;String, Object&gt; zset = redisTemplate.opsForZSet();</span><br><span class="line">        zset.add(key,value,scoure);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有序集合获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> scoure</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> scoure1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">rangeByScore</span><span class="params">(String key,<span class="keyword">double</span> scoure,<span class="keyword">double</span> scoure1)</span></span>&#123;</span><br><span class="line">        ZSetOperations&lt;String, Object&gt; zset = redisTemplate.opsForZSet();</span><br><span class="line">        <span class="keyword">return</span> zset.rangeByScore(key, scoure, scoure1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>5、测试，编写controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> com.chenqi.springboot.redis.RedisUtils;</span><br><span class="line"><span class="keyword">import</span> com.chenqi.springboot.service.TestService;</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"></span><br><span class="line">......    </span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> RedisUtils redisUtils;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping</span>(value = <span class="string">"/hello/&#123;deptNo&#125;"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">hello</span><span class="params">(@PathVariable(value = <span class="string">"deptNo"</span>)</span> String deptNo) </span>&#123;</span><br><span class="line">		<span class="comment">// 查询缓存中是否存在</span></span><br><span class="line">		<span class="keyword">boolean</span> hasKey = redisUtils.exists(deptNo);</span><br><span class="line">		Dept dept = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (hasKey) &#123;</span><br><span class="line">			<span class="comment">// 获取缓存</span></span><br><span class="line">			Object object = redisUtils.get(deptNo);</span><br><span class="line">			log.info(<span class="string">"从缓存获取的数据"</span> + object);</span><br><span class="line">			dept = (Dept) object;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 从数据库中获取信息</span></span><br><span class="line">			log.info(<span class="string">"从数据库中获取数据"</span>);</span><br><span class="line">			dept = deptService.getDeptInfo(Integer.valueOf(deptNo));</span><br><span class="line">			<span class="comment">// 数据插入缓存（set中的参数含义：key值，user对象，缓存存在时间10（long类型），时间单位）</span></span><br><span class="line">			redisUtils.set(deptNo, dept, <span class="number">10L</span>, TimeUnit.MINUTES);</span><br><span class="line">			log.info(<span class="string">"数据插入缓存"</span> + dept);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dept;</span><br><span class="line">	&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
 <p>6、启动项目，第一次访问：<a href="http://localhost:8002/hello/111" target="_blank" rel="nofollow noopener">http://localhost:8002/hello/111</a><br>
<img src="https://img-blog.csdnimg.cn/20190801200449949.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDYyMzczNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
<img src="https://img-blog.csdnimg.cn/20190801200458311.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDYyMzczNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
通过控制台输出，我们可以看到是从数据库中获取的数据，并且存入了redis缓存中。</p>                    
<p>7、我们再次刷新浏览器<br>
<img src="https://img-blog.csdnimg.cn/20190801200519680.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDYyMzczNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
可以看到，第二次是从缓存中读取的，我们试试不断刷新浏览器<br>
<img src="https://img-blog.csdnimg.cn/20190801200535433.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDYyMzczNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
可以看到，之后都是从缓存中获取的。</p>

<p>8、测试Redis<br>    测试输入命令：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">redis-cli</span><span class="selector-class">.exe</span> <span class="selector-tag">-h</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span> <span class="selector-tag">-p</span> 6379 </span><br><span class="line"><span class="selector-tag">set</span> <span class="selector-tag">userinfo</span> <span class="selector-tag">zjl</span></span><br><span class="line"><span class="selector-tag">get</span> <span class="selector-tag">userinfo</span></span><br></pre></td></tr></table></figure>
<p>9、使用RedisDesktopManager可视化工具进行查看<br><img src="https://img-blog.csdnimg.cn/20200415232823550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200415232855966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="四、SpringBoot-使用-Redis-实现-Session-共享"><a href="#四、SpringBoot-使用-Redis-实现-Session-共享" class="headerlink" title="四、SpringBoot 使用 Redis 实现 Session 共享"></a>四、SpringBoot 使用 Redis 实现 Session 共享</h2><p><strong>1、 什么是 Session</strong></p>
<blockquote>
<p>由于 HTTP 协议是无状态的协议，因而服务端需要记录用户的状态时，就需要用某种机制来识具体的用户。Session<br>是另一种记录客户状态的机制，不同的是 Cookie 保存在客户端浏览器中，而 Session<br>保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是<br>Session。客户端浏览器再次访问时只需要从该 Session 中查找该客户的状态就可以了。</p>
</blockquote>
<p><strong>2、 为什么需要同步session ？</strong></p>
<blockquote>
<p>当用户量比较大时候一个tomcat可能无法处理更多的请求，超过单个tomcat的承受能力，可能会出现用户等待，严重的导致tomcat宕机。<br><img src="https://img-blog.csdnimg.cn/2020041523514483.png#pic_center" alt="在这里插入图片描述">    </p>
<p>这时候我们后端可能会采用多个tomcat去处理请求，分派请求，不同请求让多个tomcat分担处理。</p>
<p> 登录的时候可能采用的是tomca1，下单的时候可能采用的是tomcat2 等等等。</p>
<p>若没有session共享同步，可能在tomcat1登录了，下一次请求被分派到tomcat2上，这时候用户就需要重新登录。</p>
<p>在实际工作中我们建议使用外部的缓存设备来共享 Session，避免单个节点挂掉而影响服务，使用外部缓存 Session 后，我们的<br>    共享数据都会放到外部缓存容器中，服务本身就会变成无状态的服务，可以随意的根据流量的大小增加或者减少负载的设备。</p>
</blockquote>
<p><strong>目前主流的分布式 Session 管理有两种方案</strong>。</p>
<p><strong>1 Session 复制</strong></p>
<p>部分 Web 服务器能够支持 Session 复制功能，如 Tomcat。用户可以通过修改 Web 服务器的配置文件，让 Web 服务器进行 Session 复制，保持每一个服务器节点的 Session 数据都能达到一致。</p>
<p>这种方案的实现依赖于 Web 服务器，需要 Web 服务器有 Session 复制功能。当 Web 应用中 Session 数量较多的时候，每个服务器节点都需要有一部分内存用来存放 Session，将会占用大量内存资源。同时大量的 Session 对象通过网络传输进行复制，不但占用了网络资源，还会因为复制同步出现延迟，导致程序运行错误。</p>
<p>在微服务架构中，往往需要 N 个服务端来共同支持服务，不建议采用这种方案。</p>
<p><strong>2 Session 集中存储</strong></p>
<p>在单独的服务器或服务器集群上使用缓存技术，如 Redis 存储 Session 数据，集中管理所有的 Session，所有的 Web 服务器都从这个存储介质中存取对应的 Session，实现 Session 共享。将 Session 信息从应用中剥离出来后，其实就达到了服务的无状态化，这样就方便在业务极速发展时水平扩充。</p>
<p>Spring Session<br>Spring Session 提供了一套创建和管理 Servlet HttpSession 的方案。Spring Session 提供了集群 Session（Clustered Sessions）功能，默认采用外置的 Redis 来存储 Session 数据，以此来解决 Session 共享的问题。</p>
<p>Spring Session 为企业级 Java 应用的 Session 管理带来了革新，使得以下的功能更加容易实现：</p>
<blockquote>
<p>API 和用于管理用户会话的实现； HttpSession，允许以应用程序容器（即 Tomcat）中性的方式替换<br>              HttpSession；    将 Session 所保存的状态卸载到特定的外部 Session 存储中，如 Redis 或<br>              Apache Geode    中，它们能够以独立于应用服务器的方式提供高质量的集群； 支持每个浏览器上使用多个<br>              Session，从而能够很容易地构建更加丰富的终端用户体验； 控制 Session ID<br>              如何在客户端和服务器之间进行交换，这样的话就能很容易地编写 Restful API，因为它可以从 HTTP 头信息中获取<br>              Session ID，而不必再依赖于 cookie； 当用户使用 WebSocket 发送请求的时候，能够保持<br>              HttpSession 处于活跃状态。  需要说明的很重要的一点就是，Spring Session 的核心项目并不依赖于<br>              Spring 框架，因此，我们甚至能够将其应用于不使用  Spring 框架的项目中。</p>
</blockquote>
<p>3、spring boot中如何使用<br>首先新建一个springboot项目<br>1）、pom文件中除了引人redis外还需引入</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">dependency</span>&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>2）、配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server.port=<span class="number">8080</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Redis 配置</span><br><span class="line"># Redis 数据库索引（默认为0）</span><br><span class="line">spring.redis.database=<span class="number">0</span></span><br><span class="line"># Redis 服务器地址</span><br><span class="line">spring.redis.host=localhost</span><br><span class="line"># Redis 服务器连接端口</span><br><span class="line">spring.redis.port=<span class="number">6379</span>  </span><br><span class="line"># Redis 服务器连接密码（默认为空）</span><br><span class="line">spring.redis.password=</span><br><span class="line"># 连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">spring.redis.lettuce.pool.max-active=<span class="number">8</span></span><br><span class="line">spring.redis.lettuce.pool.max-wait=-<span class="number">1</span></span><br><span class="line">spring.redis.lettuce.shutdown-timeout=<span class="number">100</span></span><br><span class="line">spring.redis.lettuce.pool.max-idle=<span class="number">8</span></span><br><span class="line">spring.redis.lettuce.pool.min-idle=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>3）、新建一个初始化类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * maxInactiveIntervalInSeconds: 设置 Session 失效时间</span></span><br><span class="line"><span class="comment"> * 使用 Redis Session 之后，原 Spring Boot 中的 server.session.timeout 属性不再生效。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableRedisHttpSession</span>(maxInactiveIntervalInSeconds = <span class="number">86400</span>*<span class="number">30</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4）、一个控制层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/setSession"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">setSession</span> <span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">       Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       request.getSession().setAttribute(<span class="string">"message"</span>, request.getRequestURL());</span><br><span class="line">       map.put(<span class="string">"request Url"</span>, request.getRequestURL());</span><br><span class="line">       <span class="keyword">return</span> map;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping</span>(value = <span class="string">"/getSession"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getSession</span> <span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">       Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       map.put(<span class="string">"sessionId"</span>, request.getSession().getId());</span><br><span class="line">       map.put(<span class="string">"message"</span>, request.getSession().getAttribute(<span class="string">"message"</span>));</span><br><span class="line">       <span class="keyword">return</span> map;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping</span>(value = <span class="string">"/login"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">login</span> <span class="params">(HttpServletRequest request,String userName,String password)</span></span>&#123;</span><br><span class="line">       String msg=<span class="string">"logon failure!"</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (userName!=<span class="keyword">null</span> &amp;&amp; <span class="string">"admin"</span>.equals(userName) &amp;&amp; <span class="string">"123"</span>.equals(password))&#123;</span><br><span class="line">           request.getSession().setAttribute(<span class="string">"user"</span>,userName);</span><br><span class="line">           msg=<span class="string">"login successful!"</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> msg;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>5）、同上再创建一个项目，该端口为8282</p>
<p>6）、分别启动并测试<br>   在端口是8282 的项目中登录<br>    <img src="https://img-blog.csdnimg.cn/20200416000520408.png#pic_center" alt="在这里插入图片描述"> 然后在端口是8282 和 8080的项目中获取session<br>    <img src="https://img-blog.csdnimg.cn/20200416000611251.png#pic_center" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200416000622929.png#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>两个服务中session id 是一致的，说明我们的session管理成功。</p>
<p>使用Spring Session 可以将session单独的从每个服务总抽离出来，存储到redis中进行集中管理。<br>相对于每个服务复制session的方式可谓简便至极，也不需要在每个Tomcat中修改配置文件，添加jar包等操作。</p>
</blockquote>
<p>有问题：316572403</p>
<p>原文出处1：<a href="http://mp.toutiao.com/preview_article/?pgc_id=6625563203793322503" target="_blank" rel="nofollow noopener">http://mp.toutiao.com/preview_article/?pgc_id=6625563203793322503</a></p>
<p>原文出处2：<a href="http://mp.toutiao.com/preview_article/?pgc_id=6625563203793322503" target="_blank" rel="nofollow noopener">https://blog.csdn.net/qq_43001609/article/details/82928798</a></p>
<p>原文出处3：<a href="http://mp.toutiao.com/preview_article/?pgc_id=6625563203793322503" target="_blank" rel="nofollow noopener">https://blog.csdn.net/weixin_40623736/article/details/98097708</a></p>   
<p>原文出处4：<a href="http://mp.toutiao.com/preview_article/?pgc_id=6625563203793322503" target="_blank" rel="nofollow noopener">https://segmentfault.com/a/1190000019625173</a></p>]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>boot</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员、架构师、技术经理、技术总监和CTO各自职责</title>
    <url>/myblog/talkabout/%E5%91%98%E3%80%81%E6%9E%B6%E6%9E%84%E5%B8%88%E3%80%81%E6%8A%80%E6%9C%AF%E7%BB%8F%E7%90%86%E3%80%81%E6%8A%80%E6%9C%AF%E6%80%BB%E7%9B%91%E5%92%8CCTO%E5%90%84%E8%87%AA%E8%81%8C%E8%B4%A3/</url>
    <content><![CDATA[<h3 id="程序员"><a href="#程序员" class="headerlink" title="程序员"></a>程序员</h3><p>　　程序员，英文名coder/programmer，大家常自嘲叫码农的阶段。这个角色职责是把需求或产品实现为用户可用的软件产品。</p>
<a id="more"></a>
<p>　　此职位为执行级别。另外因为经验较少，一般需要求助别人，或与别人一起完（ban）成（zhuan）一个任务。</p>
<p>　　此阶段大概要经历3年，程序员的职责如下：</p>
<p>　　1、负责公司运营系统的设计与开发工作</p>
<p>　　2、运营数据处理和分析</p>
<h3 id="高级程序员"><a href="#高级程序员" class="headerlink" title="高级程序员"></a>高级程序员</h3><p>　　高级程序员学名工程师。到了这个level，英文名可改叫做engineer或developer。此时你的功力开始增强，这与你平时的积累努力是分不开的，祝贺你～</p>
<p>　　此时的你不仅可以完成任务，开始注重代码的质量，能够写出工业级的代码。</p>
<p>　　你的经验可胜任模块级的系统设计，承担完成较为复杂的技术，能有效的自我管理，有帮助别人快速解决问题（trouble shooting）的能力。</p>
<p>　　此阶段你需要经历到7、8年左右的体验，中间要经历一段深刻自我历练的过程。</p>
<p>　　有时给人致命一击其实是心里的小蟊贼。一般人在5年前后遇到一个门槛，碰到天花板+彷徨期，或者你打心眼里不在喜欢编程，可尝试转为其它角色，如产品经理，售前售后支持等岗位，也不失为好选择。</p>
<p>　　当我们熬过这段儿，就会“山随平野尽，江入大荒流“，渐入佳境矣。</p>
<p>　　高级程序员定义软件功能、做开发计划推进和管理。可以带几个个帮手把产品规划的功能实现，你是团队中的”大手“，遇到难题也是你亲自攻艰克难。</p>
<p>　　所以，一个高级程序员，他的职责很清晰：</p>
<p>　　1、负责产品核心复杂功能的方案设计、编码实现</p>
<p>　　2、负责疑难BUG分析诊断、攻关解决</p>
<h3 id="架构师"><a href="#架构师" class="headerlink" title="架构师"></a>架构师</h3><p>　　到了架构师级别，想必你已经学会降龙十八掌，可登堂入世，成为一位准（lao）专（you）家（tiao）。</p>
<p>　　我们大喊声：“单打独斗，老衲谁也不惧！“，遂开始领导一众技术高手，指点武功，来设计和完成一个系统，大多是分布式，高并发的系统架构平台。</p>
<p>　　架构师的任务是为公司产品的业务问题提供高质量技术解决方案。可能每条产品线都设置了架构师，也可能多条生产品线的的后端是由一个架构师设计的平台提供。</p>
<p>　　通过上面架构师的部分成果，总结其职责如下：</p>
<p>　　1、需求分析：“知彼”有时比“知已”还重要。管理市场，产品等的需求，确立关键需求。坚持技术上的优秀与需求的愿景统一，提升技术负债意识，提供技术选项，风险预判，工期等解决方案。</p>
<p>　　2、架构设计：在产品功能中抽取中非功能的需求，由关键需求变成概念型架构。列出功能树，分层治之，如用户界面层、系统交互层，数据管理层。达成高扩展，高可用，高性能，高安全，易运维，易部署，易接入等能力。</p>
<p>　　3、功能设计与实现：对架构设计的底层代码级别实现。如公共核心类，接口实现，应用发现规则、接口变更等。</p>
<h3 id="技术经理"><a href="#技术经理" class="headerlink" title="技术经理"></a>技术经理</h3><p>　　人生就是不断上升的过程，你已经到达经理的层次了。如今的你，需要不断提高领导力，需要定期召开团队会议讨论问题。</p>
<p>　　首先我们要更加自信，在工作中显示自己的功力，给讲话增添力量。如：“本次项目虽然有很大的困难，我们也需苦战到底。当然示先垂范，身先士卒，方能成功！”</p>
<p>　　技术经理有时候也可能叫系统分析员，一些小公司可能会整个公司或者部门有一个技术经理。技术经理承担的角色主要是系统分析、架构搭建、系统构建、代 码走查等工作，如果说项目经理是总统，那么技术经理就是总理。当然不是所有公司都是这样的，有些公司项目经理是不管技术团队的，只做需求、进度和同客户沟 通，那么这个时候的项目经理就好像工厂里的跟单人员了，这种情况在外包公司比较多。对于技术经理来说，着重于技术方面，你需要知道某种功能用哪些技术合 适，需要知道某项功能需要多长的开发时间等。同时，技术经理也应该承担提高团队整体技术水平的工作。</p>
<p>　　你需要和大家站在一起，因为人们也都有解决问题的能力，更需要有以下的能力与责任：</p>
<p>　　1、任务管理：开发工作量评估、定立开发流程、分配和追踪开发任务</p>
<p>　　2、质量管理：代码review、开发风险判断/报告/协调解决</p>
<p>　　3、效率提升：代码底层研发和培训、最佳代码实践规范总结与推广、自动化生产工具、自动化部署工具</p>
<p>　　4、技术能力提升：招聘面试、试题主拟、新人指导、项目复盘与改进</p>
<h3 id="技术总监"><a href="#技术总监" class="headerlink" title="技术总监"></a>技术总监</h3><p>　　如果一个研发团队超过20人，有多条产品线或业务量很大，这时已经有多个技术经理在负责每个业务，这时需要一位技术总监。</p>
<p>　　技术总监的职责：</p>
<p>　　1、组建平台研发部，与架构师共建软件公共平台，方便各条产品业务线研发。</p>
<p>　　2、通过技术平台、通过高一层的职权，管理和协调公司各个部门与本部门各条线。现在每个产品线都应该有合格的技术经理和高级程序员。</p>
<h3 id="CTO"><a href="#CTO" class="headerlink" title="CTO"></a>CTO</h3><p>　　首席技术官，英文名Chief Technology Officer。是与CEO、COO、CFO同级的领导者，是技术和业务融合的领袖。</p>
<p>　　国内与国外对CTO的定义有些许不同。</p>
<p>　　美国对CTO的职责是设计公司三年内的产品和服务的技术发展方向，较少参与技术团队的日常管理和项目管理事务。基本是前瞻性的策略思维，比如Google的谢尔盖.布林一直保持对技术方向的敏锐，比如无人驾驶汽车，人工智能等走向。</p>
<p>　　在国内，CTO大部分则偏重于研发管理，相当于技术总监的Plus版。它相当于美国互联网公司常设的工程师副总裁+CTO的工作并集。但总体事情比美国的CTO层次低，大部分CTO的是领导技术团队开发各类产品，解决技术问题，管理不同的项目，排期交付。还有一部分的职能类似于架构师或总工程师，作为技术侧的权威，为下一步的发展方向 做研究探讨，为CEO提供建设型决定参考。</p>
<p>　　CTO的职责如下列表：</p>
<p>　　1、技术愿景：识别新技术、利用新技术、整合新技术、驱动新技术。驱动商业战略、驱动产品战略</p>
<p>　　2、技术架构：建立主营业务中的技术架构与实施模式，建立技术体系标准</p>
<p>　　3、流程制度：建立高质量，高效率的技术团队。健全的项目管理体系；完善的员工能力发展体系</p>
<p>　　4、知识培训：建立以研发内容为主的知识库管理体系、技术分享与技术文化的体系</p>
<p>　　5、业务支撑：与其它部门的沟通协作，如HR、市场、BD、财务、客服等提供技术管理接口；在产品技术层面能够领先于业内同行</p>
<p>　　6、影响力：在公司内部与行业中具备一定影响力与口碑</p>
<p>　　7、视野&amp;格局&amp;执行力：看待问题全面，具有强大的学习力，具备技术前瞻力，敏锐的市场嗅觉，战略落地的能力</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>　　CTO做的事情，是商业、产品、技术、管理、团队相平衡的综合统管，公司的技术研发方向与重点商业化的结果负责，激励员工，营造工程师文化。</p>
<p>　　而技术总监主要是协调团队内部各个资源，引入工具，和方法提升工作效率。</p>
<p>　　技术经理角色相对具体，绩效考核，产品落地，执行优胜劣汰的规则。</p>
]]></content>
      <categories>
        <category>talkabout</category>
      </categories>
      <tags>
        <tag>talkabout</tag>
      </tags>
  </entry>
  <entry>
    <title>综合面试题</title>
    <url>/myblog/interview/%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>综合面试题</p>
<a id="more"></a>
<h4 id="1-反射的实现方式"><a href="#1-反射的实现方式" class="headerlink" title="1.反射的实现方式"></a>1.反射的实现方式</h4><p>第一种：通过Object类的getClass方法<br>Class cla = foo.getClass();</p>
<p>第二种：通过对象实例方法获取对象<br>Class cla = foo.class;</p>
<p>第三种：通过Class.forName方式<br>Class cla = Class.forName(“xx.xx.Foo”);</p>
<h4 id="2-spring的事务"><a href="#2-spring的事务" class="headerlink" title="2.spring的事务"></a>2.spring的事务</h4><p>原子性 （atomicity）:强调事务的不可分割.<br>一致性 （consistency）:事务的执行的前后数据的完整性保持一致.<br>隔离性 （isolation）:一个事务执行的过程中,不应该受到其他事务的干扰<br>持久性（durability） :事务一旦结束,数据就持久到数据库</p>
<p>脏读 :一个事务读到了另一个事务的未提交的数据<br>不可重复读 :一个事务读到了另一个事务已经提交的 update 的数据导致多次查询结果不一致.<br>虚 | 幻读 :一个事务读到了另一个事务已经提交的 insert 的数据导致多次查询结果不一致.</p>
<p>DEFAULT 这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别.<br>未提交读（read uncommited） :脏读，不可重复读，虚读都有可能发生<br>已提交读 （read commited）:避免脏读。但是不可重复读和虚读有可能发生<br>可重复读 （repeatable read） :避免脏读和不可重复读.但是虚读有可能发生.<br>串行化的 （serializable） :避免以上所有读问题.<br>Mysql 默认:可重复读<br>Oracle 默认:读已提交</p>
<p>概念<br>　　Repeatable Read（可重复读）：即：事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容。<br>实现原理（MVCC [ 多版本并发控制 ]）</p>
<p>　　InnoDB在每行记录后面保存两个隐藏的列，分别保存了这个行的创建时间和行的删除时间。这里存储的并不是实际的时间值,而是系统版本号，当数据被修改时，版本号加1<br>　　在读取事务开始时，系统会给当前读事务一个版本号，事务会读取版本号&lt;=当前版本号的数据<br>　　此时如果其他写事务修改了这条数据，那么这条数据的版本号就会加1，从而比当前读事务的版本号高，读事务自然而然的就读不到更新后的数据了<br>MySQL的可重复读，对事务B进行查询时，事务A提交的更新不会影响到事务B。<br>　　但是对事务B进行更新时，事务A提交的更新会影响到事务B。<br>read uncommited：是最低的事务隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。<br>read commited：保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据。<br>repeatable read：这种事务隔离级别可以防止脏读，不可重复读。但是可能会出现幻象读。它除了保证一个事务不能被另外一个事务读取未提交的数据之外还避免了以下情况产生（不可重复读）。<br>serializable：这是花费最高代价但最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读之外，还避免了幻象读（避免三种）。</p>
<h4 id="3-java堆和栈的区别"><a href="#3-java堆和栈的区别" class="headerlink" title="3.java堆和栈的区别"></a>3.java堆和栈的区别</h4><p>堆是在运行数据区划分出来的一块内存区域，用于存储在程序运行过程中创建的对象实例和数组，在虚拟机运行的所有线程创建的对象实例和数组都共享一个堆。堆中的存储空间是有限的，当堆中存储的对象实例超过堆的存储空间时，堆就无法再存储新的实例对象，在这种情况下就会造成堆的溢出，java程序也会抛出内存溢出异常。因此当堆中的实例对象不再需要时，应及时回收空间，回收的空间再分配给新的实例对象。</p>
<p>栈是一个数据结构，栈结构是一种特殊的线性表，限定仅在表的一端进行元素的插入和删除。当表中没有元素时，称为空栈。</p>
<h4 id="4-springboot-run方法执行流程"><a href="#4-springboot-run方法执行流程" class="headerlink" title="4.springboot.run方法执行流程"></a>4.springboot.run方法执行流程</h4><p>SpringApplication.run分析<br>分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行；<br>1.首先创建一个SpringApplication对象实例，然后调用这个创建好的SpringApplication的实例方法。</p>
<p>2.收集各种条件和回调接口，调用它们的started()方法。</p>
<p>3.创建并配置当前Spring Boot应用将要使用的Environment。</p>
<p>4.遍历调用所有SpringApplicationRunListener的environmentPrepared()的方法。</p>
<p>5.如果SpringApplication的showBanner属性被设置为true，则打印banner。</p>
<p>6.创建ApplicationContext，将之前准备好的Environment给ApplicationContext使用。</p>
<p>7.遍历调用所有SpringApplicationRunListener的contextPrepared()方法。</p>
<p>8.最核心的一步，将之前通过@EnableAutoConfiguration获取的所有配置以及其他形式的IoC容器配置加载到已经准备完毕的ApplicationContext</p>
<p>9.遍历调用所有SpringApplicationRunListener的contextLoaded()方法。</p>
<p>10.调用ApplicationContext的refresh()方法，完成IoC容器可用的最后一道工序。</p>
<p>11.执行 ApplicationRunner和CommandLineRunner通告finished()。</p>
<h4 id="5-jsp执行流程"><a href="#5-jsp执行流程" class="headerlink" title="5.jsp执行流程"></a>5.jsp执行流程</h4><p>因为第一请求服务端 会有翻译 和编译的过程，因此比较慢； 后续访问 可以直接访问class,因此速度较快。但是 如果 服务端修改了代码，则再次访问时  会重新的翻译、编译。</p>
<h4 id="6-jsp与servlet的关系"><a href="#6-jsp与servlet的关系" class="headerlink" title="6.jsp与servlet的关系"></a>6.jsp与servlet的关系</h4><p>JSP是Servlet技术的扩展，本质上就是Servlet的简易方式。JSP编译后是“类servlet”。<br>Servlet和JSP最主要的不同点在于：Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML里分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。<br>JSP侧重于视图，Servlet主要用于控制逻辑。</p>
<h4 id="7-servlet生命周期"><a href="#7-servlet生命周期" class="headerlink" title="7.servlet生命周期"></a>7.servlet生命周期</h4><p>1.加载和实例化<br>Servlet容器负责加载和实例化Servlet。当Servlet容器启动时，或者在容器检测到需要这个Servlet来响应第一个请求时，创建Servlet实例。<br>2.初始化<br>在Servlet实例化之后，容器将调用Servlet的init()方法初始化这个对象。<br>3.请求处理<br>Servlet容器调用Servlet的service()方法对请求进行处理。<br>4.服务终止<br>当容器检测到一个Servlet实例应该从服务中被移除的时候，容器就会调用实例的destroy()方法，以便让该实例可以释放它所使用的资源，保存数据到持久存<br>储设备中。当需要释放内存或者容器关闭时，容器就会调用Servlet实例的destroy()方法。在destroy()方法调用之后，容器会释放这个Servlet实例，该实例<br>随后会被Java的垃圾收集器所回收。如果再次需要这个Servlet处理请求，Servlet容器会创建一个新的Servlet实例。</p>
<p>在整个Servlet的生命周期过程中，创建Servlet实例、调用实例的init()和destroy()方法都只进行一次，当初始化完成后，Servlet容器会将该实例保存在内存中，通过调用它的service()方法，为接收到的请求服务。</p>
<h4 id="8-mybatis缓存"><a href="#8-mybatis缓存" class="headerlink" title="8.mybatis缓存"></a>8.mybatis缓存</h4><p>一级缓存：指的是MyBatis中SqlSession对象的缓存</p>
<p>当我们执行查询之后，查询的结果会同时存入到SqlSession为我们提供的一块区域中。<br>该区域的结构是一个Map。当我们再次查询同样的数据，MyBatis会先去SqlSession中查询是否有，有的话直接拿来用。<br>当SqlSession对象消失时( 关闭SqlSession，或者调用clearCache()方法 )，MyBatis的一级缓存也就消失了。</p>
<p>缓存的数据问题：如果将一个查询结果保存到缓存中，次数数据库对该数据进行更改，那么就会出现缓存数据和数据集数据不匹配的情况。</p>
<p>MyBatis的解决方案：当调用SqlSession的修改、添加、删除、commit()、close()等方法时，就会清空一级缓存。</p>
<p>二级缓存：指的是MyBatis中SqlSessionFactory对象的缓存，由同一个SqlSessionFactory对象创建的SqlSession共享其缓存。</p>
<p>二级缓存的使用步骤：</p>
<p>( 配置文件方式 )<br>1.让MyBatis框架支持二级缓存( 在SqlMapConfig.xml中配置 )( 默认开启 )</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">        &lt;setting name = <span class="string">"cacheEnabled"</span> value=<span class="string">"true"</span>&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>
<p>2.让当前的映射文件支持二级缓存( 在自定义的.xml中配置 )<br><cache><br>3.让当前的操作支持二级缓存( 在select标签中配置 )</cache></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">"selectAll"</span> resultType=<span class="string">"user"</span> useCache=<span class="string">"true"</span>&gt;</span><br><span class="line">        select * from user where id=#&#123;uid&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<p>( 注解方式 )<br>1.让MyBatis框架支持二级缓存( 在SqlMapConfig.xml中配置 )( 默认开启 )</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">        &lt;setting name = <span class="string">"cacheEnabled"</span> value=<span class="string">"true"</span>&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>
<p>2.在@select等curd标签所在的类上添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CacheNamespace</span>(blocking = <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure>
<p>注 : 二级缓存中存放的是数据，不是对象。当你使用时，会将这些数据放入一个新对象中返回。</p>
<h4 id="9-sql优化方案"><a href="#9-sql优化方案" class="headerlink" title="9.sql优化方案"></a>9.sql优化方案</h4><p>   常用的SQL语句优化手段</p>
<blockquote>
<pre><code>1. 尽量去除表连接操作 
2. 尽量减少操作到的列的数目 
3. 精简数据类型和约束条件，以改进表结构 
4. 合理的构建索引 
5. 在SQL中有意、合理的利用索引 
6. 去除重复索引 
7. 删除不用的索引 
8. 尽量减少sql语句要扫描的语句数量 
9. 确保on或者using子句上的列上有索引 
10. 确保group by和order by中的表达式只涉及表中的一个列 
11. 尽量明确写出要查询的列，少用select * 
12. 尽量不要在where里面使用不等于符号，或者是进行null值判断，这会导致全表扫描 
13. 尽量不要在where里面对字段进行函数式操作 
14. 用exist代替in</code></pre></blockquote>
<p>SQL优化实际是个综合性的工作 硬件服务器、MySQL配置、表结构、索引、临时表、SQL语句</p>
<h4 id="10-springboot核心注解和功能"><a href="#10-springboot核心注解和功能" class="headerlink" title="10.springboot核心注解和功能"></a>10.springboot核心注解和功能</h4><p>1、@SpringBootApplication<br>这是 Spring Boot 最最最核心的注解，用在 Spring Boot 主类上，标识这是一个 Spring Boot 应用，用来开启 Spring Boot 的各项能力。<br>其实这个注解就是@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan这三个注解的组合，也可以用这三个注解来代替 @SpringBootApplication 注解。<br>2、@EnableAutoConfiguration<br>允许 Spring Boot 自动配置注解，开启这个注解之后，Spring Boot 就能根据当前类路径下的包或者类来配置 Spring Bean。<br>如：当前类路径下有 Mybatis 这个 JAR 包，MybatisAutoConfiguration 注解就能根据相关参数来配置 Mybatis 的各个 Spring Bean。<br>3、@Configuration<br>这是 Spring 3.0 添加的一个注解，用来代替 applicationContext.xml 配置文件，所有这个配置文件里面能做到的事情都可以通过这个注解所在类来进行注册。<br>4、@SpringBootConfiguration<br>这个注解就是 @Configuration 注解的变体，只是用来修饰是 Spring Boot 配置而已，或者可利于 Spring Boot 后续的扩展。<br>5、@ComponentScan<br>这是 Spring 3.1 添加的一个注解，用来代替配置文件中的 component-scan 配置，开启组件扫描，即自动扫描包路径下的 @Component 注解进行注册 bean 实例到 context 中。<br>6、@Conditional<br>这是 Spring 4.0 添加的新注解，用来标识一个 Spring Bean 或者 Configuration 配置文件，当满足指定的条件才开启配置。<br>7、@ConditionalOnBean<br>组合 @Conditional 注解，当容器中有指定的 Bean 才开启配置。<br>8、@ConditionalOnMissingBean<br>组合 @Conditional 注解，和 @ConditionalOnBean 注解相反，当容器中没有指定的 Bean 才开启配置。<br>9、@ConditionalOnClass<br>组合 @Conditional 注解，当容器中有指定的 Class 才开启配置。<br>10、@ConditionalOnMissingClass<br>组合 @Conditional 注解，和 @ConditionalOnMissingClass 注解相反，当容器中没有指定的 Class 才开启配置。<br>11、@ConditionalOnWebApplication<br>组合 @Conditional 注解，当前项目类型是 WEB 项目才开启配置。<br>当前项目有以下 3 种类型。<br>enum Type { /** * Any web application will match. <em>/ ANY, /*</em> * Only servlet-based web application will match. <em>/ SERVLET, /*</em> * Only reactive-based web application will match. */ REACTIVE}<br>12、@ConditionalOnNotWebApplication<br>组合 @Conditional 注解，和 @ConditionalOnWebApplication 注解相反，当前项目类型不是 WEB 项目才开启配置。<br>13、@ConditionalOnProperty<br>组合 @Conditional 注解，当指定的属性有指定的值时才开启配置。<br>14、@ConditionalOnExpression<br>组合 @Conditional 注解，当 SpEL 表达式为 true 时才开启配置。<br>15、@ConditionalOnJava<br>组合 @Conditional 注解，当运行的 Java JVM 在指定的版本范围时才开启配置。<br>16、@ConditionalOnResource<br>组合 @Conditional 注解，当类路径下有指定的资源才开启配置。<br>17、@ConditionalOnJndi<br>组合 @Conditional 注解，当指定的 JNDI 存在时才开启配置。<br>18、@ConditionalOnCloudPlatform<br>组合 @Conditional 注解，当指定的云平台激活时才开启配置。<br>19、@ConditionalOnSingleCandidate<br>组合 @Conditional 注解，当指定的 class 在容器中只有一个 Bean，或者同时有多个但为首选时才开启配置。<br>20、@ConfigurationProperties<br>用来加载额外的配置（如 .properties 文件），可用在 @Configuration 注解类，或者@Bean 注解方法上面。<br>21、@EnableConfigurationProperties<br>一般要配合 @ConfigurationProperties 注解使用，用来开启对@ConfigurationProperties 注解配置 Bean 的支持。<br>22、@AutoConfigureAfter<br>用在自动配置类上面，表示该自动配置类需要在另外指定的自动配置类配置完之后。<br>如 Mybatis 的自动配置类，需要在数据源自动配置类之后。<br>@AutoConfigureAfter(DataSourceAutoConfiguration.class)public class MybatisAutoConfiguration {<br>23、@AutoConfigureBefore<br>这个和 @AutoConfigureAfter 注解使用相反，表示该自动配置类需要在另外指定的自动配置类配置之前。<br>24、@Imp面试题ort<br>这是 Spring 3.0 添加的新注解，用来导入一个或者多个 @Configuration 注解修饰的类，这在 Spring Boot 里面应用很多。<br>25、@ImportResource<br>这是 Spring 3.0 添加的新注解，用来导入一个或者多个 Spring 配置文件，这对 Spring Boot 兼容老项目非常有用，因为有些配置无法通过 Java Config 的形式来配置就只能用这个注解来导入。</p>
<h4 id="11-springmvc的核心注解和功能"><a href="#11-springmvc的核心注解和功能" class="headerlink" title="11.springmvc的核心注解和功能"></a>11.springmvc的核心注解和功能</h4><p>1.@Controller注解<br>使用该注解时不需要实现Controller接口。只需要将该注解标注在类上面就表示他是一个控制器了，<br>然后通过spring的扫描机制找到该类就行，&lt;context:component-scan base-package=”包名”&gt;<br>与实现接口相比较，使用注解可以同时处理多个请求，而使用接口一次只能处理一个请求。</p>
<p>2.@RequestMapping注解<br>RequestMapping用于映射一个请求或者一个方法。可以标注在类上，也可以标注在方法上。</p>
<p>3.组合注解<br>@GetMapping:匹配get方式的请求<br>@PostMapping：匹配post方式的请求<br>@PutMapping:匹配put方式的请求<br>@DeleteMapping:匹配Delete方式的请求<br>@PatchMapping：匹配Patch方式的请求</p>
<p>4.@RequestBody注解<br>用于将请求体中的数据绑定到方法的形参中。该注解用在方法的形参上面。<br>也就是将json格式数据映射绑定到形参上。</p>
<p>5.@ResponseBody注解<br>用于直接返回return对象。该注解用在方法上。也就是直接返回json格式数据。</p>
<p>6.@PathVariable注解<br>用于获取url路径中的参数。用在方法的形参上面，也就是形参名和url路径上的参数名对应起来。</p>
<h4 id="12-spring-aop-应用场景和实现思路"><a href="#12-spring-aop-应用场景和实现思路" class="headerlink" title="12.spring aop 应用场景和实现思路"></a>12.spring aop 应用场景和实现思路</h4><p>作用：在不修改源代码的情况下，可以实现功能的增强。</p>
<p>AOP 思想： 基于代理思想，对原来目标对象，创建代理对象，在不修改原对象代码情况下，通过代理对象，调用增强功能的代码，从而对原有业务方法进行增强。</p>
<p>AOP应用场景<br>场景一： 记录日志<br>场景二： 监控方法运行时间 （监控性能）<br>场景三： 权限控制<br>场景四： 缓存优化 （第一次调用查询数据库，将查询结果放入内存对象， 第二次调用， 直接从内存对象返回，不需要查询数据库 ）<br>场景五： 事务管理 （调用方法前开启事务， 调用方法后提交关闭事务 ）</p>
<p>AOP的实现原理<br>那Spring中AOP是怎么实现的呢？Spring中AOP的有两种实现方式：<br>1、JDK动态代理<br>2、Cglib动态代理</p>
<h4 id="13-MySql三大范式"><a href="#13-MySql三大范式" class="headerlink" title="13.MySql三大范式"></a>13.MySql三大范式</h4><p>第一范式</p>
<p>第一范式（1NF）要求数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值。<br>若某一列有多个值，可以将该列单独拆分成一个实体，新实体和原实体间是一对多的关系。<br>在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。</p>
<p>第二范式</p>
<p>满足第二范式（2NF）必须先满足第一范式（1NF）。<br>第二范式要求实体中没一行的所有非主属性都必须完全依赖于主键；即：非主属性必须完全依赖于主键。<br>完全依赖：主键可能由多个属性构成，完全依赖要求不允许存在非主属性依赖于主键中的某一部分属性。<br>若存在哪个非主属性依赖于主键中的一部分属性，那么要将发生部分依赖的这一组属性单独新建一个实体，并且在旧实体中用外键与新实体关联，并且新实体与旧实体间是一对多的关系。</p>
<p>第三范式<br>满足第三范式必须先满足第二范式。<br>第三范式要求：实体中的属性不能是其他实体中的非主属性。因为这样会出现冗余。即：属性不依赖于其他非主属性。<br>如果一个实体中出现其他实体的非主属性，可以将这两个实体用外键关联，而不是将另一张表的非主属性直接写在当前表中。</p>
<h4 id="14-shiro核心组件"><a href="#14-shiro核心组件" class="headerlink" title="14.shiro核心组件"></a>14.shiro核心组件</h4><p>Apache Shiro是一个强大且易用的Java安全框架,执行身份验证、授权、密码和会话管理。使用Shiro的易于理解的API,您可以快速、轻松地获得任何应用程序,从最小的移动应用程序到最大的网络和企业应用程序。</p>
<p>Shiro的核心组件：</p>
<p>Subject：</p>
<p>表示主体，代表了当前用户的安全操作。外部用户与Subject进行交互，Subject记录了当前操作用户。在Shiro中，Subject这一概念并不仅仅指人，也可以是第三方进程、后台帐户（Daemon Account）或其他类似事物。它仅仅意味着“当前跟软件交互的东西”，负责收集用户名和密码等交给SecurityManager。Subject在Shiro中时一个接口，接口中定义了很多认证授权相关的方法，外部程序通过Subject进行认证授权，而Subject通过SecurityManager安全管理器进行认证授权。</p>
<p>SecurityManager：</p>
<p>表示安全管理器，对全部的Subject进行安全管理，它是Shiro框架的核心，典型的Facade模式，Shiro通过SecurityManager来管理内部组件实例，并通过它来提供安全管理的各种服务。通过SecurityManager可以完成Subject的认证、授权等，实质上SecurityManager是通过Authentication进行验证，通过Authorizer进行授权，通过SessionManager进行会话管理。</p>
<p>SecurityManager是一个接口，继承了Authenticator，Authorizer，SessionManger这三个接口。</p>
<p>Realms：</p>
<p>Realm即“领域”，相当于DataSource数据源，充当了Shiro与应用安全数据间的“桥梁”或者“连接器”，SecurityManager进行安全验证时需要通过Realm获取用户权限数据。也就是说，当对用户执行认证（登录）和授权（访问控制）验证时，Shiro会从应用配置的Realm中查找用户及其权限信息。Realm实质上是一个安全相关的DAO：它封装了数据源的连接细节，并在需要时将相关数据提供给Shiro。当配置Shiro时，你必须至少指定一个Realm，用于认证和（或）授权。配置多个Realm是可以的，但是至少需要一个。</p>
<p>Shiro内置了可以连接大量安全数据源（又名目录）的Realm，如LDAP、关系数据库（JDBC）、类似INI的文本配置资源以及属性文件等。如果缺省的Realm不能满足需求，你还可以插入代表自定义数据源的自己的Realm实现。</p>
<h4 id="15-mysql索引"><a href="#15-mysql索引" class="headerlink" title="15.mysql索引"></a>15.mysql索引</h4><p>索引是什么#<br>    索引( index )是帮助MySQL高效获取数据的数据结构。<br>    你可以简单理解为“排好序的快速查找数据结构”。<br>    会影响到where后面的查找和order by后面的排序。</p>
<p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用( 指向 )数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p>
<p>为了加快数据的查找，可以维护一个二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录。</p>
<p>一般来说索引本身也很大，不可能全部存储在内存中，因此往往以索引文件的形式存储到磁盘上。</p>
<p>索引如果没有特别指明，都是指B树(多路搜索树，并不一定是二叉树)结构组织的索引。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引。</p>
<p>索引的基本信息</p>
<p>   索引的分类：</p>
<p>   普通索引：仅加速查询<br>   唯一索引：加速查询 + 列值唯一（可以有null）<br>   主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个<br>   组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并<br>   全文索引：对文本的内容进行分词，进行搜索</p>
<p>   Orace数据库还支持  位图索引( bitmap )。</p>
<pre><code>MySQL支持以下几种类型的索引。
（1）B-Tree索引
（2）哈希索引
（3）空间数据索引（R-Tree）
（4）全文索引
（5）其他索引类别</code></pre><p>索引的优劣势</p>
<p>优势：<br>    1.提高数据检索的效率，降低数据库的IO成本。<br>    2.对数据进行排序，降低排序成本，降低了CPU的消耗。</p>
<p>劣势：<br>    1.索引实际上也是一张表( 保存了主键与索引字段 )，会占用空间。<br>    2.会降低更新的速度，每次操作会调整更新所带来的索引的键值变化。<br>    3.想要建立优秀的索引，会花时间。</p>
<h4 id="16-java-hashmap、ArrayList的底层原理"><a href="#16-java-hashmap、ArrayList的底层原理" class="headerlink" title="16.java hashmap、ArrayList的底层原理"></a>16.java hashmap、ArrayList的底层原理</h4><p>hashmap：</p>
<p>概述： HashMap基于Map接口实现，元素以键值对的方式存储，并且允许使用null 建和null值，因为key不允许重复，因此只能有一个键为null,另外HashMap不能保证放入元素的顺序，它是无序的，和放入的顺序并不能相同。HashMap是线程不安全的。</p>
<p>Note：HashMap的扩容操作是一项很耗时的任务，所以如果能估算Map的容量，最好给它一个默认初始值，避免进行多次扩容。HashMap的线程是不安全的，多线程环境中推荐是ConcurrentHashMap。</p>
<h4 id="17-常被问到的HashMap和Hashtable的区别"><a href="#17-常被问到的HashMap和Hashtable的区别" class="headerlink" title="17.常被问到的HashMap和Hashtable的区别"></a>17.常被问到的HashMap和Hashtable的区别</h4><p>1、线程安全</p>
<p>两者最主要的区别在于Hashtable是线程安全，而HashMap则非线程安全。</p>
<p>Hashtable的实现方法里面都添加了synchronized关键字来确保线程同步，因此相对而言HashMap性能会高一些，我们平时使用时若无特殊需求建议使用HashMap，在多线程环境下若使用HashMap需要使用Collections.synchronizedMap()方法来获取一个线程安全的集合。</p>
<p>Note：</p>
<p>Collections.synchronizedMap()实现原理是Collections定义了一个SynchronizedMap的内部类，这个类实现了Map接口，在调用方法时使用synchronized来保证线程同步,当然了实际上操作的还是我们传入的HashMap实例，简单的说就是Collections.synchronizedMap()方法帮我们在操作HashMap时自动添加了synchronized来实现线程同步，类似的其它Collections.synchronizedXX方法也是类似原理。</p>
<p>2、针对null的不同<br>HashMap可以使用null作为key，而Hashtable则不允许null作为key</p>
<p>3、继承结构<br>HashMap是对Map接口的实现，HashTable实现了Map接口和Dictionary抽象类。</p>
<p>4、初始容量与扩容</p>
<p>HashMap源码中的加载因子<br>static final float DEFAULT_LOAD_FACTOR = 0.75f;</p>
<p>当时想到的是应该是“哈希冲突”和“空间利用率”矛盾的一个折衷。<br>跟数据结构要么查询快要么插入快一个道理，hashmap就是一个插入慢、查询快的数据结构。<br>提高空间利用率和 减少查询成本的折中，主要是泊松分布，0.75的话碰撞最小，</p>
<p>加载因子是表示Hash表中元素的填满的程度。</p>
<p>加载因子越大,填满的元素越多,空间利用率越高，但冲突的机会加大了。<br>反之,加载因子越小,填满的元素越少,冲突的机会减小,但空间浪费多了。<br>冲突的机会越大,则查找的成本越高。反之,查找的成本越小。<br>因此,必须在 “冲突的机会”与”空间利用率”之间寻找一种平衡与折衷。<br>哈希冲突主要与两个因素有关：</p>
<ol>
<li>加载因子，加载因子是指哈希表中已存入的数据元素个数与哈希地址空间的大小的比值，a=n/m ; a越小，冲突的可能性就越小，相反则冲突可能性较大；但是a越小空间利用率也就越小，a越大，空间利用率越高。</li>
<li>与所用的哈希函数有关，如果哈希函数得当，就可以使哈希地址尽可能的均匀分布在哈希地址空间上，从而减少冲突的产生。</li>
</ol>
<p>HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75。</p>
<p>HashMap扩容时是当前容量翻倍即:capacity<em>2，Hashtable扩容时是容量翻倍+1即:capacity</em>2+1。</p>
<p>5、两者计算hash的方法不同</p>
<p>Hashtable计算hash是直接使用key的hashcode对table数组的长度直接进行取模</p>
<p>HashMap计算hash对key的hashcode进行了二次hash，以获得更好的散列值，然后对table数组长度取摸。</p>
<h4 id="18-、HashMap的数据存储结构"><a href="#18-、HashMap的数据存储结构" class="headerlink" title="18.、HashMap的数据存储结构"></a>18.、HashMap的数据存储结构</h4><p>1、HashMap由数组和链表来实现对数据的存储</p>
<p>HashMap采用Entry数组来存储key-value对，每一个键值对组成了一个Entry实体，Entry类实际上是一个单向的链表结构，它具有Next指针，可以连接下一个Entry实体，以此来解决Hash冲突的问题。</p>
<p>数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为O(1)；数组的特点是：寻址容易，插入和删除困难；链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达O（N）。链表的特点是：寻址困难，插入和删除容易。<br>数据结构由数组+链表组成，一个长度为16的数组中，每个元素存储的是一个链表的头结点。那么这些元素是按照什么样的规则存储到数组中呢。<br>一般情况是通过hash(key.hashCode())%len获得，也就是元素的key的哈希值对数组长度取模得到。比如上述哈希表中，12%16=12,28%16=12,108%16=12,140%16=12。所以12、28、108以及140都存储在数组下标为12的位置。</p>
<p>HashMap里面实现一个静态内部类Entry，其重要的属性有 hash，key，value，next。</p>
<p>HashMap里面用到链式数据结构的一个概念。上面我们提到过Entry类里面有一个next属性，作用是指向下一个Entry。打个比方， 第一个键值对A进来，通过计算其key的hash得到的index=0，记做:Entry[0] = A。一会后又进来一个键值对B，通过计算其index也等于0，现在怎么办？HashMap会这样做:B.next = A,Entry[0] = B,如果又进来C,index也等于0,那么C.next = B,Entry[0] = C；这样我们发现index=0的地方其实存取了A,B,C三个键值对,他们通过next这个属性链接在一起。所以疑问不用担心。也就是说数组中存储的是最后插入的元素。到这里为止，HashMap的大致实现，我们应该已经清楚了。</p>
<h4 id="19-如何解决哈希冲突："><a href="#19-如何解决哈希冲突：" class="headerlink" title="19.如何解决哈希冲突："></a>19.如何解决哈希冲突：</h4><p>一、 开放定址法<br>1）线性探查法(Linear Probing)：di=1,2,3,…,m-1<br>　 简单地说就是以当前冲突位置为起点，步长为１循环查找，直到找到一个空的位置就把元素插进去，循环完了都找不到说明容器满了。就像你去一条街上的店里吃饭，问了第一家被告知满座，然后挨着一家家去问是否有位置一样。<br>2）线性补偿探测法：di=Ｑ　下一个位置满足 Hi=(H(key) + Ｑ) mod m i=1,2,…k(k&lt;=m-1) ，要求 Q 与 m 是互质的，以便能探测到哈希表中的所有单元。<br>继续用上面的例子，现在你不是挨着一家家去问了，拿出计算器算了一下，然后隔Ｑ家问一次有没有位置。<br>3）伪随机探测再散列：di=伪随机数序列。还是那个例子，这是完全根据心情去选一家店来问了</p>
<p>缺点：</p>
<blockquote>
<p>这种方法建立起来的hash表当冲突多的时候数据容易堆聚在一起，这时候对查找不友好；<br>    删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点<br>    当空间满了，还要建立一个溢出表来存多出来的元素。</p>
</blockquote>
<p>二、再哈希法<br>同义词产生地址冲突时计算另一个哈希函数地址，直到不发生冲突为止。这种方法不易产生聚集，但是增加了计算时间。<br>缺点：增加了计算时间。</p>
<p>三、建立一个公共溢出区<br>所有关键字和基本表中关键字为同义词的记录，不管他们由哈希函数得到的哈希地址是什么，一旦发生冲突，都填入溢出表。简单地说就是搞个新表存冲突的元素。</p>
<p>四、链地址法（拉链法）<br>将所有关键字为同义词的记录存储在同一线性链表中，也就是把冲突位置的元素构造成链表。<br>拉链法的优点:</p>
<blockquote>
<p>拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；<br>由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；<br>在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。</p>
</blockquote>
<p>拉链法的缺点：</p>
<blockquote>
<p>指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度</p>
</blockquote>
<h4 id="20-HashMap-JDK-1-8的-改变"><a href="#20-HashMap-JDK-1-8的-改变" class="headerlink" title="20.HashMap JDK 1.8的 改变"></a>20.HashMap JDK 1.8的 改变</h4><p>HashMap采用数组+链表+红黑树实现。<br>在Jdk1.8中HashMap的实现方式做了一些改变，但是基本思想还是没有变得，只是在一些地方做了优化，下面来看一下这些改变的地方,数据结构的存储由数组+链表的方式，变化为数组+链表+红黑树的存储方式，当链表长度超过阈值( 8 )时，将链表转换为红黑树。在性能上进一步得到提升。</p>
<p>ArrayList：</p>
<p>ArrayList是基于数组实现的，是一个动态数组，其容量能自动增长，类似于C语言中的动态申请内存，动态增长内存。<br>ArrayList不是线程安全的，只能用在单线程环境下，多线程环境下可以考虑用Collections.synchronizedList(List l)函数返回一个线程安全的ArrayList类，也可以使用concurrent并发包下的CopyOnWriteArrayList类。<br>ArrayList实现了Serializable接口，因此它支持序列化，能够通过序列化传输，实现了RandomAccess接口，支持快速随机访问，实际上就是通过下标序号进行快速访问，实现了Cloneable接口，能被克隆。</p>
<p>每个ArrayList实例都有一个容量，该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向ArrayList中不断添加元素，其容量也自动增长。自动增长会带来数据向新数组的重新拷贝，因此，如果可预知数据量的多少，可在构造ArrayList时指定其容量。在添加大量元素前，应用程序也可以使用ensureCapacity操作来增加ArrayList实例的容量，这可以减少递增式再分配的数量。<br>注意，此实现不是同步的。如果多个线程同时访问一个ArrayList实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。</p>
<p>ArrayList定义只定义类两个私有属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>
<p>很容易理解，elementData存储ArrayList内的元素，size表示它包含的元素的数量。</p>
<p> ArrayList提供了三种方式的构造器，可以构造一个默认初始容量为10的空列表、构造一个指定初始容量的空列表以及构造一个包含指定collection的元素的列表，这些元素按照该collection的迭代器返回它们的顺序排列的。</p>
<p>每当向数组中添加元素时，都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容，以满足添加数据的需求。数组扩容通过一个公开的方法ensureCapacity(int minCapacity)来实现。在实际添加大量元素前，我也可以使用ensureCapacity来手动增加ArrayList实例的容量，以减少递增式再分配的数量。</p>
<p>总结:<br>关于ArrayList的源码，给出几点比较重要的总结：</p>
<blockquote>
<p>1、注意其三个不同的构造方法。无参构造方法构造的ArrayList的容量默认为10，带有Collection参数的构造方法，将Collection转化为数组赋给ArrayList的实现数组elementData。<br>2、注意扩充容量的方法ensureCapacity。ArrayList在每次增加元素（可能是1个，也可能是一组）时，都要调用该方法来确保足够的容量。当容量不足以容纳当前的元素个数时，就设置新的容量为旧的容量的1.5倍加1，如果设置后的新容量还不够，则直接新容量设置为传入的参数（也就是所需的容量），而后用Arrays.copyof()方法将元素拷贝到新的数组（详见下面的第3点）。从中可以看出，当容量不够时，每次增加元素，都要将原来的元素拷贝到一个新的数组中，非常之耗时，也因此建议在事先能确定元素数量的情况下，才使用ArrayList，否则建议使用LinkedList。<br>3、ArrayList的实现中大量地调用了Arrays.copyof()和System.arraycopy()方法。<br>4、ArrayList基于数组实现，可以通过下标索引直接查找到指定位置的元素，因此查找效率高，但每次插入或删除元素，就要大量地移动元素，插入删除元素的效率低。<br>5、在查找给定元素索引值等的方法中，源码都将该元素的值分为null和不为null两种情况处理，ArrayList中允许元素为null。</p>
</blockquote>
<h4 id="21-java中常用的工具类"><a href="#21-java中常用的工具类" class="headerlink" title="21.java中常用的工具类"></a>21.java中常用的工具类</h4><blockquote>
<p><a href="https://www.cnblogs.com/nizuimeiabc1/p/9651094.html" target="_blank" rel="noopener">https://www.cnblogs.com/nizuimeiabc1/p/9651094.html</a></p>
</blockquote>
<h4 id="22-Nginx基本概念"><a href="#22-Nginx基本概念" class="headerlink" title="22.Nginx基本概念"></a>22.Nginx基本概念</h4><p>概念：</p>
<p>Nginx (“engine x”)是一个高性能的HTTP和反向代理服务器,特点是占有内存少，并发能<br>力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx<br>网站用户有:百度、京东、新浪、网易、腾讯、淘宝等。</p>
<p>能做什么：</p>
<p>Nginx作为Web服务器</p>
<p>Nginx可以作为静态页面的web服务器，同时还支持CGI协议的动态语言，比如perl、php<br>等。但是不支持java. Java程序只能通过与tomcat配合完成。Nginx专为性能优化而开发，<br>性能是其最重要的考量,实现上非常注重效率，能经受高负载的考验，有报告表明能支持高<br>达50, 000个并发连接数。</p>
<h4 id="23-springboot如何实现热部署"><a href="#23-springboot如何实现热部署" class="headerlink" title="23.springboot如何实现热部署"></a>23.springboot如何实现热部署</h4><p>1.引入依赖</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.4.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>2.安装插件</p>
<ol start="3">
<li>在你更改了项目内容之后，需要使用Ctrl+F9快捷键来进行项目的部署，（其实这个就是build project的快捷键）。</li>
</ol>
<h4 id="24-jdk1-8新特性"><a href="#24-jdk1-8新特性" class="headerlink" title="24.jdk1.8新特性"></a>24.jdk1.8新特性</h4><p>1.Lambda表达式</p>
<p>2.函数式接口：简单来说就是只定义了一个抽象方法的接口（Object类的public方法除外），就是函数式接口，并且还提供了注解：@FunctionalInterface</p>
<p>3.方法引用和构造器调用</p>
<p>三种表现形式：</p>
<ol>
<li>对象：：实例方法名</li>
<li>类：：静态方法名</li>
<li>类：：实例方法名 （lambda参数列表中第一个参数是实例方法的调用 者，第二个参数是实例方法的参数时可用）</li>
</ol>
<p>4.Stream API</p>
<p>Stream操作的三个步骤<br>创建stream<br>中间操作（过滤、map）<br>终止操作</p>
<p>5.接口中的默认方法和静态方法</p>
<p>在接口中可以使用default和static关键字来修饰接口中定义的普通方法</p>
<p>6.新时间日期API</p>
<p>新的日期API LocalDate | LocalTime | LocalDateTime</p>
<p>21.redis的数据类型</p>
<p>String、Hash、List、Set、SortedSet</p>
<h4 id="25-线程常见问题-东西太多-仅作了解"><a href="#25-线程常见问题-东西太多-仅作了解" class="headerlink" title="25.线程常见问题( 东西太多,仅作了解 )"></a>25.线程常见问题( 东西太多,仅作了解 )</h4><p>并发编程三要素是什么：</p>
<p>原子性：原子，即一个不可再被分割的颗粒。原子性指的是一个或多个操作要么全部执行成功要么全部执行失败。<br>可见性：一个线程对共享变量的修改,另一个线程能够立刻看到。（synchronized,volatile）<br>有序性：程序执行的顺序按照代码的先后顺序执行。（处理器可能会对指令进行重排序）</p>
<p>并行和并发有什么区别：</p>
<p>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。<br>并行：单位时间内，多个处理器或多核处理器同时处理多个任务，是真正意义上的“同时进行”。<br>串行：有n个任务，由一个线程按顺序执行。由于任务、方法都在一个线程执行所以不存在线程不安全情况，也就不存在临界区的问题。</p>
<p>什么是线程死锁 | 如何解决：</p>
<p>死锁是指两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程（线程）称为死锁进程（线程）。</p>
<p>形成死锁的必要条件：</p>
<p>互斥条件：线程(进程)对于所分配到的资源具有排它性，即一个资源只能被一个线程(进程)占用，直到被该线程(进程)释放<br>请求与保持条件：一个线程(进程)因请求被占用资源而发生阻塞时，对已获得的资源保持不放。<br>不剥夺条件：线程(进程)已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。<br>循环等待条件：当发生死锁时，所等待的线程(进程)必定会形成一个环路（类似于死循环），造成永久阻塞</p>
<p>解决方式：<br>我们只要破坏产生死锁的四个条件中的其中一个就可以了。<br>1.破坏互斥条件<br>这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。<br>2.破坏请求与保持条件<br>一次性申请所有的资源。<br>3.破坏不剥夺条件<br>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。<br>4.破坏循环等待条件<br>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p>
<p>创建线程的四种方式：</p>
<p>1.继承 Thread 类<br>2.实现 Runnable 接口<br>3.实现 Callable 接口<br>4.使用 Executors 工具类创建线程池</p>
<p>线程的生命周期：</p>
<blockquote>
<ol>
<li>新建(new)：新创建了一个线程对象。</li>
<li>可运行(runnable)：线程对象创建后，当调用线程对象的 start()方法，该线程处于就绪状态，等待被线程调度选中，获取cpu的使用权。</li>
<li>运行(running)：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。</li>
<li>阻塞(block)：处于运行状态中的线程由于某种原因，暂时放弃对 CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被 CPU 调用以进入到运行状态。</li>
<li>死亡(dead)：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。</li>
</ol>
</blockquote>
<p>什么是线程池：</p>
<p>在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在 Java 中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。</p>
<p>线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。</p>
<p>常用的线程池种类：</p>
<blockquote>
<p>（1）newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。<br>（2）newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。<br>（3） newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60 秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。<br>（4）newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p>
</blockquote>
<h4 id="26-springmvc请求流程"><a href="#26-springmvc请求流程" class="headerlink" title="26.springmvc请求流程"></a>26.springmvc请求流程</h4><p>springMVC请求流程：</p>
<blockquote>
<p>1、用户发送请求至前端控制器DispatcherServlet。<br>2、DispatcherServlet收到请求调用HandlerMapping处理器映射器。<br>3、处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。<br>4、 DispatcherServlet调用HandlerAdapter处理器适配器。<br>5、HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。<br>6、Controller执行完成返回ModelAndView。<br>7、HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。<br>8、DispatcherServlet将ModelAndView传给ViewReslover视图解析器。<br>9、ViewReslover解析后返回具体View.<br>10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。<br>11、DispatcherServlet响应用户。</p>
</blockquote>
<h4 id="27-spring中的常用设计模式"><a href="#27-spring中的常用设计模式" class="headerlink" title="27.spring中的常用设计模式"></a>27.spring中的常用设计模式</h4><p>工厂模式、单例模式、懒汉 | 饿汉模式、适配器、代理、观察者</p>
<h4 id="28-缓存淘汰策略和场景"><a href="#28-缓存淘汰策略和场景" class="headerlink" title="28.缓存淘汰策略和场景"></a>28.缓存淘汰策略和场景</h4><p>当 Redis 内存超出物理内存限制时，内存的数据会开始和磁盘产生频繁的交换 。会让 Redis 的性能急剧下降，对于访问量比较频繁的 Redis 来说，这样存取效率基本上等于不可用。<br>在生产环境中我们是不允许 Redis 出现交换行为的，为了限制最大使用内存，Redis 提供了配置参数 maxmemory 来限制内存超出期望大小。<br>当实际内存超出 maxmemory 时，Redis 提供了几种可选策略 (maxmemory-policy) 来让用户自己决定该如何腾出新的空间以继续提供读写服务。<br>noeviction 不会继续处理写请求 (del,read请求可以继续进行)。这样可以保证不会丢失数据，但是会让线上的写相关的业务不能持续进行。这是默认的淘汰策略。<br>volatile-lru 尝试淘汰设置了过期时间的 key，最少使用的 key 优先被淘汰。没有设置过期时间的 key 不会被淘汰，这样可以保证需要持久化的数据不会突然丢失。<br>volatile-ttl 跟上面一样，除了淘汰的策略不是 LRU，而是 key 的剩余寿命 ttl 的值，ttl 越小越优先被淘汰。<br>volatile-random 跟上面一样，不过淘汰的 key 是过期 key 集合中随机的 key。<br>allkeys-lru 区别于 volatile-lru，这个策略要淘汰的 key 对象是全体的 key 集合，而不只是过期的 key 集合。这意味着没有设置过期时间的 key 也会被淘汰。<br>allkeys-random 跟上面一样，不过淘汰的策略是随机的 key。<br>volatile-xxx 策略只会针对带过期时间的 key 进行淘汰，allkeys-xxx 策略会对所有的 key 进行淘汰。如果你只是拿 Redis 做缓存，那应该使用 allkeys-xxx，客户端写缓存时不必携带过期时间。如果你还想同时使用 Redis 的持久化功能，那就使用 volatile-xxx 策略，这样可以保留没有设置过期时间的 key，它们是永久的 key 不会被 LRU 算法淘汰。</p>
<h4 id="29-springmvc如何实现全局异常"><a href="#29-springmvc如何实现全局异常" class="headerlink" title="29.springmvc如何实现全局异常"></a>29.springmvc如何实现全局异常</h4><blockquote>
<p>（1）使用Spring MVC提供的简单异常处理器SimpleMappingExceptionResolver；<br>（2）实现Spring的异常处理接口HandlerExceptionResolver 自定义自己的异常处理器；<br>（3）使用@ExceptionHandler注解实现异常处理； </p>
</blockquote>
<h4 id="30-springmvc实现拦截器"><a href="#30-springmvc实现拦截器" class="headerlink" title="30.springmvc实现拦截器"></a>30.springmvc实现拦截器</h4><p>   第一种方式是要定义的Interceptor类要实现了Spring的HandlerInterceptor 接口<br>   第二种方式是继承实现了HandlerInterceptor接口的类，比如Spring已经提供的实现了HandlerInterceptor接口的抽象类HandlerInterceptorAdapter</p>
<h4 id="31-mysql的主从复制-读写分离"><a href="#31-mysql的主从复制-读写分离" class="headerlink" title="31.mysql的主从复制( 读写分离 )"></a>31.mysql的主从复制( 读写分离 )</h4><p>MySQL复制过程分成三步:</p>
<blockquote>
<p>1 master将改变记录到二进制日志(binary log) 。这些记录过程叫做二进制日志事件，binary log events;<br>2 slave将master的binary log events拷贝到它的中继日志(relay log) ;<br>3 slave重做中继日志中的事件，将改变应用到自己的数据库中。MySQL复制是异步的且串行化的</p>
</blockquote>
<p>复制的基本原则：</p>
<p>1.每个slave只有一个master<br>2.每个slave只能有一个唯一的服务器ID<br>3.每个master可以有多个slave</p>
<p>如果使用“读写分离”，就需要注意这些问题：</p>
<p>1.数据库连接池要进行区分，哪些是读连接池，哪个是写连接池，研发的难度会增加；<br>2.为了保证高可用，读连接池要能够实现故障自动转移；<br>3.主从的一致性问题需要考虑。</p>
<h4 id="32-数据库锁的机制"><a href="#32-数据库锁的机制" class="headerlink" title="32.数据库锁的机制"></a>32.数据库锁的机制</h4><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。<br>在数据库中，除传统的计算资源(如CPU、RAM、I/O等)的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发<br>访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的-一个重要因素。从这个角度来说<br>锁对数据库而言显得尤其重要，也更加复杂。</p>
<p>打个比方，我们到淘宝上买一件商品，商品只有一件库存，这个时候如果还有另一个人买，<br>那么如何解决是你买到还是另一个人买到的问题?</p>
<p>这里肯定要用到事务，我们先从库存表中取出物品数量，然后插入订单，付款后插入付款表信息，<br>然后更新商品数量。在这个过程中，使用锁可以对有限的资源进行保护，解决隔离和并发的矛盾。</p>
<p>锁的分类：</p>
<p>加锁SQL：lock table表名字read(write)，表名字2 read(write)，其它;<br>释放锁SQL：unlock tables;</p>
<p>一：从对数据操作的类型分为( 读\写 锁 )</p>
<p>1.读锁(共享锁)：针对同一份数据，多个读操作可以同时进行而不会互相影响。</p>
<p>2.写锁( 排他锁 )：当前写操作没有完成前，它会阻断其他写锁和读锁。</p>
<p>二：从对数据操作的粒度分( 表\行 锁 )</p>
<p>表锁 ：偏向MyISAM存储引擎，开销小，加锁快;无死锁;锁定粒度大，发生锁冲突的概率最高,并发度最低( 效率低 )。</p>
<p>行锁：偏向InnoDB存储引擎，开销大，加锁慢;会出现死锁:锁定粒度最小，发生锁冲突的概率最低,并发度也最高( 支持事务 )。</p>
<p>间隙锁：</p>
<p>什么是间隙锁</p>
<p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁;<br>对于键值在条件范围内但并不存在的记录，叫做“间隙(GAP)”,<br>InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁(Next-Key锁) 。</p>
<p>危害：</p>
<p>因为Query执行过程中通过过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值并不存在。<br>间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无<br>法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害</p>
<p>死锁：<br>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。当事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时也可能会产生死锁。锁的行为和顺序和存储引擎相关。以同样的顺序执行语句，有些存储引擎会产生死锁有些不会——死锁有双重原因：真正的数据冲突；存储引擎的实现方式。<br>死锁恢复：死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁，InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。所以事务型应用程序在设计时必须考虑如何处理死锁，多数情况下只需要重新执行因死锁回滚的事务即可。</p>
<p>乐观锁、悲观锁：</p>
<blockquote>
<p>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 乐观锁不能解决脏读的问题。</p>
</blockquote>
<p>乐观锁, 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。</p>
<blockquote>
<p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。</p>
</blockquote>
<p>悲观锁，顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p>
<h4 id="33-实现动态代理的方法"><a href="#33-实现动态代理的方法" class="headerlink" title="33.实现动态代理的方法"></a>33.实现动态代理的方法</h4><p>代理模式</p>
<p>代理(Proxy)是一种设计模式,提供了对目标对象另外的访问方式;即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能.<br>这里使用到编程中的一个思想:不要随意去修改别人已经写好的代码或者方法,如果需改修改,可以通过代理的方式来扩展该方法</p>
<p>举个例子来说明代理的作用:假设我们想邀请一位明星,那么并不是直接连接明星,而是联系明星的经纪人,来达到同样的目的.明星就是一个目标对象,他只要负责活动中的节目,而其他琐碎的事情就交给他的代理人(经纪人)来解决.这就是代理思想在现实中的一个例子</p>
<p>动态代理有以下特点:</p>
<p>1.代理对象,不需要实现接口<br>2.代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)<br>3.动态代理也叫做:JDK代理,接口代理</p>
<p>JDK中生成代理对象的API<br>代理类所在包:java.lang.reflect.Proxy<br>JDK实现代理只需要使用newProxyInstance方法,但是该方法需要接收三个参数。</p>
<p>ClassLoader loader,:指定当前目标对象使用类加载器,获取加载器的方法是固定的<br>Class&lt;?&gt;[] interfaces,:目标对象实现的接口的类型,使用泛型方式确认类型<br>InvocationHandler h:事件处理,执行目标对象的方法时,会触发事件处理器的方法,会把当前执行目标对象的方法作为参数传入</p>
<h4 id="34-springboot的十个核心模块"><a href="#34-springboot的十个核心模块" class="headerlink" title="34.springboot的十个核心模块"></a>34.springboot的十个核心模块</h4><p>Spring Boot 的核心模块</p>
<blockquote>
<p>1、spring-boot  这是Spring Boot 的主模块，也是支持其他模块的核心模块。<br>2、spring-boot-autoconfigure    提供的 @EnableAutoConfiguration 注解就能启用 Spring 功能的自动配置<br>3、spring-boot-starters    启动器<br>4、spring-boot-cli    这是 Spring Boot 的命令行工具，用于编译和运行 Groovy 源程序，可以十分简单的编写并运行一个应用程序。它也能监控你的文件，一旦有变动就会自动重新编译和重新启动应用程序。<br>5、spring-boot-actuator     这是 Spring Boot 提供的执行端点，你可以更好的监控及和你的应用程序交互<br>6、spring-boot-actuator-autoconfigure    这个原理同上，为 Spring Boot 执行端点提供自动配置。<br>7、spring-boot-test  Spring Boot测试模块，为应用测试提供了许多非常有用的核心功能。<br>8、spring-boot-test-autoconfigure    这个原理同上，为Spring Boot 测试模块提供自动配置。<br>9、spring-boot-loader    这个模块可以用来构建一个单独可执行的 jar 包，使用 java -jar 就能直接运行。<br>10、spring-boot-devtools    开发者工具模块。</p>
</blockquote>
<h4 id="35-spring的核心模块"><a href="#35-spring的核心模块" class="headerlink" title="35.spring的核心模块"></a>35.spring的核心模块</h4><p>核心容器( core、beans、context等 )、AOP、Web、数据访问( JPA、tx、orm等 )、text( 单元测试 )</p>
<h4 id="36-Redis常见问题"><a href="#36-Redis常见问题" class="headerlink" title="36.Redis常见问题"></a>36.Redis常见问题</h4><p>缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题<br>一、缓存雪崩我们可以简单的理解为：由于原有缓存失效，新缓存未到期间<br>(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。<br>解决办法：<br>大多数系统设计者考虑用加锁（ 最多的解决方案）或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就时讲缓存失效时间分散开。</p>
<p>二、缓存穿透<br>缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。<br>解决办法;<br>最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。<br>另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。<br>5TB的硬盘上放满了数据，请写一个算法将这些数据进行排重。如果这些数据是一些32bit大小的数据该如何解决？如果是64bit的呢？</p>
<p>对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。<br>Bitmap： 典型的就是哈希表<br>缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了。</p>
<p>布隆过滤器（推荐）<br>就是引入了k(k&gt;1)k(k&gt;1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。<br>它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。<br>Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。<br>Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是Bloom-Filter的基本思想。<br>Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。<br>受提醒补充：缓存穿透与缓存击穿的区别<br>缓存击穿：指一个key非常热点，大并发集中对这个key进行访问，当这个key在失效的瞬间，仍然持续的大并发访问就穿破缓存，转而直接请求数据库。<br>解决方案;在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。</p>
<p>三、缓存预热<br>缓存预热这个应该是一个比较常见的概念，相信很多小伙伴都应该可以很容易的理解，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！<br>解决思路：</p>
<blockquote>
<p>1、直接写个缓存刷新页面，上线时手工操作下；<br>2、数据量不大，可以在项目启动的时候自动进行加载；<br>3、定时刷新缓存；</p>
</blockquote>
<p>四、缓存更新<br>除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p>
<blockquote>
<p>（1）定时去清理过期的缓存；<br>（2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。<br>两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。<br>五、缓存降级<br>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。<br>降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。<br>以参考日志级别设置预案：<br>（1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；<br>（2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；<br>（3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；<br>（4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</p>
</blockquote>
<p>服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。</p>
<h4 id="37-其他问题"><a href="#37-其他问题" class="headerlink" title="37.其他问题"></a>37.其他问题</h4><p>1.项目中哪些地方用到了多线程</p>
<p>2.项目中的难点</p>
<p>3.遇到的BUG</p>
<p>4.你负责的模块</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云短信验证</title>
    <url>/myblog/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81/%E4%BA%91%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81/</url>
    <content><![CDATA[<h2 id="阿里云短信验证"><a href="#阿里云短信验证" class="headerlink" title="阿里云短信验证"></a>阿里云短信验证</h2><p>ps:这是一个根据前端发送的手机号 发送一个验证码 和注册功能！！！！</p>
<a id="more"></a>
<h4 id="一、先在项目里导入jar包"><a href="#一、先在项目里导入jar包" class="headerlink" title="一、先在项目里导入jar包"></a>一、先在项目里导入jar包</h4><p>1、pom形式</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">  &lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;com.aliyun&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;4.5.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;com.aliyun&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;aliyun-java-sdk-dysmsapi&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;1.1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2、jar包链接</p>
<blockquote>
<p>百度云：<a href="https://pan.baidu.com/s/1ld5CzBhIE0HHEkja2Xa90A" target="_blank" rel="noopener">https://pan.baidu.com/s/1ld5CzBhIE0HHEkja2Xa90A</a> 提取码：2etr</p>
</blockquote>
<h4 id="二、Controller-层"><a href="#二、Controller-层" class="headerlink" title="二、Controller 层"></a>二、Controller 层</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 产品名称:云通信短信API产品,开发者无需替换</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> String product = <span class="string">"Dysmsapi"</span>;</span><br><span class="line">	<span class="comment">// 产品域名,开发者无需替换</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> String domain = <span class="string">"dysmsapi.aliyuncs.com"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// TODO 此处需要替换成开发者自己的AK(在阿里云访问控制台寻找)</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> String accessKeyId = <span class="string">"？？？？？？"</span>; <span class="comment">// TODO 修改成自己的</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> String accessKeySecret = <span class="string">"？？？？？？"</span>; <span class="comment">// TODO 修改成自己的</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SendSmsResponse <span class="title">sendSms</span><span class="params">(String telephone, String code)</span> <span class="keyword">throws</span> ClientException </span>&#123;</span><br><span class="line">		<span class="comment">// 可自助调整超时时间</span></span><br><span class="line">		System.setProperty(<span class="string">"sun.net.client.defaultConnectTimeout"</span>, <span class="string">"30000"</span>);</span><br><span class="line">		System.setProperty(<span class="string">"sun.net.client.defaultReadTimeout"</span>, <span class="string">"30000"</span>);</span><br><span class="line">		<span class="comment">// 初始化acsClient,暂不支持region化</span></span><br><span class="line">		IClientProfile profile = DefaultProfile.getProfile(<span class="string">"cn-hangzhou"</span>, accessKeyId, accessKeySecret);</span><br><span class="line">		DefaultProfile.addEndpoint(<span class="string">"cn-hangzhou"</span>, <span class="string">"cn-hangzhou"</span>, product, domain);</span><br><span class="line">		IAcsClient acsClient = <span class="keyword">new</span> DefaultAcsClient(profile);</span><br><span class="line">		<span class="comment">// 组装请求对象-具体描述见控制台-文档部分内容</span></span><br><span class="line">		SendSmsRequest request = <span class="keyword">new</span> SendSmsRequest();</span><br><span class="line">		<span class="comment">// 必填:待发送手机号</span></span><br><span class="line">		request.setPhoneNumbers(telephone);</span><br><span class="line">		<span class="comment">// 必填:短信签名-可在短信控制台中找到</span></span><br><span class="line">		request.setSignName(<span class="string">"？？？？？"</span>); <span class="comment">// TODO 修改成自己的</span></span><br><span class="line">		<span class="comment">// 必填:短信模板-可在短信控制台中找到</span></span><br><span class="line">		request.setTemplateCode(<span class="string">"？？？？？"</span>); <span class="comment">// TODO 修改成自己的</span></span><br><span class="line">		<span class="comment">// 可选:模板中的变量替换JSON串,如模板内容为"亲爱的$&#123;name&#125;,您的验证码为$&#123;code&#125;"时,此处的值为</span></span><br><span class="line"><span class="comment">//		        request.setTemplateParam("&#123;\"name\":\"Tom\", \"code\":\"123\"&#125;");</span></span><br><span class="line">		request.setTemplateParam(<span class="string">"&#123;\"code\":\""</span> + code + <span class="string">"\"&#125;"</span>);</span><br><span class="line">		<span class="comment">// 选填-上行短信扩展码(无特殊需求用户请忽略此字段)</span></span><br><span class="line">		<span class="comment">// request.setSmsUpExtendCode("90997");</span></span><br><span class="line">		<span class="comment">// 可选:outId为提供给业务方扩展字段,最终在短信回执消息中将此值带回给调用者</span></span><br><span class="line">		request.setOutId(<span class="string">"yourOutId"</span>);</span><br><span class="line">		<span class="comment">// hint 此处可能会抛出异常，注意catch</span></span><br><span class="line">		SendSmsResponse sendSmsResponse = acsClient.getAcsResponse(request);</span><br><span class="line">		<span class="keyword">if</span> (sendSmsResponse.getCode() != <span class="keyword">null</span> &amp;&amp; sendSmsResponse.getCode().equals(<span class="string">"OK"</span>)) &#123;</span><br><span class="line">			System.out.println(<span class="string">"短信发送成功！"</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"短信发送失败！"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sendSmsResponse;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Map&lt;Object, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 接受手机号发短信</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> feedback</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> ClientException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@PostMapping</span>(<span class="string">"/inserts"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Result <span class="title">inserts</span><span class="params">(@RequestBody Member member, HttpServletRequest request)</span> <span class="keyword">throws</span> ClientException </span>&#123;</span><br><span class="line">		<span class="comment">// 随机一个4位数</span></span><br><span class="line">		<span class="keyword">int</span> a = (<span class="keyword">int</span>) (Math.random() * <span class="number">9000</span> + <span class="number">1000</span>);</span><br><span class="line">		String code = Integer.toString(a);</span><br><span class="line">		String codess = map.get(member.getTelePhone());</span><br><span class="line">		map.put(member.getTelePhone(), code);</span><br><span class="line">		SendSmsResponse response = sendSms(member.getTelePhone(), code);</span><br><span class="line">		<span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Result(code, <span class="number">200</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="string">"操作失败"</span>, -<span class="number">200</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@PostMapping</span>(<span class="string">"/zc"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Result <span class="title">insertss</span><span class="params">(@RequestBody Member member)</span> </span>&#123;</span><br><span class="line">		Date date = <span class="keyword">new</span> Date();</span><br><span class="line">		SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyMMddhhmmss"</span>);</span><br><span class="line">		String now = dateFormat.format(date).toString();</span><br><span class="line">		member.setId(<span class="string">"KWY"</span> + now + (<span class="keyword">int</span>) (Math.random() * <span class="number">9000</span> + <span class="number">1000</span>));</span><br><span class="line">		String codess = map.get(member.getTelePhone());</span><br><span class="line">		String n = member.getCode();</span><br><span class="line">		<span class="keyword">if</span> (codess.equals(n)) &#123;</span><br><span class="line"></span><br><span class="line">			restTemplate.postForObject(memberServiceUrl + <span class="string">"/Member/zc"</span>, member, Result<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Result(n, <span class="number">200</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="string">"操作失败"</span>, -<span class="number">200</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>阿里云短信验证</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>阿里云短信验证</tag>
      </tags>
  </entry>
  <entry>
    <title> 消息队列: 解耦、异步、削峰, 现有MQ对比</title>
    <url>/myblog/interview/%E6%81%AF%E9%98%9F%E5%88%97-%E8%A7%A3%E8%80%A6%E3%80%81%E5%BC%82%E6%AD%A5%E3%80%81%E5%89%8A%E5%B3%B0-%E7%8E%B0%E6%9C%89MQ%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<h3 id="解耦合、异步、流量削峰有哪些消息队列？"><a href="#解耦合、异步、流量削峰有哪些消息队列？" class="headerlink" title="解耦合、异步、流量削峰有哪些消息队列？"></a>解耦合、异步、流量削峰有哪些消息队列？</h3><p>RabbitMQ、RocketMQ、Kafka</p>
<a id="more"></a>
<h5 id="什么是消息队列（MQ）"><a href="#什么是消息队列（MQ）" class="headerlink" title="什么是消息队列（MQ）?"></a>什么是消息队列（MQ）?</h5><blockquote>
<p>其实字面意思很清楚了，存放消息的队列。<br>由于它的应用场景在服务器方面被重新定义而名声大噪，它的价值也被由原先的通信而重新定义，成为高并发场景下，分布式系统解耦合，任务异步，流量削峰的利器。<br>其实消息队列属于一种中间件。</p>
</blockquote>
<h4 id="一、如何实现分布式系统解耦合"><a href="#一、如何实现分布式系统解耦合" class="headerlink" title="一、如何实现分布式系统解耦合"></a>一、如何实现分布式系统解耦合</h4><h6 id="传统做法"><a href="#传统做法" class="headerlink" title="传统做法"></a>传统做法</h6><p>传统的做法是，订单系统调用库存系统的接口。如下图：<br><img src="https://img-blog.csdnimg.cn/20200912140600880.png#pic_center" alt="在这里插入图片描述"><br><strong>传统模式的缺点</strong>：假如库存系统无法访问，则订单减库存将失败，从而导致订单失败，订单系统与库存系统耦合</p>
<p>如何解决以上问题呢？</p>
<blockquote>
<p>使用消息队列</p>
</blockquote>
<p>引入应用消息队列后的方案，如下图：<br><img src="https://img-blog.csdnimg.cn/20200912140700786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功</p>
</blockquote>
<blockquote>
<p>库存系统：订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作</p>
</blockquote>
<blockquote>
<p>在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦.</p>
</blockquote>
<p><strong>举个新例子：</strong></p>
<p>比如说某一个系统A要与其他系统打交道（即调用其中的方法），如果其它系统改变或者新增系统，那么A系统都会改变，这样的话耦合度比较高，比较麻烦。<br><img src="https://img-blog.csdnimg.cn/20200912140752645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>使用消息队列来解决这个问题。</p>
<p>我们A系统将产生的数据发入消息队列中，其它的系统再去消息队列来进行消费，那么其他系统的减少或者新增系统即与A系统关系不大了，这样来实现解耦的功能。</p>
<p><img src="https://img-blog.csdnimg.cn/20200912140816784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="二、如何实现任务异步"><a href="#二、如何实现任务异步" class="headerlink" title="二、如何实现任务异步"></a>二、如何实现任务异步</h4><p><strong>场景说明：用户注册后，需要发注册邮件和注册短信</strong></p>
<p><em>传统做法</em></p>
<p><strong>串行</strong>：将注册信息写入数据库成功后，发送注册邮件，再发送注册短信</p>
<p><img src="https://img-blog.csdnimg.cn/20200912141042797.png#pic_center" alt="在这里插入图片描述"><br><strong>并行</strong>：将注册信息写入数据库成功后，发送注册邮件的同时，发送注册短信</p>
<p><img src="https://img-blog.csdnimg.cn/20200912141133429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>其实让我想我也就只能想到并行。</p>
</blockquote>
<p><strong>使用消息队列</strong></p>
<p>将不是必须的业务逻辑，异步处理。改造后的架构如下：<br><img src="https://img-blog.csdnimg.cn/20200912141220955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>举个新例子</strong></p>
<p>某一个用户使用系统A，但是A要调用系统B,C,D,但是每一个系统返回的时间是不一样的，你必须要等待全部返回后才可以响应用户。</p>
<p><img src="https://img-blog.csdnimg.cn/20200912141249629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>如果我们这里采用消息队列，当用户发送请求后，我们把数据传给消息队列，然后再直接响应给用户我已经发送了信息。</p>
<p><img src="https://img-blog.csdnimg.cn/20200912141317593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="三、流量削峰"><a href="#三、流量削峰" class="headerlink" title="三、流量削峰"></a>三、流量削峰</h4><p><strong>场景说明：商品秒杀业务，一般会因为流量过大，导致流量暴增，应用挂掉</strong></p>
<p>传统做法</p>
<blockquote>
<p>限制用户数量</p>
</blockquote>
<p>使用消息队列</p>
<blockquote>
<p>用户的请求，服务器接收后，首先写入消息队列，秒杀业务</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200912141445983.png#pic_center" alt="在这里插入图片描述"><br><strong>举个新例子</strong></p>
<p>比如平常用户的请求我们会直接访问数据库，在大量用户过来的时候，这样的话我们会对数据库照常比较大的压力</p>
<p><img src="https://img-blog.csdnimg.cn/20200912141513530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>在这里我们增加一个消息队列，这样的话不管你请求来多少，我先存入消息队列，然后我再让系统慢慢的处理你的请求（如上图），这样很好的减缓了数据库的访问压力。</p>
</blockquote>
<h4 id="四、优劣点"><a href="#四、优劣点" class="headerlink" title="四、优劣点"></a>四、优劣点</h4><p>当下比较流行的，其实也就三种：RabbitMQ、RocketMQ、Kafka</p>
<h6 id="一、RabbitMQ"><a href="#一、RabbitMQ" class="headerlink" title="一、RabbitMQ"></a>一、RabbitMQ</h6><p>RabbitMQ在一开始是很强势的，也就是曾经很辉煌，当然，现在也不赖，只不过由于一些后起之秀，光芒不胜从前了，毕竟后来的也很优秀，</p>
<p>RabbitMQ它的<strong>优点</strong>你需要记住：</p>
<blockquote>
<p>开箱即用<br>轻量级<br>易于部署和使用<br>支持灵活的路由配置<br>客户端支持的编程语言是最多的（至少目前是）<br>……</p>
</blockquote>
<p>不足之处嘛：</p>
<blockquote>
<p>使用Erlang语言编写（这是个啥语言我之前真不知道，这就导致一个大问题，想要二次开发与扩展，以及遇到问题的话，解决的成本都比较高啊）</p>
<p>对消息堆积支持的不友好（消息队列就是进行消息收发的啊，大量的消息扔进RabbitMQ的话，它的性能表现就不那么好了）</p>
<p>性能相比较RocketMQ和Kafka是最差的</p>
</blockquote>
<h6 id="二、RocketMQ"><a href="#二、RocketMQ" class="headerlink" title="二、RocketMQ"></a>二、RocketMQ</h6><p>RocketMQ属于明星产品啊，它是阿里巴巴搞出来的，后来捐赠给了Apache基金会，2017年成了其顶级项目，阿里内部也是使用的它。</p>
<p>可以说，RocketMQ是一款综合变现都很不错的消息队列产品，无论是性能还是稳定性，亦或是可靠性，RocketMQ表现的都很不错，反正吧，这家伙是越来越首欢迎了。</p>
<h6 id="三、Kafka"><a href="#三、Kafka" class="headerlink" title="三、Kafka"></a>三、Kafka</h6><p>它一开始是为了用于处理海量日志的，所以，它与大数据关系颇深，它在处理海量日志或者是监控信息，以及流计算这些的时候，无疑是最好的选择。</p>
<p>而且Kafka可以说是与周边开源产品兼容最好的一个中间件，也就是说，几乎所有的相关开源软件系统都会优先支持Kafka。</p>
<p>另外它使用java和Scala编写，在性能，稳定性和可靠性上也都表现优异，这么一看，这家伙好像是集万众宠爱于一身啊，妥妥的老大啊，各方面都很优异啊。</p>
<p>不足之处：<br>但是它对消息是进行异步批量进行处理的，这就带来一个问题，延迟比较高，这点他是比不上RocketMQ。</p>
<h4 id="五、使用场景"><a href="#五、使用场景" class="headerlink" title="五、使用场景"></a>五、使用场景</h4><p>首先对于RabbitMQ，我们讲到它的时候，可能最先想到的就是它的轻量，开箱即用易于维护，所以基于这个特点，<strong>如果你的项目需要用到消息队列，但是消息队列又不是你系统的主角，那么RabbitMQ是一个不错的选择</strong>  。</p>
<p>当然，<strong>如果对于你的系统，消息队列扮演着重要的角色，对性能，稳定性以及可靠性等都有一定的要求，更重要的是你需要使用消息队列来处理在线业务场景，那么你最好选择RocketMQ</strong>，因为它优越的低延迟，以及优秀的稳定性绝对会给你给力的表现。</p>
<p><strong>如果你是需要处理海量的信息，业务涉及大数据，流计算等，那么这样的情况下，Kafka无疑是最好的选择了</strong>。</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>关于限流的6种实现方案</title>
    <url>/myblog/tool/%E5%85%B3%E4%BA%8E%E9%99%90%E6%B5%81%E7%9A%846%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h3 id="为什么需要限流"><a href="#为什么需要限流" class="headerlink" title="为什么需要限流"></a>为什么需要限流</h3><a id="more"></a>
<p>关于这个命题，相信很多同学心中都有各种答案，最能想到的或许就是淘宝双十一活动了。这里我们假设一个系统只能为 10W 人提供服务，突然有一天因为这个热点事件，造成了系统短时间内的访问量迅速增加到了 50W，那么导致的直接结果是系统崩溃，任何人都不能用系统了，显然只有少人数能用远比所有人都不能用更符合我们的预期，因此这个时候我们要使用「限流」了。</p>
<h3 id="限流分类"><a href="#限流分类" class="headerlink" title="限流分类"></a>限流分类</h3><p>限流的实现方案有很多种，这里稍微理了一下，限流的分类如下所示：</p>
<ol>
<li><p>合法性验证限流：比如验证码、IP 黑名单等，这些手段可以有效的防止恶意攻击和爬虫采集；</p>
</li>
<li><p>容器限流：比如 Tomcat、Nginx 等限流手段，其中 Tomcat 可以设置最大线程数（maxThreads），当并发超过最大线程数会排队等待执行；而 Nginx 提供了两种限流手段：一是控制速率，二是控制并发连接数；</p>
</li>
<li><p>服务端限流：比如我们在服务器端通过限流算法实现限流，此项也是我们本文介绍的重点。</p>
</li>
</ol>
<p>合法性验证限流为最常规的业务代码，就是普通的验证码和 IP 黑名单系统，本文就不做过多的叙述了，我们重点来看下后两种限流的实现方案：容器限流和服务端限流。</p>
<h3 id="容器限流"><a href="#容器限流" class="headerlink" title="容器限流"></a>容器限流</h3><h5 id="Tomcat-限流"><a href="#Tomcat-限流" class="headerlink" title="Tomcat 限流"></a>Tomcat 限流</h5><p>Tomcat 8.5 版本的最大线程数在 conf/server.xml 配置中，如下所示：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;Connector port="8080" protocol="HTTP/1.1"</span><br><span class="line">          connectionTimeout="20000"</span><br><span class="line">          maxThreads="150"</span><br><span class="line">          redirectPort="8443" /&gt;</span><br></pre></td></tr></table></figure>

<p>其中 maxThreads 就是 Tomcat 的最大线程数，当请求的并发大于此值（maxThreads）时，请求就会排队执行，这样就完成了限流的目的。</p>
<blockquote>
<p>小贴士：maxThreads 的值可以适当的调大一些，此值默认为 150（Tomcat 版本 8.5.42），但这个值也不是越大越好，要看具体的硬件配置，需要注意的是每开启一个线程需要耗用 1MB 的 JVM 内存空间用于作为线程栈之用，并且线程越多 GC 的负担也越重。最后需要注意一下，操作系统对于进程中的线程数有一定的限制，Windows 每个进程中的线程数不允许超过 2000，Linux 每个进程中的线程数不允许超过 1000。</p>
</blockquote>
<h5 id="Nginx-限流"><a href="#Nginx-限流" class="headerlink" title="Nginx 限流"></a>Nginx 限流</h5><p>Nginx 提供了两种限流手段：一是控制速率，二是控制并发连接数。<br>控制速率</p>
<p>我们需要使用 limit_req_zone 用来限制单位时间内的请求数，即速率限制，示例配置如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">limit_req_zone $binary_remote_addr zone=mylimit:10m rate=2r/s;</span><br><span class="line"><span class="selector-tag">server</span> &#123; </span><br><span class="line">    location / &#123; </span><br><span class="line">        limit_req zone=mylimit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上配置表示，限制每个 IP 访问的速度为 2r/s，因为 Nginx 的限流统计是基于毫秒的，我们设置的速度是 2r/s，转换一下就是 500ms 内单个 IP 只允许通过 1 个请求，从 501ms 开始才允许通过第 2 个请求。</p>
<p>我们使用单 IP 在 10ms 内发并发送了 6 个请求的执行结果如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200528204228602.png#pic_center" alt="在这里插入图片描述">从以上结果可以看出他的执行符合我们的预期，只有 1 个执行成功了，其他的 5 个被拒绝了（第 2 个在 501ms 才会被正常执行）</p>
<h6 id="速率限制升级版"><a href="#速率限制升级版" class="headerlink" title="速率限制升级版"></a>速率限制升级版</h6><p>上面的速率控制虽然很精准但是应用于真实环境未免太苛刻了，真实情况下我们应该控制一个 IP 单位总时间内的总访问次数，而不是像上面那么精确但毫秒，我们可以使用 burst 关键字开启此设置，示例配置如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">limit_req_zone $binary_remote_addr zone=mylimit:10m rate=2r/s;</span><br><span class="line"><span class="selector-tag">server</span> &#123; </span><br><span class="line">    location / &#123; </span><br><span class="line">        limit_req zone=mylimit burst=4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>burst=4 表示每个 IP 最多允许4个突发请求，如果单个 IP 在 10ms 内发送 6 次请求的结果如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200528204503222.png#pic_center" alt="在这里插入图片描述">从以上结果可以看出，有 1 个请求被立即处理了，4 个请求被放到 burst 队列里排队执行了，另外 1 个请求被拒绝了。</p>
<h6 id="控制并发数"><a href="#控制并发数" class="headerlink" title="控制并发数"></a>控制并发数</h6><p>利用 limit_conn_zone 和 limit_conn 两个指令即可控制并发数，示例配置如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">limit_conn_zone $binary_remote_addr zone=perip:10m;</span><br><span class="line">limit_conn_zone $server_name zone=perserver:10m;</span><br><span class="line"><span class="selector-tag">server</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="selector-tag">limit_conn</span> <span class="selector-tag">perip</span> 10;</span><br><span class="line">    <span class="selector-tag">limit_conn</span> <span class="selector-tag">perserver</span> 100;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 limit_conn perip 10 表示限制单个 IP 同时最多能持有 10 个连接；limit_conn perserver 100 表示 server 同时能处理并发连接的总数为 100 个。</p>
<blockquote>
<p>小贴士：只有当 request header 被后端处理后，这个连接才进行计数。</p>
</blockquote>
<h5 id="服务端限流"><a href="#服务端限流" class="headerlink" title="服务端限流"></a>服务端限流</h5><p>服务端限流需要配合限流的算法来执行，而算法相当于执行限流的“大脑”，用于指导限制方案的实现。</p>
<p>有人看到「算法」两个字可能就晕了，觉得很深奥，其实并不是。算法就相当于操作某个事务的具体实现步骤汇总，其实并不难懂，不要被它的表象给吓到哦~</p>
<p>限流的常见算法有以下三种：</p>
<ol>
<li><p>时间窗口算法</p>
</li>
<li><p>漏桶算法</p>
</li>
<li><p>令牌算法</p>
</li>
</ol>
<p>接下来我们分别看来。<br>1.时间窗口算法</p>
<p>所谓的滑动时间算法指的是以当前时间为截止时间，往前取一定的时间，比如往前取 60s 的时间，在这 60s 之内运行最大的访问数为 100，此时算法的执行逻辑为，先清除 60s 之前的所有请求记录，再计算当前集合内请求数量是否大于设定的最大请求数 100，如果大于则执行限流拒绝策略，否则插入本次请求记录并返回可以正常执行的标识给客户端。</p>
<p>滑动时间窗口如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/2020052820515955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>其中每一小个表示 10s，被红色虚线包围的时间段则为需要判断的时间间隔，比如 60s 秒允许 100 次请求，那么红色虚线部分则为 60s。</p>
<p>我们可以借助 Redis 的有序集合 ZSet 来实现时间窗口算法限流，实现的过程是先使用 ZSet 的 key 存储限流的 ID，score 用来存储请求的时间，每次有请求访问来了之后，先清空之前时间窗口的访问量，统计现在时间窗口的个数和最大允许访问量对比，如果大于等于最大访问量则返回 false 执行限流操作，负责允许执行业务逻辑，并且在 ZSet 中添加一条有效的访问记录，具体实现代码如下。</p>
<p>我们借助 Jedis 包来操作 Redis，实现在 pom.xml 添加 Jedis 框架的引用，配置如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span><br><span class="line">&lt;<span class="selector-tag">dependency</span>&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>具体的 Java 实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLimit</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Redis 操作客户端</span></span><br><span class="line">    <span class="keyword">static</span> Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> res = isPeriodLimiting(<span class="string">"java"</span>, <span class="number">3</span>, <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                System.out.println(<span class="string">"正常执行请求："</span> + i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"被限流："</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 休眠 4s</span></span><br><span class="line">        Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">        <span class="comment">// 超过最大执行时间之后，再从发起请求</span></span><br><span class="line">        <span class="keyword">boolean</span> res = isPeriodLimiting(<span class="string">"java"</span>, <span class="number">3</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (res) &#123;</span><br><span class="line">            System.out.println(<span class="string">"休眠后，正常执行请求"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"休眠后，被限流"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 限流方法（滑动时间算法）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key      限流标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> period   限流时间范围（单位：秒）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxCount 最大运行访问次数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPeriodLimiting</span><span class="params">(String key, <span class="keyword">int</span> period, <span class="keyword">int</span> maxCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> nowTs = System.currentTimeMillis(); <span class="comment">// 当前时间戳</span></span><br><span class="line">        <span class="comment">// 删除非时间段内的请求数据（清除老访问数据，比如 period=60 时，标识清除 60s 以前的请求记录）</span></span><br><span class="line">        jedis.zremrangeByScore(key, <span class="number">0</span>, nowTs - period * <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">long</span> currCount = jedis.zcard(key); <span class="comment">// 当前请求次数</span></span><br><span class="line">        <span class="keyword">if</span> (currCount &gt;= maxCount) &#123;</span><br><span class="line">            <span class="comment">// 超过最大请求次数，执行限流</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未达到最大请求数，正常执行业务</span></span><br><span class="line">        jedis.zadd(key, nowTs, <span class="string">""</span> + nowTs); <span class="comment">// 请求记录 +1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上程序的执行结果为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">正常执行请求：0</span><br><span class="line"></span><br><span class="line">正常执行请求：1</span><br><span class="line"></span><br><span class="line">正常执行请求：2</span><br><span class="line"></span><br><span class="line">正常执行请求：3</span><br><span class="line"></span><br><span class="line">正常执行请求：4</span><br><span class="line"></span><br><span class="line">正常执行请求：5</span><br><span class="line"></span><br><span class="line">正常执行请求：6</span><br><span class="line"></span><br><span class="line">正常执行请求：7</span><br><span class="line"></span><br><span class="line">正常执行请求：8</span><br><span class="line"></span><br><span class="line">正常执行请求：9</span><br><span class="line"></span><br><span class="line">被限流：10</span><br><span class="line"></span><br><span class="line">被限流：11</span><br><span class="line"></span><br><span class="line">被限流：12</span><br><span class="line"></span><br><span class="line">被限流：13</span><br><span class="line"></span><br><span class="line">被限流：14</span><br><span class="line"></span><br><span class="line">休眠后，正常执行请求</span><br></pre></td></tr></table></figure>

<p>此实现方式存在的缺点有两个：</p>
<ol>
<li><p>使用 ZSet 存储有每次的访问记录，如果数据量比较大时会占用大量的空间，比如 60s 允许 100W 访问时；</p>
</li>
<li><p>此代码的执行非原子操作，先判断后增加，中间空隙可穿插其他业务逻辑的执行，最终导致结果不准确。</p>
</li>
</ol>
<h6 id="2-漏桶算法"><a href="#2-漏桶算法" class="headerlink" title="2.漏桶算法"></a>2.漏桶算法</h6><p>漏桶算法的灵感源于漏斗，如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20200528210453706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">滑动时间算法有一个问题就是在一定范围内，比如 60s 内只能有 10 个请求，当第一秒时就到达了 10 个请求，那么剩下的 59s 只能把所有的请求都给拒绝掉，而漏桶算法可以解决这个问题。</p>
<p>漏桶算法类似于生活中的漏斗，无论上面的水流倒入漏斗有多大，也就是无论请求有多少，它都是以均匀的速度慢慢流出的。当上面的水流速度大于下面的流出速度时，漏斗会慢慢变满，当漏斗满了之后就会丢弃新来的请求;当上面的水流速度小于下面流出的速度的话，漏斗永远不会被装满，并且可以一直流出。</p>
<p>漏桶算法的实现步骤是，先声明一个队列用来保存请求，这个队列相当于漏斗，当队列容量满了之后就放弃新来的请求，然后重新声明一个线程定期从任务队列中获取一个或多个任务进行执行，这样就实现了漏桶算法。</p>
<p>上面我们演示 Nginx 的控制速率其实使用的就是漏桶算法，当然我们也可以借助 Redis 很方便的实现漏桶算法。</p>
<p>我们可以使用 Redis 4.0 版本中提供的 Redis-Cell 模块，该模块使用的是漏斗算法，并且提供了原子的限流指令，而且依靠 Redis 这个天生的分布式程序就可以实现比较完美的限流了。</p>
<p>Redis-Cell 实现限流的方法也很简单，只需要使用一条指令 cl.throttle 即可，使用示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; cl.throttle mylimit 15 30 60</span><br><span class="line">1）（<span class="built_in">integer</span>）0 <span class="comment"># 0 表示获取成功，1 表示拒绝</span></span><br><span class="line">2）（<span class="built_in">integer</span>）15 <span class="comment"># 漏斗容量</span></span><br><span class="line">3）（<span class="built_in">integer</span>）14 <span class="comment"># 漏斗剩余容量</span></span><br><span class="line">4）（<span class="built_in">integer</span>）-1 <span class="comment"># 被拒绝之后，多长时间之后再试（单位：秒）-1 表示无需重试</span></span><br><span class="line">5）（<span class="built_in">integer</span>）2 <span class="comment"># 多久之后漏斗完全空出来</span></span><br></pre></td></tr></table></figure>
<p>其中 15 为漏斗的容量，30 / 60s 为漏斗的速率。</p>
<h6 id="3-令牌算法"><a href="#3-令牌算法" class="headerlink" title="3.令牌算法"></a>3.令牌算法</h6><p>在令牌桶算法中有一个程序以某种恒定的速度生成令牌，并存入令牌桶中，而每个请求需要先获取令牌才能执行，如果没有获取到令牌的请求可以选择等待或者放弃执行，如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20200528210631294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">我们可以使用 Google 开源的 guava 包，很方便的实现令牌桶算法，首先在 pom.xml 添加 guava 引用，配置如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.google.guava/guava --&gt;</span><br><span class="line">&lt;<span class="selector-tag">dependency</span>&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;28.2-jre&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>具体实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.util.concurrent.RateLimiter;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.time.Instant;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Guava 实现限流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimiterExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每秒产生 10 个令牌（每 100 ms 产生一个）</span></span><br><span class="line">        RateLimiter rt = RateLimiter.create(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 获取 1 个令牌</span></span><br><span class="line">                rt.acquire();</span><br><span class="line">                System.out.println(<span class="string">"正常执行方法，ts:"</span> + Instant.now());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">正常执行方法，ts:2020-05-15T14:46:37.175Z</span><br><span class="line"></span><br><span class="line">正常执行方法，ts:2020-05-15T14:46:37.237Z</span><br><span class="line"></span><br><span class="line">正常执行方法，ts:2020-05-15T14:46:37.339Z</span><br><span class="line"></span><br><span class="line">正常执行方法，ts:2020-05-15T14:46:37.442Z</span><br><span class="line"></span><br><span class="line">正常执行方法，ts:2020-05-15T14:46:37.542Z</span><br><span class="line"></span><br><span class="line">正常执行方法，ts:2020-05-15T14:46:37.640Z</span><br><span class="line"></span><br><span class="line">正常执行方法，ts:2020-05-15T14:46:37.741Z</span><br><span class="line"></span><br><span class="line">正常执行方法，ts:2020-05-15T14:46:37.840Z</span><br><span class="line"></span><br><span class="line">正常执行方法，ts:2020-05-15T14:46:37.942Z</span><br><span class="line"></span><br><span class="line">正常执行方法，ts:2020-05-15T14:46:38.042Z</span><br><span class="line"></span><br><span class="line">正常执行方法，ts:2020-05-15T14:46:38.142Z</span><br></pre></td></tr></table></figure>

<p>从以上结果可以看出令牌确实是每 100ms 产生一个，而 acquire() 方法为阻塞等待获取令牌，它可以传递一个 int 类型的参数，用于指定获取令牌的个数。它的替代方法还有 tryAcquire()，此方法在没有可用令牌时就会返回 false 这样就不会阻塞等待了。当然 tryAcquire() 方法也可以设置超时时间，未超过最大等待时间会阻塞等待获取令牌，如果超过了最大等待时间，还没有可用的令牌就会返回 false。</p>
<blockquote>
<p>注意：使用 guava 实现的令牌算法属于程序级别的单机限流方案，而上面使用 Redis-Cell 的是分布式的限流方案。</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文提供了 6 种具体的实现限流的手段，他们分别是：Tomcat 使用 maxThreads 来实现限流；Nginx 提供了两种限流方式，一是通过 limit_req_zone 和 burst 来实现速率限流，二是通过 limit_conn_zone 和 limit_conn 两个指令控制并发连接的总数。</p>
<p>最后我们讲了时间窗口算法借助 Redis 的有序集合可以实现，还有漏桶算法可以使用 Redis-Cell 来实现，以及令牌算法可以解决 Google 的 guava 包来实现。</p>
<p>需要注意的是借助 Redis 实现的限流方案可用于分布式系统，而 guava 实现的限流只能应用于单机环境。如果你嫌弃服务器端限流麻烦，甚至可以在不改代码的情况下直接使用容器限流（Nginx 或 Tomcat），但前提是能满足你的业务需求。</p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>限流</tag>
      </tags>
  </entry>
  <entry>
    <title>我的外包经验：印度、中国和菲律宾（译文）</title>
    <url>/myblog/talkabout/%E6%9D%82%E8%B0%88/</url>
    <content><![CDATA[<h1 id="page-title" class="asset-name entry-title">我的外包经验：印度、中国和菲律宾（译文）</h1>
作者： 阮一峰

<p>日期：2020年2月27日</p>
<p>外包在软件业很常见，各种规模的公司都在用，每年要吸纳大量就业。</p><p></p>
<p>但是，外包的曝光量很少，大家似乎都不太关心，很少有人谈论。这导致许多人不了解外包到底是怎么回事。</p>
<a id="more"></a>
<p>本周，我读到 Troy Hunt 在2016年的<a href="https://www.troyhunt.com/offshoring-roulette-lessons-from-outsourcing-to-india-china-and-the-philippines/" target="_blank">一篇旧文</a>，介绍他的外包经验。我觉得，读起来很新鲜，有启发。下面就是节选的译文，插图是我配的。</p><p></p>
<h2>我的外包经验：印度、中国和菲律宾</h2>

<p>作者：Troy Hunt</p>

<p>原文网址：<a href="https://www.troyhunt.com/offshoring-roulette-lessons-from-outsourcing-to-india-china-and-the-philippines/" target="_blank">troyhunt.com</a></p>

<p>1、</p>

<p><img src="https://www.wangbase.com/blogimg/asset/202002/bg2020022506.jpg" alt title></p>

<p>我有很多与亚洲外包供应商合作的经历。这篇文章我想来谈谈，多年来将软件项目外包到印度，中国和菲律宾的经验。</p>

<p>我以前的工作是辉瑞公司的软件架构师，一共干了14年，曾经负责过亚太地区的软件架构。</p>

<p>2、</p>

<p><img src="https://www.wangbase.com/blogimg/asset/202002/bg2020022507.jpg" alt title></p>

<p>辉瑞公司的软件开发策略很简单，就是将所有事情外包。</p>

<p>这是行业的标准做法，我因此跟亚太地区数十个软件供应商合作过，参与了各种各样的项目，范围很广，从简单的产品宣传网站到大型临床研究系统，从移动应用 App 到 POS 机的终端程序。</p>

<p>我对印度、中国和菲律宾的软件外包行业，接触得比较多，感触尤其深，我想讨论对它们的观察。</p>

<p>3、</p>

<p><img src="https://www.wangbase.com/blogimg/asset/202002/bg2020022508.jpg" alt title></p>

<p>辉瑞公司为什么要外包？</p>

<p>原因很简单，因为程序员很贵。你必须花很多钱，雇佣很多人来构建软件产品，无论他们是否在工作，你都需要支付薪水。而且你雇来的程序员不一定懂每个项目所需的特定技能，这意味着你还要雇佣更多的人。</p>

<p>外包就相当于"云程序员"，你可以只在需要的时候去用它，只为所消费的东西付费，因此减轻了自己公司的负担。</p>

<p>4、</p>

<p><img src="https://www.wangbase.com/blogimg/asset/202002/bg2020022509.jpg" alt title></p>

<p>外包一般都选择亚洲，因为其他地方的工资太高。澳大利亚很贵，美国很贵，英国很贵，上图是世界银行的人均收入数据，这三个地区与印度、中国、菲律宾。</p>

<p>以我的经验，前三个国家的外包公司小时工资，比后三个国家贵4到5倍。</p>

<p>5、</p>

<p><img src="https://www.wangbase.com/blogimg/asset/202002/bg2020022510.jpg" alt title></p>

<p>先来看印度。这个国家已经成为离岸外包的代名词，在许多 IT 经理的心中，外包就等于印度。原因有很多。</p>

<ul>
<li>印度当过英国的殖民地，印度人的英语水平很好。</li>
<li>印度拥有超过13亿人口，这意味着它有源源不断的工程师。</li>
<li>印度的外包行业很成熟，外包巨头 Tech Mahindra、Infosys、Wipro 有规范的外包流程，在这个领域进行了大量投资。</li>
</ul>

<p>6、</p>

<p><img src="https://www.wangbase.com/blogimg/asset/202002/bg2020022511.jpg" alt title></p>

<p>印度许多程序员都是通过单项技术的强化培训而大量生产的，往往只懂培训教的非常特定的技术栈。我常常发现，他们只懂软件组件的一个独立部分，而这就是他们要做的全部事情。</p>

<p>这对项目带来的后果就是，最终会导致很多人参与其中。我查看工作量估算，向外包负责人提问："为什么需要这么多人？"。里面会有初级程序员、高级程序员，专门从事 API 开发的人员，负责网站的人员，负责数据库的人员等等。有些项目由于庞大的规模，需要这样做，但即使是很小的项目，也是这个样子。</p>

<p>7、</p>

<p><img src="https://www.wangbase.com/blogimg/asset/202002/bg2020022515.jpg" alt title></p>

<p>印度的另一个问题是流失率，程序员总是在离开。传统的公司忠诚度在印度并不盛行，大多数人在一家外包公司不会超过一两年。程序员总是去其他地方寻求更好的机会，这无可厚非，但是这种流失率意味着项目会产生更多的摩擦。这些并不会出现在你的外包合同中。</p>

<p>我还发现，印度程序员对需求文档要求很高，他们始终要求真正详细的文档。其他地方的程序员也要求需求文档，但在印度这个要求更强烈，细节对印度人来说很重要。很多时候，我们假设软件应该包括的功能，事后发现这些功能被认为是"超出范围"。这可能在全世界任何地方的任何项目中发生，但在印度极为盛行。</p>

<p>最合适外包到印度的项目，我认为最好是一个独立的工作单元，范围有着明确的界定，文档齐全，并且完全遵循印度公司现有的模式。你要知道，那里的程序员接受的是非常具体的事情的训练，并以工厂流水线的心态在开发，你按照他们的模式，那就会走上"快乐之路"。</p>

<p>8、</p>

<p><img src="https://www.wangbase.com/blogimg/asset/202002/bg2020022516.jpg" alt title></p>

<p>接着来谈谈中国。</p>

<p>中国正在快速城市化，越来越多的人口接受高等教育。他们是一个非常精通技术的国家，在这方面不断壮大，从新兴的硬件提供商变成现在占主导地位的厂商，比如华为和联想，也有像阿里巴巴这样的非常强的服务类公司。这些公司如今已经进入了世界舞台。如果您热衷于技术而不关心中国的动态，那么可能会错过未来几十年世界上最重要的技术创新和增长来源。</p>

<p>9、</p>

<p><img src="https://www.wangbase.com/blogimg/asset/202002/bg2020022517.jpg" alt title></p>

<p>对于外国人来说，中国人并不容易合作，主要原因是外语水平。中国的内部市场很大，几乎所有项目都有自己的中文服务，因此中国人接触英语的机会很有限，如果要跟他们清晰的沟通可能是一件很棘手的事情。</p>

<p>这意味着，你几乎总是与实际从事开发的程序员，至少隔了一层。通常会有一个具有一定英语技能的客户经理，你与他联系，他再把你的意思翻译给技术人员。这样的后果就是，当你真正需要进行详细讨论时，没法跟程序员直接沟通。中国程序员会在内部自己商量，你不知道他们在想些什么，并且很多东西在翻译过程中丢失了。</p>

<p>这对代码质量有深刻影响。从功能上讲，代码本身可能还不错，但这是很少或几乎没有英语技能的人编写的代码。高质量软件的要求之一，就是代码本身就是自我记录的文档，这一点很难实现。他们的代码可能无法清晰地描述软件的功能，不仅对作者也对将来维护的人，都很难阅读。</p>

<p>要是你愿意一直跟同一个软件供应商合作，那可能不会成为问题，但如果你收回代码或交给其他人维护，就会遇到严重问题。我的切身体会是，很难评审中国程序员编写的代码。另外，语言障碍对用户界面也有影响，那些编写代码的人由于不太了解英语，编写的​​标签和标题可能会使英语用户不适应，这意味着要进行许多意想不到的（且预算未定）的修订。</p>

<p>10、</p>

<p><img src="https://www.wangbase.com/blogimg/asset/202002/bg2020022518.jpg" alt title></p>

<p>我有一个习惯，一直要求供应商提供工作分解表。如果我要外包一个具有20个功能的应用程序，那么我想知道每个功能要花多少钱。然后，我可以评估，讨论一下每个功能的重要性，是否要通过放弃价值较低的功能来降低成本。</p>

<p>但是在中国，供应商无法提供这种表格，因为他们不是以这种方式核算成本。他们给我的细分，只是有多少个大三和​​大四的学生、项目经理、测试人员参与，他们每个人的花费是多少。在我看来，这根本没用，但我也没办法。</p>

<p>中国的另一个现象，就是工时非常高，他们会投入大量的时间。我很清楚地记得一个案例，中国供应商的报价与澳大利亚的本地供应商相同，而工时却大了一个数量级。</p>

<p>11、</p>

<p><img src="https://www.wangbase.com/blogimg/asset/202002/bg2020022606.jpg" alt title></p>

<p>中国现在变得越来越昂贵，根据我得到的消息，北京程序员的薪水是两位数的涨幅，有报告称，他们的年薪约为25,000美元，而孟买的年薪约为7,000美元。这是一个非常重要的差异。</p>

<p>中国的优势之一（尤其跟印度相比）就是对需求文档的要求不高。中国有一种真正的"可以做"的态度，不管你提什么要求，他们都愿意拿起任何东西去尝试。不过，虽然他们对任何事情都会说"是"，但是实际上的意思很可能是"否"或别的，这里会存在风险。但是总的来说，我发现他们的适应性非常强，这是一大优势。</p>

<p>我更倾向于外包给中国，因为那里更加灵活，限制也更少。不过由于语言障碍，与新的供应商合作期间，涉及的摩擦也更大。</p>

<p>12、</p>

<p><img src="https://www.wangbase.com/blogimg/asset/202002/bg2020022605.jpg" alt title></p>

<p>再来谈谈菲律宾。</p>

<p>我在马尼拉度过了很多时间，可以很自信地说，菲律宾人是你在任何地方所能遇到的最友好的一群人。由于菲律宾当过美国的殖民地，所以当地人的英语水平很出色，英语是菲律宾排名第二的官方语言。你在马尼拉的任何地方，都能毫无问题地被理解，并与当地人进行交流。</p>

<p>近年来，我注意到的一件事是，呼叫中心转移到菲律宾的趋势很明显。以前你打客服电话，是印度人接听，现在每次我打给电信公司，都会与菲律宾人交谈。我认为，这是他们强大的英语能力，友善的性格和新兴的科技行业共同作用的结果。另外，菲律宾的薪水比中国低得多，更接近印度。</p>

<p>13、</p>

<p><img src="https://www.wangbase.com/blogimg/asset/202002/bg2020022607.jpg" alt title></p>

<p>菲律宾是一个贫困的国家，到处都可以看到这一点，特别是在前往机场的路上穿过摇摇欲坠的房屋时。</p>

<p>这对技术领域也产生了影响，我在外包中看到的最明显的一点，就是菲律宾程序员对 PHP 的强烈亲和力。这样说并不是要贬低 PHP，而是 LAMP 技术栈的低成本造成的。辉瑞公司所使用的 Microsoft 技术栈在菲律宾很难找到市场。你随便去一家供应商，他们的默认态度总是"是的，我们将用 PHP 和 MySQL做到你们的需求。 "尽管我们后来确实找到了可以使用 Microsoft 技术栈的供应商，但我始终觉得它们并不受到重视，这让我对他们的技术能力有些担心。</p>

<p>14、</p>

<p><img src="https://www.wangbase.com/blogimg/asset/202002/bg2020022608.jpg" alt title></p>

<p>在成本上，菲律宾肯定比中国低，而且经常比印度低。根据现在的趋势，这种情况大概会保持很长一段时间。</p>

<p>在许多方面，菲律宾是世界上最好的。除了成本，他们还有这个价格的国家中最好的英语技能，友善的性格，以及我在中国观察到的相同的"可以做"的态度。</p>

<p>15、</p>

<p><img src="https://www.wangbase.com/blogimg/asset/202002/bg2020022609.jpg" alt title></p>

<p>最后，谈谈我的外包经验。</p>

<p>首先，外包是一种不稳定的商品，因为程序员是不稳定的，尤其是在印度。我们当时与一家孟买的开发商合作，花了很多时间和金钱培训一个叫做 Avni 的程序员，让她掌握所需的特定技术。这个项目进展顺利，但是有一天，Avni 离开了。我怀疑她要去生孩子了，根据我的经验，这种情况通常会在发生几个月后才通知你。开发商跟我们说不要担心，会给你找另一个 Avni，跟上一个一样！</p>

<p>开发人员不是可以替代的商品。你不能简单地用一个人去替代另一个人，然后期望他们同样地工作。我经常看到外包供应商信誓旦旦地断言，他们能够像更换厨房灯泡那样简单地更换程序员。这是一种危险的不称职的信念，表明对软件开发的实际情况有根本的误解。</p>

<p>16、</p>

<p><img src="https://www.wangbase.com/blogimg/asset/202002/bg2020022610.jpg" alt title></p>

<p>第二点，外包软件的质量，不一定能够在项目交付时看出来。通常要花上数月甚至数年的时间，才能意识到你所承担的"技术债务"的成本。供应商开发完软件，将其移交给客户之后，如果客户以后要添加功能，发现代码难以辨认，将花多少钱才能解决？在软件产品生命周期中，长期的成本通常被忽略，因为人们争先恐后地希望立即节省短期成本。</p>

<p>我从未见过，外包供应商为项目编写任何单元测试！他们没有自动化测试流程，总是用人工测试确保一切正常。开发人员甚至从未听说过自动化测试这种概念，因为编写额外的代码将花费更多的金钱，一切在他们看来理所当然。所以，外包项目的长期可维护性和成本是可怕的。</p>

<p>17、</p>

<p><img src="https://www.wangbase.com/blogimg/asset/202002/bg2020022611.jpg" alt title></p>

<p>第三点，如果想让外包成功，最好采用混合模式。不是"将所有事情外包"，而是"让我们的人与他们的人一起工作，各自做自己最擅长的事情"。</p>

<p>我花了大量时间，到世界各地的外包公司，培训他们的开发人员，跟他们的团队待在一起，交谈要开发的项目。我遇到了各种坏的故事，但也有一些非常积极的经历。</p>

<p>避免依赖外包组织中的个人，比如上文的 Avni，外包行业的人员流动性比一般情况大得多。相反地，应将重点放在让更多人一起参与，如果其中一个离开，你就不会损失太多的项目知识。</p>

<p>还可以多应用一些开发工具，比如代码质量检查工具、构建服务、版本管理等等，让工作过程变得更加可预测。</p>

<p>18、</p>

<p><img src="https://www.wangbase.com/blogimg/asset/202002/bg2020022612.jpg" alt title></p>

<p>第四点，也是最重要的一点，不要把小时费率视为外包成功的指标，不要根据报价的高低选择供应商。</p>

<p>外包给哪个供应商，通常是由公司内部对软件开发了解最少的人决定的。低报价吸引了他们，只考虑了短期成本和交付条件，没有将长期成本（诸如可维护性，可用性以及安全性之类的因素）考虑在内。因为公司的预算和业务目标总是聚焦在短期，难怪那些掌握资金却不了解技术的人做出了不明智的外包决策。</p>

<p>廉价的离岸外包是软件行业的麦当劳。因为需求量很大，外包公司就把软件开发做成了批量生产的产品。但如果你一直吃麦当劳，就不是很好。你最好将外包视为均衡饮食的一部分，做出明智的决定，不要因标价低而盲目选择，不考虑要支付的实际成本。</p>

<p>（完）</p>


<h3>文档信息</h3>
<ul>
<li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">创意共享3.0许可证</a>）</li>
<li>发表日期： <abbr class="published" title="2020-02-27T09:15:27+08:00">2020年2月27日</abbr></li>

</ul>
                                

                            

  <div style="display: inline-block ! important;width: 100%;">

  </div>

<p>留言（35条）</p>
<p>我现在教三年级的儿子学C语言编程，要求他无论是变量命名，还是写注释，全部使用英语，不会的就谷歌翻译，从小严格要求。</p>
        
<span class="vcard author"><a title="https://mp.weixin.qq.com/s/5c7aaokFZ3umLdnypNzQ9A" href="https://mp.weixin.qq.com/s/5c7aaokFZ3umLdnypNzQ9A" target="_blank" rel="nofollow">布莱恩特</a></span>

<p> 说：<br>                </p>
<p></p>
            
        
        <div class="comment-content" id="comment-quote-416445">
            <p>之前在外包工作过，之前在杭州待过一段时间，在qq群上看到一条招聘信息，说深圳坂田有一个岗位非常匹配，问我要不要试试，确实是·非常匹配·，不知道你们听没听说过xamarin？这玩意根本没人做，并非恶意去黑微软的移动快平台框架，招聘网站确实几乎没有啊。</p>

<p><br>
后来才知道我被‘三包’了，客户公司外包项目给大外包公司，大外包再外包一个人头，我太太太难，结果是非常悲剧的，我tm以为能长期做，至少也能做个一年半载，结果把我的小摩托车从杭州物流到深圳，花了860，后来骑了不到2个月，就被深圳交警没收。毕竟三无车辆，没收也是理所当然。</p>

<p>外包合同签了一年，一般都是一年，便于灵活操作。要人再招人，做完再释放，以此循环，毕竟外包公司是中间商赚差价。</p>

<p>后来，没出任何意外，项目按原计划3个月完成，我也不出意外的·被动离职了。</p>

<p>辞职之后，回到老家湖北，已经失业3个月了。</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
<abbr class="published" title="February 27, 2020 10:08 PM">2020年2月27日 22:08</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416445" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用布莱恩特的这条留言" onclick="return CommentQuote('comment-quote-416445','布莱恩特');">引用</a>
</p>
</div>
</div>
    

weston

<p> 说：<br>                </p>
<p></p>
            
        
        <div class="comment-content" id="comment-quote-416447">
            <p>实际上去东南亚的中国人并不是做外包，大部分是去做菠菜的，工资也比国内高一些，但是风险更是高了好几倍。菠菜现在已经演变成，大陆提供技术人员，香港提供资金，台湾提供运维和客服，面向的却是大陆市场，每年造成大量的金钱外流。</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
                   <abbr class="published" title="February 28, 2020  1:13 AM">2020年2月28日 01:13</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416447" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用weston的这条留言" onclick="return CommentQuote('comment-quote-416447','weston');">引用</a>
</p>
</div>
</div>
    

<div id="comment-416449" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
<span class="byline">

<p><span class="vcard author">ww</span></p>
<p> 说：<br>                </p></span></p>
<p>我现在教三年级的儿子学C语言编程，要求他无论是变量命名，还是写注释，全部使用英语，不会的就谷歌翻译，从小严格要求。</p>



<p>母语不是英语这种操作根本没用，因为一些英语专业词汇不是靠Google翻译就能表达的清的。</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
                   <abbr class="published" title="February 28, 2020  9:00 AM">2020年2月28日 09:00</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416449" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用ww的这条留言" onclick="return CommentQuote('comment-quote-416449','ww');">引用</a>
</p>
</div>
</div>
    </div>
</div>
<div id="comment-416455" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
                <span class="byline">
 <span class="vcard author">哼哼哈嘿</span>

<p> 说：<br>                </p></span></p>
<p></p>
            </div>
        </div>
        <div class="comment-content" id="comment-quote-416455">
            <blockquote>
<pre>引用江云的发言：</pre>

<p>印度人的英语真的好难听懂</p>

</blockquote>

<p>但是英美系国家的人反而可以和印度人几乎无障碍的沟通，且信息传达效率高。而东亚国家的英语口音似乎没那么重，但实际沟通起来却令人费解得多。个人认为，英语在中国的普及可能还需要一两代人才能实现，学习英语的确对理解世界大有裨益。</p>
</div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
<abbr class="published" title="February 28, 2020 11:10 AM">2020年2月28日 11:10</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416455" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用哼哼哈嘿的这条留言" onclick="return CommentQuote('comment-quote-416455','哼哼哈嘿');">引用</a>
</p>
</div>
</div>
    </div>
</div>
<div id="comment-416478" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
<span class="byline">
 <span class="vcard author">胡森</span>

<p> 说：<br></p></span></p>
<p></p>
</div>
        </div>
        <div class="comment-content" id="comment-quote-416478">
            <p>涨知识</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
                   <abbr class="published" title="February 28, 2020  3:47 PM">2020年2月28日 15:47</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416478" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用胡森的这条留言" onclick="return CommentQuote('comment-quote-416478','胡森');">引用</a>
</p>
</div>
</div>
    </div>
</div>
<div id="comment-416482" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
<span class="byline">
<span class="vcard author">hei</span>

<p> 说：<br></p></span></p>
<p></p>
 </div>
</div>
<div class="comment-content" id="comment-quote-416482">
            <p>涨知识了</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
<abbr class="published" title="February 28, 2020  4:57 PM">2020年2月28日 16:57</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416482" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用hei的这条留言" onclick="return CommentQuote('comment-quote-416482','hei');">引用</a>
</p>
</div>
</div>
    </div>
</div>
<div id="comment-416486" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
                <span class="byline">
 <span class="vcard author">无畏</span>

<p> 说：<br></p></span></p>
<p></p>
</div>
        </div>
        <div class="comment-content" id="comment-quote-416486">
            <p>能干成事儿的都是有本事的，绝大部分还是像咱们这种在国内发展平平出去也还是个渣渣</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
                   <abbr class="published" title="February 28, 2020  6:26 PM">2020年2月28日 18:26</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416486" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用无畏的这条留言" onclick="return CommentQuote('comment-quote-416486','无畏');">引用</a>
</p>
</div>
</div>
    </div>
</div>
<div id="comment-416495" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
                <span class="byline">
<span class="vcard author"><a title="https://blog.ifuture.pro/" href="https://blog.ifuture.pro/" target="_blank" rel="nofollow">ifuture</a></span>

<p> 说：<br></p></span></p>
<p></p>
            </div>
        </div>
        <div class="comment-content" id="comment-quote-416495">
            <p>其实最应该思考，我们应该怎么改变</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
                   <abbr class="published" title="February 29, 2020 10:55 AM">2020年2月29日 10:55</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416495" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用ifuture的这条留言" onclick="return CommentQuote('comment-quote-416495','ifuture');">引用</a>
</p>
</div>
</div>
    </div>
</div>
<div id="comment-416508" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
                <span class="byline">
<span class="vcard author">lliw</span>

<p> 说：<br>                </p></span></p>
<p></p>
            </div>
        </div>
        <div class="comment-content" id="comment-quote-416508">
            <blockquote>
<pre>引用bluesen的发言：</pre>

<p>我现在教三年级的儿子学C语言编程，要求他无论是变量命名，还是写注释，全部使用英语，不会的就谷歌翻译，从小严格要求。</p>

</blockquote>

<p>你是亲爹吗？</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
                   <abbr class="published" title="February 29, 2020  3:26 PM">2020年2月29日 15:26</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416508" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用lliw的这条留言" onclick="return CommentQuote('comment-quote-416508','lliw');">引用</a>
</p>
</div>
</div>
    </div>
</div>
<div id="comment-416513" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
                <span class="byline">
  <span class="vcard author"><a title="http://attilax" href="http://attilax" target="_blank" rel="nofollow">attilax</a></span>

<p> 说：<br>                </p></span></p>
<p></p>
            </div>
        </div>
        <div class="comment-content" id="comment-quote-416513">
            <blockquote>
<pre>引用lwl的发言：</pre>

<p></p>

<p>那岂不是比国内赚的钱还少？</p>

</blockquote>

<p>你不懂，哈哈，比上海更高赚的。。</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
                   <abbr class="published" title="February 29, 2020  9:01 PM">2020年2月29日 21:01</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416513" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用attilax的这条留言" onclick="return CommentQuote('comment-quote-416513','attilax');">引用</a>
</p>
</div>
</div>
    </div>
</div>
 <div id="comment-416514" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
                <span class="byline">
 <span class="vcard author">两仪院水月</span>

<p> 说：<br> </p></span></p>
<p></p>
            </div>
        </div>
        <div class="comment-content" id="comment-quote-416514">
            <p>正在外包 目前已经开始自动化，且自己就是项目组里的开发</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
                   <abbr class="published" title="February 29, 2020  9:08 PM">2020年2月29日 21:08</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416514" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用两仪院水月的这条留言" onclick="return CommentQuote('comment-quote-416514','两仪院水月');">引用</a>
</p>
</div>
</div>
    </div>
</div>
 <div id="comment-416525" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
                <span class="byline">
 <span class="vcard author"><a title="http://www.wekair.com" href="http://www.wekair.com" target="_blank" rel="nofollow">Kevin</a></span>

<p> 说：<br>                </p></span></p>
<p></p>
            </div>
        </div>
        <div class="comment-content" id="comment-quote-416525">
            <p>深刻地体会到，在不是英语系的国家要把英语学好确实很难。</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
                   <abbr class="published" title="March  2, 2020  9:27 AM">2020年3月 2日 09:27</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416525" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用Kevin的这条留言" onclick="return CommentQuote('comment-quote-416525','Kevin');">引用</a>
</p>
</div>
</div>
    </div>
</div>
<div id="comment-416526" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
                <span class="byline">
 <span class="vcard author"><a title="http://attilax" href="http://attilax" target="_blank" rel="nofollow">attilax</a></span>

<p> 说：<br>                </p></span></p>
<p></p>
            </div>
        </div>
        <div class="comment-content" id="comment-quote-416526">
            <blockquote>
<pre>引用哼哼哈嘿的发言：</pre>

<p></p>

<p>但是英美系国家的人反而可以和印度人几乎无障碍的沟通，且信息传达效率高。而东亚国家的英语口音似乎没那么重，但实际沟通起来却令人费解得多。个人认为，英语在中国的普及可能还需要一两代人才能实现，学习英语的确对理解世界大有裨益。</p>

</blockquote>

<p>没办法，谁让印度人和欧美都是一个种族呢。。。东南亚种族不同，做事方法不同差异大，<br>
</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
                   <abbr class="published" title="March  2, 2020 11:46 AM">2020年3月 2日 11:46</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416526" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用attilax的这条留言" onclick="return CommentQuote('comment-quote-416526','attilax');">引用</a>
</p>
</div>
</div>
    </div>
</div>
<div id="comment-416527" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
                <span class="byline">
 <span class="vcard author"><a title="http://andyron.com" href="http://andyron.com" target="_blank" rel="nofollow">AndyRon</a></span>

<p> 说：<br>                </p></span></p>
<p></p>
            </div>
        </div>
        <div class="comment-content" id="comment-quote-416527">
            <p>"技术债务"  哇，第一次听说</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
                   <abbr class="published" title="March  2, 2020  2:03 PM">2020年3月 2日 14:03</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416527" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用AndyRon的这条留言" onclick="return CommentQuote('comment-quote-416527','AndyRon');">引用</a>
</p>
</div>
</div>
    </div>
</div>
<div id="comment-416543" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
                <span class="byline">
 <span class="vcard author"><a title="http://没有" href="http://没有" target="_blank" rel="nofollow">岑小白</a></span>

<p> 说：<br>                </p></span></p>
<p></p>
            </div>
        </div>
        <div class="comment-content" id="comment-quote-416543">
            <p>“中国的优势之一（尤其跟印度相比）就是对需求文档的要求不高。中国有一种真正的"可以做"的态度，不管你提什么要求，他们都愿意拿起任何东西去尝试。不过，虽然他们对任何事情都会说"是"，但是实际上的意思很可能是"否"或别的，这里会存在风险。但是总的来说，我发现他们的适应性非常强，这是一大优势。”</p>

<p>----</p>

<p>翻译过来就是，操起键盘就能干，能不能成另说。</p>

<p>其实外包在远程工作中特别常见，但是说实话，专干互联网外包项目的公司就悬了，因为互联网项目能做三个月就已经是大项目！</p>

<p>这类项目不仅开发周期短，命也断。无论是短期线上活动还是官网、 APP， 甚至线下物联网项目做个能滚会说的“小机器人”，都是小跑快打，新手一直泡在这样的项目中自然难有技术积累。</p>

<p>再者，因为项目大多是一锤子买卖，少有长期运维或者版本升级迭代一说，所以公司单位时间承接的项目总量起伏特别大，员工会在闲死和忙死中反复切换！人员流动自然大了。</p>

<p>总之，互联网外包项目只适合经验丰富的小团队，不适合新手、菜鸟踩坑，这种项目就是赚快钱。三五个人把技术栈撸齐了，收入还是非常可观的，时间上也相对灵活可控，方便照顾家庭。</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
                   <abbr class="published" title="March  3, 2020 12:12 AM">2020年3月 3日 00:12</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416543" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用岑小白的这条留言" onclick="return CommentQuote('comment-quote-416543','岑小白');">引用</a>
</p>
</div>
</div>
    </div>
</div>
<div id="comment-416548" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
                <span class="byline">
<span class="vcard author">流浪码农</span>

<p> 说：<br>                </p></span></p>
<p></p>
            </div>
        </div>
        <div class="comment-content" id="comment-quote-416548">
            <p>这篇老外的文章写得蛮中肯，站在外国人的观点看中国，确实英语这方面要抓紧，我觉得中国是缺少英语环境，不是缺少能力，我跟外国人交流不用注重语法也能沟通</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
                   <abbr class="published" title="March  3, 2020 12:47 PM">2020年3月 3日 12:47</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416548" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用流浪码农的这条留言" onclick="return CommentQuote('comment-quote-416548','流浪码农');">引用</a>
</p>
</div>
</div>
    </div>
</div>
<div id="comment-416549" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
                <span class="byline">
<span class="vcard author">adc</span>

<p> 说：<br>                </p></span></p>
<p></p>
            </div>
        </div>
        <div class="comment-content" id="comment-quote-416549">
            <p>云程序员。。</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
                   <abbr class="published" title="March  3, 2020  1:48 PM">2020年3月 3日 13:48</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416549" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用adc的这条留言" onclick="return CommentQuote('comment-quote-416549','adc');">引用</a>
</p>
</div>
</div>
    </div>
</div>
<div id="comment-416556" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
                <span class="byline">
<span class="vcard author">Thinker</span>

<p> 说：<br>                </p></span></p>
<p></p>
            </div>
        </div>
        <div class="comment-content" id="comment-quote-416556">
            <blockquote>
<pre>引用daly的发言：</pre>

<p>正在外包工作，表示从未有过单元测试与自动化测试</p>

</blockquote>

<p>确实要做这些要多很多工作量</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
<abbr class="published" title="March  3, 2020  5:18 PM">2020年3月 3日 17:18</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416556" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用Thinker的这条留言" onclick="return CommentQuote('comment-quote-416556','Thinker');">引用</a>
</p>
</div>
</div>
    </div>
</div>
<div id="comment-416692" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
                <span class="byline">
 <span class="vcard author"><a title="http://www.91guangju.com" href="http://www.91guangju.com" target="_blank" rel="nofollow">我要吃肉</a></span>

<p> 说：<br>                </p></span></p>
<p></p>
            </div>
        </div>
        <div class="comment-content" id="comment-quote-416692">
            <p>确实英语环境不一样啊</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
                   <abbr class="published" title="March  8, 2020  6:53 PM">2020年3月 8日 18:53</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416692" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用我要吃肉的这条留言" onclick="return CommentQuote('comment-quote-416692','我要吃肉');">引用</a>
</p>
</div>
</div>
    </div>
</div>
<div id="comment-416693" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
                <span class="byline">
<span class="vcard author"><a title="http://www.91guangju.com" href="http://www.91guangju.com" target="_blank" rel="nofollow">guangju</a></span>

<p> 说：<br>                </p></span></p>
<p></p>
            </div>
        </div>
        <div class="comment-content" id="comment-quote-416693">
            <p>看来以后要加强英语水平了，毕竟有的新技术是英文原版，方便学习和交流啊</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
                   <abbr class="published" title="March  8, 2020  6:55 PM">2020年3月 8日 18:55</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416693" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用guangju的这条留言" onclick="return CommentQuote('comment-quote-416693','guangju');">引用</a>
</p>
</div>
</div>
    </div>
</div>
<div id="comment-416803" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
                <span class="byline">
 <span class="vcard author">Feng</span>

<p> 说：<br>                </p></span></p>
<p></p>
            </div>
        </div>
        <div class="comment-content" id="comment-quote-416803">
            <blockquote>
<pre>引用bluesen的发言：</pre>

<p>我现在教三年级的儿子学C语言编程，要求他无论是变量命名，还是写注释，全部使用英语，不会的就谷歌翻译，从小严格要求。</p>

</blockquote>

<p>大神，膜拜啊！三年级就被你推坑里去了！！</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
                   <abbr class="published" title="March 11, 2020  3:11 PM">2020年3月11日 15:11</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416803" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用Feng的这条留言" onclick="return CommentQuote('comment-quote-416803','Feng');">引用</a>
</p>
</div>
</div>
    </div>
</div>
<div id="comment-416860" class="comment">
    <div class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
                <span class="byline">
<span class="vcard author"><a title="http://www.leoseo.cn" href="http://www.leoseo.cn" target="_blank" rel="nofollow">吕民康</a></span>

<p> 说：<br>                </p></span></p>
<p></p>
            </div>
        </div>
        <div class="comment-content" id="comment-quote-416860">
            <blockquote>
<pre>引用bluesen的发言：</pre>

<p>我现在教三年级的儿子学C语言编程，要求他无论是变量命名，还是写注释，全部使用英语，不会的就谷歌翻译，从小严格要求。</p>

</blockquote>

<p>这个。。。你也要看他是不是适合，是不是喜欢编程这个东西吧。这个世界这么大， 孩子的未来是有无限可能性的，他可以靠其他的技能一样生活得很好。</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
                   <abbr class="published" title="March 13, 2020  9:37 PM">2020年3月13日 21:37</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416860" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用吕民康的这条留言" onclick="return CommentQuote('comment-quote-416860','吕民康');">引用</a>
</p>
</div>
</div>
    </div>
</div>
<div id="comment-416905" class="comment">
    <div id="comment-last" class="inner">
        <div class="comment-header">
            <div class="asset-meta">
<p>
                <span class="byline">
 <span class="vcard author">Q</span>

<p> 说：<br>                </p></span></p>
<p></p>
            </div>
        </div>
        <div class="comment-content" id="comment-quote-416905">
            <p>印度约两亿人（约占总人口1/7）说流利英语，这一点比菲律宾好，菲律宾人口才一亿多</p>
        </div>
<div class="comment-footer">
<div class="comment-footer-inner">
<p>
                   <abbr class="published" title="March 18, 2020 12:14 PM">2020年3月18日 12:14</abbr>
 | <a href="http://www.ruanyifeng.com/blog/2020/02/software-outsourcing.html#comment-416905" target="_blank" rel="noopener">#</a>
 | <a href="#comment-text" title="引用Q的这条留言" onclick="return CommentQuote('comment-quote-416905','Q');">引用</a>
</p>
</div>
</div>
    </div>
</div>
 </div>

]]></content>
      <categories>
        <category>talkabout</category>
      </categories>
      <tags>
        <tag>talkabout</tag>
      </tags>
  </entry>
  <entry>
    <title>一次面试经历</title>
    <url>/myblog/interview/%E6%AC%A1%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/</url>
    <content><![CDATA[<h4 id="面试场景"><a href="#面试场景" class="headerlink" title="面试场景"></a>面试场景</h4><a id="more"></a>
<p>面试官：自我介绍一下吧</p>
<p>程序员：你好，我毕业于XXX，工作3年了，最近的工作主要是负责在柬埔寨做移动支付钱包（聚合支付的项目，让柬埔寨当地华人能使用微信、支付宝支付），吧啦吧吧…….</p>
<p>面试官：你项目这块儿功能是怎么实现的呢xxxxxxxxx吧啦吧啦….为什么选择使用这个技术实现..吧啦吧啦…..</p>
<p>程序员：这块儿的功能是使用xxxxxxx吧啦吧啦…….</p>
<p>面试官：看到你写到熟练掌握Java语言的高级特性，简单介绍一下Bean SpringBean一个注入过程吧</p>
<p>程序员：Bean的注入过程……首先是从配置文件（注解）里面把它和对象…..额，我对这方面还是不太熟悉</p>
<p>面试官：没事没事….我们接着往下聊</p>
<p>程序员：尴尬一笑</p>
<p>面试官：我看大你写到你了解一些高级特性，你能给我简单的介绍一下Java8有哪些新特性吗，或者你比较擅长的新特性有哪些？</p>
<p>程序员：Java8主要就是在语法上就是lambda表达式，它可以用函数式进行那个函数式编程，函数式接口的意思就是它这个接口它只有一个方法…..</p>
<p>面试官：还有别的吗？</p>
<p>程序员：还有一些流的操作，比如：Stream API它可以简化编程语义，显得更清晰，比如在做一个filter功能，就可以绑定数据把不符合要求的数据过滤掉，就在以前的话写一个for循环，看起来就没那么好理解….然后对于数据结构进行了一些优化，像ConcurrentHashMap，它底层实现改成了红黑树…..</p>
<p>面试官：你刚刚说的都是一些优化，我问的是它新加的一些高级特性</p>
<p>程序员：再次尴尬一笑…..</p>
<p>面试官：你刚刚提到它的流式处理，那对比像foreach或者基本的for循环，它有没有在效率上进行优化，还是说它更慢了？你有去了解过吗？</p>
<p>程序员：额…没有</p>
<p>面试官：我看你说对并发编程有些了解，你能跟我讲一下Synchronized和Lock锁它的底层实现原理吗？</p>
<p>程序员：啊….Synchronized是一个语义级的支持，它在一个对象头里面，它有一个Mark Word的标记去记录它的锁，Lock显示锁是利用了它底层是一个AQS，它式一个双向链表的先进先出的一个队列，它只有当前持有锁的线程就是一个对头，然后它释放出来之后，就会利用一个自旋的操作，让下一个线程作为队头这样子</p>
<p>面试官：那它们两个分别是什么层面的呢，是jdk层面还是JVM层面，还是？</p>
<p>程序员：Synchronized是JVM层面的，Lock是jdk层面的</p>
<p>面试官：刚刚你说到了Synchronized，你有去了解过它锁方法、锁对象和锁代码块分别是怎么去实现的吗？</p>
<p>程序员：额…..这个没有</p>
<p>面试官：那你了解Synchronized锁升级过程吗？</p>
<p>程序员：没有….</p>
<p>面试官：那刚刚提到了Lock，CAS你能给我简单的介绍一下吗？</p>
<p>程序员：CAS就是比较并交换</p>
<p>面试官：恩恩，提到这点就可以了，那你有在实际开发过程中有实际的一些应用吗？应用到乐观锁的一个过程</p>
<p>程序员：有的，就譬如，我在更新数据库的时候，如果一个数据库用的是乐观锁的话，我也用一个自旋的操作，就把他更新到成功为止</p>
<p>面试官：自旋的效率会不会很低？如果一直取不到这个锁的话，那可能会造成一些线程堵塞，或者在高并发场景下其他的会影响到很多效率，有考虑到这个问题吗？</p>
<p>程序员：也考虑到了…..如果并发高的时候确实不太适用用自旋，这个时候更适合用悲观锁</p>
<p>面试官：那跟我聊一下线程池吧</p>
<p>程序员：线程池是…..我还是先说一下它的工作流程，再变成先提交进来，它先进入核心吃里面，如果线程书大于coreSize，就会进入一个阻塞队列，阻塞队列满了后就会新建一些线程，进入最大的池里面；当线程数，连maxSize的超出了之后，它就会执行一个拒绝策略，JDK自带的拒绝策略有四种：一种是直接丢弃；一种是抛异常；一种是由调用者的线程执行；一种是丢弃阻塞队列里面等待时间最长的一个线程</p>
<p>面试官：我看你简历上还提到了熟练掌握JVM调优的知识，我能问一下你了解它调优的一些基本步骤吗？</p>
<p>程序员：啊….一口老血，调优的基本步骤….就譬如，我从…恩..我从OOM说起吧….如果生产上发生一个OOM异常，首先是要判断它是在堆里面发生的还是元空间里面，还有……它还有一种类型就是GC效率过低…..吧啦吧啦</p>
<p><img src="https://img-blog.csdnimg.cn/20200909132324691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200909132324524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020090913232345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200909132322991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>面试官：我看你基本上都是待了一年就离职了，你能说一下你离职的原因吗？</p>
<p>程序员：………</p>
<p>面试官：你对自己职业规划大概是什么样的？</p>
<p>程序员：往互联网金融行业走</p>
<p>面试官：你有什么想问我的？</p>
<p>程序员：问了一些之前没太懂的</p>
<blockquote>
<p>面试总结：从这场面试官中可以看出，面试官没有深问，不然估计80%的内容都答不上来，基本上都是偏基础的东西，底层的内容没有怎么问，写了个Dubbo在简历上，面试官都没有问他Spring Cloud，Hystrix容器这些，连bus都可以问出一堆东西，一旦问了真的就只有尴尬了，问到怀疑人生。</p>
</blockquote>
<h4 id="如何备战面试"><a href="#如何备战面试" class="headerlink" title="如何备战面试"></a>如何备战面试</h4><p>首先，像这位朋友一样，可以去投一些小公司的简历，去面试扫盲，看看哪些东西不会，欠缺哪些知识，然后回家做面试复盘。</p>
<p>针对自己简历做优化，不要搞得写了一个Dubbo，然后面试官稍微往深一点问你就答不出来了。简历上注意以下三点：</p>
<blockquote>
<p>（1）注意区分：了解，熟悉，精通，不要乱写，面试官很多问题都是根据简历描述来进行的；</p>
</blockquote>
<blockquote>
<p>（2）专业知识和项目经验在精不在多，尤其是项目经验一定要写自己熟悉的且有内容可说的，不要认为写得越多越好；</p>
</blockquote>
<blockquote>
<p>（3）要熟悉自己的简历内容，准确掌握，最好是多阅读自己的简历。</p>
</blockquote>
<h4 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h4><p>大家可以把Java基础，JVM，并发编程，MySQL，Redis，Spring，Spring Boot、Spring cloud等等做一个知识总结以及延伸，再去进行操作，不然光记是学不会的。</p>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>无论是哪家公司，都很重视基础，大厂更加重视技术的深度和广度，面试是一个双向选择的过程，不要抱着畏惧的心态去面试，不利于自己的发挥。同时看中的应该不止薪资，还要看你是不是真的喜欢这家公司，长远来看是不是能真的得到锻炼。</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>大型网站一般架构技术</title>
    <url>/myblog/talkabout/%E5%9E%8B%E7%BD%91%E7%AB%99%E4%B8%80%E8%88%AC%E6%9E%B6%E6%9E%84%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h3 id="一、-前端架构"><a href="#一、-前端架构" class="headerlink" title="一、  前端架构"></a>一、  前端架构</h3><p>前端指用户请求到达网站应用服务器之前经历的环节，通常不包含网站业务逻辑，不处理动态内容。</p>
<a id="more"></a>
<p>（1）    浏览器优化技术；</p>
<p>（2）    CDN；</p>
<p>（3）    动静分离，静态资源独立部署；</p>
<p>（4）    图片服务；</p>
<p>（5）    反向代理；</p>
<p>（6）    DNS：域名服务，将域名解析成IP地址，利用DNS可以实现DNS负载均衡，配置CDN也需要修改DNS，使域名解析后指向CDN服务器。</p>
<h3 id="二、-应用层架构"><a href="#二、-应用层架构" class="headerlink" title="二、  应用层架构"></a>二、  应用层架构</h3><p>应用层是处理网站主要业务逻辑的地方</p>
<p>（1）    开发框架；</p>
<p>（2）    页面渲染；</p>
<p>（3）    负载均衡；</p>
<p>（4）    Session管理；</p>
<p>（5）    动态页面静态化；</p>
<p>（6）    业务拆分；</p>
<p>（7）    虚拟化服务器；</p>
<h3 id="三、-服务层架构"><a href="#三、-服务层架构" class="headerlink" title="三、  服务层架构"></a>三、  服务层架构</h3><p>提供基础服务，供应用层调用，完成网站业务。</p>
<p>（1）    分布式消息：利用消息队列机制，实现业务与业务、业务和服务之间的异步消息发送及低耦合的业务关系；</p>
<p>（2）    分布式服务；提供高性能、低耦合、易复用、易管理的分布式服务，在网站实现面向服务架构（SOA）；</p>
<p>（3）    分布式缓存：通过可伸缩的服务器集群提供大规模热点数据的缓存服务，是网站性能优化的重要手段；</p>
<p>（4）    分布式配置；</p>
<h3 id="四、-存储层架构"><a href="#四、-存储层架构" class="headerlink" title="四、  存储层架构"></a>四、  存储层架构</h3><p>提供数据、文件的持久化存储访问与管理服务。</p>
<p>（1）    分布式文件；</p>
<p>（2）    关系数据库；</p>
<p>（3）    NoSQL数据库；</p>
<p>（4）    数据同步；</p>
<h3 id="五、-后台架构"><a href="#五、-后台架构" class="headerlink" title="五、  后台架构"></a>五、  后台架构</h3><p>网站应用中，除了要处理用户的实时访问请求外，还有一些后台非实时数据分析要处理。</p>
<p>（1）    搜索引擎：即使是网站内部的搜索引擎，也需要进行数据增量更新及全量更新、构建索引等。这些操作通过后台系统定时执行；</p>
<p>（2）    数据仓库：根据离线数据，提供数据分析与数据挖掘服务；</p>
<p>（3）    推荐系统：社交网站及购物网站通过挖掘任何人之间的关系，任何商品之间的关系，发觉潜在的人际关系和购物兴趣，为用户提供个性化推荐服务；</p>
<h3 id="六、-数据采集与监控"><a href="#六、-数据采集与监控" class="headerlink" title="六、  数据采集与监控"></a>六、  数据采集与监控</h3><p>监控网站访问情况与系统运行情况，为网站运营决策和运维管理提供支持保障。</p>
<p>（1）    浏览器数据采集：通过在网站页面中嵌入JS脚本采集用户浏览器环境与操作记录，分析用户行为；</p>
<p>（2）    服务器业务数据采集：服务器业务数据包括两种，一种是采集在服务端记录的用户请求操作日志；一种是采集应用程序运行期业务数据，比如待处理消息数目等；</p>
<p>（3）    服务器性能数据采集；</p>
<p>（4）    系统监控；</p>
<p>（5）    系统报警；</p>
<h3 id="七、-安全架构"><a href="#七、-安全架构" class="headerlink" title="七、  安全架构"></a>七、  安全架构</h3><p>保护网站免遭攻击及敏感信息泄露。</p>
<p>（1）    Web攻击；</p>
<p>（2）    数据保护；</p>
<h3 id="八、-数据中心机房架构"><a href="#八、-数据中心机房架构" class="headerlink" title="八、  数据中心机房架构"></a>八、  数据中心机房架构</h3><p>大型网站需要的服务器规模数以万计，机房物理架构也需要关注。</p>
<p>（1）    机房架构</p>
<p>（2）    机柜架构</p>
<p>（3）    服务器架构</p>
]]></content>
      <categories>
        <category>talkabout</category>
      </categories>
      <tags>
        <tag>talkabout</tag>
      </tags>
  </entry>
  <entry>
    <title>综合面试题02</title>
    <url>/myblog/interview/%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%982/</url>
    <content><![CDATA[<p>综合面试题02</p>
<a id="more"></a>
<h4 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h4><p>1、 Java语言有哪些特点，JDK与JRE的区别</p>
<p>2、面向对象和面向过程的区别</p>
<p>3 、八种基本数据类型的大小，以及他们的封装类</p>
<p>4、标识符的命名规则。</p>
<p>5、instanceof 关键字的作用</p>
<p>6、Java自动装箱与拆箱</p>
<p>7、 重载和重写的区别</p>
<p>8、 equals与==的区别，==与===的区别</p>
<p>9、 Hashcode的作用</p>
<p>10、String、String StringBuffer 和 StringBuilder 的区别是什么?</p>
<p>11、ArrayList和linkedList的区别</p>
<p>12、 HashMap和HashTable的区别</p>
<p>13、 Collection包结构，与Collections的区别</p>
<p>14、 Java的四种引用，强弱软虚</p>
<p>15、 泛型常用特点</p>
<p>16、Java创建对象有几种方式？</p>
<p>17、有没有可能两个不相等的对象有相同的hashcode</p>
<p>18、深拷贝和浅拷贝的区别是什么?</p>
<p>19、final有哪些用法?</p>
<p>20、static都有哪些用法?</p>
<p>21、3*0.1==0.3返回值是什么</p>
<p>22、a=a+b与a+=b有什么区别吗</p>
<p>23、try catch finally，try里有return，finally还执行么？</p>
<p>24、 Excption与Error包结构</p>
<p>25、OOM你遇到过哪些情况，SOF你遇到过哪些情况</p>
<p>26、 简述线程、程序、进程的基本概念。以及他们之间关系是什么?</p>
<p>27、线程有哪些基本状态?</p>
<p>28、Java 序列化中如果有些字段不想进行序列化，怎么办？</p>
<p>29、Java 中 IO 流</p>
<p>30、 Java IO与 NIO的区别</p>
<p>31、java反射的作用于原理</p>
<p>32、说说List,Set,Map三者的区别</p>
<p>33、java类与类之间的关系有哪些</p>
<p>34、int i = 1;执行 i++ 与 ++i  有什么区别</p>
<h4 id="JVM篇"><a href="#JVM篇" class="headerlink" title="JVM篇"></a>JVM篇</h4><p>1、知识点汇总</p>
<p>2、知识点详解：</p>
<p>3、类加载与卸载</p>
<p>4、简述一下JVM的内存模型 - 线程私有区 - 线程共享区</p>
<p>5、堆和栈的区别</p>
<p>6、 什么时候会触发FullGC</p>
<p>7、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？</p>
<p>8、Java内存结构</p>
<p>9、对象分配规则</p>
<p>10、描述一下JVM加载class文件的原理机制？</p>
<p>11、Java对象创建过程</p>
<p>12、类的生命周期</p>
<p>13、简述Java的对象结构</p>
<p>14、如何判断对象可以被回收？</p>
<p>15、JVM的永久代中会发生垃圾回收么？</p>
<p>16、垃圾收集算法</p>
<p>17、调优命令有哪些？</p>
<p>18、调优工具</p>
<p>19、Minor GC与Full GC分别在什么时候发生？</p>
<p>20、你知道哪些JVM性能调优</p>
<h4 id="多线程-amp-并发篇"><a href="#多线程-amp-并发篇" class="headerlink" title="多线程&amp;并发篇"></a>多线程&amp;并发篇</h4><p>1、Java中实现多线程有几种方法</p>
<p>2、如何停止一个正在运行的线程</p>
<p>3、notify()和notifyAll()有什么区别？</p>
<p>4、sleep()和wait() 有什么区别？</p>
<p>5、volatile 是什么?可以保证有序性吗?</p>
<p>6、Thread 类中的start() 和 run() 方法有什么区别？</p>
<p>7、为什么wait, notify 和 notifyAll这些方法不在thread类里面？</p>
<p>8、为什么wait和notify方法要在同步块中调用？</p>
<p>9、Java中interrupted 和 isInterruptedd方法的区别？</p>
<p>10、Java中synchronized 和 ReentrantLock 有什么不同？</p>
<p>11、有三个线程T1,T2,T3,如何保证顺序执行？</p>
<p>12、SynchronizedMap和ConcurrentHashMap有什么区别？</p>
<p>13、什么是线程安全</p>
<p>14、Thread类中的yield方法有什么作用？</p>
<p>15、Java线程池中submit() 和 execute()方法有什么区别？</p>
<p>16、说一说自己对于 synchronized 关键字的了解</p>
<p>17、说说自己是怎么使用 synchronized 关键字，在项目中用到了吗synchronized关键字最主要的三种使用方式：</p>
<p>18、什么是线程安全？Vector是一个线程安全类吗？</p>
<p>19、 volatile关键字的作用？</p>
<p>20、常用的线程池有哪些？</p>
<p>21、简述一下你对线程池的理解</p>
<p>22、Java程序是如何执行的</p>
<h6 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h6><p>1）现在有三个线程：T1、T2和T3。如何确保T2在T1完成后执行，T3在T2完成后执行？</p>
<blockquote>
<p>这个线程问题通常在第一阶段或电话面试阶段询问，以确定您是否熟悉“连接”方法。此多线程问题比较简单，可以在联接方法中实现。</p>
</blockquote>
<p>2）在java锁接口优势比同步块是什么？您需要实现一个高效的高速缓存，允许多个用户读取，但只允许一个用户写入，以保持其完整性。你是如何实现的？</p>
<blockquote>
<p>在多线程和并发编程锁接口最大的优势是，他们对阅读和写作分别提供锁，可以满足高性能的数据结构和条件阻止你写像ConcurrentHashMap。java线程的面试问题越来越基于面试官的答案变得。我强烈建议您在进行多线程访问之前仔细阅读锁，因为现在它被广泛用于为电子事务构建客户端缓存和事务连接空间。</p>
</blockquote>
<p>3）在java的等待和睡眠的方法之间的区别吗？</p>
<blockquote>
<p>java线程的面试往往是在电话采访中问。最大的区别是，当等待等待时，锁被释放，睡眠锁住了锁。等待通常用于线程间交互，而休眠通常用于暂停执行。</p>
</blockquote>
<p>4）阻塞队列是用java实现的。</p>
<blockquote>
<p>这是一个比较困难的多线程面试问题，它可以达到很多的目标。首先，它可以检测应试者是否可以与java线程编写程序。其次，它可以检测考生对并发场景的理解，并在此基础上提出许多问题。如果他用等待（）和通知（）方法来实现阻塞队列，你可以请他写了最新的java 5并发。</p>
</blockquote>
<p>5）编写的代码在java解决生产者消费者问题。</p>
<blockquote>
<p>这与上面的问题很相似，但这是一个比较经典的问题，有时面试会问以下问题。有，当然，很多的解决方案如何解决java生产者消费者问题，我已经分享了一个阻塞队列的方法。有时他们甚至问如何做哲学家的饭。</p>
</blockquote>
<p>6）编程程序，用java可能导致死锁，你将如何解决呢？</p>
<blockquote>
<p>这是我最喜欢的java线程面试问题，因为即使是很常见的死锁问题的时候写的多线程的并发程序，很多考生不能写无死锁的代码（无死锁的代码）。他们在挣扎。只要告诉他们你有N个资源和N个线程，你需要所有的资源来做一个操作。为了简单地将n替换为2，数据越大会使问题看起来更复杂。关于死锁的更多信息是通过避免在java死锁了。</p>
</blockquote>
<p>7）原子操作是什么，什么是java的原子操作？</p>
<blockquote>
<p>一个很简单的java线程面试问题，接下来的问题是，你需要同步一个原子操作。</p>
</blockquote>
<p>8）在java中挥发性的关键的作用是什么？怎么用它？从同步方法在java的区别是什么？</p>
<blockquote>
<p>由于java 5和java内存模式发生了改变，基于关键字volatile的线程问题越来越受关注。你应该准备回答如何能确保volatile变量的可见性，sequentility，在并行环境的一致性。</p>
</blockquote>
<p>9）竞争的条件是什么？你如何找到并解决竞争？</p>
<blockquote>
<p>这是在多线程面试的高级阶段出现的问题。大多数面试官都在问你最近遇到的竞争环境，以及你如何解决这些问题。有时候他们会编写简单的代码，然后让你发现代码的竞争条件。你可以参考我之前的文章对java的竞争条件。在我看来，这是一个最好的java线程面试问题。它可以检测该候选人的经验来解决竞争条件完全相同，或写作，这是免费的数据种族或种族代码，”“这是最好的书“java”并行的实践。</p>
</blockquote>
<p>10）如何使用线程转储？你将如何分析线程转储？</p>
<blockquote>
<p>在UNIX中，您可以使用杀- 3，线程转储将打印日志，您可以在Windows中使用“Ctrl +中断”。这是一个非常简单和专业的线程面试问题，但如果他问你如何分析它，这将是棘手的。</p>
</blockquote>
<p>11）为什么我们在调用开始（）方法时执行run（）方法，为什么我们不能直接调用run（）方法呢？</p>
<blockquote>
<p>这是一个非常经典的java多线程面试问题。这也是我刚开始编写线程程序时的一个难题。现在这个问题通常是在电话面试或在第一中级java面试第一轮问。这个问题的答案应该是，当你调用开始（）方法时，你将创建一个新的线程并在run（）方法中执行代码。但是，如果直接调用run（）方法，它不会创建一个新线程，也不会执行调用线程的代码。阅读我之前写过的关于启动和运行方法之间的差异的文章，以便获得更多信息。</p>
</blockquote>
<p>12）你如何唤醒阻塞的线程在java？</p>
<blockquote>
<p>这是线程和阻塞的一个棘手问题，它有很多解决方案。如果线程被IO阻塞了，我认为没有办法停止线程。如果线程通过调用等待阻塞（），睡眠（），或加入（），您可以中断线程和投掷它唤醒InterruptedException。如何处理阻塞方法在java，我早些时候写的，有很多关于处理阻塞的线程信息。</p>
</blockquote>
<p>13）在java CycliBarriar和countdownlatch之间的区别是什么？</p>
<blockquote>
<p>这个线程的问题主要是用来检测你是否熟悉JDK5并发包。两者的区别是，cyclicbarrier可以重用已经过去，countdownlatch不能重用的障碍。</p>
</blockquote>
<p>14）什么是不可变对象，它对编写并发应用程序有什么帮助？</p>
<blockquote>
<p>另一个多线程的经典面试问题与线程无关，但它有很大帮助。这个java面试问题是非常棘手的，如果他要求你写一个不可变的对象，或者问你为什么字符串是不可变的。</p>
</blockquote>
<p>15）在多线程环境中遇到的常见问题是什么？你是怎么解决的？</p>
<blockquote>
<p>经常遇到的多线程和内存接口，工艺复杂的竞争条件，死锁，活锁和饥饿。这个问题没有尽头。如果你犯了一个错误，很难找到和调试。这是最基础的面试，不是java线程的问题，根据实际应用。</p>
</blockquote>
<h4 id="Spring篇"><a href="#Spring篇" class="headerlink" title="Spring篇"></a>Spring篇</h4><p>1、 Spring的IOC和AOP机制？</p>
<p>2、 Spring中Autowired和Resource关键字的区别？</p>
<p>3、依赖注入的方式有几种，各是什么?</p>
<p>4、讲一下什么是Spring</p>
<p>5、Spring MVC流程</p>
<p>6、SpringMVC怎么样设定重定向和转发的？</p>
<p>7、 SpringMVC常用的注解有哪些？</p>
<p>8、 Spring的AOP理解：</p>
<p>9、Spring的IOC理解</p>
<p>10、解释一下spring bean的生命周期</p>
<p>11、 解释Spring支持的几种bean的作用域。</p>
<p>12、 Spring基于xml注入bean的几种方式：</p>
<p>13、Spring框架中都用到了哪些设计模式？</p>
<p>14、简述下pring事务</p>
<h4 id="MyBatis篇"><a href="#MyBatis篇" class="headerlink" title="MyBatis篇"></a>MyBatis篇</h4><p>1、什么是MyBatis</p>
<p>2、MyBatis的优点和缺点</p>
<p>3、#{}和${}的区别是什么？</p>
<p>4、当实体类中的属性名和表中的字段名不一样 ，怎么办 ？</p>
<p>5、Mybatis是如何进行分页的？分页插件的原理是什么？</p>
<p>6、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</p>
<p>7、 如何执行批量插入？</p>
<p>8、Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？</p>
<p>9、MyBatis实现一对一有几种方式?具体怎么操作的？</p>
<p>10、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</p>
<p>11、Mybatis的一级、二级缓存。</p>
<h4 id="SpringBoot篇"><a href="#SpringBoot篇" class="headerlink" title="SpringBoot篇"></a>SpringBoot篇</h4><p>1、什么是SpringBoot？为什么要用SpringBoot</p>
<p>2、Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</p>
<p>3、运行Spring Boot有哪几种方式？</p>
<p>4、如何理解 Spring Boot 中的 Starters？</p>
<p>5、 如何在Spring Boot启动的时候运行一些特定的代码？</p>
<p>6、 Spring Boot 需要独立的容器运行吗？</p>
<p>7、 Spring Boot中的监视器是什么？</p>
<p>8、 如何使用Spring Boot实现异常处理？</p>
<p>9、 你如何理解 Spring Boot 中的 Starters？</p>
<p>10、 springboot常用的starter有哪些</p>
<p>11、 SpringBoot 实现热部署有哪几种方式？</p>
<p>12、 Spring Boot如何实现初始化，如何理解 Spring Boot 配置加载顺序？</p>
<p>13、 Spring Boot 的核心配置文件有哪几个？它们的区别是什么？</p>
<p>14、如何集成 Spring Boot 和 ActiveMQ？</p>
<p>15、如何重新加载Spring Boot上的更改，而无需重新启动服务器？</p>
<p>16、 Spring Boot、Spring MVC 和 Spring 有什么区别？</p>
<p>17、 能否举一个例子来解释更多 Staters 的内容？</p>
<p>18、 Spring Boot 还提供了其它的哪些 Starter Project Options？</p>
<p>19、如何自定义一个Starter</p>
<h4 id="MySQL篇"><a href="#MySQL篇" class="headerlink" title="MySQL篇"></a>MySQL篇</h4><p>1、数据库的三范式是什么</p>
<p>2、数据库引擎有哪些</p>
<p>3、InnoDB与MyISAM的区别</p>
<p>4、数据库的事务</p>
<p>5、索引问题</p>
<p>6、SQL优化</p>
<p>7、简单说一说drop、delete与truncate的区别</p>
<p>8、什么是视图</p>
<p>9、 什么是内联接、左外联接、右外联接？</p>
<p>10、并发事务带来哪些问题?</p>
<p>11、事务隔离级别有哪些?MySQL的默认隔离级别是?</p>
<p>12、大表如何优化？</p>
<ol>
<li><p>限定数据的范围</p>
</li>
<li><p>读/写分离</p>
</li>
<li><p>垂直分区</p>
</li>
<li><p>水平分区</p>
</li>
</ol>
<p>13、分库分表之后,id 主键如何处理？</p>
<p>14、mysql有关权限的表都有哪几个</p>
<p>15、mysql有哪些数据类型</p>
<p>16、创建索引的三种方式，删除索引</p>
<h4 id="Redis篇"><a href="#Redis篇" class="headerlink" title="Redis篇"></a>Redis篇</h4><p>1、Redis持久化机制</p>
<p>2、缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题</p>
<p>3、热点数据和冷数据是什么</p>
<p>4、Memcache与Redis的区别都有哪些？</p>
<p>5、单线程的redis为什么这么快</p>
<p>6、redis的数据类型，以及每种数据类型的使用场景</p>
<p>7、redis的过期策略以及内存淘汰机制</p>
<p>8、Redis 为什么是单线程的</p>
<p>9、Redis 常见性能问题和解决方案？</p>
<p>10、为什么Redis的操作是原子性的，怎么保证原子性的？</p>
<p>11、Redis事务</p>
<h4 id="SpringCloud篇"><a href="#SpringCloud篇" class="headerlink" title="SpringCloud篇"></a>SpringCloud篇</h4><p>1、什么是SpringCloud</p>
<p>2、什么是微服务</p>
<p>3、SpringCloud有什么优势</p>
<p>4、 什么是服务熔断？什么是服务降级？</p>
<p>5、 Eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？</p>
<p>6、SpringBoot和SpringCloud的区别？</p>
<p>7、负载平衡的意义什么？</p>
<p>8、什么是Hystrix？它如何实现容错？</p>
<p>9、什么是Hystrix断路器？我们需要它吗？</p>
<p>10、说说 RPC 的实现原理</p>
<h4 id="Nginx篇"><a href="#Nginx篇" class="headerlink" title="Nginx篇"></a>Nginx篇</h4><p>1、简述一下什么是Nginx，它有什么优势和功能？</p>
<p>2、Nginx是如何处理一个HTTP请求的呢？</p>
<p>3、列举一些Nginx的特性</p>
<p>4、请列举Nginx和Apache 之间的不同点</p>
<p>5、在Nginx中，如何使用未定义的服务器名称来阻止处理请求？</p>
<p>6、请解释Nginx服务器上的Master和Worker进程分别是什么?</p>
<p>7、请解释代理中的正向代理和反向代理</p>
<p>8、解释Nginx用途</p>
<h4 id="MQ篇"><a href="#MQ篇" class="headerlink" title="MQ篇"></a>MQ篇</h4><p>1、为什么使用MQ</p>
<p>2、MQ优缺点</p>
<p>3、Kafka、ActiveMQ、RabbitMQ、RocketMQ 都有什么区别？</p>
<p>4、如何保证高可用的？</p>
<p>5、如何保证消息的可靠传输？如果消息丢了怎么办</p>
<p>6、如何保证消息的顺序性</p>
<p>7、 如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？</p>
<p>8、设计MQ的思路</p>
<h5 id="数据结构与算法篇"><a href="#数据结构与算法篇" class="headerlink" title="数据结构与算法篇"></a>数据结构与算法篇</h5><p>1、常用的数据结构 - 1. 数组 - 2. 栈 - 3. 队列 - 4. 链表 - 5. 图 - 6. 树 - 7. 前缀树 - 8. 哈希表</p>
<p>2、 数据里有{1,2,3,4,5,6,7,8,9}，请随机打乱顺序，生成一个新的数组（请以代码实现）</p>
<p>3、 写出代码判断一个整数是不是2的阶次方（请代码实现，谢绝调用API方法）</p>
<p>4、 假设今日是2015年3月1日，星期日，请算出13个月零6天后是星期几，距离现在多少天（请用代码实现，谢绝调用API方法）</p>
<p>5、 有两个篮子，分别为A 和 B，篮子A里装有鸡蛋，篮子B里装有苹果，请用面向对象的思想实现两个篮子里的物品交换（请用代码实现）</p>
<p>6、更多算法练习</p>
<h4 id="Linux篇"><a href="#Linux篇" class="headerlink" title="Linux篇"></a>Linux篇</h4><p>1、 绝对路径用什么符号表示？当前目录、上层目录用什么表示？主目录用什么表示? 切换目录用什么命令？</p>
<p>2、 怎么查看当前进程？怎么执行退出？怎么查看当前路径？</p>
<p>3、查看文件有哪些命令</p>
<p>4、列举几个常用的Linux命令</p>
<p>5、你平时是怎么查看日志的？</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>如何设计一个高并发系统</title>
    <url>/myblog/spring-cloud/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h4 id="1、面试题"><a href="#1、面试题" class="headerlink" title="1、面试题"></a>1、面试题</h4><p>如何设计一个高并发系统？</p>
<a id="more"></a>
<h4 id="2、面试官心里分析"><a href="#2、面试官心里分析" class="headerlink" title="2、面试官心里分析"></a>2、面试官心里分析</h4><p>说实话，如果面试官问你这个题目，那么你必须要使出全身吃奶劲了。为啥？因为你没看到现在很多公司招聘的jd里都是说啥，有高并发就经验者优先。</p>
<p>所以如果你确实有真才实学，在互联网公司里干过高并发系统，那你确实拿offer基本如探囊取物，没啥问题。但是如果你要是真是干过高并发系统，面试官绝对绝对不会问这个问题，否则他就不太明智了。</p>
<p>假设你在某知名电商公司干过高并发系统，用户上亿，一天流量几十亿，高峰期并发量上万，甚至是十万。那么人家一定会仔细盘问你的系统架构，你们系统啥架构？怎么部署的？部署了多少台机器？缓存咋用的？MQ咋用的？数据库咋用的？就是深挖你到底是如何抗下高并发的。</p>
<p>因为真正干过高并发的人一定知道，脱离了业务的系统架构都是在纸上谈兵，真正在复杂业务场景而且还高并发的时候，那系统架构一定不是那么简单的，用个redis，用mq就能搞定？当然不是，真实的系统架构搭配上业务之后，会比这种简单的所谓“高并发架构”要复杂很多倍。</p>
<p>如果有面试官问你个问题说，如何设计一个高并发系统？那么不好意思，一定是因为你实际上没干过高并发系统。面试官看你简历就没啥出彩的，感觉就不咋地，所以就会问问你，如何设计一个高并发系统？其实说白了本质就是看看你有没有自己研究过，有没有一定的知识积累。</p>
<p>最好的当然是招聘个真正干过高并发的哥儿们咯，但是这种哥儿们人数稀缺，不好招。所以可能次一点的就是招一个自己研究过的哥儿们，总比招一个啥也不会的哥儿们好吧！</p>
<p>所以这个时候你必须得做一把个人秀了，秀出你所有关于高并发的知识！</p>
<h4 id="3、面试题剖析"><a href="#3、面试题剖析" class="headerlink" title="3、面试题剖析"></a>3、面试题剖析</h4><p>其实所谓的高并发，如果你要理解这个问题呢，其实就得从高并发的根源出发，为啥会有高并发？为啥高并发就很牛逼？</p>
<p>我说的浅显一点，很简单，就是因为刚开始系统都是连接数据库的，但是要知道数据库支撑到每秒并发两三千的时候，基本就快完了。所以才有说，很多公司，刚开始干的时候，技术比较low，结果业务发展太快，有的时候系统扛不住压力就挂了。（你们访问量大约多少？访问量不是很高，为什么还需要使用到这些高并发技术呢？）</p>
<p>当然会挂了，凭什么不挂？你数据库如果瞬间承载每秒5000,8000，甚至上万的并发，一定会宕机，因为比如mysql就压根儿扛不住这么高的并发量。</p>
<p>所以为啥高并发牛逼？就是因为现在用互联网的人越来越多，很多app、网站、系统承载的都是高并发请求，可能高峰期每秒并发量几千，很正常的。如果是什么双十一了之类的，每秒并发几万几十万都有可能。</p>
<p>高并发系统的架构组成.png</p>
<p>那么如此之高的并发量，加上原本就如此之复杂的业务，咋玩儿？真正厉害的，一定是在复杂业务系统里玩儿过高并发架构的人，但是你没有，那么我给你说一下你该怎么回答这个问题：</p>
<p>（1）系统拆分，将一个系统拆分为多个子系统，用分布式来实现。然后每个系统连一个数据库，这样本来就一个库，现在多个数据库，不也可以抗高并发么。</p>
<p>（2）缓存，必须得用缓存。大部分的高并发场景，都是读多写少，那你完全可以在数据库和缓存里都写一份，然后读的时候大量走缓存不就得了。毕竟人家redis轻轻松松单机几万的并发啊。没问题的。所以你可以考虑考虑你的项目里，那些承载主要请求的读场景，怎么用缓存来抗高并发。</p>
<p>（3）MQ，必须得用MQ。可能你还是会出现高并发写的场景，比如说一个业务操作里要频繁搞数据库几十次，增删改增删改，疯了。那高并发绝对搞挂你的系统，你要是用redis来承载写那肯定不行，人家是缓存，数据随时就被LRU了，数据格式还无比简单，没有事务支持。所以该用mysql还得用mysql啊。那你咋办？用MQ吧，大量的写请求灌入MQ里，排队慢慢玩儿，后边系统消费后慢慢写，控制在mysql承载范围之内。所以你得考虑考虑你的项目里，那些承载复杂写业务逻辑的场景里，如何用MQ来异步写，提升并发性。MQ单机抗几万并发也是ok的，这个之前还特意说过。</p>
<p>（4）分库分表，可能到了最后数据库层面还是免不了抗高并发的要求，好吧，那么就将一个数据库拆分为多个库，多个库来抗更高的并发；然后将一个表拆分为多个表，每个表的数据量保持少一点，提高sql跑的性能。</p>
<p>（5）读写分离，这个就是说大部分时候数据库可能也是读多写少，没必要所有请求都集中在一个库上吧，可以搞个主从架构，主库写入，从库读取，搞一个读写分离。读流量太多的时候，还可以加更多的从库。</p>
<p>（6）合理使用数据库Elasticsearch。es是分布式的，可以随便扩容，分布式天然就可以支撑高并发，因为动不动就可以扩容加机器来抗更高的并发。那么一些比较简单的查询、统计类的操作，可以考虑用es来承载，还有一些全文搜索类的操作，也可以考虑用es来承载。对非索引字段的查询</p>
<p> (7) 使用Undertow来替代Tomcat来作为http服务。Undertow在高并发业务场景中，性能要优于Tomcat，并且Undertow在新版本中默认使用持久连接，这将会进一步提高它的并发吞吐能力。</p>
<p>上面的7点，基本就是高并发系统肯定要干的一些事儿，大家可以仔细结合之前讲过的知识考虑一下，到时候你可以系统的把这块阐述一下，然后每个部分要注意哪些问题，之前都讲过了，你都可以阐述阐述，表明你对这块是有点积累的。</p>
<p>说句实话，毕竟真正你厉害的一点，不是在于弄明白一些技术，或者大概知道一个高并发系统应该长什么样？其实实际上在真正的复杂的业务系统里，做高并发要远远比我这个图复杂几十倍到上百倍。你需要考虑，哪些需要分库分表，哪些不需要分库分表，单库单表跟分库分表如何join，哪些数据要放到缓存里去啊，放哪些数据再可以抗掉高并发的请求，你需要完成对一个复杂业务系统的分析之后，然后逐步逐步的加入高并发的系统架构的改造，这个过程是务必复杂的，一旦做过一次，一旦做好了，你在这个市场上就会非常的吃香。</p>
<p>其实大部分公司，真正看重的，不是说你掌握高并发相关的一些基本的架构知识，架构中的一些技术，RocketMQ、Kafka、Redis、Elasticsearch，高并发这一块，次一等的人才。对一个有几十万行代码的复杂的分布式系统，一步一步架构、设计以及实践过高并发架构的人，这个经验是难能可贵的。</p>
<p>参考链接：<a href="https://blog.csdn.net/A_BlacksMoon/article/details/86386705" target="_blank" rel="noopener">https://blog.csdn.net/A_BlacksMoon/article/details/86386705</a></p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>cloud</tag>
        <tag>高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>一个简单的拦截器</title>
    <url>/myblog/interceptor/%E7%AE%80%E5%8D%95%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    <content><![CDATA[<h4 id="一个简单的拦截器"><a href="#一个简单的拦截器" class="headerlink" title="一个简单的拦截器"></a>一个简单的拦截器</h4><a id="more"></a>
<h4 id="一、创建一个LoginInterceptor-继承"><a href="#一、创建一个LoginInterceptor-继承" class="headerlink" title="一、创建一个LoginInterceptor 继承"></a>一、创建一个LoginInterceptor 继承</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HandlerInterceptorpackage cn.lxl.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.lxl.utils.RedisUtils;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(LoginInterceptor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">      </span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> RedisUtils redisUtils;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		LOGGER.info(<span class="string">"############进入用户token验证拦截器"</span>);</span><br><span class="line">		String uri = request.getRequestURI().toString();</span><br><span class="line">		LOGGER.info(uri);</span><br><span class="line">		<span class="comment">// 根据名称获取请求头的值</span></span><br><span class="line">		String token = request.getHeader(<span class="string">"Authorization"</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> == token) &#123;</span><br><span class="line">			LOGGER.error(<span class="string">"##########当前用户未登录"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 根据key获取缓存中的val</span></span><br><span class="line">		<span class="keyword">boolean</span> hasKey = redisUtils.exists(token);</span><br><span class="line">		<span class="keyword">if</span> (hasKey == <span class="keyword">false</span>) &#123;</span><br><span class="line">			LOGGER.error(<span class="string">"##########当前用户token在redis中不存在,token:&#123;&#125;"</span> + token);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 根据key获取过期时间</span></span><br><span class="line">		Long expire = redisUtils.getExpire(token);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (expire &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			LOGGER.error(<span class="string">"##########当前用户token已失效,token:&#123;&#125;"</span> + token);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 为当前登录用户重置登录活性</span></span><br><span class="line">		<span class="comment">// 向redis里存入数据和设置缓存时间</span></span><br><span class="line">		redisUtils.set(token, token, <span class="number">1L</span>, TimeUnit.DAYS);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在业务处理器处理请求完成之后，生成视图之前执行</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">			ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在DispatcherServlet完全处理完请求之后被调用，可用于清理资源</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                           , Object handler, Exception ex)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二、在这个类里写判断条件，然后创建一个WebConfigurer 继承 jar包里的WebMvcConfigurer类 引用LoginInterceptor类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lxl.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.lxl.controller.LoginInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfigurer</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> LoginInterceptor loginInterceptor;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这个方法是用来配置静态资源的，比如html，js，css，等等</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 解决跨域请求问题</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">		registry.addMapping(<span class="string">"/**"</span>).allowedOrigins(<span class="string">"*"</span>).allowCredentials(<span class="keyword">true</span>)</span><br><span class="line">				.allowedMethods(<span class="string">"GET"</span>, <span class="string">"POST"</span>, <span class="string">"DELETE"</span>, <span class="string">"PUT"</span>).maxAge(<span class="number">3600</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这个方法用来注册拦截器，我们自己写好的拦截器需要通过这里添加注册才能生效</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// addPathPatterns("/**") 表示拦截所有的请求，</span></span><br><span class="line">		<span class="comment">// excludePathPatterns("/login", "/register") 表示除了登陆与注册之外，因为登陆注册不需要登陆也可以访问</span></span><br><span class="line">		registry.addInterceptor(loginInterceptor).addPathPatterns(<span class="string">"/**"</span>)</span><br><span class="line">				.excludePathPatterns(<span class="string">"/FeedbackService/login/&#123;card&#125;"</span>);</span><br><span class="line">		<span class="comment">/* super.addInterceptors(registry); */</span> <span class="comment">// 较新Spring Boot的版本中这里可以直接去掉，否则会报错</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 众多的拦截器组成了一个拦截器链</span></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 主要方法说明： addPathPatterns 用于添加拦截规则 excludePathPatterns 用户排除拦截</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">// registry.addInterceptor(new FirstInterceptor()).addPathPatterns("/*");</span></span><br><span class="line">		<span class="comment">// 拦截器SecondInterceptor不拦截hello</span></span><br><span class="line">		<span class="comment">// registry.addInterceptor(new</span></span><br><span class="line">		<span class="comment">// LoginInterceptor()).addPathPatterns("/*").excludePathPatterns("/hello");</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面写需要拦截的方法 和 放行的方法 路径</p>
]]></content>
      <categories>
        <category>interceptor</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>interceptor</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用命令</title>
    <url>/myblog/tool/it%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><p>1、初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>2、添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>3、备注</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">'add'</span></span><br></pre></td></tr></table></figure>
<p>4、推送到仓库,</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PS:此处是推送到master分支下</p>
</blockquote>
<h2 id="创建分支并切换"><a href="#创建分支并切换" class="headerlink" title="创建分支并切换"></a>创建分支并切换</h2><p>1）新建分支</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">git branch <span class="title">xxx</span> <span class="params">(xxx填写你的分支名称)</span></span></span><br></pre></td></tr></table></figure>
<p>2）查看所有分支</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure>
<p>3）切换到某一分支</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">git checkout <span class="title">xxx</span> <span class="params">(xxx填写要切换的分支名称）</span></span></span><br></pre></td></tr></table></figure>
<p>4）添加修改代码到缓存（注意最后的”.”前面有个空格</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>
<p>5）添加提交代码的备注</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">"xxx"</span> （xxx为本次提交代码的备注）</span><br></pre></td></tr></table></figure>
<p>6）提交代码到指定分支</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git push origin xxx （xxx为要提交代码的分支名称）</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据库面试题</title>
    <url>/myblog/interview/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h4 id="数据库基础知识"><a href="#数据库基础知识" class="headerlink" title="数据库基础知识"></a>数据库基础知识</h4><a id="more"></a>
<h5 id="为什么要使用数据库"><a href="#为什么要使用数据库" class="headerlink" title="为什么要使用数据库"></a>为什么要使用数据库</h5><p><strong>数据保存在内存</strong></p>
<p>优点： 存取速度快</p>
<p>缺点： 数据不能永久保存</p>
<p><strong>数据保存在文件</strong></p>
<p>优点： 数据永久保存</p>
<p>缺点：1）速度比内存操作慢，频繁的IO操作。2）查询数据不方便</p>
<p><strong>数据保存在数据库</strong></p>
<p>1）数据永久保存</p>
<p>2）使用SQL语句，查询方便效率高。</p>
<p>3）管理数据方便</p>
<h5 id="什么是SQL？"><a href="#什么是SQL？" class="headerlink" title="什么是SQL？"></a>什么是SQL？</h5><!--more-->

<p>结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询语言。</p>
<p>作用：用于存取数据、查询、更新和管理关系数据库系统。</p>
<h4 id="什么是MySQL"><a href="#什么是MySQL" class="headerlink" title="什么是MySQL?"></a>什么是MySQL?</h4><p>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。</p>
<h5 id="数据库三大范式是什么"><a href="#数据库三大范式是什么" class="headerlink" title="数据库三大范式是什么"></a>数据库三大范式是什么</h5><p>第一范式：每个列都不可以再拆分。</p>
<p>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</p>
<p>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</p>
<p>在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。</p>
<h5 id="mysql有关权限的表都有哪几个"><a href="#mysql有关权限的表都有哪几个" class="headerlink" title="mysql有关权限的表都有哪几个"></a>mysql有关权限的表都有哪几个</h5><p>MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下面分别介绍一下这些表的结构和内容：</p>
<ul>
<li>user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</li>
<li>db权限表：记录各个帐号在各个数据库上的操作权限。</li>
<li>table_priv权限表：记录数据表级的操作权限。</li>
<li>columns_priv权限表：记录数据列级的操作权限。</li>
<li>host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。</li>
</ul>
<h5 id="MySQL的binlog有有几种录入格式？分别有什么区别？"><a href="#MySQL的binlog有有几种录入格式？分别有什么区别？" class="headerlink" title="MySQL的binlog有有几种录入格式？分别有什么区别？"></a>MySQL的binlog有有几种录入格式？分别有什么区别？</h5><p>有三种格式，statement，row和mixed。</p>
<ul>
<li>statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。</li>
<li>row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。</li>
<li>mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。</li>
</ul>
<p>此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。</p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><h5 id="mysql有哪些数据类型"><a href="#mysql有哪些数据类型" class="headerlink" title="mysql有哪些数据类型"></a>mysql有哪些数据类型</h5><table>
<thead>
<tr>
<th><strong>分类</strong></th>
<th><strong>类型名称</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>整数类型</strong></td>
<td>tinyInt</td>
<td>很小的整数(8位二进制)</td>
</tr>
<tr>
<td></td>
<td>smallint</td>
<td>小的整数(16位二进制)</td>
</tr>
<tr>
<td></td>
<td>mediumint</td>
<td>中等大小的整数(24位二进制)</td>
</tr>
<tr>
<td></td>
<td>int(integer)</td>
<td>普通大小的整数(32位二进制)</td>
</tr>
<tr>
<td><strong>小数类型</strong></td>
<td>float</td>
<td>单精度浮点数</td>
</tr>
<tr>
<td></td>
<td>double</td>
<td>双精度浮点数</td>
</tr>
<tr>
<td></td>
<td>decimal(m,d)</td>
<td>压缩严格的定点数</td>
</tr>
<tr>
<td><strong>日期类型</strong></td>
<td>year</td>
<td>YYYY 1901~2155</td>
</tr>
<tr>
<td></td>
<td>time</td>
<td>HH:MM:SS -838:59:59~838:59:59</td>
</tr>
<tr>
<td></td>
<td>date</td>
<td>YYYY-MM-DD 1000-01-01~9999-12-3</td>
</tr>
<tr>
<td></td>
<td>datetime</td>
<td>YYYY-MM-DD  HH:MM:SS 1000-01-01 00:00:00~ 9999-12-31 23:59:59</td>
</tr>
<tr>
<td></td>
<td>timestamp</td>
<td>YYYY-MM-DD HH:MM:SS   19700101 00:00:01 UTC~2038-01-19 03:14:07UTC</td>
</tr>
<tr>
<td><strong>文本、二进制类型</strong></td>
<td>CHAR(M)</td>
<td>M为0~255之间的整数</td>
</tr>
<tr>
<td></td>
<td>VARCHAR(M)</td>
<td>M为0~65535之间的整数</td>
</tr>
<tr>
<td></td>
<td>TINYBLOB</td>
<td>允许长度0~255字节</td>
</tr>
<tr>
<td></td>
<td>BLOB</td>
<td>允许长度0~65535字节</td>
</tr>
<tr>
<td></td>
<td>MEDIUMBLOB</td>
<td>允许长度0~167772150字节</td>
</tr>
<tr>
<td></td>
<td>LONGBLOB</td>
<td>允许长度0~4294967295字节</td>
</tr>
<tr>
<td></td>
<td>TINYTEXT</td>
<td>允许长度0~255字节</td>
</tr>
<tr>
<td></td>
<td>TEXT</td>
<td>允许长度0~65535字节</td>
</tr>
<tr>
<td></td>
<td>MEDIUMTEXT</td>
<td>允许长度0~167772150字节</td>
</tr>
<tr>
<td></td>
<td>LONGTEXT</td>
<td>允许长度0~4294967295字节</td>
</tr>
<tr>
<td></td>
<td>VARBINARY(M)</td>
<td>允许长度0~M个字节的变长字节字符串</td>
</tr>
<tr>
<td></td>
<td>BINARY(M)</td>
<td>允许长度0~M个字节的定长字节字符串</td>
</tr>
</tbody></table>
<p>1、整数类型，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。<br>长度：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNED ZEROFILL属性配合使用才有意义。<br>例子，假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数据库实际存储数据为00012。</p>
<p>2、实数类型，包括FLOAT、DOUBLE、DECIMAL。<br>DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。<br>而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。<br>计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。</p>
<p>3、字符串类型，包括VARCHAR、CHAR、TEXT、BLOB<br>VARCHAR用于存储可变长字符串，它比定长类型更节省空间。<br>VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2字节表示。<br>VARCHAR存储的内容超出设置的长度时，内容会被截断。<br>CHAR是定长的，根据定义的字符串长度分配足够的空间。<br>CHAR会根据需要使用空格进行填充方便比较。<br>CHAR适合存储很短的字符串，或者所有值都接近同一个长度。<br>CHAR存储的内容超出设置的长度时，内容同样会被截断。</p>
<p>使用策略：<br>对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。<br>对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。<br>使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。<br>尽量避免使用TEXT/BLOB类型，查询时会使用临时表，导致严重的性能开销。</p>
<p>4、枚举类型（ENUM），把不重复的数据存储为一个预定义的集合。<br>有时可以使用ENUM代替常用的字符串类型。<br>ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。<br>ENUM在内部存储时，其实存的是整数。<br>尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。<br>排序是按照内部存储的整数</p>
<p>5、日期和时间类型，尽量使用timestamp，空间效率高于datetime，<br>用整数保存时间戳通常不方便处理。<br>如果需要存储微妙，可以使用bigint存储。<br>看到这里，这道真题是不是就比较容易回答了。</p>
<h4 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h4><h5 id="MySQL存储引擎MyISAM与InnoDB区别"><a href="#MySQL存储引擎MyISAM与InnoDB区别" class="headerlink" title="MySQL存储引擎MyISAM与InnoDB区别"></a>MySQL存储引擎MyISAM与InnoDB区别</h5><p>存储引擎Storage engine：MySQL中的数据、索引以及其他对象是如何存储的，是一套文件系统的实现。</p>
<p>常用的存储引擎有以下：</p>
<ul>
<li>Innodb引擎：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。</li>
<li>MyIASM引擎(原本Mysql的默认引擎)：不提供事务的支持，也不支持行级锁和外键。</li>
<li>MEMORY引擎：所有的数据都在内存中，数据的处理速度快，但是安全性不高。</li>
</ul>
<h5 id="MyISAM与InnoDB区别"><a href="#MyISAM与InnoDB区别" class="headerlink" title="MyISAM与InnoDB区别"></a>MyISAM与InnoDB区别</h5><table>
<thead>
<tr>
<th></th>
<th>MyISAM</th>
<th>Innodb</th>
</tr>
</thead>
<tbody><tr>
<td>存储结构</td>
<td>每张表被存放在三个文件：frm-表格定义、MYD(MYData)-数据文件、MYI(MYIndex)-索引文件</td>
<td>所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB</td>
</tr>
<tr>
<td>存储空间</td>
<td>MyISAM可被压缩，存储空间较小</td>
<td>InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引</td>
</tr>
<tr>
<td>可移植性、备份及恢复</td>
<td>由于MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作</td>
<td>免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了</td>
</tr>
<tr>
<td>文件格式</td>
<td>数据和索引是分别存储的，数据<code>.MYD</code>，索引<code>.MYI</code></td>
<td>数据和索引是集中存储的，<code>.ibd</code></td>
</tr>
<tr>
<td>记录存储顺序</td>
<td>按记录插入顺序保存</td>
<td>按主键大小有序插入</td>
</tr>
<tr>
<td>外键</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>事务</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>锁支持（锁是避免资源争用的一个机制，MySQL锁对用户几乎是透明的）</td>
<td>表级锁定</td>
<td>行级锁定、表级锁定，锁定力度小并发能力高</td>
</tr>
<tr>
<td>SELECT</td>
<td>MyISAM更优</td>
<td></td>
</tr>
<tr>
<td>INSERT、UPDATE、DELETE</td>
<td></td>
<td>InnoDB更优</td>
</tr>
<tr>
<td>select count(*)</td>
<td>myisam更快，因为myisam内部维护了一个计数器，可以直接调取。</td>
<td></td>
</tr>
<tr>
<td>索引的实现方式</td>
<td>B+树索引，myisam 是堆表</td>
<td>B+树索引，Innodb 是索引组织表</td>
</tr>
<tr>
<td>哈希索引</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>全文索引</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<h5 id="MyISAM索引与InnoDB索引的区别？"><a href="#MyISAM索引与InnoDB索引的区别？" class="headerlink" title="MyISAM索引与InnoDB索引的区别？"></a>MyISAM索引与InnoDB索引的区别？</h5><ul>
<li>InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。</li>
<li>InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。</li>
<li>MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。</li>
<li>InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</li>
</ul>
<h4 id="InnoDB引擎的4大特性"><a href="#InnoDB引擎的4大特性" class="headerlink" title="InnoDB引擎的4大特性"></a>InnoDB引擎的4大特性</h4><ul>
<li>插入缓冲（insert buffer)</li>
<li>二次写(double write)</li>
<li>自适应哈希索引(ahi)</li>
<li>预读(read ahead)</li>
</ul>
<p>存储引擎选择</p>
<p>如果没有特别的需求，使用默认的Innodb即可。</p>
<p>MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。</p>
<p>Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如OA自动化办公系统。</p>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><h5 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h5><p>索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。</p>
<p>索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</p>
<p>更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。</p>
<h5 id="索引有哪些优缺点？"><a href="#索引有哪些优缺点？" class="headerlink" title="索引有哪些优缺点？"></a>索引有哪些优缺点？</h5><p>索引的优点</p>
<ul>
<li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li>
</ul>
<p>索引的缺点</p>
<ul>
<li>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；</li>
<li>空间方面：索引需要占物理空间。</li>
</ul>
<h5 id="索引使用场景（重点）"><a href="#索引使用场景（重点）" class="headerlink" title="索引使用场景（重点）"></a>索引使用场景（重点）</h5><p>where</p>
<p><img src="http://zhao.zcycomputer.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8yLzE5LzE2OTA0NTk2ZTFiNTU4YjI.png" alt></p>
<p>上图中，根据id查询记录，因为id字段仅建立了主键索引，因此此SQL执行可选的索引只有主键索引，如果有多个，最终会选一个较优的作为检索的依据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 增加一个没有建立索引的字段</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> innodb1 <span class="keyword">add</span> sex <span class="built_in">char</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">-- 按sex检索时可选的索引为null</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">from</span> innodb1 <span class="keyword">where</span> sex=<span class="string">'男'</span>;</span><br></pre></td></tr></table></figure>

<p><img src="http://zhao.zcycomputer.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8yLzE5LzE2OTA0NTk2Zjk1YTdmOTk.png" alt></p>
<pre><code>可以尝试在一个字段未建立索引时，根据该字段查询的效率，然后对该字段建立索引（alter table 表名 add index(字段名)），同样的SQL执行的效率，你会发现查询效率会有明显的提升（数据量越大越明显）。</code></pre><p>order by</p>
<p>当我们使用order by将查询结果按照某个字段排序时，如果该字段没有建立索引，那么执行计划会将查询出的所有数据使用外部排序（将数据从硬盘分批读取到内存使用内部排序，最后合并排序结果），这个操作是很影响性能的，因为需要将查询涉及到的所有数据从磁盘中读到内存（如果单条数据过大或者数据量过多都会降低效率），更无论读到内存之后的排序了。</p>
<p>但是如果我们对该字段建立索引alter table 表名 add index(字段名)，那么由于索引本身是有序的，因此直接按照索引的顺序和映射关系逐条取出数据即可。而且如果分页的，那么只用取出索引表某个范围内的索引对应的数据，而不用像上述那取出所有数据进行排序再返回某个范围内的数据。（从磁盘取数据是最影响性能的）</p>
<p>join</p>
<pre><code>对join语句匹配关系（on）涉及的字段建立索引能够提高效率</code></pre><p>索引覆盖</p>
<p>如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖。因此我们需要尽可能的在select后<strong>只写必要的查询字段</strong>，以增加索引覆盖的几率。</p>
<p>这里值得注意的是不要想着为每个字段建立索引，因为优先使用索引的优势就在于其体积小。</p>
<h5 id="索引有哪几种类型？"><a href="#索引有哪几种类型？" class="headerlink" title="索引有哪几种类型？"></a>索引有哪几种类型？</h5><p>主键索引: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。</p>
<p>唯一索引: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</p>
<ul>
<li>可以通过 <code>ALTER TABLE table_name ADD UNIQUE (column);</code> 创建唯一索引</li>
<li>可以通过 <code>ALTER TABLE table_name ADD UNIQUE (column1,column2);</code> 创建唯一组合索引</li>
</ul>
<p>普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值。</p>
<ul>
<li>可以通过ALTER TABLE table_name ADD INDEX index_name (column);创建普通索引</li>
<li>可以通过ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);创建组合索引</li>
</ul>
<p><strong>全文索引</strong>： 是目前搜索引擎使用的一种关键技术。</p>
<ul>
<li>可以通过ALTER TABLE table_name ADD FULLTEXT (column);创建全文索引</li>
</ul>
<h5 id="索引的数据结构（b树，hash）"><a href="#索引的数据结构（b树，hash）" class="headerlink" title="索引的数据结构（b树，hash）"></a>索引的数据结构（b树，hash）</h5><p>索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有Hash索引，B+树索引等，而我们经常使用的InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</p>
<p>1）B树索引</p>
<p>mysql通过存储引擎取数据，基本上90%的人用的就是InnoDB了，按照实现方式分，InnoDB的索引类型目前只有两种：BTREE（B树）索引和HASH索引。B树索引是Mysql数据库中使用最频繁的索引类型，基本所有存储引擎都支持BTree索引。通常我们说的索引不出意外指的就是（B树）索引（实际是用B+树实现的，因为在查看表索引时，mysql一律打印BTREE，所以简称为B树索引）</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC85LzI0LzE2NjBjMGYxNGRhY2Y2ZjU?x-oss-process=image/format,png" alt></p>
<p>查询方式：</p>
<p>主键索引区:PI(关联保存的时数据的地址)按主键查询,</p>
<p>普通索引区:si(关联的id的地址,然后再到达上面的地址)。所以按主键查询,速度最快</p>
<p>B+tree性质：</p>
<p>1.）n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。</p>
<p>2.）所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p>
<p>3.）所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</p>
<p>4.）B+ 树中，数据对象的插入和删除仅在叶节点上进行。</p>
<p>5.）B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</p>
<p>2）哈希索引</p>
<p>简要说下，类似于数据结构中简单实现的HASH表（散列表）一样，当我们在mysql中用哈希索引时，主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。当然这只是简略模拟图。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC85LzI0LzE2NjBjMGYxNThhNzZmOTQ?x-oss-process=image/format,png" alt></p>
<h5 id="索引的基本原理"><a href="#索引的基本原理" class="headerlink" title="索引的基本原理"></a>索引的基本原理</h5><p>索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。</p>
<p>索引的原理很简单，就是把无序的数据变成有序的查询</p>
<ol>
<li>把创建了索引的列的内容进行排序</li>
<li>对排序结果生成倒排表</li>
<li>在倒排表内容上拼上数据地址链</li>
<li>在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</li>
</ol>
<h5 id="索引算法有哪些？"><a href="#索引算法有哪些？" class="headerlink" title="索引算法有哪些？"></a>索引算法有哪些？</h5><p>索引算法有 BTree算法和Hash算法</p>
<p><strong>BTree算法</strong></p>
<p>BTree是最常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在=,&gt;,&gt;=,&lt;,&lt;=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量， 例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 只要它的查询条件是一个不以通配符开头的常量</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'jack%'</span>; </span><br><span class="line"><span class="comment">-- 如果一通配符开头，或者没有使用常量，则不会使用索引，例如： </span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%jack'</span>;</span><br></pre></td></tr></table></figure>

<p><strong>Hash算法</strong></p>
<p>Hash Hash索引只能用于对等比较，例如=,&lt;=&gt;（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。</p>
<h4 id="索引设计的原则？"><a href="#索引设计的原则？" class="headerlink" title="索引设计的原则？"></a>索引设计的原则？</h4><ol>
<li>适合索引的列是出现在where子句中的列，或者连接子句中指定的列</li>
<li>基数较小的类，索引效果较差，没有必要在此列建立索引</li>
<li>使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间</li>
<li>不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</li>
</ol>
<h5 id="创建索引的原则（重中之重）"><a href="#创建索引的原则（重中之重）" class="headerlink" title="创建索引的原则（重中之重）"></a>创建索引的原则（重中之重）</h5><p>索引虽好，但也不是无限制的使用，最好符合一下几个原则</p>
<p>1） 最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p>
<p>2）较频繁作为查询条件的字段才去创建索引</p>
<p>3）更新频繁字段不适合创建索引</p>
<p>4）若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)</p>
<p>5）尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p>
<p>6）定义有外键的数据列一定要建立索引。</p>
<p>7）对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</p>
<p>8）对于定义为text、image和bit的数据类型的列不要建立索引。</p>
<h5 id="创建索引的三种方式，删除索引"><a href="#创建索引的三种方式，删除索引" class="headerlink" title="创建索引的三种方式，删除索引"></a>创建索引的三种方式，删除索引</h5><p>第一种方式：在执行CREATE TABLE时创建索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_index2 (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">INT</span> auto_increment PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">	first_name <span class="built_in">VARCHAR</span> (<span class="number">16</span>),</span><br><span class="line">	last_name <span class="built_in">VARCHAR</span> (<span class="number">16</span>),</span><br><span class="line">	id_card <span class="built_in">VARCHAR</span> (<span class="number">18</span>),</span><br><span class="line">	information <span class="built_in">text</span>,</span><br><span class="line">	<span class="keyword">KEY</span> <span class="keyword">name</span> (first_name, last_name),</span><br><span class="line">	FULLTEXT <span class="keyword">KEY</span> (information),</span><br><span class="line">	<span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> (id_card)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>第二种方式：使用ALTER TABLE命令去增加索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name (column_list);</span><br></pre></td></tr></table></figure>

<p>ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。</p>
<p>其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。</p>
<p>索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。</p>
<p>第三种方式：使用CREATE INDEX命令创建</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> table_name (column_list);</span><br></pre></td></tr></table></figure>

<p>CREATE INDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARY KEY索引）</p>
<p>删除索引</p>
<p>根据索引名删除普通索引、唯一索引、全文索引：alter table 表名 drop KEY 索引名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">drop</span> <span class="keyword">KEY</span> <span class="keyword">name</span>;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">drop</span> <span class="keyword">KEY</span> id_card;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">drop</span> <span class="keyword">KEY</span> information;</span><br></pre></td></tr></table></figure>

<p>删除主键索引：alter table 表名 drop primary key（因为主键只有一个）。这里值得注意的是，如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8yLzE5LzE2OTA0NTk2YjIxZTIwOWM?x-oss-process=image/format,png" alt></p>
<p>需要取消自增长再行删除：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index</span><br><span class="line"><span class="comment">-- 重新定义字段</span></span><br><span class="line"><span class="keyword">MODIFY</span> <span class="keyword">id</span> <span class="built_in">int</span>,</span><br><span class="line"><span class="keyword">drop</span> PRIMARY <span class="keyword">KEY</span></span><br></pre></td></tr></table></figure>

<p>但通常不会删除主键，因为设计主键一定与业务逻辑无关。</p>
<h5 id="创建索引时需要注意什么？"><a href="#创建索引时需要注意什么？" class="headerlink" title="创建索引时需要注意什么？"></a>创建索引时需要注意什么？</h5><ul>
<li>非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</li>
<li>取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</li>
<li>索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</li>
</ul>
<h5 id="使用索引查询一定能提高查询的性能吗？为什么"><a href="#使用索引查询一定能提高查询的性能吗？为什么" class="headerlink" title="使用索引查询一定能提高查询的性能吗？为什么"></a>使用索引查询一定能提高查询的性能吗？为什么</h5><p>通常，通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。</p>
<ul>
<li>索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:</li>
<li>基于一个范围的检索，一般查询返回结果集小于表中记录数的30%</li>
<li>基于非唯一性索引的检索</li>
</ul>
<h5 id="百万级别或以上的数据如何删除"><a href="#百万级别或以上的数据如何删除" class="headerlink" title="百万级别或以上的数据如何删除"></a>百万级别或以上的数据如何删除</h5><p>关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。</p>
<ol>
<li>所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</li>
<li>然后删除其中无用数据（此过程需要不到两分钟）</li>
<li>删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</li>
<li>与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</li>
</ol>
<h5 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h5><p>语法：index(field(10))，使用字段值的前10个字符建立索引，默认是使用字段的全部内容建立索引。</p>
<p>前提：前缀的标识度高。比如密码就适合建立前缀索引，因为密码几乎各不相同。</p>
<p>实操的难度：在于前缀截取的长度。</p>
<p>我们可以利用select count(*)/count(distinct left(password,prefixLen));，通过从调整prefixLen的值（从1自增）查看不同前缀长度的一个平均匹配度，接近1时就可以了（表示一个密码的前prefixLen个字符几乎能确定唯一一条记录）<br>什么是最左前缀原则？什么是最左匹配原则</p>
<ul>
<li>顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。</li>
<li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li>
<li>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li>
</ul>
<p>B树和B+树的区别</p>
<ul>
<li><p>在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。</p>
</li>
<li><p>B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC85LzIxLzE2NWZiNjgyZTc1OWNmMTI?x-oss-process=image/format,png" alt></p>
</li>
</ul>
<h5 id="使用B树的好处"><a href="#使用B树的好处" class="headerlink" title="使用B树的好处"></a>使用B树的好处</h5><p>B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。</p>
<h5 id="使用B-树的好处"><a href="#使用B-树的好处" class="headerlink" title="使用B+树的好处"></a>使用B+树的好处</h5><p>由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。 B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间</p>
<h5 id="Hash索引和B-树所有有什么区别或者说优劣呢"><a href="#Hash索引和B-树所有有什么区别或者说优劣呢" class="headerlink" title="Hash索引和B+树所有有什么区别或者说优劣呢?"></a>Hash索引和B+树所有有什么区别或者说优劣呢?</h5><p>首先要知道Hash索引和B+树索引的底层实现原理：</p>
<p>hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据。B+树底层实现是多路平衡查找树。对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。</p>
<p>那么可以看出他们有以下的不同：</p>
<ul>
<li>hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。</li>
</ul>
<p>因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。</p>
<ul>
<li>hash索引不支持使用索引进行排序，原理同上。</li>
<li>hash索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为hash函数的不可预测。AAAA和AAAAB的索引没有相关性。</li>
<li>hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。</li>
<li>hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。</li>
</ul>
<p>因此，在大多数情况下，直接选择B+树索引可以获得稳定且较好的查询速度。而不需要使用hash索引。</p>
<h5 id="数据库为什么使用B-树而不是B树"><a href="#数据库为什么使用B-树而不是B树" class="headerlink" title="数据库为什么使用B+树而不是B树"></a>数据库为什么使用B+树而不是B树</h5><ul>
<li>B树只适合随机检索，而B+树同时支持随机检索和顺序检索；</li>
<li>B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素；</li>
<li>B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。</li>
<li>B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。</li>
<li>增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。</li>
</ul>
<h5 id="B-树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，"><a href="#B-树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，" class="headerlink" title="B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，"></a>B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，</h5><p>在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。 在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。</p>
<p>当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。</p>
<h5 id="什么是聚簇索引？何时使用聚簇索引与非聚簇索引"><a href="#什么是聚簇索引？何时使用聚簇索引与非聚簇索引" class="headerlink" title="什么是聚簇索引？何时使用聚簇索引与非聚簇索引"></a>什么是聚簇索引？何时使用聚簇索引与非聚簇索引</h5><ul>
<li>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</li>
<li>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因</li>
</ul>
<p>澄清一个概念：innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值</p>
<p>何时使用聚簇索引与非聚簇索引</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMDE1NDQ5OS1kNTNhNWNlOWNlY2YyMmYzLnBuZw?x-oss-process=image/format,png" alt></p>
<h5 id="非聚簇索引一定会回表查询吗？"><a href="#非聚簇索引一定会回表查询吗？" class="headerlink" title="非聚簇索引一定会回表查询吗？"></a>非聚簇索引一定会回表查询吗？</h5><p>不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。</p>
<p>举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行select age from employee where age &lt; 20的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。</p>
<h5 id="联合索引是什么？为什么需要注意联合索引中的顺序？"><a href="#联合索引是什么？为什么需要注意联合索引中的顺序？" class="headerlink" title="联合索引是什么？为什么需要注意联合索引中的顺序？"></a>联合索引是什么？为什么需要注意联合索引中的顺序？</h5><p>MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。</p>
<p>具体原因为:</p>
<p>MySQL使用索引时需要索引有序，假设现在建立了”name，age，school”的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。</p>
<p>当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。</p>
<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><h5 id="什么是数据库事务？"><a href="#什么是数据库事务？" class="headerlink" title="什么是数据库事务？"></a>什么是数据库事务？</h5><p>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>
<p>事务最经典也经常被拿出来说例子就是转账了。</p>
<p>假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p>
<h5 id="事物的四大特性-ACID-介绍一下"><a href="#事物的四大特性-ACID-介绍一下" class="headerlink" title="事物的四大特性(ACID)介绍一下?"></a>事物的四大特性(ACID)介绍一下?</h5><p>关系性数据库需要遵循ACID规则，具体内容如下：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC81LzIwLzE2MzdiMDhiOTg2MTk0NTU?x-oss-process=image/format,png" alt></p>
<p>事务的特性</p>
<ol>
<li>原子性： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li>一致性： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>
<li>隔离性： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li>持久性： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ol>
<h5 id="什么是脏读？幻读？不可重复读？"><a href="#什么是脏读？幻读？不可重复读？" class="headerlink" title="什么是脏读？幻读？不可重复读？"></a>什么是脏读？幻读？不可重复读？</h5><ul>
<li>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</li>
<li>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</li>
<li>幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</li>
</ul>
<h5 id="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"><a href="#什么是事务的隔离级别？MySQL的默认隔离级别是什么？" class="headerlink" title="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"></a>什么是事务的隔离级别？MySQL的默认隔离级别是什么？</h5><p>为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻影读</th>
</tr>
</thead>
<tbody><tr>
<td>READ-UNCOMMITTED</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>READ-COMMITTED</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE-READ</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<p>SQL 标准定义了四个隔离级别：</p>
<ul>
<li><strong>READ-UNCOMMITTED(读取未提交)</strong>： 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读。</strong></li>
<li><strong>READ-COMMITTED(读取已提交)</strong>： 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生。</strong></li>
<li><strong>REPEATABLE-READ(可重复读)</strong>： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li>
<li><strong>SERIALIZABLE(可串行化)</strong>： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li>
</ul>
<p>这里需要注意的是：Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别</p>
<p>事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。</p>
<p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED(读取提交内容):，但是你要知道的是InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ（可重读）</strong>并不会有任何性能损失。</p>
<p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到<strong>SERIALIZABLE(可串行化)</strong>隔离级别。</p>
<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><h5 id="对MySQL的锁了解吗"><a href="#对MySQL的锁了解吗" class="headerlink" title="对MySQL的锁了解吗"></a>对MySQL的锁了解吗</h5><p>当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来保证访问的次序，锁机制就是这样的一个机制。</p>
<p>就像酒店的房间，如果大家随意进出，就会出现多人抢夺同一个房间的情况，而在房间上装上锁，申请到钥匙的人才可以入住并且将房间锁起来，其他人只有等他使用完毕才可以再次使用。</p>
<h5 id="隔离级别与锁的关系"><a href="#隔离级别与锁的关系" class="headerlink" title="隔离级别与锁的关系"></a>隔离级别与锁的关系</h5><p>在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突</p>
<p>在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；</p>
<p>在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</p>
<p>SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。</p>
<h5 id="按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法"><a href="#按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法" class="headerlink" title="按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法"></a>按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法</h5><p>在关系型数据库中，可以按照锁的粒度把数据库锁分为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。</p>
<p>MyISAM和InnoDB存储引擎使用的锁：</p>
<ul>
<li>MyISAM采用表级锁(table-level locking)。</li>
<li>InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁</li>
</ul>
<p>行级锁，表级锁和页级锁对比</p>
<p><strong>行级锁</strong> 行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。</p>
<p>特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>
<p><strong>表级锁</strong> 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。</p>
<p>特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</p>
<p><strong>页级锁</strong> 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。</p>
<p>特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p>
<h5 id="从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了"><a href="#从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了" class="headerlink" title="从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了"></a>从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了</h5><p><strong>从锁的类别上来讲</strong>，有共享锁和排他锁。</p>
<p>共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。</p>
<p>排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。</p>
<p>用上面的例子来说就是用户的行为有两种，一种是来看房，多个用户一起看房是可以接受的。 一种是真正的入住一晚，在这期间，无论是想入住的还是想看房的都不可以。</p>
<p>锁的粒度取决于具体的存储引擎，InnoDB实现了行级锁，页级锁，表级锁。</p>
<p>他们的加锁开销从大到小，并发能力也是从大到小。</p>
<h5 id="MySQL中InnoDB引擎的行锁是怎么实现的？"><a href="#MySQL中InnoDB引擎的行锁是怎么实现的？" class="headerlink" title="MySQL中InnoDB引擎的行锁是怎么实现的？"></a>MySQL中InnoDB引擎的行锁是怎么实现的？</h5><p>答：InnoDB是基于索引来完成行锁</p>
<p>例: select * from tab_with_index where id = 1 for update;</p>
<p>for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将完成表锁，并发将无从谈起<br>InnoDB存储引擎的锁的算法有三种</p>
<ul>
<li>Record lock：单个行记录上的锁</li>
<li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li>
<li>Next-key lock：record+gap 锁定一个范围，包含记录本身</li>
</ul>
<p>相关知识点：</p>
<ol>
<li>innodb对于行的查询使用next-key lock</li>
<li>Next-locking keying为了解决Phantom Problem幻读问题</li>
<li>当查询的索引含有唯一属性时，将next-key lock降级为record key</li>
<li>Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</li>
<li>有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1</li>
</ol>
<h5 id="什么是死锁？怎么解决？"><a href="#什么是死锁？怎么解决？" class="headerlink" title="什么是死锁？怎么解决？"></a>什么是死锁？怎么解决？</h5><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</p>
<p>常见的解决死锁的方法</p>
<p>1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</p>
<p>2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</p>
<p>3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</p>
<p>如果业务处理不好可以用分布式事务锁或者使用乐观锁</p>
<h5 id="数据库的乐观锁和悲观锁是什么？怎么实现的？"><a href="#数据库的乐观锁和悲观锁是什么？怎么实现的？" class="headerlink" title="数据库的乐观锁和悲观锁是什么？怎么实现的？"></a>数据库的乐观锁和悲观锁是什么？怎么实现的？</h5><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p>
<p><strong>悲观锁</strong>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制</p>
<p><strong>乐观锁</strong>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。</p>
<p><strong>两种锁的使用场景</strong></p>
<p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐<strong>观锁适用于写比较少的情况下（多读场景）</strong>，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。</p>
<p>但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以<strong>一般多写的场景下用悲观锁就比较合</strong>适。</p>
<h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><h5 id="为什么要使用视图？什么是视图？"><a href="#为什么要使用视图？什么是视图？" class="headerlink" title="为什么要使用视图？什么是视图？"></a>为什么要使用视图？什么是视图？</h5><p>为了提高复杂SQL语句的复用性和表操作的安全性，MySQL数据库管理系统提供了视图特性。所谓视图，本质上是一种虚拟表，在物理上是不存在的，其内容与真实的表相似，包含一系列带有名称的列和行数据。但是，视图并不在数据库中以储存的数据值形式存在。行和列数据来自定义视图的查询所引用基本表，并且在具体引用视图时动态生成。</p>
<p>视图使开发者只关心感兴趣的某些特定数据和所负责的特定任务，只能看到视图中所定义的数据，而不是视图所引用表中的数据，从而提高了数据库中数据的安全性。</p>
<h5 id="视图有哪些特点？"><a href="#视图有哪些特点？" class="headerlink" title="视图有哪些特点？"></a>视图有哪些特点？</h5><p>视图的特点如下:</p>
<ul>
<li>视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。</li>
<li>视图是由基本表(实表)产生的表(虚表)。</li>
<li>视图的建立和删除不影响基本表。</li>
<li>对视图内容的更新(添加，删除和修改)直接影响基本表。</li>
<li>当视图来自多个基本表时，不允许添加和删除数据。</li>
</ul>
<p>视图的操作包括创建视图，查看视图，删除视图和修改视图。</p>
<h5 id="视图的使用场景有哪些？"><a href="#视图的使用场景有哪些？" class="headerlink" title="视图的使用场景有哪些？"></a>视图的使用场景有哪些？</h5><p>视图根本用途：简化sql查询，提高开发效率。如果说还有另外一个用途那就是兼容老的表结构。</p>
<p>下面是视图的常见使用场景：</p>
<ul>
<li>重用SQL语句；</li>
<li>简化复杂的SQL操作。在编写查询后，可以方便的重用它而不必知道它的基本查询细节；</li>
<li>使用表的组成部分而不是整个表；</li>
<li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限；</li>
<li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li>
</ul>
<h5 id="视图的优点"><a href="#视图的优点" class="headerlink" title="视图的优点"></a>视图的优点</h5><ol>
<li>查询简单化。视图能简化用户的操作</li>
<li>数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护</li>
<li>逻辑数据独立性。视图对重构数据库提供了一定程度的逻辑独立性</li>
</ol>
<h5 id="视图的缺点"><a href="#视图的缺点" class="headerlink" title="视图的缺点"></a>视图的缺点</h5><ol>
<li>性能。数据库必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也把它变成一个复杂的结合体，需要花费一定的时间。</li>
<li>修改限制。当用户试图修改视图的某些行时，数据库必须把它转化为对基本表的某些行的修改。事实上，当从视图中插入或者删除时，情况也是这样。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的</li>
<li>这些视图有如下特征：1.有UNIQUE等集合操作符的视图。2.有GROUP BY子句的视图。3.有诸如AVG\SUM\MAX等聚合函数的视图。 4.使用DISTINCT关键字的视图。5.连接表的视图（其中有些例外）</li>
</ol>
<h5 id="什么是游标？"><a href="#什么是游标？" class="headerlink" title="什么是游标？"></a>什么是游标？</h5><p>游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果，每个游标区都有一个名字。用户可以通过游标逐一获取记录并赋给主变量，交由主语言进一步处理。</p>
<h5 id="存储过程与函数"><a href="#存储过程与函数" class="headerlink" title="存储过程与函数"></a>存储过程与函数</h5><h5 id="什么是存储过程？有哪些优缺点？"><a href="#什么是存储过程？有哪些优缺点？" class="headerlink" title="什么是存储过程？有哪些优缺点？"></a>什么是存储过程？有哪些优缺点？</h5><p>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。</p>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>1）存储过程是预编译过的，执行效率高。</p>
<p>2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</p>
<p>3）安全性高，执行存储过程需要有一定权限的用户。</p>
<p>4）存储过程可以重复使用，减少数据库开发人员的工作量。</p>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>1）调试麻烦，但是用 PL/SQL Developer 调试很方便！弥补这个缺点。</p>
<p>2）移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。</p>
<p>3）重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。</p>
<p>4）如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。</p>
<h4 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h4><h5 id="什么是触发器？触发器的使用场景有哪些？"><a href="#什么是触发器？触发器的使用场景有哪些？" class="headerlink" title="什么是触发器？触发器的使用场景有哪些？"></a>什么是触发器？触发器的使用场景有哪些？</h5><p>触发器是用户定义在关系表上的一类由事件驱动的特殊的存储过程。触发器是指一段代码，当触发某个事件时，自动执行这些代码。</p>
<p>使用场景</p>
<ul>
<li>可以通过数据库中的相关表实现级联更改。</li>
<li>实时监控某张表中的某个字段的更改而需要做出相应的处理。</li>
<li>例如可以生成某些业务的编号。</li>
<li>注意不要滥用，否则会造成数据库及应用程序的维护困难。</li>
<li>大家需要牢记以上基础知识点，重点是理解数据类型CHAR和VARCHAR的差异，表存储引擎InnoDB和MyISAM的区别。</li>
</ul>
<h5 id="MySQL中都有哪些触发器？"><a href="#MySQL中都有哪些触发器？" class="headerlink" title="MySQL中都有哪些触发器？"></a>MySQL中都有哪些触发器？</h5><p>在MySQL数据库中有如下六种触发器：</p>
<ul>
<li>Before Insert</li>
<li>After Insert</li>
<li>Before Update</li>
<li>After Update</li>
<li>Before Delete</li>
<li>After Delete</li>
</ul>
<h4 id="常用SQL语句"><a href="#常用SQL语句" class="headerlink" title="常用SQL语句"></a>常用SQL语句</h4><h5 id="SQL语句主要分为哪几类"><a href="#SQL语句主要分为哪几类" class="headerlink" title="SQL语句主要分为哪几类"></a>SQL语句主要分为哪几类</h5><p>数据定义语言DDL（Data Ddefinition Language）CREATE，DROP，ALTER</p>
<p>主要为以上操作 即对逻辑结构等有操作的，其中包括表结构，视图和索引。</p>
<p>数据查询语言DQL（Data Query Language）SELECT</p>
<p>这个较为好理解 即查询操作，以select关键字。各种简单查询，连接查询等 都属于DQL。</p>
<p>数据操纵语言DML（Data Manipulation Language）INSERT，UPDATE，DELETE</p>
<p>主要为以上操作 即对数据进行操作的，对应上面所说的查询操作 DQL与DML共同构建了多数初级程序员常用的增删改查操作。而查询是较为特殊的一种 被划分到DQL中。</p>
<p>数据控制功能DCL（Data Control Language）GRANT，REVOKE，COMMIT，ROLLBACK</p>
<p>主要为以上操作 即对数据库安全性完整性等有操作的，可以简单的理解为权限控制等。</p>
<h5 id="超键、候选键、主键、外键分别是什么？"><a href="#超键、候选键、主键、外键分别是什么？" class="headerlink" title="超键、候选键、主键、外键分别是什么？"></a>超键、候选键、主键、外键分别是什么？</h5><ul>
<li>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</li>
<li>候选键：是最小超键，即没有冗余元素的超键。</li>
<li>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</li>
<li>外键：在一个表中存在的另一个表的主键称此表的外键。</li>
</ul>
<p>SQL 约束有哪几种？</p>
<pre><code>SQL 约束有哪几种？</code></pre><ul>
<li>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</li>
<li>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</li>
<li>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</li>
<li>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li>
<li>CHECK: 用于控制字段的值范围。</li>
</ul>
<h5 id="六种关联查询"><a href="#六种关联查询" class="headerlink" title="六种关联查询"></a>六种关联查询</h5><ul>
<li>交叉连接（CROSS JOIN）</li>
<li>内连接（INNER JOIN）</li>
<li>外连接（LEFT JOIN/RIGHT JOIN）</li>
<li>联合查询（UNION与UNION ALL）</li>
<li>全连接（FULL JOIN）</li>
<li>交叉连接（CROSS JOIN）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A,B(,C)或者<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> B (<span class="keyword">CROSS</span> <span class="keyword">JOIN</span> C)<span class="comment">#没有任何关联条件，结果是笛卡尔积，结果集会很大，没有意义，很少使用内连接（INNER JOIN）SELECT * FROM A,B WHERE A.id=B.id或者SELECT * FROM A INNER JOIN B ON A.id=B.id多表中同时符合某种条件的数据记录的集合，INNER JOIN可以缩写为JOIN</span></span><br></pre></td></tr></table></figure>

<p>内连接分为三类</p>
<ul>
<li>等值连接：ON A.id=B.id</li>
<li>不等值连接：ON A.id &gt; B.id</li>
<li>自连接：SELECT * FROM A T1 INNER JOIN A T2 ON T1.id=T2.pid</li>
</ul>
<p>外连接（LEFT JOIN/RIGHT JOIN）</p>
<ul>
<li>左外连接：LEFT OUTER JOIN, 以左表为主，先查询出左表，按照ON后的关联条件匹配右表，没有匹配到的用NULL填充，可以简写成LEFT JOIN</li>
<li>右外连接：RIGHT OUTER JOIN, 以右表为主，先查询出右表，按照ON后的关联条件匹配左表，没有匹配到的用NULL填充，可以简写成RIGHT JOIN</li>
</ul>
<p>联合查询（UNION与UNION ALL）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A <span class="keyword">UNION</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> B <span class="keyword">UNION</span> ...</span><br></pre></td></tr></table></figure>

<ul>
<li>就是把多个结果集集中在一起，UNION前的结果为基准，需要注意的是联合查询的列数要相等，相同的记录行会合并</li>
<li>如果使用UNION ALL，不会合并重复的记录行</li>
<li>效率 UNION 高于 UNION ALL</li>
</ul>
<p>全连接（FULL JOIN）</p>
<ul>
<li>MySQL不支持全连接</li>
<li>可以使用LEFT JOIN 和UNION和RIGHT JOIN联合使用</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> B <span class="keyword">ON</span> A.id=B.id UNIONSELECT * <span class="keyword">FROM</span> A <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> B <span class="keyword">ON</span> A.id=B.id</span><br></pre></td></tr></table></figure>

<p>表连接面试题</p>
<p>有2张表，1张R、1张S，R表有ABC三列，S表有CD两列，表中各有三条记录。</p>
<p>R表</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
</tr>
</tbody></table>
<p>S表</p>
<table>
<thead>
<tr>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>c4</td>
<td>d3</td>
</tr>
</tbody></table>
<ol>
<li>交叉连接(笛卡尔积):</li>
</ol>
<p>select r.<em>,s.</em> from r,s</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c4</td>
<td>d3</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c4</td>
<td>d3</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td>c4</td>
<td>d3</td>
</tr>
</tbody></table>
<ol start="2">
<li><p>内连接结果：</p>
<p>select r.<em>,s.</em> from r inner join s on r.c=s.c</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
</tbody></table>
<ol start="3">
<li>左连接结果：</li>
</ol>
<p>​       select r.<em>,s.</em> from r left join s on r.c=s.c</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ol start="4">
<li>右连接结果：</li>
</ol>
<p>​          select r.<em>,s.</em> from r right join s on r.c=s.c</p>
<p>​            </p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>c4</td>
<td>d3</td>
</tr>
</tbody></table>
<ol start="5">
<li>全表连接的结果（MySql不支持，Oracle支持）：</li>
</ol>
<p>​       select r.<em>,s.</em> from r full join s on r.c=s.c</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>3</td>
<td>b3</td>
<td>c3</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>c4</td>
<td>d3</td>
</tr>
</tbody></table>
<p>什么是子查询</p>
<ol>
<li>条件：一条SQL语句的查询结果做为另一条查询语句的条件或查询结果</li>
<li>嵌套：多条SQL语句嵌套使用，内部的SQL查询语句称为子查询。</li>
</ol>
<p>子查询的三种情况</p>
<ol>
<li>子查询是单行单列的情况：结果集是一个值，父查询使用：=、 &lt;、 &gt; 等运算符</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询工资最高的员工是谁？ </span></span><br><span class="line"><span class="keyword">select</span>  * <span class="keyword">from</span> employee <span class="keyword">where</span> salary=(<span class="keyword">select</span> <span class="keyword">max</span>(salary) <span class="keyword">from</span> employee);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>子查询是多行单列的情况：结果集类似于一个数组，父查询使用：in 运算符</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询工资最高的员工是谁？ </span></span><br><span class="line"><span class="keyword">select</span>  * <span class="keyword">from</span> employee <span class="keyword">where</span> salary=(<span class="keyword">select</span> <span class="keyword">max</span>(salary) <span class="keyword">from</span> employee);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>子查询是多行多列的情况：结果集类似于一张虚拟表，不能用于where条件，用于select子句中做为子表</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1) 查询出2011年以后入职的员工信息</span></span><br><span class="line"><span class="comment">-- 2) 查询所有的部门信息，与上面的虚拟表中的信息比对，找出所有部门ID相等的员工。</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> dept d,  (<span class="keyword">select</span> * <span class="keyword">from</span> employee <span class="keyword">where</span> join_date &gt; <span class="string">'2011-1-1'</span>) e <span class="keyword">where</span> e.dept_id =  d.id;    </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用表连接：</span></span><br><span class="line"><span class="keyword">select</span> d.*, e.* <span class="keyword">from</span>  dept d <span class="keyword">inner</span> <span class="keyword">join</span> employee e <span class="keyword">on</span> d.id = e.dept_id <span class="keyword">where</span> e.join_date &gt;  <span class="string">'2011-1-1'</span></span><br></pre></td></tr></table></figure>

<h5 id="mysql中-in-和-exists-区别"><a href="#mysql中-in-和-exists-区别" class="headerlink" title="mysql中 in 和 exists 区别"></a>mysql中 in 和 exists 区别</h5><p>mysql中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。一直大家都认为exists比in语句的效率要高，这种说法其实是不准确的。这个是要区分环境的。</p>
<ol>
<li>如果查询的两个表大小相当，那么用in和exists差别不大。</li>
<li>如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。</li>
<li>not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。</li>
</ol>
<h5 id="varchar与char的区别"><a href="#varchar与char的区别" class="headerlink" title="varchar与char的区别"></a>varchar与char的区别</h5><p><strong>char的特点</strong></p>
<ul>
<li>char表示定长字符串，长度是固定的；</li>
<li>如果插入数据的长度小于char的固定长度时，则用空格填充；</li>
<li>因为长度固定，所以存取速度要比varchar快很多，甚至能快50%，但正因为其长度固定，所以会占据多余的空间，是空间换时间的做法；</li>
<li>对于char来说，最多能存放的字符个数为255，和编码无关</li>
</ul>
<p><strong>varchar的特点</strong></p>
<ul>
<li>varchar表示可变长字符串，长度是可变的；</li>
<li>插入的数据是多长，就按照多长来存储；</li>
<li>varchar在存取方面与char相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法；</li>
<li>对于varchar来说，最多能存放的字符个数为65532</li>
</ul>
<p>总之，结合性能角度（char更快）和节省磁盘空间角度（varchar更小），具体情况还需具体来设计数据库才是妥当的做法。</p>
<h5 id="varchar-50-中50的涵义"><a href="#varchar-50-中50的涵义" class="headerlink" title="varchar(50)中50的涵义"></a>varchar(50)中50的涵义</h5><p>最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)。在早期 MySQL 版本中， 50 代表字节数，现在代表字符数。</p>
<h5 id="int-20-中20的涵义"><a href="#int-20-中20的涵义" class="headerlink" title="int(20)中20的涵义"></a>int(20)中20的涵义</h5><p>是指显示字符的长度。20表示最大显示宽度为20，但仍占4字节存储，存储范围不变；</p>
<p>不影响内部存储，只是影响带 zerofill 定义的 int 时，前面补多少个 0，易于报表展示</p>
<h5 id="mysql为什么这么设计"><a href="#mysql为什么这么设计" class="headerlink" title="mysql为什么这么设计"></a>mysql为什么这么设计</h5><p>对大多数应用没有意义，只是规定一些工具用来显示字符的个数；int(1)和int(20)存储和计算均一样；</p>
<h5 id="mysql中int-10-和char-10-以及varchar-10-的区别"><a href="#mysql中int-10-和char-10-以及varchar-10-的区别" class="headerlink" title="mysql中int(10)和char(10)以及varchar(10)的区别"></a>mysql中int(10)和char(10)以及varchar(10)的区别</h5><ul>
<li>int(10)的10表示显示的数据的长度，不是存储数据的大小；chart(10)和varchar(10)的10表示存储数据的大小，即表示存储多少个字符。int(10) 10位的数据长度 9999999999，占32个字节，int型4位</li>
<li>char(10) 10位固定字符串，不足补空格 最多10个字符</li>
<li>varchar(10) 10位可变字符串，不足补空格 最多10个字符char(10)表示存储定长的10个字符，不足10个就用空格补齐，占用更多的存储空间varchar(10)表示存储10个变长的字符，存储多少个就是多少个，空格也按一个字符存储，这一点是和char(10)的空格不同的，char(10)的空格表示占位不算一个字符</li>
</ul>
<p>FLOAT和DOUBLE的区别是什么？</p>
<ul>
<li>FLOAT类型数据可以存储至多8位十进制数，并在内存中占4字节。</li>
<li>DOUBLE类型数据可以存储至多18位十进制数，并在内存中占8字节。</li>
</ul>
<h5 id="drop、delete与truncate的区别"><a href="#drop、delete与truncate的区别" class="headerlink" title="drop、delete与truncate的区别"></a>drop、delete与truncate的区别</h5><p>三者都表示删除，但是三者有一些差别：<br>    Delete     Truncate     Drop</p>
<table>
<thead>
<tr>
<th></th>
<th>Delete</th>
<th>Truncate</th>
<th>Drop</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>属于DML</td>
<td>属于DDL</td>
<td>属于DDL</td>
</tr>
<tr>
<td>回滚</td>
<td>可回滚</td>
<td>不可回滚</td>
<td>不可回滚</td>
</tr>
<tr>
<td>删除内容</td>
<td>表结构还在，删除表的全部或者一部分数据行</td>
<td>表结构还在，删除表中的所有数据</td>
<td>从数据库中删除表，所有的数据行，索引和权限也会被删除</td>
</tr>
<tr>
<td>删除速度</td>
<td>删除速度慢，需要逐行删除</td>
<td>删除速度快</td>
<td>删除速度最快</td>
</tr>
</tbody></table>
<p>因此，在不再需要一张表的时候，用drop；在想删除部分数据行时候，用delete；在保留表而删除所有数据的时候用truncate。</p>
<h5 id="UNION与UNION-ALL的区别？"><a href="#UNION与UNION-ALL的区别？" class="headerlink" title="UNION与UNION ALL的区别？"></a>UNION与UNION ALL的区别？</h5><ul>
<li>如果使用UNION ALL，不会合并重复的记录行</li>
<li>效率 UNION 高于 UNION ALL</li>
</ul>
<h4 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h4><h5 id="如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到-或者说怎么才可以知道这条语句运行很慢的原因？"><a href="#如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到-或者说怎么才可以知道这条语句运行很慢的原因？" class="headerlink" title="如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？"></a>如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？</h5><p>对于低性能的SQL语句的定位，最重要也是最有效的方法就是使用执行计划，MySQL提供了explain命令来查看语句的执行计划。 我们知道，不管是哪种数据库，或者是哪种数据库引擎，在对一条SQL语句进行执行的过程中都会做很多相关的优化，<strong>对于查询语句，最重要的优化方式就是使用索引。 而执行计划，就是显示数据库引擎对于SQL语句的执行的详细情况，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200310171131582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt></p>
<p>执行计划包含的信息 id 有一组数字组成。表示一个查询中各个子查询的执行顺序;</p>
<ul>
<li>id相同执行顺序由上至下。</li>
<li>id不同，id值越大优先级越高，越先被执行。</li>
<li>id为null时表示一个结果集，不需要使用它查询，常出现在包含union等查询语句中。</li>
</ul>
<p><strong>select_type</strong> 每个子查询的查询类型，一些常见的查询类型。</p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>不包含任何子查询或union等查询</td>
</tr>
<tr>
<td>2</td>
<td>PRIMARY</td>
<td>包含子查询最外层查询就显示为 PRIMARY</td>
</tr>
<tr>
<td>3</td>
<td>SUBQUERY</td>
<td>在select或 where字句中包含的查询</td>
</tr>
<tr>
<td>4</td>
<td>DERIVED</td>
<td>from字句中包含的查询</td>
</tr>
<tr>
<td>5</td>
<td>UNION</td>
<td>出现在union后的查询语句中</td>
</tr>
<tr>
<td>6</td>
<td>UNION RESULT</td>
<td>从UNION中获取结果集，例如上文的第三个例子</td>
</tr>
</tbody></table>
<p><strong>table</strong> 查询的数据表，当从衍生表中查数据时会显示 x 表示对应的执行计划id partitions 表分区、表创建的时候可以指定通过那个列进行表分区。 举个例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tmp (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)</span><br><span class="line">) <span class="keyword">engine</span> = <span class="keyword">innodb</span></span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">key</span> (<span class="keyword">id</span>) <span class="keyword">partitions</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p><strong>type</strong>(非常重要，可以看到有没有走索引) 访问类型</p>
<ul>
<li>ALL 扫描全表数据</li>
<li>index 遍历索引</li>
<li>range 索引范围查找</li>
<li>index_subquery 在子查询中使用 ref</li>
<li>unique_subquery 在子查询中使用 eq_ref</li>
<li>ref_or_null 对Null进行索引的优化的 ref</li>
<li>fulltext 使用全文索引</li>
<li>ref 使用非唯一索引查找数据</li>
<li>eq_ref 在join查询中使用PRIMARY KEYorUNIQUE NOT NULL索引关联。</li>
</ul>
<p><strong>possible_keys</strong> 可能使用的索引，注意不一定会使用。查询涉及到的字段上若存在索引，则该索引将被列出来。当该列为 NULL时就要考虑当前的SQL是否需要优化了。</p>
<p><strong>key</strong> 显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL。</p>
<p><strong>TIPS</strong>:查询中若使用了覆盖索引(覆盖索引：索引的数据覆盖了需要查询的所有数据)，则该索引仅出现在key列表中</p>
<p><strong>key_length</strong> 索引长度</p>
<p><strong>ref</strong> 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p>
<p><strong>rows</strong> 返回估算的结果集数目，并不是一个准确的值。</p>
<p><strong>extra</strong> 的信息非常丰富，常见的有：</p>
<ol>
<li><p>Using index 使用覆盖索引</p>
</li>
<li><p>Using where 使用了用where子句来过滤结果集</p>
</li>
<li><p>Using filesort 使用文件排序，使用非索引列进行排序时出现，非常消耗性能，尽量优化。</p>
</li>
<li><p>Using temporary 使用了临时表 sql优化的目标可以参考阿里开发手册</p>
<p> 【推荐】SQL性能优化的目标：至少要达到 range 级别，要求是ref级别，如果可以是consts最好。<br> 说明：<br> 1） consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。<br> 2） ref 指的是使用普通的索引（normal index）。<br> 3） range 对索引进行范围检索。<br> 反例：explain表的结果，type=index，索引物理文件全扫描，速度非常慢，这个index级别比较range还低，与全表扫描是小巫见大巫。</p>
</li>
</ol>
<h5 id="SQL的生命周期？"><a href="#SQL的生命周期？" class="headerlink" title="SQL的生命周期？"></a>SQL的生命周期？</h5><ol>
<li><p>应用服务器与数据库服务器建立一个连接</p>
</li>
<li><p>数据库进程拿到请求sql</p>
</li>
<li><p>解析并生成执行计划，执行</p>
</li>
<li><p>读取数据到内存并进行逻辑处理</p>
</li>
<li><p>通过步骤一的连接，发送结果到客户端</p>
</li>
<li><p>关掉连接，释放资源大表数据查询，怎么优化</p>
<p><img src="https://img-blog.csdnimg.cn/20200310170936478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt></p>
</li>
</ol>
<h3 id="大表数据查询，怎么优化"><a href="#大表数据查询，怎么优化" class="headerlink" title="大表数据查询，怎么优化"></a>大表数据查询，怎么优化</h3><ol>
<li><p>优化shema、sql语句+索引；</p>
</li>
<li><p>第二加缓存，memcached, redis；</p>
</li>
<li><p>主从复制，读写分离；</p>
</li>
<li><p>垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；</p>
</li>
<li><p>水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding </p>
<p>key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；</p>
</li>
</ol>
<h5 id="超大分页怎么处理？"><a href="#超大分页怎么处理？" class="headerlink" title="超大分页怎么处理？"></a>超大分页怎么处理？</h5><p>超大的分页一般从两个方向上来解决.</p>
<ul>
<li>数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于select * from table where age &gt; 20 limit 1000000,10这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为select * from table where id in (select id from table where age &gt; 20 limit 1000000,10).这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以select * from table where id &gt; 1000000 limit 10,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据.</li>
<li>从需求的角度减少这种请求…主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.</li>
</ul>
<p>解决超大分页,其实主要是靠缓存,可预测性的提前查到内容,缓存至redis等k-V数据库中,直接返回即可.</p>
<p>在阿里巴巴《Java开发手册》中,对超大分页的解决办法是类似于上面提到的第一种.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">【推荐】利用延迟关联或者子查询优化超多分页场景。 </span><br><span class="line"></span><br><span class="line">说明：MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。 </span><br><span class="line"></span><br><span class="line">正例：先快速定位需要获取的id段，然后再关联： </span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> a.* <span class="keyword">FROM</span> 表<span class="number">1</span> a, (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">where</span> 条件 <span class="keyword">LIMIT</span> <span class="number">100000</span>,<span class="number">20</span> ) b <span class="keyword">where</span> a.id=b.id</span><br></pre></td></tr></table></figure>

<h5 id="mysql-分页"><a href="#mysql-分页" class="headerlink" title="mysql 分页"></a>mysql 分页</h5><p>LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是 0(而不是 1)</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15</span><br></pre></td></tr></table></figure>

<p>为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last.</span><br></pre></td></tr></table></figure>

<p>如果只给定一个参数，它表示返回最大的记录行数目：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM table LIMIT 5; //检索前 5 个记录行</span><br></pre></td></tr></table></figure>

<p>换句话说，LIMIT n 等价于 LIMIT 0,n。<br>慢查询日志</p>
<pre><code>用于记录执行时间超过某个临界值的SQL日志，用于快速定位慢查询，为我们的优化做参考。</code></pre><p>开启慢查询日志</p>
<p>配置项：slow_query_log</p>
<p>可以使用show variables like ‘slov_query_log’查看是否开启，如果状态值为OFF，可以使用set GLOBAL slow_query_log = on来开启，它会在datadir下产生一个xxx-slow.log的文件。</p>
<p>设置临界时间</p>
<p>配置项：long_query_time</p>
<p>查看：show VARIABLES like ‘long_query_time’，单位秒</p>
<p>设置：set long_query_time=0.5</p>
<p>实操时应该从长时间设置到短的时间，即将最慢的SQL优化掉</p>
<p>查看日志，一旦SQL超过了我们设置的临界时间就会被记录到xxx-slow.log中</p>
<h5 id="关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？"><a href="#关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？" class="headerlink" title="关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？"></a>关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？</h5><p>在业务系统中，除了使用主键进行的查询，其他的我都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。</p>
<p>慢查询的优化首先要搞明白慢的原因是什么？ 是查询条件没有命中索引？是load了不需要的数据列？还是数据量太大？</p>
<p>所以优化也是针对这三个方向来的，</p>
<ul>
<li>首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。</li>
<li>分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。</li>
<li>如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。</li>
</ul>
<h5 id="为什么要尽量设定一个主键？"><a href="#为什么要尽量设定一个主键？" class="headerlink" title="为什么要尽量设定一个主键？"></a>为什么要尽量设定一个主键？</h5><p>主键是数据库确保数据行在整张表唯一性的保障，即使业务上本张表没有主键，也建议添加一个自增长的ID列作为主键。设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。</p>
<h5 id="主键使用自增ID还是UUID？"><a href="#主键使用自增ID还是UUID？" class="headerlink" title="主键使用自增ID还是UUID？"></a>主键使用自增ID还是UUID？</h5><p>推荐使用自增ID，不要使用UUID。</p>
<p>因为在InnoDB存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降。</p>
<p>总之，在数据量大一些的情况下，用自增主键性能会好一些。</p>
<p>关于主键是聚簇索引，如果没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个隐式的主键。</p>
<h5 id="字段为什么要求定义为not-null？"><a href="#字段为什么要求定义为not-null？" class="headerlink" title="字段为什么要求定义为not null？"></a>字段为什么要求定义为not null？</h5><p>null值会占用更多的字节，且会在程序中造成很多与预期不符的情况。</p>
<h5 id="如果要存储用户的密码散列，应该使用什么字段进行存储？"><a href="#如果要存储用户的密码散列，应该使用什么字段进行存储？" class="headerlink" title="如果要存储用户的密码散列，应该使用什么字段进行存储？"></a>如果要存储用户的密码散列，应该使用什么字段进行存储？</h5><p>密码散列，盐，用户身份证号等固定长度的字符串应该使用char而不是varchar来存储，这样可以节省空间且提高检索效率。</p>
<h5 id="优化查询过程中的数据访问"><a href="#优化查询过程中的数据访问" class="headerlink" title="优化查询过程中的数据访问"></a>优化查询过程中的数据访问</h5><ul>
<li>访问数据太多导致查询性能下降</li>
<li>确定应用程序是否在检索大量超过需要的数据，可能是太多行或列</li>
<li>确认MySQL服务器是否在分析大量不必要的数据行</li>
<li>避免犯如下SQL语句错误</li>
<li>查询不需要的数据。解决办法：使用limit解决</li>
<li>多表关联返回全部列。解决办法：指定列名</li>
<li>总是返回全部列。解决办法：避免使用SELECT *</li>
<li>重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存</li>
<li>是否在扫描额外的记录。解决办法：</li>
<li>使用explain进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优化：</li>
<li>使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。</li>
<li>改变数据库和表的结构，修改数据表范式</li>
<li>重写SQL语句，让优化器可以以更优的方式执行查询。</li>
</ul>
<h5 id="优化长难的查询语句"><a href="#优化长难的查询语句" class="headerlink" title="优化长难的查询语句"></a>优化长难的查询语句</h5><ul>
<li>一个复杂查询还是多个简单查询</li>
<li>MySQL内部每秒能扫描内存中上百万行数据，相比之下，响应数据给客户端就要慢得多</li>
<li>使用尽可能小的查询是好的，但是有时将一个大的查询分解为多个小的查询是很有必要的。</li>
<li>切分查询</li>
<li>将一个大的查询分为多个小的相同的查询</li>
<li>一次性删除1000万的数据要比一次删除1万，暂停一会的方案更加损耗服务器开销。</li>
<li>分解关联查询，让缓存的效率更高。</li>
<li>执行单个查询可以减少锁的竞争。</li>
<li>在应用层做关联更容易对数据库进行拆分。</li>
<li>查询效率会有大幅提升。</li>
<li>较少冗余记录的查询。</li>
</ul>
<h5 id="优化特定类型的查询语句"><a href="#优化特定类型的查询语句" class="headerlink" title="优化特定类型的查询语句"></a>优化特定类型的查询语句</h5><ul>
<li>count(*)会忽略所有的列，直接统计所有列数，不要使用count(列名)</li>
<li><em>MyISAM中，没有任何where条件的count(</em>)非常快。</li>
<li>当有where条件时，MyISAM的count统计不一定比其它引擎快。</li>
<li>可以使用explain查询近似值，用近似值替代count(*)</li>
<li>增加汇总表</li>
<li>使用缓存</li>
</ul>
<h5 id="优化关联查询"><a href="#优化关联查询" class="headerlink" title="优化关联查询"></a>优化关联查询</h5><ul>
<li>确定ON或者USING子句中是否有索引。</li>
<li>确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引。</li>
</ul>
<h5 id="优化子查询"><a href="#优化子查询" class="headerlink" title="优化子查询"></a>优化子查询</h5><ul>
<li>用关联查询替代</li>
<li>优化GROUP BY和DISTINCT</li>
<li>这两种查询据可以使用索引来优化，是最有效的优化方法</li>
<li>关联查询中，使用标识列分组的效率更高</li>
<li>如果不需要ORDER BY，进行GROUP BY时加ORDER BY NULL，MySQL不会再进行文件排序。</li>
<li>WITH ROLLUP超级聚合，可以挪到应用程序处理</li>
</ul>
<h5 id="优化LIMIT分页"><a href="#优化LIMIT分页" class="headerlink" title="优化LIMIT分页"></a>优化LIMIT分页</h5><ul>
<li>LIMIT偏移量大的时候，查询效率较低</li>
<li>可以记录上次查询的最大ID，下次查询时直接根据该ID来查询</li>
</ul>
<h5 id="优化UNION查询"><a href="#优化UNION查询" class="headerlink" title="优化UNION查询"></a>优化UNION查询</h5><ul>
<li>UNION ALL的效率高于UNION</li>
</ul>
<h5 id="优化WHERE子句"><a href="#优化WHERE子句" class="headerlink" title="优化WHERE子句"></a>优化WHERE子句</h5><p>解题方法</p>
<p>对于此类考题，先说明如何定位低效SQL语句，然后根据SQL语句可能低效的原因做排查，先从索引着手，如果索引没有问题，考虑以上几个方面，数据访问的问题，长难查询句的问题还是一些特定类型优化的问题，逐一回答。</p>
<p>SQL语句优化的一些方法？</p>
<ul>
<li>1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li>
<li>2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">is</span> <span class="literal">null</span></span><br><span class="line"><span class="comment">-- 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=</span><br></pre></td></tr></table></figure>

<ul>
<li>3.应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。</li>
<li>4.应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">10</span> <span class="keyword">or</span> <span class="keyword">num</span>=<span class="number">20</span></span><br><span class="line"><span class="comment">-- 可以这样查询：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">10</span> <span class="keyword">union</span> <span class="keyword">all</span> <span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">20</span></span><br></pre></td></tr></table></figure>

<ul>
<li>5.in 和 not in 也要慎用，否则会导致全表扫描，如：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) </span><br><span class="line"><span class="comment">-- 对于连续的数值，能用 between 就不要用 in 了：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>6.下面的查询也将导致全表扫描：select id from t where name like ‘%李%’若要提高效率，可以考虑全文检索。</li>
<li>7.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=@<span class="keyword">num</span></span><br><span class="line"><span class="comment">-- 可以改为强制查询使用索引：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">with</span>(<span class="keyword">index</span>(索引名)) <span class="keyword">where</span> <span class="keyword">num</span>=@<span class="keyword">num</span></span><br></pre></td></tr></table></figure>

<ul>
<li>8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>/<span class="number">2</span>=<span class="number">100</span></span><br><span class="line"><span class="comment">-- 应改为:</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">100</span>*<span class="number">2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">substring</span>(<span class="keyword">name</span>,<span class="number">1</span>,<span class="number">3</span>)=’abc’</span><br><span class="line"><span class="comment">-- name以abc开头的id应改为:</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> ‘abc%’</span><br></pre></td></tr></table></figure>

<ul>
<li>10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</li>
</ul>
<h4 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h4><h5 id="为什么要优化"><a href="#为什么要优化" class="headerlink" title="为什么要优化"></a>为什么要优化</h5><ul>
<li>系统的吞吐量瓶颈往往出现在数据库的访问速度上</li>
<li>随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢</li>
<li>数据是存放在磁盘上的，读写速度无法和内存相比</li>
</ul>
<p>优化原则：减少系统瓶颈，减少资源占用，增加系统的反应速度。</p>
<h5 id="数据库结构优化"><a href="#数据库结构优化" class="headerlink" title="数据库结构优化"></a>数据库结构优化</h5><p>一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。</p>
<p>需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</p>
<p><strong>将字段很多的表分解成多个表</strong></p>
<p>对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。</p>
<p>因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</p>
<p><strong>增加中间表</strong></p>
<p>对于需要经常联合查询的表，可以建立中间表以提高查询效率。</p>
<p>通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。</p>
<p><strong>增加冗余字段</strong></p>
<p>设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。</p>
<p>表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。</p>
<p><strong>注意</strong>：</p>
<p><strong>冗余字段的值在一个表中修改了，就要想办法在其他表中更新，否则就会导致数据不一致的问题。</strong></p>
<h5 id="MySQL数据库cpu飙升到500-的话他怎么处理？"><a href="#MySQL数据库cpu飙升到500-的话他怎么处理？" class="headerlink" title="MySQL数据库cpu飙升到500%的话他怎么处理？"></a>MySQL数据库cpu飙升到500%的话他怎么处理？</h5><p>当 cpu 飙升到 500%时，先用操作系统命令 top 命令观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。</p>
<p>如果是 mysqld 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。</p>
<p>一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。</p>
<p>也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等</p>
<h5 id="大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？"><a href="#大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？" class="headerlink" title="大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？"></a>大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？</h5><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p>
<ol>
<li>限定数据的范围： 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。；</li>
<li>读/写分离： 经典的数据库拆分方案，主库负责写，从库负责读；</li>
<li>缓存： 使用MySQL的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；</li>
</ol>
<p>还有就是通过分库分表的方式进行优化，主要有垂直分表和水平分表</p>
<ol>
<li><p><strong>垂直分区：</strong></p>
<p><strong>根据数据库里面数据表的相关性进行拆分</strong>。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p>
<p><strong>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表</strong>。 如下图所示，这样来说大家应该就更容易理解了。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC82LzE2LzE2NDA4NDM1NGJhMmUwZmQ?x-oss-process=image/format,png" alt></p>
</li>
</ol>
<p><strong>垂直拆分的优点</strong>： 可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</p>
<p><strong>垂直拆分的缺点</strong>： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</p>
<h5 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h5><p>把主键和一些列放在一个表，然后把主键和另外的列放在另一个表中</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy90dVNhS2M2U2ZQcjh0NFBaVVFJVUszVHl0aWF3T0VRa2dFZnBCTm4xZkNtdEVhMkRaNTlISFNSaWN2SEIzeU43Yk5LY1hkc3NWZGFNb25TOEFKanY5cFdBLzY0MA?x-oss-process=image/format,png" alt></p>
<p><strong>适用场景</strong><br>    1、如果一个表中某些列常用，另外一些列不常用<br>    2、可以使数据行变小，一个数据页能存储更多数据，查询时减少I/O次数<br><strong>缺点</strong><br>       1.  有些分表的策略基于应用层的逻辑算法，一旦逻辑算法改变，整个分表逻辑都会改变，扩展性较 差<br>            2.  对于应用层来说，逻辑算法增加开发成本<br>                     3.  管理冗余列，查询所有数据需要join操作</p>
<p><strong>水平分区</strong>：</p>
<p><strong>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</strong></p>
<p>水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC82LzE2LzE2NDA4NGI3ZTllNDIzZTM?x-oss-process=image/format,png" alt></p>
<p>水品拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 <strong>水平拆分最好分库 。</strong></p>
<p>水平拆分能够 <strong>支持非常大的数据量存储，应用端改造也少</strong>，但 <strong>分片事务难以解决</strong> ，跨界点Join性能较差，逻辑复杂。</p>
<p>《Java工程师修炼之道》的作者推荐 尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度 ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。<br><strong>水平分表</strong>：</p>
<p>表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询次数</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy90dVNhS2M2U2ZQcjh0NFBaVVFJVUszVHl0aWF3T0VRa2dkQVpyU1Y3M2liMWZkRENYS2M3QUd6Wmhid3FjS0ZVWkpGWThwMFZkVXRPM3JNYzZ2eDFBdzVBLzY0MA?x-oss-process=image/format,png" alt></p>
<p><strong>适用场景</strong><br>    1、表中的数据本身就有独立性，例如表中分表记录各个地区的数据或者不同时期的数据，特别是有些数据常用，有些不常用。<br>    2、需要把数据存放在多个介质上。<br><strong>水平切分的缺点</strong><br>    1、给应用增加复杂度，通常查询时需要多个表名，查询所有数据都需UNION操作<br>    2、在许多数据库应用中，这种复杂度会超过它带来的优点，查询时会增加读一个索引层的磁盘次数</p>
<p><strong>下面补充一下数据库分片的两种常见方案：</strong><br>    <strong>客户端代理</strong>： 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。 当当网的 Sharding-JDBC 、阿里的TDDL是两种比较常用的实现。<br>    <strong>中间件代理</strong>： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。 我们现在谈的 Mycat 、360的Atlas、网易的DDB等等都是这种架构的实现。</p>
<p><strong>分库分表后面临的问题</strong></p>
<ul>
<li><strong>事务支持</strong> 分库分表后，就成了分布式事务了。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价； 如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。</li>
<li><strong>跨库join</strong> 只要是进行切分，跨节点Join的问题是不可避免的。但是良好的设计和切分却可以减少此类情况的发生。解决这一问题的普遍做法是分两次查询实现。在第一次查询的结果集中找出关联数据的id,根据这些id发起第二次请求得到关联数据。 分库分表方案产品</li>
<li><strong>跨节点的count,order by,group by以及聚合函数问题</strong> 这些是一类问题，因为它们都需要基于全部数据集合进行计算。多数的代理都不会自动处理合并工作。解决方案：与解决跨节点join问题的类似，分别在各个节点上得到结果后在应用程序端进行合并。和join不同的是每个结点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。</li>
<li><strong>数据迁移，容量规划，扩容等问题</strong> 来自淘宝综合业务平台团队，它利用对2的倍数取余具有向前兼容的特性（如对4取余得1的数对2取余也是1）来分配数据，避免了行级别的数据迁移，但是依然需要进行表级别的迁移，同时对扩容规模和分表数量都有限制。总得来说，这些方案都不是十分的理想，多多少少都存在一些缺点，这也从一个侧面反映出了Sharding扩容的难度。</li>
<li><strong>ID</strong>问题</li>
<li>一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的ID无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得ID,以便进行SQL路由. 一些常见的主键生成策略</li>
</ul>
<p><strong>UUID</strong> 使用UUID作主键是最简单的方案，但是缺点也是非常明显的。由于UUID非常的长，除占用大量存储空间外，最主要的问题是在索引上，在建立索引和基于索引进行查询时都存在性能问题。 <strong>Twitter的分布式自增ID算法Snowflake 在</strong>分布式系统中，需要生成全局UID的场合还是比较多的，twitter的snowflake解决了这种需求，实现也还是很简单的，除去配置信息，核心代码就是毫秒级时间41位 机器ID 10位 毫秒内序列12位。</p>
<ul>
<li>跨分片的排序分页</li>
</ul>
<p>般来讲，分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会变得比较复杂了。为了最终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，并将不同分片返回的结果集进行汇总和再次排序，最后再返回给用户。如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20200310170753848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt></p>
<h4 id="MySQL的复制原理以及流程"><a href="#MySQL的复制原理以及流程" class="headerlink" title="MySQL的复制原理以及流程"></a>MySQL的复制原理以及流程</h4><p>主从复制：将主数据库中的DDL和DML操作通过二进制日志（BINLOG）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。</p>
<h5 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h5><ol>
<li>主数据库出现问题，可以切换到从数据库。</li>
<li>可以进行数据库层面的读写分离。</li>
<li>可以在从数据库上进行日常备份。</li>
</ol>
<h5 id="MySQL主从复制解决的问题"><a href="#MySQL主从复制解决的问题" class="headerlink" title="MySQL主从复制解决的问题"></a>MySQL主从复制解决的问题</h5><ul>
<li>数据分布：随意开始或停止复制，并在不同地理位置分布数据备份</li>
<li>负载均衡：降低单个服务器的压力</li>
<li>高可用和故障切换：帮助应用程序避免单点失败</li>
<li>升级测试：可以用更高版本的MySQL作为从库</li>
</ul>
<h5 id="MySQL主从复制工作原理"><a href="#MySQL主从复制工作原理" class="headerlink" title="MySQL主从复制工作原理"></a>MySQL主从复制工作原理</h5><p><strong>基本原理流程，3个线程以及之间的关联</strong></p>
<p><strong>主</strong>：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；</p>
<p><strong>从</strong>：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进自己的relay log中；</p>
<p><strong>从</strong>：sql执行线程——执行relay log中的语句；</p>
<p><strong>复制过程</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC85LzIxLzE2NWZiNjgzMjIyMDViMmU?x-oss-process=image/format,png" alt></p>
<p>Binary log：主数据库的二进制日志</p>
<p>Relay log：从服务器的中继日志</p>
<p>第一步：master在每个事务更新数据完成之前，将该操作记录串行地写入到binlog文件中。</p>
<p>第二步：salve开启一个I/O Thread，该线程在master打开一个普通连接，主要工作是binlog dump process。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的事件。I/O线程最终的目的是将这些事件写入到中继日志中。</p>
<p>第三步：SQL Thread会读取中继日志，并顺序执行该日志中的SQL事件，从而与主数据库中的数据保持一致。</p>
<h5 id="读写分离有哪些解决方案？"><a href="#读写分离有哪些解决方案？" class="headerlink" title="读写分离有哪些解决方案？"></a>读写分离有哪些解决方案？</h5><p>读写分离是依赖于主从复制，而主从复制又是为读写分离服务的。因为主从复制要求slave不能写只能读（如果对slave执行写操作，那么show slave status将会呈现Slave_SQL_Running=NO，此时你需要按照前面提到的手动同步一下slave）。</p>
<p><strong>方案一</strong></p>
<p>使用mysql-proxy代理</p>
<p>优点：直接实现读写分离和负载均衡，不用修改代码，master和slave用一样的帐号，mysql官方不建议实际生产中使用</p>
<p>缺点：降低性能， 不支持事务</p>
<p><strong>方案二</strong></p>
<p>使用AbstractRoutingDataSource+aop+annotation在dao层决定数据源。<br>如果采用了mybatis， 可以将读写分离放在ORM层，比如mybatis可以通过mybatis plugin拦截sql语句，所有的insert/update/delete都访问master库，所有的select 都访问salve库，这样对于dao层都是透明。 plugin实现时可以通过注解或者分析语句是读写方法来选定主从库。不过这样依然有一个问题， 也就是不支持事务， 所以我们还需要重写一下DataSourceTransactionManager， 将read-only的事务扔进读库， 其余的有读有写的扔进写库。</p>
<p><strong>方案三</strong></p>
<p>使用AbstractRoutingDataSource+aop+annotation在service层决定数据源，可以支持事务.</p>
<p>缺点：类内部方法通过this.xx()方式相互调用时，aop不会进行拦截，需进行特殊处理。</p>
<h5 id="备份计划，mysqldump以及xtranbackup的实现原理"><a href="#备份计划，mysqldump以及xtranbackup的实现原理" class="headerlink" title="备份计划，mysqldump以及xtranbackup的实现原理"></a>备份计划，mysqldump以及xtranbackup的实现原理</h5><p><strong>(1)备份计划</strong></p>
<p>视库的大小来定，一般来说 100G 内的库，可以考虑使用 mysqldump 来做，因为 mysqldump更加轻巧灵活，备份时间选在业务低峰期，可以每天进行都进行全量备份(mysqldump 备份出来的文件比较小，压缩之后更小)。</p>
<p>100G 以上的库，可以考虑用 xtranbackup 来做，备份速度明显要比 mysqldump 要快。一般是选择一周一个全备，其余每天进行增量备份，备份时间为业务低峰期。</p>
<p>(<strong>2)备份恢复时间</strong></p>
<p>物理备份恢复快，逻辑备份恢复慢</p>
<p>这里跟机器，尤其是硬盘的速率有关系，以下列举几个仅供参考</p>
<p>20G的2分钟（mysqldump）</p>
<p>80G的30分钟(mysqldump)</p>
<p>111G的30分钟（mysqldump)</p>
<p>288G的3小时（xtra)</p>
<p>3T的4小时（xtra)</p>
<p>逻辑导入时间一般是备份时间的5倍以上</p>
<p><strong>(3)备份恢复失败如何处理</strong></p>
<p>首先在恢复之前就应该做足准备工作，避免恢复的时候出错。比如说备份之后的有效性检查、权限检查、空间检查等。如果万一报错，再根据报错的提示来进行相应的调整。</p>
<p>(4)mysqldump和xtrabackup实现原理</p>
<p>mysqldump</p>
<p>mysqldump 属于逻辑备份。加入–single-transaction 选项可以进行一致性备份。后台进程会先设置 session 的事务隔离级别为 RR(SET SESSION TRANSACTION ISOLATION LEVELREPEATABLE READ)，之后显式开启一个事务(START TRANSACTION /*!40100 WITH CONSISTENTSNAPSHOT */)，这样就保证了该事务里读到的数据都是事务事务时候的快照。之后再把表的数据读取出来。如果加上–master-data=1 的话，在刚开始的时候还会加一个数据库的读锁(FLUSH TABLES WITH READ LOCK),等开启事务后，再记录下数据库此时 binlog 的位置(showmaster status)，马上解锁，再读取表的数据。等所有的数据都已经导完，就可以结束事务</p>
<p>Xtrabackup:</p>
<p>xtrabackup 属于物理备份，直接拷贝表空间文件，同时不断扫描产生的 redo 日志并保存下来。最后完成 innodb 的备份后，会做一个 flush engine logs 的操作(老版本在有 bug，在5.6 上不做此操作会丢数据)，确保所有的 redo log 都已经落盘(涉及到事务的两阶段提交</p>
<p>概念，因为 xtrabackup 并不拷贝 binlog，所以必须保证所有的 redo log 都落盘，否则可能会丢最后一组提交事务的数据)。这个时间点就是 innodb 完成备份的时间点，数据文件虽然不是一致性的，但是有这段时间的 redo 就可以让数据文件达到一致性(恢复的时候做的事</p>
<p>情)。然后还需要 flush tables with read lock，把 myisam 等其他引擎的表给备份出来，备份完后解锁。这样就做到了完美的热备。</p>
<h5 id="数据表损坏的修复方式有哪些？"><a href="#数据表损坏的修复方式有哪些？" class="headerlink" title="数据表损坏的修复方式有哪些？"></a>数据表损坏的修复方式有哪些？</h5><p>使用 myisamchk 来修复，具体步骤：</p>
<ul>
<li>1）修复前将mysql服务停止。</li>
<li>2）打开命令行方式，然后进入到mysql的/bin目录。</li>
<li>3）执行myisamchk –recover 数据库所在路径/*.MYI</li>
</ul>
<p>使用repair table 或者 OPTIMIZE table命令来修复，REPAIR TABLE table_name 修复表 OPTIMIZE TABLE table_name 优化表 REPAIR TABLE 用于修复被破坏的表。 OPTIMIZE TABLE 用于回收闲置的数据库空间，当表上的数据行被删除时，所占据的磁盘空间并没有立即被回收，使用了OPTIMIZE TABLE命令后这些空间将被回收，并且对磁盘上的数据行进行重排（注意：是磁盘上，而非数据库）</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程--JUC-Lock锁(ReentrantLock、AQS)</title>
    <url>/myblog/interview/%E7%BA%BF%E7%A8%8B-JUC-Lock%E9%94%81-ReentrantLock%E3%80%81AQS/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>java.util.concurrent 在并发编程中使用的工具类，其重点有lock锁、辅助工具类、Atomic原子类以及并发集合框架等。</p>
<a id="more"></a>
<p>lock 最 常 用 的 类 就 是 ReentrantLock ， 其 底 层 实 现 使 用 的 是AbstractQueuedSynchronizer（AQS）</p>
<p><img src="https://img-blog.csdnimg.cn/20200916110359791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="Java是如何实现原子操作？"><a href="#Java是如何实现原子操作？" class="headerlink" title="Java是如何实现原子操作？"></a>Java是如何实现原子操作？</h4><p>在Java中可以通过锁和循环CAS的方式来实现原子操作</p>
<blockquote>
<p>Atomic原子类（循环CAS操作直到成功）</p>
</blockquote>
<blockquote>
<p>AQS（自旋、LockSupport、CAS）<br>       AQS（AbstractQueuedSynchronizer）是一个抽象同步框架，可以用来实现一个依赖状态的同步器，也就是队列同步器。多线程访问共享资源的同步器。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200916110726869.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>AQS 有⼀个 state 标记位，值为1 时表示有线程占⽤，其他线程需要进⼊到同步队列等待，同步队列是⼀个双向链表。</p>
<p><img src="https://img-blog.csdnimg.cn/20200916110753416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>当获得锁的线程需要等待某个条件时，会进⼊ condition 的等待队列，等待队列可以有多个。</p>
<p>当 condition 条件满⾜时，线程会从等待队列重新进⼊同步队列进⾏获取锁的竞争。</p>
<h5 id="AQS-原理"><a href="#AQS-原理" class="headerlink" title="AQS 原理"></a>AQS 原理</h5><p>Node内部类构成的⼀个双向链表结构的同步队列，通过控制（volatile的int类型）state状态来判断锁的状态，对于⾮可重⼊锁状态不是0则去阻塞；</p>
<p>对于可重⼊锁如果是0则执⾏，⾮0则判断当前线程是否是获取到这个锁的线程，是的话把state状态＋1，⽐如重⼊5次，那么state=5。 ⽽在释放锁的时候，同样需要释放5次直到state=0其他线程才有资格获得锁。</p>
<h5 id="AQS加锁过程"><a href="#AQS加锁过程" class="headerlink" title="AQS加锁过程"></a>AQS加锁过程</h5><p><img src="https://img-blog.csdnimg.cn/2020091611090330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200916110917991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="AQS两种资源共享⽅式"><a href="#AQS两种资源共享⽅式" class="headerlink" title="AQS两种资源共享⽅式"></a>AQS两种资源共享⽅式</h4><p>Exclusive：独占，只有⼀个线程能执⾏，如ReentrantLock</p>
<p>Share：共享，多个线程可以同时执⾏，如Semaphore、CountDownLatch、ReadWriteLock，CyclicBarrier</p>
<p>ReentrantLock（可重入锁）</p>
<h5 id="什么是-“可重入”"><a href="#什么是-“可重入”" class="headerlink" title="什么是 “可重入”"></a>什么是 “可重入”</h5><p>可重入就是说某个线程已经获得某个锁，可以再次获取锁而不会出现死锁（如同计数器++而已），可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），一定程度上避免死锁。</p>
<h5 id="ReentrantLock-是如何实现可重⼊性的-？"><a href="#ReentrantLock-是如何实现可重⼊性的-？" class="headerlink" title="ReentrantLock 是如何实现可重⼊性的 ？"></a>ReentrantLock 是如何实现可重⼊性的 ？</h5><p>内部⾃定义了同步器 Sync，加锁的时候通过CAS 算法 ，将线程对象放到⼀个双向链表 中，每次获取锁的时候 ，看下当前维 护的那个线程ID和当前请求的线程ID是否⼀样，⼀样就可重⼊了；</p>
<h4 id="synchronized与ReentrantLock区别"><a href="#synchronized与ReentrantLock区别" class="headerlink" title="synchronized与ReentrantLock区别"></a>synchronized与ReentrantLock区别</h4><blockquote>
<p>✓都是可重⼊锁； ReentrantLock是显示获取和释放锁，synchronized是隐式；</p>
</blockquote>
<blockquote>
<p>✓ReentrantLock更灵活可以知道有没有成功获取锁，可以定义读写锁，是api级别，synchronized是JVM级别；</p>
</blockquote>
<blockquote>
<p>✓ReentrantLock可以定义公平锁；Lock是接⼝，synchronized是java中的关键字</p>
</blockquote>
<blockquote>
<p>ReentrantLock 就是基于 AQS 实现的，如下图所示，ReentrantLock 内部有公平锁和⾮公平锁两种实现，差别就在于新来的线程是否⽐已经在同步队列中的等待线程更早获得锁。</p>
</blockquote>
<h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p> 非常公平， 不能够插队，必须先来后到！</p>
<h4 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h4><p>非常不公平，可以插队 （默认都是非公平）,但公平锁需多维护⼀个锁线程队列，效率低</p>
<p><img src="https://img-blog.csdnimg.cn/20200916111153652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>从图中可以看到，ReentrantLock⾥⾯有⼀个内部类Sync，Sync继承AQS（AbstractQueuedSynchronizer），添加锁和释放锁的⼤部分操作实际上都是在Sync中实现的。</p>
<p>它有公平锁FairSync和⾮公平锁NonfairSync两个⼦类。</p>
<p>ReentrantLock默认使⽤⾮公平锁，也可以通过构造器来显示的指定使⽤公平锁。</p>
<h4 id="ReentrantLock原理（CAS-AQS）"><a href="#ReentrantLock原理（CAS-AQS）" class="headerlink" title="ReentrantLock原理（CAS+AQS）"></a>ReentrantLock原理（CAS+AQS）</h4><p>CAS+AQS队列来实现</p>
<ol>
<li><p>先通过CAS尝试获取锁， 如果此时已经有线程占据了锁，那就加⼊AQS队列并且被挂起；</p>
</li>
<li><p>当锁被释放之后， 排在队⾸的线程会被唤醒CAS再次尝试获取锁，</p>
</li>
<li><p>如果是⾮公平锁， 同时还有另⼀个线程进来尝试获取可能会让这个线程抢到锁；</p>
</li>
<li><p>如果是公平锁， 会排到队尾，由队⾸的线程获取到锁。</p>
</li>
</ol>
<h4 id="ReentrantLock如何避免死锁"><a href="#ReentrantLock如何避免死锁" class="headerlink" title="ReentrantLock如何避免死锁?"></a>ReentrantLock如何避免死锁?</h4><blockquote>
<p>✓响应中断lockInterruptibly</p>
</blockquote>
<blockquote>
<p>✓可轮询锁tryLock</p>
</blockquote>
<blockquote>
<p>✓定时锁tryLock（long time）</p>
</blockquote>
<h4 id="tryLock-和-lock-和-lockInterruptibly-的区别"><a href="#tryLock-和-lock-和-lockInterruptibly-的区别" class="headerlink" title="tryLock 和 lock 和 lockInterruptibly 的区别"></a>tryLock 和 lock 和 lockInterruptibly 的区别</h4><ol>
<li><p>tryLock 能获得锁就返回 true，不能就⽴即返回 false</p>
</li>
<li><p>tryLock（long timeout，TimeUnit unit），可以增加时间限制，如果超过该时间段还没获得锁，返回 false</p>
</li>
<li><p>lock 能获得锁就返回 true，不能的话⼀直等待获得锁</p>
</li>
</ol>
<h4 id="JUC辅助工具类—Semaphore（计数信号量）"><a href="#JUC辅助工具类—Semaphore（计数信号量）" class="headerlink" title="JUC辅助工具类—Semaphore（计数信号量）"></a>JUC辅助工具类—Semaphore（计数信号量）</h4><p>和 ReentrantLock 实现⽅式类似，Semaphore 也是基于 AQS 的，差别在于 ReentrantLock 是独占锁，Semaphore 是共享锁。</p>
<h4 id="什么是信号量Semaphore（共享锁）"><a href="#什么是信号量Semaphore（共享锁）" class="headerlink" title="什么是信号量Semaphore（共享锁）"></a>什么是信号量Semaphore（共享锁）</h4><p>信号量是⼀种固定资源的限制的⼀种并发⼯具包，基于AQS实现的，在构造的时候会设置⼀个值，代表着资源数量。信号量主要是应⽤于是⽤于多个共享资源的互斥使⽤，和⽤于并发线程数的控制（druid的数据库连接数，就是⽤这个实现的），信号量也分公平和⾮公平的情况，基本⽅式和reentrantLock差不多，在请求资源调⽤task时，会⽤⾃旋的⽅式减1，如果成功，则获取成功了，如果失败，导致资源数变为了0，就会加⼊队列⾥⾯去等待。调⽤release的时候会加⼀，补充资源,并唤醒等待队列。</p>
<p> <strong>过程：</strong></p>
<p>semaphore.acquire 获得，假设如果已经满了，等待，等待被释放为止！</p>
<p>semaphore.release: 释放，会将当前的信号量释放 + 1，然后唤醒等待的线程！</p>
<blockquote>
<p>作用： 多个共享资源互斥的使用！并发限流，控制最大的线程数！</p>
</blockquote>
<h4 id="Semaphore-应⽤"><a href="#Semaphore-应⽤" class="headerlink" title="Semaphore 应⽤"></a>Semaphore 应⽤</h4><p>acquire release 可⽤于对象池，资源池的构建，⽐如静态全局对象池，数据库连接池；</p>
<p>可创建计数为1的S，作为互斥锁（⼆元信号量）</p>
<p>JUC辅助工具类—CountDownLatch</p>
<p>允许一个或多个线程等待直到在其他线程中执行的一组操作完成的同步辅助，用来协调多个线程之间的同步，或者说起到线程之间的通信。</p>
<p>能够使一个线程在等待另外一些线程完成各自工作之后，再继续执行。</p>
<p><strong>过程：</strong></p>
<p>countDownLatch.countDown; // 数量-1</p>
<p>countDownLatch.await; // 等待计数器归零，然后再向下执行</p>
<p>每次有线程调用 countDown 数量-1，假设计数器变为0，countDownLatch.await 就会被唤醒，继续执行！</p>
<h4 id="CountDownLatch的不足"><a href="#CountDownLatch的不足" class="headerlink" title="CountDownLatch的不足"></a>CountDownLatch的不足</h4><p>CountDownLatch是一次性的，计算器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当CountDownLatch使用完毕后，它不能再次被使用</p>
<p>JUC辅助工具类—CyclicBarrier（加法计数器）</p>
<p>CyclicBarrier字面意思是“可重复使用的栅栏”，它是 ReentrantLock 和 Condition 的组合使用。</p>
<p>允许一组线程全部等待彼此达到共同屏障点的同步辅助。 循环阻塞在涉及固定大小的线程方的程序中很有用，这些线程必须偶尔等待彼此。 屏障被称为循环 ，因为它可以在等待的线程被释放之后重新使用。</p>
<p>如旅游时要等全部人都到齐了才出发，比赛时要等运动员都上场后才开始。</p>
<p><img src="https://img-blog.csdnimg.cn/2020091611174416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0Mjk4Mjg=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="CyclicBarrier与CountDownLatch的区别"><a href="#CyclicBarrier与CountDownLatch的区别" class="headerlink" title="CyclicBarrier与CountDownLatch的区别"></a>CyclicBarrier与CountDownLatch的区别</h4><p>CountDownLatch和CyclicBarrier的比较</p>
<blockquote>
<p>✓CountDownLatch是线程组之间的等待，即一个(或多个)线程等待N个线程完成某件事情之后再执行；而CyclicBarrier则是线程组内的等待，即每个线程相互等待，即N个线程都被拦截之后，然后依次执行。</p>
</blockquote>
<blockquote>
<p>✓ CountDownLatch是减计数方式，而CyclicBarrier是加计数方式。</p>
</blockquote>
<blockquote>
<p>✓CountDownLatch计数为0无法重置，而CyclicBarrier计数达到初始值，则可以重置。</p>
</blockquote>
<blockquote>
<p>✓CountDownLatch不可以复用，而CyclicBarrier可以复用。</p>
</blockquote>
<p><strong>ReentrantReadWriteLock读写锁（非公平锁）</strong></p>
<p>对共享资源有读和写的操作，且写操作没有读操作那么频繁。在没有写操作的时候，多个线程同时读一个资源没有任何问题，所以应该允许多个线程同时读取共享资源；但是如果一个线程想去写这些共享资源，就不应该允许其他线程对该资源进行读和写的操作了</p>
<p>ReentrantReadWriteLock 能够兼顾数据操作的原子性和读写的性能。</p>
<h4 id="读可以被多线程同时读，但写只能一个线程写"><a href="#读可以被多线程同时读，但写只能一个线程写" class="headerlink" title="读可以被多线程同时读，但写只能一个线程写"></a>读可以被多线程同时读，但写只能一个线程写</h4><p>独占锁（写锁） 一次只能被一个线程占有</p>
<p>共享锁（读锁） 多个线程可以同时占有</p>
<p>ReadWriteLock</p>
<p>读-读 可以共存！</p>
<p>读-写 不能共存！</p>
<p>写-写 不能共存！</p>
<h4 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h4><p>读锁是一个共享锁。读锁是 ReentrantReadWriteLock 的内部静态类，它的 lock、trylock、unlock 都是委托 Sync 类实现。</p>
<p>Sync 是真正实现读写锁功能的类，它继承AbstractQueuedSynchronizer</p>
<h4 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h4><p>写锁是一个排他锁。写锁也是 ReentrantReadWriteLock 的内部静态类，它的 lock、trylock、unlock 也都是委托 Sync 类实现。写锁的代码类似于读锁，但是在同一时刻写锁是不能被多个线程所获取，它是独占式锁。</p>
<p>写锁可以降级成读锁</p>
<h4 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h4><p>锁降级是指先获取写锁，再获取读锁，然后再释放写锁的过程 。锁降级是为了保证数据的可见性。锁降级是 ReentrantReadWriteLock 重要特性之一。</p>
<p>值得注意的是，ReentrantReadWriteLock 并不能实现锁升级</p>
<p>如果读写锁当前没有读者，也没有写者，那么写者可以立刻获的读写锁，否则必须自旋，直到没有任何的写锁或者读锁存在。如果读写锁没有写锁，那么读锁可以立马获取，否则必须等待写锁释放。(但是有一个例外，就是读写锁中的锁降级操作，当同一个线程获取写锁后，在写锁没有释放的情况下可以获取读锁再释放读锁这就是锁降级的一个过程)</p>
<blockquote>
<p>ReentrantReadWriteLock 读写锁适用于读多写少的场景，以提高系统的并发性</p>
</blockquote>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>IO与NIO面试题</title>
    <url>/myblog/interview/O%E4%B8%8ENIO%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p><strong>1.Java 中 IO 流分为几种?</strong></p>
<a id="more"></a>
<ol>
<li><p>按照流的流向分，可以分为输入流和输出流；</p>
</li>
<li><p>按照操作单元划分，可以划分为字节流和字符流；</p>
</li>
<li><p>按照流的角色划分为节点流和处理流。</p>
</li>
</ol>
<p>Java Io 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p>
<ol>
<li><p>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</p>
</li>
<li><p>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</p>
</li>
</ol>
<p><strong>2、 Java IO与 NIO的区别</strong></p>
<p>NIO即New IO，这个库是在JDK1.4中才引入的。NIO和IO有相同的作用和目的，但实现方式不同，NIO 主要用到的是块，所以NIO的效率要比IO高很多。在Java API中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO。</p>
<p><strong>3、常用io类有那些</strong><br><img src="https://img-blog.csdnimg.cn/20200916142058620.png#pic_center" alt="在这里插入图片描述"></p>
<p><strong>4、字节流与字符流的区别</strong></p>
<p>以字节为单位输入输出数据，字节流按照8位传输</p>
<p>以字符为单位输入输出数据，字符流按照16位传输</p>
<p><strong>5、阻塞 IO 模型</strong></p>
<p>最传统的一种 IO 模型，即在读写数据过程中会发生阻塞现象。当用户线程发出 IO 请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出 CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用 户线程才解除 block 状态。典型的阻塞 IO 模型的例子为： data = socket.read;如果数据没有就绪，就会一直阻塞在 read 方法</p>
<p><strong>6、非阻塞 IO 模型</strong></p>
<p>当用户线程发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。 如果结果是一个error 时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。所以事实上，在非阻塞 IO 模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞 IO不会交出 CPU，而会一直占用 CPU。 典型的非阻塞 IO 模型一般如下：<br><img src="https://img-blog.csdnimg.cn/20200916142120933.png#pic_center" alt="在这里插入图片描述"></p>
<p>但是对于非阻塞 IO 就有一个非常严重的问题， 在 while 循环中需要不断地去询问内核数据是否就绪，这样会导致 CPU 占用率非常高，因此一般情况下很少使用 while 循环这种方式来读取数据。</p>
<p><strong>7、多路复用 IO 模型</strong></p>
<p>多路复用 IO 模型是目前使用得比较多的模型。 Java NIO 实际上就是多路复用 IO。在多路复用 IO模型中，会有一个线程不断去轮询多个socket 的状态，只有当 socket 真正有读写事件时，才真正调用实际的 IO 读写操作。因为在多路复用 IO 模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket 读写事件进行时，才会使用IO 资源，所以它大大减少了资源占用。在 Java NIO 中，是通过 selector.select去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。多路复用 IO 模式，通过一个线程就可以管理多个 socket，只有当socket 真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用 IO 比较适合连接数比较多的情况。</p>
<p>另外多路复用 IO 为何比非阻塞 IO 模型的效率高是因为在非阻塞 IO 中，不断地询问 socket 状态时通过用户线程去进行的，而在多路复用IO 中，轮询每个 socket 状态是内核在进行的，这个效率要比用户线程要高的多。</p>
<p>不过要注意的是，多路复用 IO 模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用 IO 模型来说， 一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。</p>
<p><strong>8、信号驱动 IO 模型在</strong></p>
<p>信号驱动 IO 模型中，当用户线程发起一个 IO 请求操作，会给对应的 socket 注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用 IO 读写操作来进行实际的 IO 请求操作。</p>
<p><strong>9、异步 IO 模型</strong></p>
<p>异步 IO 模型才是最理想的 IO 模型，在异步 IO 模型中，当用户线程发起 read 操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个 asynchronous read 之后，它会立刻返回，说明 read 请求已经成功发起了，因此不会对用户线程产生任何block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read 操作完成了。也就说用户线程完全不需要实际的整个 IO 操作是如何进行的， 只需要先发起一个请求，当接收内核返回的成功信号时表示 IO 操作已经完成，可以直接去使用数据了。</p>
<p>也就说在异步 IO 模型中， IO 操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用 IO 函数进行具体的读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用 IO 函数进行实际的读写操作；而在异步 IO 模型中，收到信号表示 IO 操作已经完成，不需要再在用户线程中调用 IO 函数进行实际的读写操作。</p>
<p>注意，异步 IO 是需要操作系统的底层支持，在 Java 7 中，提供了 Asynchronous IO。</p>
<p><strong>10、JAVA NIO</strong></p>
<p>NIO 主要有三大核心部分： Channel(通道)， Buffer(缓冲区), Selector。</p>
<p>传统 IO 基于字节流和字符流进行操作， 而 NIO 基于 Channel 和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。 Selector(选择区)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。 NIO 和传统 IO 之间第一个最大的区别是， IO 是面向流的， NIO 是面向缓冲区的。</p>
<p><strong>11、NIO 的缓冲区</strong></p>
<p>Java IO 面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据， 需要先将它缓存到一个缓冲区。 NIO 的缓冲导向方法不同。</p>
<p>数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p>
<p><strong>12、NIO 的非阻塞</strong></p>
<p>IO 的各种流是阻塞的。这意味着，当一个线程调用 read 或 write时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 NIO 的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞 IO 的空闲时间用于在其它通道上执行 IO 操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p>
<p><strong>13、Channel</strong></p>
<p>首先说一下 Channel，国内大多翻译成“通道”。 Channel 和 IO 中的 Stream(流)是差不多一个等级的。 只不过 Stream 是单向的，譬如：InputStream, OutputStream， 而 Channel 是双向的，既可以用来进行读操作，又可以用来进行写操作。NIO 中的 Channel 的主要实现有：</p>
<p>FileChannel</p>
<p>DatagramChannel</p>
<p>SocketChannel</p>
<p>ServerSocketChannel</p>
<p>这里看名字就可以猜出个所以然来：分别可以对应文件 IO、 UDP 和 TCP（Server 和 Client）。下面演示的案例基本上就是围绕这 4 个类型的 Channel 进行陈述的。</p>
<p><strong>14、Buffer</strong></p>
<p>Buffer，故名思意， 缓冲区，实际上是一个容器，是一个连续数组。 Channel 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer。<br><img src="https://img-blog.csdnimg.cn/20200916142158597.png#pic_center" alt="在这里插入图片描述"></p>
<p>上面的图描述了从一个客户端向服务端发送数据，然后服务端接收数据的过程。客户端发送数据时，必须先将数据存入 Buffer 中，然后将Buffer 中的内容写入通道。服务端这边接收数据必须通过 Channel 将数据读入到 Buffer 中，然后再从 Buffer 中取出数据来处理。</p>
<p>在 NIO 中， Buffer 是一个顶层父类，它是一个抽象类，常用的 Buffer 的子类有：ByteBuffer、 IntBuffer、 CharBuffer、 LongBuffer、DoubleBuffer、 FloatBuffer、ShortBuffer</p>
<p><strong>15、SelectorSelector</strong></p>
<p>类是 NIO 的核心类， Selector 能够检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然后针对每个事件进行相应的响应处理。这样一来，只是用一个单线程就可以管理多个通道，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程，并且避免了多线程之间的上下文切换导致的开销。</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>几种常见写法导致MySQL索引失效</title>
    <url>/myblog/interview/%E7%A7%8D%E5%B8%B8%E8%A7%81%E5%86%99%E6%B3%95%E5%AF%BC%E8%87%B4MySQL%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/</url>
    <content><![CDATA[<p>表的设计以及字段设计的不合理，随着业务的增长，出现了大量的慢SQL，导致MySQL的CPU资源飙升，其中一方面的原因可能就是索引失效了。</p>
<a id="more"></a>
<h4 id="关于索引"><a href="#关于索引" class="headerlink" title="关于索引"></a>关于索引</h4><p>个人见解：并不是所以的表都需要去建立索引，对于一些业务数据，可能量比较大了，查询数据已经有了一点压力，那么最简单、快速的办法就是建立合适的索引，但是有些业务可能表里就没多少数据，或者表的使用频率非常不高的情况下是没必要必须要去做索引的。就像我们有些表，2年了可能就10来条数据，有索引和没索引性能方面差不多多少。</p>
<p>索引只是我们优化业务的一种方式，千万为了为了建索引而去建索引。</p>
<h4 id="这些写法会导致索引失效"><a href="#这些写法会导致索引失效" class="headerlink" title="这些写法会导致索引失效"></a>这些写法会导致索引失效</h4><h5 id="一、单个索引"><a href="#一、单个索引" class="headerlink" title="一、单个索引"></a>一、单个索引</h5><p><strong>1、使用!= 或者 &lt;&gt; 导致索引失效</strong></p>
<p>SELECT * FROM <code>user</code> WHERE <code>name</code> != ‘冰峰’;</p>
<p>我们给name字段建立了索引，但是如果!= 或者 &lt;&gt; 这种都会导致索引失效，进行全表扫描，所以如果数据量大的话，谨慎使用</p>
<p><img src="https://img-blog.csdnimg.cn/20200916145347130.png#pic_center" alt="在这里插入图片描述"><br><strong>2、类型不一致导致的索引失效</strong></p>
<p>在说这个之前，一定要说一下设计表字段的时候，千万、一定、必须要保持字段类型的一致性，啥意思？比如user表的id是int自增，到了用户的账户表user_id这个字段，一定、必须也是int类型，千万不要写成varchar、char什么的骚操作。</p>
<p>SELECT * FROM <code>user</code> WHERE height= 175;</p>
<p>这个SQL一定要看清楚，height表字段类型是varchar，但是我查询的时候使用了数字类型，因为这个中间存在一个隐式的类型转换，所以就会导致索引失效，进行全表扫描。</p>
<p><img src="https://img-blog.csdnimg.cn/20200916145448331.png#pic_center" alt="在这里插入图片描述"><br>现在明白我为啥说设计字段的时候一定要保持类型的一致性了不，如果你不保证一致性，一个int一个varchar，在进行多表联合查询（eg: 1 = ‘1’）必然走不了索引。</p>
<p>遇到这样的表，里面有几千万数据，改又不能改，那种痛可能你们暂时还体会。</p>
<p>少年们，切记，切记。</p>
<p><strong>3、函数导致的索引失效</strong></p>
<p>SELECT * FROM <code>user</code> WHERE DATE(create_time) = ‘2020-09-03’;</p>
<p>如果你的索引字段使用了索引，对不起，他是真的不走索引的。</p>
<p><img src="https://img-blog.csdnimg.cn/20200916145535943.png#pic_center" alt="在这里插入图片描述"><br><strong>4、运算符导致的索引失效</strong></p>
<p>SELECT * FROM <code>user</code> WHERE age - 1 = 20;</p>
<p>如果你对列进行了（+，-，*，/，!）, 那么都将不会走索引。</p>
<p><strong>5、OR引起的索引失效</strong></p>
<p>SELECT * FROM <code>user</code> WHERE <code>name</code> = ‘张三’ OR height = ‘175’;</p>
<p>OR导致索引是在特定情况下的，并不是所有的OR都是使索引失效，如果OR连接的是同一个字段，那么索引不会失效，反之索引失效。</p>
<p><strong>6、模糊搜索导致的索引失效</strong></p>
<p>SELECT * FROM <code>user</code> WHERE <code>name</code> LIKE ‘%冰’;</p>
<p>模糊搜索如果前缀也进行模糊搜索，那么不会走索引。</p>
<p><strong>7、NOT IN、NOT EXISTS导致索引失效</strong></p>
<p>SELECT s.* FROM <code>user</code> s WHERE NOT EXISTS (SELECT * FROM <code>user</code> u WHERE u.name = s.<code>name</code> AND u.<code>name</code> = ‘冰峰’) SELECT * FROM <code>user</code> WHERE <code>name</code> NOT IN (‘冰峰’);</p>
<p>这两种用法，也将使索引失效。但是NOT IN 还是走索引的，千万不要误解为 IN 全部是不走索引的</p>
<p>8、IS NULL不走索引，IS NOT NULL走索引</p>
<p>SELECT * FROM <code>user</code> WHERE address IS NULL   不走索引。</p>
<p>SELECT * FROM <code>user</code> WHERE address IS NOT NULL; 走索引。</p>
<p>根据这个情况，建议大家这设计字段的时候，如果没有必要的要求必须为NULL，那么最好给个默认值空字符串，这可以解决很多后续的麻烦（有深刻的体验&lt;体验=教训&gt;）。</p>
<h4 id="二、符合索引"><a href="#二、符合索引" class="headerlink" title="二、符合索引"></a>二、符合索引</h4><p><strong>1、最左匹配原则</strong></p>
<p>EXPLAIN SELECT * FROM <code>user</code> WHERE sex = ‘男’; EXPLAIN SELECT * FROM <code>user</code> WHERE name = ‘冰峰’ AND sex = ‘男’;</p>
<p>测试之前，删除其他的单列索引。</p>
<p>啥叫最左匹配原则，就是对于符合索引来说，它的一个索引的顺序是从左往右依次进行比较的，像第二个查询语句，name走索引，接下来回去找age，结果条件中没有age那么后面的sex也将不走索引。</p>
<p>注意：</p>
<p>SELECT * FROM <code>user</code> WHERE sex = ‘男’ AND age = 22 AND <code>name</code> = ‘冰峰’;</p>
<p>可能有些搬砖工可能跟我最开始有个误解，我们的索引顺序明明是name、sex、age，你现在的查询顺序是sex、age、name，这肯定不走索引啊，你要是自己没测试过，也有这种不成熟的想法，那跟我一样还是太年轻了，它其实跟顺序是没有任何关系的，因为mysql的底层会帮我们做一个优化，它会把你的SQL优化为它认为一个效率最高的样子进行执行。所以千万不要有这种误解。</p>
<p><strong>2、如果使用了!=会导致后面的索引全部失效</strong></p>
<p>SELECT * FROM <code>user</code> WHERE sex = ‘男’ AND <code>name</code> != ‘冰峰’ AND age = 22;</p>
<p>我们在name字段使用了 != ，由于name字段是最左边的一个字段，根据最左匹配原则，如果name不走索引，后面的字段也将不走索引。</p>
<p>关于符合索引导致索引失效的情况能说的目前就这两种，其实我觉得对于符合索引来说，重要的是如何建立高效的索引，千万不能说我用到那个字段我就去建立一个单独的索引，不是就可以全局用了嘛。这样是可以，但是这样并没有符合索引高效。</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>interview</tag>
      </tags>
  </entry>
</search>
